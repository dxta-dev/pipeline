import { createRequire as topLevelCreateRequire } from 'module';
const require = topLevelCreateRequire(import.meta.url);
import { fileURLToPath as topLevelFileUrlToPath, URL as topLevelURL } from "url"
const __dirname = topLevelFileUrlToPath(new topLevelURL(".", import.meta.url))

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
  get: (a10, b11) => (typeof require !== "undefined" ? require : a10)[b11]
}) : x4)(function(x4) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x4 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d10, b11) {
  extendStatics(d10, b11);
  function __() {
    this.constructor = d10;
  }
  __name(__, "__");
  d10.prototype = b11 === null ? Object.create(b11) : (__.prototype = b11.prototype, new __());
}
function __rest(s10, e10) {
  var t6 = {};
  for (var p11 in s10)
    if (Object.prototype.hasOwnProperty.call(s10, p11) && e10.indexOf(p11) < 0)
      t6[p11] = s10[p11];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p11 = Object.getOwnPropertySymbols(s10); i10 < p11.length; i10++) {
      if (e10.indexOf(p11[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p11[i10]))
        t6[p11[i10]] = s10[p11[i10]];
    }
  return t6;
}
function __decorate(decorators, target, key, desc2) {
  var c11 = arguments.length, r10 = c11 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d10;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r10 = Reflect.decorate(decorators, target, key, desc2);
  else
    for (var i10 = decorators.length - 1; i10 >= 0; i10--)
      if (d10 = decorators[i10])
        r10 = (c11 < 3 ? d10(r10) : c11 > 3 ? d10(target, key, r10) : d10(target, key)) || r10;
  return c11 > 3 && r10 && Object.defineProperty(target, key, r10), r10;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e10) {
        reject(e10);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e10) {
        reject(e10);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t6[0] & 1)
      throw t6[1];
    return t6[1];
  }, trys: [], ops: [] }, f11, y4, t6, g10;
  return g10 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g10[Symbol.iterator] = function() {
    return this;
  }), g10;
  function verb(n10) {
    return function(v7) {
      return step([n10, v7]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f11)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f11 = 1, y4 && (t6 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t6 = y4["return"]) && t6.call(y4), 0) : y4.next) && !(t6 = t6.call(y4, op[1])).done)
          return t6;
        if (y4 = 0, t6)
          op = [op[0] & 2, t6.value];
        switch (op[0]) {
          case 0:
          case 1:
            t6 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y4 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t6 = _.trys, t6 = t6.length > 0 && t6[t6.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t6 || op[1] > t6[0] && op[1] < t6[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t6[1]) {
              _.label = t6[1];
              t6 = op;
              break;
            }
            if (t6 && _.label < t6[2]) {
              _.label = t6[2];
              _.ops.push(op);
              break;
            }
            if (t6[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e10) {
        op = [6, e10];
        y4 = 0;
      } finally {
        f11 = t6 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
function __createBinding(o10, m11, k10, k22) {
  if (k22 === void 0)
    k22 = k10;
  o10[k22] = m11[k10];
}
function __exportStar(m11, exports) {
  for (var p11 in m11)
    if (p11 !== "default" && !exports.hasOwnProperty(p11))
      exports[p11] = m11[p11];
}
function __values(o10) {
  var s10 = typeof Symbol === "function" && Symbol.iterator, m11 = s10 && o10[s10], i10 = 0;
  if (m11)
    return m11.call(o10);
  if (o10 && typeof o10.length === "number")
    return {
      next: function() {
        if (o10 && i10 >= o10.length)
          o10 = void 0;
        return { value: o10 && o10[i10++], done: !o10 };
      }
    };
  throw new TypeError(s10 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o10, n10) {
  var m11 = typeof Symbol === "function" && o10[Symbol.iterator];
  if (!m11)
    return o10;
  var i10 = m11.call(o10), r10, ar = [], e10;
  try {
    while ((n10 === void 0 || n10-- > 0) && !(r10 = i10.next()).done)
      ar.push(r10.value);
  } catch (error) {
    e10 = { error };
  } finally {
    try {
      if (r10 && !r10.done && (m11 = i10["return"]))
        m11.call(i10);
    } finally {
      if (e10)
        throw e10.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i10 = 0; i10 < arguments.length; i10++)
    ar = ar.concat(__read(arguments[i10]));
  return ar;
}
function __spreadArrays() {
  for (var s10 = 0, i10 = 0, il = arguments.length; i10 < il; i10++)
    s10 += arguments[i10].length;
  for (var r10 = Array(s10), k10 = 0, i10 = 0; i10 < il; i10++)
    for (var a10 = arguments[i10], j10 = 0, jl = a10.length; j10 < jl; j10++, k10++)
      r10[k10] = a10[j10];
  return r10;
}
function __await(v7) {
  return this instanceof __await ? (this.v = v7, this) : new __await(v7);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g10 = generator.apply(thisArg, _arguments || []), i10, q10 = [];
  return i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10;
  function verb(n10) {
    if (g10[n10])
      i10[n10] = function(v7) {
        return new Promise(function(a10, b11) {
          q10.push([n10, v7, a10, b11]) > 1 || resume(n10, v7);
        });
      };
  }
  __name(verb, "verb");
  function resume(n10, v7) {
    try {
      step(g10[n10](v7));
    } catch (e10) {
      settle(q10[0][3], e10);
    }
  }
  __name(resume, "resume");
  function step(r10) {
    r10.value instanceof __await ? Promise.resolve(r10.value.v).then(fulfill, reject) : settle(q10[0][2], r10);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle(f11, v7) {
    if (f11(v7), q10.shift(), q10.length)
      resume(q10[0][0], q10[0][1]);
  }
  __name(settle, "settle");
}
function __asyncDelegator(o10) {
  var i10, p11;
  return i10 = {}, verb("next"), verb("throw", function(e10) {
    throw e10;
  }), verb("return"), i10[Symbol.iterator] = function() {
    return this;
  }, i10;
  function verb(n10, f11) {
    i10[n10] = o10[n10] ? function(v7) {
      return (p11 = !p11) ? { value: __await(o10[n10](v7)), done: n10 === "return" } : f11 ? f11(v7) : v7;
    } : f11;
  }
  __name(verb, "verb");
}
function __asyncValues(o10) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m11 = o10[Symbol.asyncIterator], i10;
  return m11 ? m11.call(o10) : (o10 = typeof __values === "function" ? __values(o10) : o10[Symbol.iterator](), i10 = {}, verb("next"), verb("throw"), verb("return"), i10[Symbol.asyncIterator] = function() {
    return this;
  }, i10);
  function verb(n10) {
    i10[n10] = o10[n10] && function(v7) {
      return new Promise(function(resolve, reject) {
        v7 = o10[n10](v7), settle(resolve, reject, v7.done, v7.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d10, v7) {
    Promise.resolve(v7).then(function(v8) {
      resolve({ value: v8, done: d10 });
    }, reject);
  }
  __name(settle, "settle");
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k10 in mod)
      if (Object.hasOwnProperty.call(mod, k10))
        result[k10] = mod[k10];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "../../node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js"() {
    extendStatics = /* @__PURE__ */ __name(function(d10, b11) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d11, b12) {
        d11.__proto__ = b12;
      } || function(d11, b12) {
        for (var p11 in b12)
          if (b12.hasOwnProperty(p11))
            d11[p11] = b12[p11];
      };
      return extendStatics(d10, b11);
    }, "extendStatics");
    __name(__extends, "__extends");
    __assign = /* @__PURE__ */ __name(function() {
      __assign = Object.assign || /* @__PURE__ */ __name(function __assign3(t6) {
        for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
          s10 = arguments[i10];
          for (var p11 in s10)
            if (Object.prototype.hasOwnProperty.call(s10, p11))
              t6[p11] = s10[p11];
        }
        return t6;
      }, "__assign");
      return __assign.apply(this, arguments);
    }, "__assign");
    __name(__rest, "__rest");
    __name(__decorate, "__decorate");
    __name(__param, "__param");
    __name(__metadata, "__metadata");
    __name(__awaiter, "__awaiter");
    __name(__generator, "__generator");
    __name(__createBinding, "__createBinding");
    __name(__exportStar, "__exportStar");
    __name(__values, "__values");
    __name(__read, "__read");
    __name(__spread, "__spread");
    __name(__spreadArrays, "__spreadArrays");
    __name(__await, "__await");
    __name(__asyncGenerator, "__asyncGenerator");
    __name(__asyncDelegator, "__asyncDelegator");
    __name(__asyncValues, "__asyncValues");
    __name(__makeTemplateObject, "__makeTemplateObject");
    __name(__importStar, "__importStar");
    __name(__importDefault, "__importDefault");
    __name(__classPrivateFieldGet, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet, "__classPrivateFieldSet");
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js
var fromUtf8, toUtf8;
var init_pureJs = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/pureJs.js"() {
    fromUtf8 = /* @__PURE__ */ __name((input) => {
      const bytes = [];
      for (let i10 = 0, len = input.length; i10 < len; i10++) {
        const value = input.charCodeAt(i10);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i10 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i10 + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i10) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    }, "fromUtf8");
    toUtf8 = /* @__PURE__ */ __name((input) => {
      let decoded = "";
      for (let i10 = 0, len = input.length; i10 < len; i10++) {
        const byte = input[i10];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i10];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i10], input[++i10], input[++i10]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i10] & 63) << 6 | input[++i10] & 63);
        }
      }
      return decoded;
    }, "toUtf8");
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js
function fromUtf82(input) {
  return new TextEncoder().encode(input);
}
function toUtf82(input) {
  return new TextDecoder("utf-8").decode(input);
}
var init_whatwgEncodingApi = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/whatwgEncodingApi.js"() {
    __name(fromUtf82, "fromUtf8");
    __name(toUtf82, "toUtf8");
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  fromUtf8: () => fromUtf83,
  toUtf8: () => toUtf83
});
var fromUtf83, toUtf83;
var init_dist_es = __esm({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js"() {
    init_pureJs();
    init_whatwgEncodingApi();
    fromUtf83 = /* @__PURE__ */ __name((input) => typeof TextEncoder === "function" ? fromUtf82(input) : fromUtf8(input), "fromUtf8");
    toUtf83 = /* @__PURE__ */ __name((input) => typeof TextDecoder === "function" ? toUtf82(input) : toUtf8(input), "toUtf8");
  }
});

// ../../node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "../../node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var fromUtf85 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf85(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    __name(convertToBuffer, "convertToBuffer");
    exports.convertToBuffer = convertToBuffer;
  }
});

// ../../node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "../../node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    __name(isEmptyData, "isEmptyData");
    exports.isEmptyData = isEmptyData;
  }
});

// ../../node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "../../node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    __name(numToUint8, "numToUint8");
    exports.numToUint8 = numToUint8;
  }
});

// ../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    __name(uint32ArrayFrom, "uint32ArrayFrom");
    exports.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// ../../node_modules/@aws-crypto/util/build/index.js
var require_build = __commonJS({
  "../../node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// ../../node_modules/@aws-crypto/crc32/build/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "../../node_modules/@aws-crypto/crc32/build/aws_crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    var index_1 = require_build2();
    var AwsCrc32 = (
      /** @class */
      function() {
        function AwsCrc322() {
          this.crc32 = new index_1.Crc32();
        }
        __name(AwsCrc322, "AwsCrc32");
        AwsCrc322.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc322.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc322.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc322;
      }()
    );
    exports.AwsCrc32 = AwsCrc32;
  }
});

// ../../node_modules/@aws-crypto/crc32/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/@aws-crypto/crc32/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_build();
    function crc32(data) {
      return new Crc323().update(data).digest();
    }
    __name(crc32, "crc32");
    exports.crc32 = crc32;
    var Crc323 = (
      /** @class */
      function() {
        function Crc324() {
          this.checksum = 4294967295;
        }
        __name(Crc324, "Crc32");
        Crc324.prototype.update = function(data) {
          var e_1, _a2;
          try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
                _a2.call(data_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return this;
        };
        Crc324.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc324;
      }()
    );
    exports.Crc32 = Crc323;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// ../../node_modules/@smithy/util-hex-encoding/dist-es/index.js
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i10 = 0; i10 < encoded.length; i10 += 2) {
    const encodedByte = encoded.slice(i10, i10 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i10 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes) {
  let out = "";
  for (let i10 = 0; i10 < bytes.byteLength; i10++) {
    out += SHORT_TO_HEX[bytes[i10]];
  }
  return out;
}
var SHORT_TO_HEX, HEX_TO_SHORT;
var init_dist_es2 = __esm({
  "../../node_modules/@smithy/util-hex-encoding/dist-es/index.js"() {
    SHORT_TO_HEX = {};
    HEX_TO_SHORT = {};
    for (let i10 = 0; i10 < 256; i10++) {
      let encodedByte = i10.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i10] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i10;
    }
    __name(fromHex, "fromHex");
    __name(toHex, "toHex");
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/Int64.js
function negate(bytes) {
  for (let i10 = 0; i10 < 8; i10++) {
    bytes[i10] ^= 255;
  }
  for (let i10 = 7; i10 > -1; i10--) {
    bytes[i10]++;
    if (bytes[i10] !== 0)
      break;
  }
}
var Int64;
var init_Int64 = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/Int64.js"() {
    init_dist_es2();
    Int64 = class _Int64 {
      static {
        __name(this, "Int64");
      }
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i10 = 7, remaining = Math.abs(Math.round(number)); i10 > -1 && remaining > 0; i10--, remaining /= 256) {
          bytes[i10] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new _Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
    __name(negate, "negate");
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller, HEADER_VALUE_TYPE, BOOLEAN_TAG, BYTE_TAG, SHORT_TAG, INT_TAG, LONG_TAG, BINARY_TAG, STRING_TAG, TIMESTAMP_TAG, UUID_TAG, UUID_PATTERN;
var init_HeaderMarshaller = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js"() {
    init_dist_es2();
    init_Int64();
    HeaderMarshaller = class {
      static {
        __name(this, "HeaderMarshaller");
      }
      constructor(toUtf85, fromUtf85) {
        this.toUtf8 = toUtf85;
        this.fromUtf8 = fromUtf85;
      }
      format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
          const bytes = this.fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
          out.set(chunk, position);
          position += chunk.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = this.fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
      parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
          const nameLength = headers.getUint8(position++);
          const name2 = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
          position += nameLength;
          switch (headers.getUint8(position++)) {
            case 0:
              out[name2] = {
                type: BOOLEAN_TAG,
                value: true
              };
              break;
            case 1:
              out[name2] = {
                type: BOOLEAN_TAG,
                value: false
              };
              break;
            case 2:
              out[name2] = {
                type: BYTE_TAG,
                value: headers.getInt8(position++)
              };
              break;
            case 3:
              out[name2] = {
                type: SHORT_TAG,
                value: headers.getInt16(position, false)
              };
              position += 2;
              break;
            case 4:
              out[name2] = {
                type: INT_TAG,
                value: headers.getInt32(position, false)
              };
              position += 4;
              break;
            case 5:
              out[name2] = {
                type: LONG_TAG,
                value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
              };
              position += 8;
              break;
            case 6:
              const binaryLength = headers.getUint16(position, false);
              position += 2;
              out[name2] = {
                type: BINARY_TAG,
                value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
              };
              position += binaryLength;
              break;
            case 7:
              const stringLength = headers.getUint16(position, false);
              position += 2;
              out[name2] = {
                type: STRING_TAG,
                value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
              };
              position += stringLength;
              break;
            case 8:
              out[name2] = {
                type: TIMESTAMP_TAG,
                value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
              };
              position += 8;
              break;
            case 9:
              const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
              position += 16;
              out[name2] = {
                type: UUID_TAG,
                value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
              };
              break;
            default:
              throw new Error(`Unrecognized header type tag`);
          }
        }
        return out;
      }
    };
    (function(HEADER_VALUE_TYPE2) {
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
      HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
    BOOLEAN_TAG = "boolean";
    BYTE_TAG = "byte";
    SHORT_TAG = "short";
    INT_TAG = "integer";
    LONG_TAG = "long";
    BINARY_TAG = "binary";
    STRING_TAG = "string";
    TIMESTAMP_TAG = "timestamp";
    UUID_TAG = "uuid";
    UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
var import_crc32, PRELUDE_MEMBER_LENGTH, PRELUDE_LENGTH, CHECKSUM_LENGTH, MINIMUM_MESSAGE_LENGTH;
var init_splitMessage = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js"() {
    import_crc32 = __toESM(require_build2());
    PRELUDE_MEMBER_LENGTH = 4;
    PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    CHECKSUM_LENGTH = 4;
    MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var import_crc322;
var init_EventStreamCodec = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js"() {
    import_crc322 = __toESM(require_build2());
    init_HeaderMarshaller();
    init_splitMessage();
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/Message.js
var init_Message = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/Message.js"() {
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
var MessageDecoderStream;
var init_MessageDecoderStream = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js"() {
    MessageDecoderStream = class {
      static {
        __name(this, "MessageDecoderStream");
      }
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
          const decoded = this.options.decoder.decode(bytes);
          yield decoded;
        }
      }
    };
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
var MessageEncoderStream;
var init_MessageEncoderStream = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js"() {
    MessageEncoderStream = class {
      static {
        __name(this, "MessageEncoderStream");
      }
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
          const encoded = this.options.encoder.encode(msg);
          yield encoded;
        }
        if (this.options.includeEndFrame) {
          yield new Uint8Array(0);
        }
      }
    };
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
var SmithyMessageDecoderStream;
var init_SmithyMessageDecoderStream = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js"() {
    SmithyMessageDecoderStream = class {
      static {
        __name(this, "SmithyMessageDecoderStream");
      }
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const message of this.options.messageStream) {
          const deserialized = await this.options.deserializer(message);
          if (deserialized === void 0)
            continue;
          yield deserialized;
        }
      }
    };
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
var SmithyMessageEncoderStream;
var init_SmithyMessageEncoderStream = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js"() {
    SmithyMessageEncoderStream = class {
      static {
        __name(this, "SmithyMessageEncoderStream");
      }
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
          const payloadBuf = this.options.serializer(chunk);
          yield payloadBuf;
        }
      }
    };
  }
});

// ../../node_modules/@smithy/eventstream-codec/dist-es/index.js
var init_dist_es3 = __esm({
  "../../node_modules/@smithy/eventstream-codec/dist-es/index.js"() {
    init_EventStreamCodec();
    init_HeaderMarshaller();
    init_Int64();
    init_Message();
    init_MessageDecoderStream();
    init_MessageEncoderStream();
    init_SmithyMessageDecoderStream();
    init_SmithyMessageEncoderStream();
  }
});

// ../../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "../../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js"() {
    normalizeProvider = /* @__PURE__ */ __name((input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    }, "normalizeProvider");
  }
});

// ../../node_modules/@smithy/util-middleware/dist-es/index.js
var init_dist_es4 = __esm({
  "../../node_modules/@smithy/util-middleware/dist-es/index.js"() {
    init_normalizeProvider();
  }
});

// ../../node_modules/@smithy/is-array-buffer/dist-es/index.js
var isArrayBuffer;
var init_dist_es5 = __esm({
  "../../node_modules/@smithy/is-array-buffer/dist-es/index.js"() {
    isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
  }
});

// ../../node_modules/@smithy/util-buffer-from/dist-es/index.js
import { Buffer as Buffer2 } from "buffer";
var fromArrayBuffer, fromString;
var init_dist_es6 = __esm({
  "../../node_modules/@smithy/util-buffer-from/dist-es/index.js"() {
    init_dist_es5();
    fromArrayBuffer = /* @__PURE__ */ __name((input, offset = 0, length = input.byteLength - offset) => {
      if (!isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return Buffer2.from(input, offset, length);
    }, "fromArrayBuffer");
    fromString = /* @__PURE__ */ __name((input, encoding) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding ? Buffer2.from(input, encoding) : Buffer2.from(input);
    }, "fromString");
  }
});

// ../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.js
var fromUtf84;
var init_fromUtf8 = __esm({
  "../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.js"() {
    init_dist_es6();
    fromUtf84 = /* @__PURE__ */ __name((input) => {
      const buf = fromString(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }, "fromUtf8");
  }
});

// ../../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
var toUint8Array;
var init_toUint8Array = __esm({
  "../../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js"() {
    init_fromUtf8();
    toUint8Array = /* @__PURE__ */ __name((data) => {
      if (typeof data === "string") {
        return fromUtf84(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }, "toUint8Array");
  }
});

// ../../node_modules/@smithy/util-utf8/dist-es/toUtf8.js
var toUtf84;
var init_toUtf8 = __esm({
  "../../node_modules/@smithy/util-utf8/dist-es/toUtf8.js"() {
    init_dist_es6();
    toUtf84 = /* @__PURE__ */ __name((input) => fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8"), "toUtf8");
  }
});

// ../../node_modules/@smithy/util-utf8/dist-es/index.js
var init_dist_es7 = __esm({
  "../../node_modules/@smithy/util-utf8/dist-es/index.js"() {
    init_fromUtf8();
    init_toUint8Array();
    init_toUtf8();
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/constants.js
var ALGORITHM_QUERY_PARAM, CREDENTIAL_QUERY_PARAM, AMZ_DATE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, EXPIRES_QUERY_PARAM, SIGNATURE_QUERY_PARAM, TOKEN_QUERY_PARAM, AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER, GENERATED_HEADERS, SIGNATURE_HEADER, SHA256_HEADER, TOKEN_HEADER, ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN, ALGORITHM_IDENTIFIER, EVENT_ALGORITHM_IDENTIFIER, UNSIGNED_PAYLOAD, MAX_CACHE_SIZE, KEY_TYPE_IDENTIFIER, MAX_PRESIGNED_TTL;
var init_constants = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/constants.js"() {
    ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    AUTH_HEADER = "authorization";
    AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    DATE_HEADER = "date";
    GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    SHA256_HEADER = "x-amz-content-sha256";
    TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    ALWAYS_UNSIGNABLE_HEADERS = {
      authorization: true,
      "cache-control": true,
      connection: true,
      expect: true,
      from: true,
      "keep-alive": true,
      "max-forwards": true,
      pragma: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      "x-amzn-trace-id": true
    };
    PROXY_HEADER_PATTERN = /^proxy-/;
    SEC_HEADER_PATTERN = /^sec-/;
    ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    MAX_CACHE_SIZE = 50;
    KEY_TYPE_IDENTIFIER = "aws4_request";
    MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
var signingKeyCache, cacheQueue, createScope, getSigningKey, hmac;
var init_credentialDerivation = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js"() {
    init_dist_es2();
    init_dist_es7();
    init_constants();
    signingKeyCache = {};
    cacheQueue = [];
    createScope = /* @__PURE__ */ __name((shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`, "createScope");
    getSigningKey = /* @__PURE__ */ __name(async (sha256Constructor, credentials, shortDate, region, service) => {
      const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
      const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
      if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
      }
      cacheQueue.push(cacheKey);
      while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
      }
      let key = `AWS4${credentials.secretAccessKey}`;
      for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
      }
      return signingKeyCache[cacheKey] = key;
    }, "getSigningKey");
    hmac = /* @__PURE__ */ __name((ctor, secret, data) => {
      const hash = new ctor(secret);
      hash.update(toUint8Array(data));
      return hash.digest();
    }, "hmac");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
var getCanonicalHeaders;
var init_getCanonicalHeaders = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js"() {
    init_constants();
    getCanonicalHeaders = /* @__PURE__ */ __name(({ headers }, unsignableHeaders, signableHeaders) => {
      const canonical = {};
      for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == void 0) {
          continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
          if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
            continue;
          }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
      }
      return canonical;
    }, "getCanonicalHeaders");
  }
});

// ../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
var escapeUri, hexEncode;
var init_escape_uri = __esm({
  "../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js"() {
    escapeUri = /* @__PURE__ */ __name((uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode), "escapeUri");
    hexEncode = /* @__PURE__ */ __name((c11) => `%${c11.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode");
  }
});

// ../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
var init_escape_uri_path = __esm({
  "../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js"() {
    init_escape_uri();
  }
});

// ../../node_modules/@smithy/util-uri-escape/dist-es/index.js
var init_dist_es8 = __esm({
  "../../node_modules/@smithy/util-uri-escape/dist-es/index.js"() {
    init_escape_uri();
    init_escape_uri_path();
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
var getCanonicalQuery;
var init_getCanonicalQuery = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js"() {
    init_dist_es8();
    init_constants();
    getCanonicalQuery = /* @__PURE__ */ __name(({ query = {} }) => {
      const keys = [];
      const serialized = {};
      for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
          serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
        } else if (Array.isArray(value)) {
          serialized[key] = value.slice(0).sort().reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).join("&");
        }
      }
      return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    }, "getCanonicalQuery");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash;
var init_getPayloadHash = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js"() {
    init_dist_es5();
    init_dist_es2();
    init_dist_es7();
    init_constants();
    getPayloadHash = /* @__PURE__ */ __name(async ({ headers, body }, hashConstructor) => {
      for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers[headerName];
        }
      }
      if (body == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(toUint8Array(body));
        return toHex(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    }, "getPayloadHash");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/headerUtil.js
var hasHeader;
var init_headerUtil = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/headerUtil.js"() {
    hasHeader = /* @__PURE__ */ __name((soughtHeader, headers) => {
      soughtHeader = soughtHeader.toLowerCase();
      for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    }, "hasHeader");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
var cloneRequest, cloneQuery2;
var init_cloneRequest = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/cloneRequest.js"() {
    cloneRequest = /* @__PURE__ */ __name(({ headers, query, ...rest }) => ({
      ...rest,
      headers: { ...headers },
      query: query ? cloneQuery2(query) : void 0
    }), "cloneRequest");
    cloneQuery2 = /* @__PURE__ */ __name((query) => Object.keys(query).reduce((carry, paramName) => {
      const param2 = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param2) ? [...param2] : param2
      };
    }, {}), "cloneQuery");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery;
var init_moveHeadersToQuery = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js"() {
    init_cloneRequest();
    moveHeadersToQuery = /* @__PURE__ */ __name((request3, options = {}) => {
      const { headers, query = {} } = typeof request3.clone === "function" ? request3.clone() : cloneRequest(request3);
      for (const name2 of Object.keys(headers)) {
        const lname = name2.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
          query[name2] = headers[name2];
          delete headers[name2];
        }
      }
      return {
        ...request3,
        headers,
        query
      };
    }, "moveHeadersToQuery");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
var prepareRequest;
var init_prepareRequest = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js"() {
    init_cloneRequest();
    init_constants();
    prepareRequest = /* @__PURE__ */ __name((request3) => {
      request3 = typeof request3.clone === "function" ? request3.clone() : cloneRequest(request3);
      for (const headerName of Object.keys(request3.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request3.headers[headerName];
        }
      }
      return request3;
    }, "prepareRequest");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/utilDate.js
var iso8601, toDate;
var init_utilDate = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/utilDate.js"() {
    iso8601 = /* @__PURE__ */ __name((time2) => toDate(time2).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601");
    toDate = /* @__PURE__ */ __name((time2) => {
      if (typeof time2 === "number") {
        return new Date(time2 * 1e3);
      }
      if (typeof time2 === "string") {
        if (Number(time2)) {
          return new Date(Number(time2) * 1e3);
        }
        return new Date(time2);
      }
      return time2;
    }, "toDate");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var SignatureV4, formatDate, getCanonicalHeaderList;
var init_SignatureV4 = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js"() {
    init_dist_es3();
    init_dist_es2();
    init_dist_es4();
    init_dist_es7();
    init_constants();
    init_credentialDerivation();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_headerUtil();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_utilDate();
    SignatureV4 = class {
      static {
        __name(this, "SignatureV4");
      }
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        this.headerMarshaller = new HeaderMarshaller(toUtf84, fromUtf84);
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
      }
      async presign(originalRequest, options = {}) {
        const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request3 = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
          request3.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request3.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request3.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request3.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request3.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request3, unsignableHeaders, signableHeaders);
        request3.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request3.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request3, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request3;
      }
      async sign(toSign, options) {
        if (typeof toSign === "string") {
          return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
          return this.signEvent(toSign, options);
        } else if (toSign.message) {
          return this.signMessage(toSign, options);
        } else {
          return this.signRequest(toSign, options);
        }
      }
      async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = toHex(await hash.digest());
        const stringToSign = [
          EVENT_ALGORITHM_IDENTIFIER,
          longDate,
          scope,
          priorSignature,
          hashedHeaders,
          hashedPayload
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
      }
      async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
          headers: this.headerMarshaller.format(signableMessage.message.headers),
          payload: signableMessage.message.body
        }, {
          signingDate,
          signingRegion,
          signingService,
          priorSignature: signableMessage.priorSignature
        });
        return promise.then((signature) => {
          return { message: signableMessage.message, signature };
        });
      }
      async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
      }
      async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const request3 = prepareRequest(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request3.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
          request3.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request3, this.sha256);
        if (!hasHeader(SHA256_HEADER, request3.headers) && this.applyChecksum) {
          request3.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request3, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request3, canonicalHeaders, payloadHash));
        request3.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
        return request3;
      }
      createCanonicalRequest(request3, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request3.method}
${this.getCanonicalPath(request3)}
${getCanonicalQuery(request3)}
${sortedHeaders.map((name2) => `${name2}:${canonicalHeaders[name2]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
      }
      async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update(toUint8Array(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
      }
      getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
          const normalizedPathSegments = [];
          for (const pathSegment of path.split("/")) {
            if (pathSegment?.length === 0)
              continue;
            if (pathSegment === ".")
              continue;
            if (pathSegment === "..") {
              normalizedPathSegments.pop();
            } else {
              normalizedPathSegments.push(pathSegment);
            }
          }
          const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
          const doubleEncoded = encodeURIComponent(normalizedPath);
          return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
      }
      async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update(toUint8Array(stringToSign));
        return toHex(await hash.digest());
      }
      getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
      }
      validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
          throw new Error("Resolved credential object is not valid");
        }
      }
    };
    formatDate = /* @__PURE__ */ __name((now) => {
      const longDate = iso8601(now).replace(/[\-:]/g, "");
      return {
        longDate,
        shortDate: longDate.slice(0, 8)
      };
    }, "formatDate");
    getCanonicalHeaderList = /* @__PURE__ */ __name((headers) => Object.keys(headers).sort().join(";"), "getCanonicalHeaderList");
  }
});

// ../../node_modules/@smithy/signature-v4/dist-es/index.js
var init_dist_es9 = __esm({
  "../../node_modules/@smithy/signature-v4/dist-es/index.js"() {
    init_SignatureV4();
    init_getCanonicalHeaders();
    init_getCanonicalQuery();
    init_getPayloadHash();
    init_moveHeadersToQuery();
    init_prepareRequest();
    init_credentialDerivation();
  }
});

// ../../node_modules/@smithy/querystring-parser/dist-es/index.js
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}
var init_dist_es10 = __esm({
  "../../node_modules/@smithy/querystring-parser/dist-es/index.js"() {
    __name(parseQueryString, "parseQueryString");
  }
});

// ../../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../../node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = /* @__PURE__ */ __name(function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index2 = 0; index2 < len; index2++) {
          allmatches.push(match[index2]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    }, "getAllMatches");
    var isName = /* @__PURE__ */ __name(function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    }, "isName");
    exports.isExist = function(v7) {
      return typeof v7 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a10, arrayMode) {
      if (a10) {
        const keys = Object.keys(a10);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          if (arrayMode === "strict") {
            target[keys[i10]] = [a10[keys[i10]]];
          } else {
            target[keys[i10]] = a10[keys[i10]];
          }
        }
      }
    };
    exports.getValue = function(v7) {
      if (exports.isExist(v7)) {
        return v7;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util2 = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<" && xmlData[i10 + 1] === "?") {
          i10 += 2;
          i10 = readPI(xmlData, i10);
          if (i10.err)
            return i10;
        } else if (xmlData[i10] === "<") {
          let tagStartPos = i10;
          i10++;
          if (xmlData[i10] === "!") {
            i10 = readCommentAndCDATA(xmlData, i10);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i10] === "/") {
              closingTag = true;
              i10++;
            }
            let tagName = "";
            for (; i10 < xmlData.length && xmlData[i10] !== ">" && xmlData[i10] !== " " && xmlData[i10] !== "	" && xmlData[i10] !== "\n" && xmlData[i10] !== "\r"; i10++) {
              tagName += xmlData[i10];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i10--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i10));
            }
            const result = readAttributeStr(xmlData, i10);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i10));
            }
            let attrStr = result.value;
            i10 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i10 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid3 = validateAttributeString(attrStr, options);
              if (isValid3 === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid3.err.code, isValid3.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid3.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i10));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid3 = validateAttributeString(attrStr, options);
              if (isValid3 !== true) {
                return getErrorObject(isValid3.err.code, isValid3.err.msg, getLineNumberForPosition(xmlData, i10 - attrStr.length + isValid3.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i10));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i10++; i10 < xmlData.length; i10++) {
              if (xmlData[i10] === "<") {
                if (xmlData[i10 + 1] === "!") {
                  i10++;
                  i10 = readCommentAndCDATA(xmlData, i10);
                  continue;
                } else if (xmlData[i10 + 1] === "?") {
                  i10 = readPI(xmlData, ++i10);
                  if (i10.err)
                    return i10;
                } else {
                  break;
                }
              } else if (xmlData[i10] === "&") {
                const afterAmp = validateAmpersand(xmlData, i10);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i10));
                i10 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i10])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i10));
                }
              }
            }
            if (xmlData[i10] === "<") {
              i10--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i10])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i10] + "' is not expected.", getLineNumberForPosition(xmlData, i10));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t6) => t6.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    __name(isWhiteSpace, "isWhiteSpace");
    function readPI(xmlData, i10) {
      const start = i10;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] == "?" || xmlData[i10] == " ") {
          const tagname = xmlData.substr(start, i10 - start);
          if (i10 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i10));
          } else if (xmlData[i10] == "?" && xmlData[i10 + 1] == ">") {
            i10++;
            break;
          } else {
            continue;
          }
        }
      }
      return i10;
    }
    __name(readPI, "readPI");
    function readCommentAndCDATA(xmlData, i10) {
      if (xmlData.length > i10 + 5 && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === "-") {
        for (i10 += 3; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "-" && xmlData[i10 + 1] === "-" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      } else if (xmlData.length > i10 + 8 && xmlData[i10 + 1] === "D" && xmlData[i10 + 2] === "O" && xmlData[i10 + 3] === "C" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "Y" && xmlData[i10 + 6] === "P" && xmlData[i10 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i10] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i10 + 9 && xmlData[i10 + 1] === "[" && xmlData[i10 + 2] === "C" && xmlData[i10 + 3] === "D" && xmlData[i10 + 4] === "A" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "A" && xmlData[i10 + 7] === "[") {
        for (i10 += 8; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "]" && xmlData[i10 + 1] === "]" && xmlData[i10 + 2] === ">") {
            i10 += 2;
            break;
          }
        }
      }
      return i10;
    }
    __name(readCommentAndCDATA, "readCommentAndCDATA");
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i10) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === doubleQuote || xmlData[i10] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i10];
          } else if (startChar !== xmlData[i10]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i10] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i10];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i10,
        tagClosed
      };
    }
    __name(readAttributeStr, "readAttributeStr");
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util2.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i10 = 0; i10 < matches.length; i10++) {
        if (matches[i10][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' has no space in starting.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] !== void 0 && matches[i10][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i10][2] + "' is without value.", getPositionFromMatch(matches[i10]));
        } else if (matches[i10][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i10][2] + "' is not allowed.", getPositionFromMatch(matches[i10]));
        }
        const attrName = matches[i10][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i10]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i10]));
        }
      }
      return true;
    }
    __name(validateAttributeString, "validateAttributeString");
    function validateNumberAmpersand(xmlData, i10) {
      let re = /\d/;
      if (xmlData[i10] === "x") {
        i10++;
        re = /[\da-fA-F]/;
      }
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === ";")
          return i10;
        if (!xmlData[i10].match(re))
          break;
      }
      return -1;
    }
    __name(validateNumberAmpersand, "validateNumberAmpersand");
    function validateAmpersand(xmlData, i10) {
      i10++;
      if (xmlData[i10] === ";")
        return -1;
      if (xmlData[i10] === "#") {
        i10++;
        return validateNumberAmpersand(xmlData, i10);
      }
      let count = 0;
      for (; i10 < xmlData.length; i10++, count++) {
        if (xmlData[i10].match(/\w/) && count < 20)
          continue;
        if (xmlData[i10] === ";")
          break;
        return -1;
      }
      return i10;
    }
    __name(validateAmpersand, "validateAmpersand");
    function getErrorObject(code2, message, lineNumber) {
      return {
        err: {
          code: code2,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    __name(getErrorObject, "getErrorObject");
    function validateAttrName(attrName) {
      return util2.isName(attrName);
    }
    __name(validateAttrName, "validateAttrName");
    function validateTagName(tagname) {
      return util2.isName(tagname);
    }
    __name(validateTagName, "validateTagName");
    function getLineNumberForPosition(xmlData, index2) {
      const lines = xmlData.substring(0, index2).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    __name(getLineNumberForPosition, "getLineNumberForPosition");
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
    __name(getPositionFromMatch, "getPositionFromMatch");
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = /* @__PURE__ */ __name(function(options) {
      return Object.assign({}, defaultOptions, options);
    }, "buildOptions");
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
    "use strict";
    var XmlNode = class {
      static {
        __name(this, "XmlNode");
      }
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module2.exports = XmlNode;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
    var util2 = require_util();
    function readDocType(xmlData, i10) {
      const entities = {};
      if (xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "C" && xmlData[i10 + 5] === "T" && xmlData[i10 + 6] === "Y" && xmlData[i10 + 7] === "P" && xmlData[i10 + 8] === "E") {
        i10 = i10 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i10 < xmlData.length; i10++) {
          if (xmlData[i10] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i10)) {
              i10 += 7;
              [entityName, val, i10] = readEntityExp(xmlData, i10 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i10))
              i10 += 8;
            else if (hasBody && isAttlist(xmlData, i10))
              i10 += 8;
            else if (hasBody && isNotation(xmlData, i10))
              i10 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i10] === ">") {
            if (comment) {
              if (xmlData[i10 - 1] === "-" && xmlData[i10 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i10] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i10];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i10 };
    }
    __name(readDocType, "readDocType");
    function readEntityExp(xmlData, i10) {
      let entityName2 = "";
      for (; i10 < xmlData.length && (xmlData[i10] !== "'" && xmlData[i10] !== '"'); i10++) {
        entityName2 += xmlData[i10];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i10++];
      let val2 = "";
      for (; i10 < xmlData.length && xmlData[i10] !== startChar; i10++) {
        val2 += xmlData[i10];
      }
      return [entityName2, val2, i10];
    }
    __name(readEntityExp, "readEntityExp");
    function isComment(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "-" && xmlData[i10 + 3] === "-")
        return true;
      return false;
    }
    __name(isComment, "isComment");
    function isEntity(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "N" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "I" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "Y")
        return true;
      return false;
    }
    __name(isEntity, "isEntity");
    function isElement(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "E" && xmlData[i10 + 3] === "L" && xmlData[i10 + 4] === "E" && xmlData[i10 + 5] === "M" && xmlData[i10 + 6] === "E" && xmlData[i10 + 7] === "N" && xmlData[i10 + 8] === "T")
        return true;
      return false;
    }
    __name(isElement, "isElement");
    function isAttlist(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "A" && xmlData[i10 + 3] === "T" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "L" && xmlData[i10 + 6] === "I" && xmlData[i10 + 7] === "S" && xmlData[i10 + 8] === "T")
        return true;
      return false;
    }
    __name(isAttlist, "isAttlist");
    function isNotation(xmlData, i10) {
      if (xmlData[i10 + 1] === "!" && xmlData[i10 + 2] === "N" && xmlData[i10 + 3] === "O" && xmlData[i10 + 4] === "T" && xmlData[i10 + 5] === "A" && xmlData[i10 + 6] === "T" && xmlData[i10 + 7] === "I" && xmlData[i10 + 8] === "O" && xmlData[i10 + 9] === "N")
        return true;
      return false;
    }
    __name(isNotation, "isNotation");
    function validateEntityName(name2) {
      if (util2.isName(name2))
        return name2;
      else
        throw new Error(`Invalid entity name ${name2}`);
    }
    __name(validateEntityName, "validateEntityName");
    module2.exports = readDocType;
  }
});

// ../../node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../../node_modules/strnum/strnum.js"(exports, module2) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    __name(toNumber, "toNumber");
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    __name(trimZeros, "trimZeros");
    module2.exports = toNumber;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
    "use strict";
    var util2 = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util2.nameRegexp);
    var OrderedObjParser = class {
      static {
        __name(this, "OrderedObjParser");
      }
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i10 = 0; i10 < entKeys.length; i10++) {
        const ent = entKeys[i10];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    __name(addExternalEntities, "addExternalEntities");
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    __name(parseTextData, "parseTextData");
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    __name(resolveNameSpace, "resolveNameSpace");
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util2.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i10 = 0; i10 < len; i10++) {
          const attrName = this.resolveNameSpace(matches[i10][1]);
          let oldVal = matches[i10][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    __name(buildAttributesMap, "buildAttributesMap");
    var parseXml = /* @__PURE__ */ __name(function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i10 = 0; i10 < xmlData.length; i10++) {
        const ch = xmlData[i10];
        if (ch === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            let tagData = readTagExp(xmlData, i10, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i10 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i10 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i10 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i10 = endIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i10);
            this.docTypeEntities = result.entities;
            i10 = result.i;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i10 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i10 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i10, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i10 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i10 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i10 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i10 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i10];
        }
      }
      return xmlObj.child;
    }, "parseXml");
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    __name(addChild, "addChild");
    var replaceEntitiesValue = /* @__PURE__ */ __name(function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    }, "replaceEntitiesValue");
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    __name(saveTextToParentTag, "saveTextToParentTag");
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    __name(isItStopNode, "isItStopNode");
    function tagExpWithClosingIndex(xmlData, i10, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index2 = i10; index2 < xmlData.length; index2++) {
        let ch = xmlData[index2];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index2 + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index: index2
              };
            }
          } else {
            return {
              data: tagExp,
              index: index2
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    __name(tagExpWithClosingIndex, "tagExpWithClosingIndex");
    function findClosingIndex(xmlData, str, i10, errMsg) {
      const closingIndex = xmlData.indexOf(str, i10);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    __name(findClosingIndex, "findClosingIndex");
    function readTagExp(xmlData, i10, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i10 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    __name(readTagExp, "readTagExp");
    function readStopNodeData(xmlData, tagName, i10) {
      const startIndex = i10;
      let openTagCount = 1;
      for (; i10 < xmlData.length; i10++) {
        if (xmlData[i10] === "<") {
          if (xmlData[i10 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i10, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i10 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i10),
                  i: closeIndex
                };
              }
            }
            i10 = closeIndex;
          } else if (xmlData[i10 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i10 + 1, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i10 + 3, "StopNode is not closed.");
            i10 = closeIndex;
          } else if (xmlData.substr(i10 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i10, "StopNode is not closed.") - 2;
            i10 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i10, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i10 = tagData.closeIndex;
            }
          }
        }
      }
    }
    __name(readStopNodeData, "readStopNodeData");
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util2.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    __name(parseValue, "parseValue");
    module2.exports = OrderedObjParser;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    __name(prettify, "prettify");
    function compress(arr, options, jPath) {
      let text2;
      const compressedObj = {};
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text2 === void 0)
            text2 = tagObj[property];
          else
            text2 += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text2 === "string") {
        if (text2.length > 0)
          compressedObj[options.textNodeName] = text2;
      } else if (text2 !== void 0)
        compressedObj[options.textNodeName] = text2;
      return compressedObj;
    }
    __name(compress, "compress");
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    __name(propName, "propName");
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i10 = 0; i10 < len; i10++) {
          const atrrName = keys[i10];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    __name(assignAttributes, "assignAttributes");
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    __name(isLeafTag, "isLeafTag");
    exports.prettify = prettify;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser4 = class {
      static {
        __name(this, "XMLParser");
      }
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module2.exports = XMLParser4;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    __name(toXml, "toXml");
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i10 = 0; i10 < arr.length; i10++) {
        const tagObj = arr[i10];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    __name(arrToStr, "arrToStr");
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i10 = 0; i10 < keys.length; i10++) {
        const key = keys[i10];
        if (key !== ":@")
          return key;
      }
    }
    __name(propName, "propName");
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    __name(attr_to_str, "attr_to_str");
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index2 in options.stopNodes) {
        if (options.stopNodes[index2] === jPath || options.stopNodes[index2] === "*." + tagName)
          return true;
      }
      return false;
    }
    __name(isStopNode, "isStopNode");
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i10 = 0; i10 < options.entities.length; i10++) {
          const entity = options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    __name(replaceEntitiesValue, "replaceEntitiesValue");
    module2.exports = toXml;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a10) {
        return a10;
      },
      attributeValueProcessor: function(attrName, a10) {
        return a10;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    __name(Builder, "Builder");
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j10 = 0; j10 < arrLen; j10++) {
            const item = jObj[key][j10];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j10 = 0; j10 < L; j10++) {
              attrStr += this.buildAttrPairStr(Ks[j10], "" + jObj[key][Ks[j10]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    __name(processTextOrObjNode, "processTextOrObjNode");
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i10 = 0; i10 < this.options.entities.length; i10++) {
          const entity = this.options.entities[i10];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    __name(indentate, "indentate");
    function isAttribute(name2) {
      if (name2.startsWith(this.options.attributeNamePrefix)) {
        return name2.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    __name(isAttribute, "isAttribute");
    module2.exports = Builder;
  }
});

// ../../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
    "use strict";
    var validator = require_validator();
    var XMLParser4 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module2.exports = {
      XMLParser: XMLParser4,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// ../../node_modules/aws-crt/dist/common/promise.js
var require_promise = __commonJS({
  "../../node_modules/aws-crt/dist/common/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newLiftedPromise = exports.makeSelfCleaningPromise = void 0;
    function makeSelfCleaningPromise(promise, cleaner) {
      if (!cleaner) {
        return promise;
      }
      return promise.finally(() => {
        cleaner();
      });
    }
    __name(makeSelfCleaningPromise, "makeSelfCleaningPromise");
    exports.makeSelfCleaningPromise = makeSelfCleaningPromise;
    function newLiftedPromise(promiseBody) {
      let localResolve = void 0;
      let localReject = void 0;
      let promise = new Promise((resolve, reject) => {
        localResolve = resolve;
        localReject = reject;
      });
      if (!localResolve || !localReject) {
        throw new Error("Failed to bind resolve and reject when making lifted promise");
      }
      if (promiseBody) {
        promiseBody(localResolve, localReject);
      }
      return {
        promise,
        resolve: localResolve,
        reject: localReject
      };
    }
    __name(newLiftedPromise, "newLiftedPromise");
    exports.newLiftedPromise = newLiftedPromise;
  }
});

// ../../node_modules/aws-crt/dist/common/cancel.js
var require_cancel = __commonJS({
  "../../node_modules/aws-crt/dist/common/cancel.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newCancellablePromiseFromNextEvent = exports.CancelController = exports.EVENT_NAME = void 0;
    var events_1 = __require("events");
    var promise = __importStar2(require_promise());
    exports.EVENT_NAME = "cancelled";
    var CancelController = class {
      static {
        __name(this, "CancelController");
      }
      constructor(options) {
        this.cancelled = false;
        if (options && options.emitterFactory) {
          this.emitter = options.emitterFactory();
        } else {
          this.emitter = new events_1.EventEmitter();
        }
      }
      /**
       * Cancels all asynchronous operations associated with this controller
       */
      cancel() {
        if (!this.cancelled) {
          this.cancelled = true;
          this.emitter.emit(exports.EVENT_NAME);
          this.emitter.removeAllListeners(exports.EVENT_NAME);
        }
      }
      /**
       * Checks whether or not the controller is in the cancelled state
       */
      hasBeenCancelled() {
        return this.cancelled;
      }
      /**
       * Registers a callback to be notified when cancel() is invoked externally.  In general, the callback
       * will cancel an asynchronous operation by rejecting the associated promise.
       *
       * IMPORTANT: The listener is invoked synchronously if the controller has already been cancelled.
       *
       * @param listener - function to invoke on cancel; invoked synchronously if the controller has been cancelled
       *
       * @return undefined if the controller has already been cancelled, otherwise a function object whose invocation
       * will remove the listener from the controller's event emitter.
       *
       */
      addListener(listener) {
        if (this.cancelled) {
          listener();
          return void 0;
        }
        this.emitter.on(exports.EVENT_NAME, listener);
        return () => {
          this.emitter.removeListener(exports.EVENT_NAME, listener);
        };
      }
    };
    exports.CancelController = CancelController;
    function newCancellablePromiseFromNextEvent(config) {
      let onEvent = void 0;
      let cancelRemoveListener = void 0;
      let liftedPromise = promise.newLiftedPromise();
      onEvent = /* @__PURE__ */ __name((eventData) => {
        try {
          if (config.eventDataTransformer) {
            liftedPromise.resolve(config.eventDataTransformer(eventData));
          } else {
            liftedPromise.resolve(eventData);
          }
        } catch (err) {
          liftedPromise.reject(err);
        }
      }, "onEvent");
      config.emitter.addListener(config.eventName, onEvent);
      if (config.cancelController) {
        cancelRemoveListener = config.cancelController.addListener(() => {
          liftedPromise.reject(config.cancelMessage);
        });
      }
      return promise.makeSelfCleaningPromise(liftedPromise.promise, () => {
        if (onEvent) {
          config.emitter.removeListener(config.eventName, onEvent);
        }
        if (cancelRemoveListener) {
          cancelRemoveListener();
        }
      });
    }
    __name(newCancellablePromiseFromNextEvent, "newCancellablePromiseFromNextEvent");
    exports.newCancellablePromiseFromNextEvent = newCancellablePromiseFromNextEvent;
  }
});

// ../../node_modules/aws-crt/package.json
var require_package = __commonJS({
  "../../node_modules/aws-crt/package.json"(exports, module2) {
    module2.exports = {
      name: "aws-crt",
      version: "1.17.0",
      description: "NodeJS/browser bindings to the aws-c-* libraries",
      homepage: "https://github.com/awslabs/aws-crt-nodejs",
      repository: {
        type: "git",
        url: "git+https://github.com/awslabs/aws-crt-nodejs.git"
      },
      contributors: [
        "AWS Common Runtime Team <aws-sdk-common-runtime@amazon.com>"
      ],
      license: "Apache-2.0",
      main: "./dist/index.js",
      browser: "./dist.browser/browser.js",
      types: "./dist/index.d.ts",
      scripts: {
        tsc: "node ./scripts/tsc.js",
        test: "npm run test:native",
        "test:node": "npm run test:native",
        "test:native": "npx jest --runInBand --verbose --config test/native/jest.config.js --forceExit",
        "test:browser": "npx jest --runInBand --verbose --config test/browser/jest.config.js --forceExit",
        "test:browser:ci": "npm run install:puppeteer && npm run test:browser",
        "install:puppeteer": "npm install --save-dev jest-puppeteer puppeteer @types/puppeteer",
        prepare: "node ./scripts/tsc.js && node ./scripts/install.js",
        install: "node ./scripts/install.js"
      },
      devDependencies: {
        "@types/crypto-js": "^3.1.43",
        "@types/jest": "^27.0.1",
        "@types/node": "^10.17.54",
        "@types/prettier": "2.6.0",
        "@types/puppeteer": "^5.4.7",
        "@types/uuid": "^3.4.8",
        "@types/ws": "^7.4.7",
        "aws-sdk": "^2.848.0",
        "cmake-js": "^6.3.2",
        "https-proxy-agent": "^5.0.1",
        jest: "^27.2.1",
        "jest-puppeteer": "^5.0.4",
        "jest-runtime": "^27.2.1",
        puppeteer: "^3.3.0",
        tar: "^6.1.11",
        "ts-jest": "^27.0.5",
        typedoc: "^0.22.18",
        "typedoc-plugin-merge-modules": "^3.1.0",
        typescript: "^4.7.4",
        uuid: "^8.3.2",
        yargs: "^17.2.1"
      },
      dependencies: {
        "@aws-sdk/util-utf8-browser": "^3.109.0",
        "@httptoolkit/websocket-stream": "^6.0.0",
        axios: "^0.24.0",
        buffer: "^6.0.3",
        "cmake-js": "^6.3.2",
        "crypto-js": "^4.0.0",
        mqtt: "^4.3.7",
        process: "^0.11.10",
        tar: "^6.1.11"
      }
    };
  }
});

// ../../node_modules/aws-crt/dist/common/platform.js
var require_platform = __commonJS({
  "../../node_modules/aws-crt/dist/common/platform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crt_version = exports.package_info = exports.is_browser = exports.is_nodejs = void 0;
    function is_nodejs() {
      return typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node !== "undefined";
    }
    __name(is_nodejs, "is_nodejs");
    exports.is_nodejs = is_nodejs;
    function is_browser() {
      return !is_nodejs();
    }
    __name(is_browser, "is_browser");
    exports.is_browser = is_browser;
    function package_info() {
      try {
        const pkg = require_package();
        return pkg;
      } catch (err) {
        return {
          name: "aws-crt-nodejs",
          version: "UNKNOWN"
        };
      }
    }
    __name(package_info, "package_info");
    exports.package_info = package_info;
    function crt_version() {
      const pkg = package_info();
      return pkg.version;
    }
    __name(crt_version, "crt_version");
    exports.crt_version = crt_version;
  }
});

// ../../node_modules/aws-crt/dist/common/resource_safety.js
var require_resource_safety = __commonJS({
  "../../node_modules/aws-crt/dist/common/resource_safety.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.using = void 0;
    function using(resource, func) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          yield func(resource);
        } finally {
          resource.close();
        }
      });
    }
    __name(using, "using");
    exports.using = using;
  }
});

// ../../node_modules/aws-crt/dist/native/binding.js
var require_binding = __commonJS({
  "../../node_modules/aws-crt/dist/native/binding.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cRuntime = exports.CRuntimeType = void 0;
    var path = __importStar2(__require("path"));
    var os_1 = __require("os");
    var fs_1 = __require("fs");
    var process_1 = __require("process");
    var child_process_1 = __importDefault2(__require("child_process"));
    var CRuntimeType = Object.freeze({
      NON_LINUX: "cruntime",
      MUSL: "musl",
      GLIBC: "glibc"
    });
    exports.CRuntimeType = CRuntimeType;
    function getCRuntime() {
      if ((0, os_1.platform)() !== "linux") {
        return CRuntimeType.NON_LINUX;
      }
      try {
        const spawnedProcess = child_process_1.default.spawnSync("ldd", ["--version"], { encoding: "utf8" });
        const output = spawnedProcess.stdout + spawnedProcess.stderr;
        if (output.includes(CRuntimeType.MUSL)) {
          return CRuntimeType.MUSL;
        } else {
          return CRuntimeType.GLIBC;
        }
      } catch (error) {
        return CRuntimeType.GLIBC;
      }
    }
    __name(getCRuntime, "getCRuntime");
    var upgrade_string = "Please upgrade to node >=10.16.0, or use the provided browser implementation.";
    if ("napi" in process_1.versions) {
      const napi_version = parseInt(process_1.versions["napi"]);
      if (napi_version < 4) {
        throw new Error("The AWS CRT native implementation requires that NAPI version 4 be present. " + upgrade_string);
      }
    } else {
      throw new Error("The current runtime is not reporting an NAPI version. " + upgrade_string);
    }
    var cRuntime = getCRuntime();
    exports.cRuntime = cRuntime;
    var binary_name = "aws-crt-nodejs";
    var platformDir = `${os_1.platform}-${os_1.arch}-${cRuntime}`;
    var source_root = path.resolve(__dirname, "..", "..");
    var dist = path.join(source_root, "dist");
    if ((0, fs_1.existsSync)(dist)) {
      source_root = dist;
    }
    var bin_path = path.resolve(source_root, "bin");
    var search_paths = [
      path.join(bin_path, platformDir, binary_name)
    ];
    var binding;
    for (const path2 of search_paths) {
      if ((0, fs_1.existsSync)(path2 + ".node")) {
        binding = __require(path2);
        break;
      }
    }
    if (binding == void 0) {
      throw new Error("AWS CRT binary not present in any of the following locations:\n	" + search_paths.join("\n	"));
    }
    exports.default = binding;
  }
});

// ../../node_modules/aws-crt/dist/native/error.js
var require_error = __commonJS({
  "../../node_modules/aws-crt/dist/native/error.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CrtError = void 0;
    var binding_1 = __importDefault2(require_binding());
    var CrtError = class extends Error {
      static {
        __name(this, "CrtError");
      }
      /** @var error - The original error. Most often an error_code, but possibly some other context */
      constructor(error) {
        super(extract_message(error));
        this.error = error;
        this.error_code = extract_code(error);
        this.error_name = extract_name(error);
      }
    };
    exports.CrtError = CrtError;
    function extract_message(error) {
      if (typeof error === "number") {
        return binding_1.default.error_code_to_string(error);
      } else if (error instanceof CrtError) {
        return error.message;
      }
      return error.toString();
    }
    __name(extract_message, "extract_message");
    function extract_code(error) {
      if (typeof error === "number") {
        return error;
      } else if (error instanceof CrtError) {
        return error.error_code;
      }
      return void 0;
    }
    __name(extract_code, "extract_code");
    function extract_name(error) {
      if (typeof error === "number") {
        return binding_1.default.error_code_to_name(error);
      } else if (error instanceof CrtError) {
        return error.error_name;
      }
      return void 0;
    }
    __name(extract_name, "extract_name");
  }
});

// ../../node_modules/aws-crt/dist/native/native_resource.js
var require_native_resource = __commonJS({
  "../../node_modules/aws-crt/dist/native/native_resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NativeResourceMixin = exports.NativeResource = void 0;
    var NativeResource = class {
      static {
        __name(this, "NativeResource");
      }
      constructor(handle) {
        this.handle = handle;
      }
      /** @internal */
      native_handle() {
        return this.handle;
      }
    };
    exports.NativeResource = NativeResource;
    function NativeResourceMixin(Base) {
      return class extends Base {
        /** @internal */
        constructor(...args) {
          const handle = args.shift();
          super(...args);
          this._handle = handle;
        }
        /** @internal */
        _super(handle) {
          this._handle = handle;
        }
        /** @internal */
        native_handle() {
          return this._handle;
        }
      };
    }
    __name(NativeResourceMixin, "NativeResourceMixin");
    exports.NativeResourceMixin = NativeResourceMixin;
  }
});

// ../../node_modules/aws-crt/dist/common/io.js
var require_io = __commonJS({
  "../../node_modules/aws-crt/dist/common/io.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketDomain = exports.SocketType = exports.TlsVersion = void 0;
    var TlsVersion;
    (function(TlsVersion2) {
      TlsVersion2[TlsVersion2["SSLv3"] = 0] = "SSLv3";
      TlsVersion2[TlsVersion2["TLSv1"] = 1] = "TLSv1";
      TlsVersion2[TlsVersion2["TLSv1_1"] = 2] = "TLSv1_1";
      TlsVersion2[TlsVersion2["TLSv1_2"] = 3] = "TLSv1_2";
      TlsVersion2[TlsVersion2["TLSv1_3"] = 4] = "TLSv1_3";
      TlsVersion2[TlsVersion2["Default"] = 128] = "Default";
    })(TlsVersion = exports.TlsVersion || (exports.TlsVersion = {}));
    var SocketType;
    (function(SocketType2) {
      SocketType2[SocketType2["STREAM"] = 0] = "STREAM";
      SocketType2[SocketType2["DGRAM"] = 1] = "DGRAM";
    })(SocketType = exports.SocketType || (exports.SocketType = {}));
    var SocketDomain;
    (function(SocketDomain2) {
      SocketDomain2[SocketDomain2["IPV4"] = 0] = "IPV4";
      SocketDomain2[SocketDomain2["IPV6"] = 1] = "IPV6";
      SocketDomain2[SocketDomain2["LOCAL"] = 2] = "LOCAL";
    })(SocketDomain = exports.SocketDomain || (exports.SocketDomain = {}));
  }
});

// ../../node_modules/aws-crt/dist/native/io.js
var require_io2 = __commonJS({
  "../../node_modules/aws-crt/dist/native/io.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pkcs11Lib = exports.TlsConnectionOptions = exports.ServerTlsContext = exports.ClientTlsContext = exports.TlsContext = exports.TlsContextOptions = exports.SocketOptions = exports.ClientBootstrap = exports.InputStream = exports.is_alpn_available = exports.enable_logging = exports.LogLevel = exports.error_code_to_name = exports.error_code_to_string = exports.SocketDomain = exports.SocketType = exports.TlsVersion = void 0;
    var binding_1 = __importDefault2(require_binding());
    var native_resource_1 = require_native_resource();
    var io_1 = require_io();
    var io_2 = require_io();
    Object.defineProperty(exports, "TlsVersion", { enumerable: true, get: function() {
      return io_2.TlsVersion;
    } });
    Object.defineProperty(exports, "SocketType", { enumerable: true, get: function() {
      return io_2.SocketType;
    } });
    Object.defineProperty(exports, "SocketDomain", { enumerable: true, get: function() {
      return io_2.SocketDomain;
    } });
    var error_1 = require_error();
    function error_code_to_string(error_code) {
      return binding_1.default.error_code_to_string(error_code);
    }
    __name(error_code_to_string, "error_code_to_string");
    exports.error_code_to_string = error_code_to_string;
    function error_code_to_name(error_code) {
      return binding_1.default.error_code_to_name(error_code);
    }
    __name(error_code_to_name, "error_code_to_name");
    exports.error_code_to_name = error_code_to_name;
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["NONE"] = 0] = "NONE";
      LogLevel2[LogLevel2["FATAL"] = 1] = "FATAL";
      LogLevel2[LogLevel2["ERROR"] = 2] = "ERROR";
      LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
      LogLevel2[LogLevel2["INFO"] = 4] = "INFO";
      LogLevel2[LogLevel2["DEBUG"] = 5] = "DEBUG";
      LogLevel2[LogLevel2["TRACE"] = 6] = "TRACE";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    function enable_logging(level) {
      binding_1.default.io_logging_enable(level);
    }
    __name(enable_logging, "enable_logging");
    exports.enable_logging = enable_logging;
    function is_alpn_available() {
      return binding_1.default.is_alpn_available();
    }
    __name(is_alpn_available, "is_alpn_available");
    exports.is_alpn_available = is_alpn_available;
    var InputStream = class extends native_resource_1.NativeResource {
      static {
        __name(this, "InputStream");
      }
      constructor(source) {
        super(binding_1.default.io_input_stream_new(16 * 1024));
        this.source = source;
        this.source.on("data", (data) => {
          data = Buffer.isBuffer(data) ? data : Buffer.from(data.toString());
          binding_1.default.io_input_stream_append(this.native_handle(), data);
        });
        this.source.on("end", () => {
          binding_1.default.io_input_stream_append(this.native_handle(), void 0);
        });
      }
    };
    exports.InputStream = InputStream;
    var ClientBootstrap = class extends native_resource_1.NativeResource {
      static {
        __name(this, "ClientBootstrap");
      }
      constructor() {
        super(binding_1.default.io_client_bootstrap_new());
      }
    };
    exports.ClientBootstrap = ClientBootstrap;
    var SocketOptions = class extends native_resource_1.NativeResource {
      static {
        __name(this, "SocketOptions");
      }
      constructor(type = io_1.SocketType.STREAM, domain = io_1.SocketDomain.IPV6, connect_timeout_ms = 5e3, keepalive = false, keep_alive_interval_sec = 0, keep_alive_timeout_sec = 0, keep_alive_max_failed_probes = 0) {
        super(binding_1.default.io_socket_options_new(type, domain, connect_timeout_ms, keep_alive_interval_sec, keep_alive_timeout_sec, keep_alive_max_failed_probes, keepalive));
      }
    };
    exports.SocketOptions = SocketOptions;
    var TlsContextOptions = class _TlsContextOptions {
      static {
        __name(this, "TlsContextOptions");
      }
      constructor() {
        this.min_tls_version = io_1.TlsVersion.Default;
        this.alpn_list = [];
        this.verify_peer = true;
      }
      /**
       * Overrides the default system trust store.
       * @param ca_dirpath - Only used on Unix-style systems where all trust anchors are
       * stored in a directory (e.g. /etc/ssl/certs).
       * @param ca_filepath - Single file containing all trust CAs, in PEM format
       */
      override_default_trust_store_from_path(ca_dirpath, ca_filepath) {
        this.ca_dirpath = ca_dirpath;
        this.ca_filepath = ca_filepath;
      }
      /**
       * Overrides the default system trust store.
       * @param certificate_authority - String containing all trust CAs, in PEM format
       */
      override_default_trust_store(certificate_authority) {
        this.certificate_authority = certificate_authority;
      }
      /**
       * Create options configured for mutual TLS in client mode,
       * with client certificate and private key provided as in-memory strings.
       * @param certificate - Client certificate file contents, in PEM format
       * @param private_key - Client private key file contents, in PEM format
       *
       * @returns newly configured TlsContextOptions object
       */
      static create_client_with_mtls(certificate, private_key) {
        let opt = new _TlsContextOptions();
        opt.certificate = certificate;
        opt.private_key = private_key;
        opt.verify_peer = true;
        return opt;
      }
      /**
       * Create options configured for mutual TLS in client mode,
       * with client certificate and private key provided via filepath.
       * @param certificate_filepath - Path to client certificate, in PEM format
       * @param private_key_filepath - Path to private key, in PEM format
       *
       * @returns newly configured TlsContextOptions object
       */
      static create_client_with_mtls_from_path(certificate_filepath, private_key_filepath) {
        let opt = new _TlsContextOptions();
        opt.certificate_filepath = certificate_filepath;
        opt.private_key_filepath = private_key_filepath;
        opt.verify_peer = true;
        return opt;
      }
      /**
       * Create options for mutual TLS in client mode,
       * with client certificate and private key bundled in a single PKCS#12 file.
       * @param pkcs12_filepath - Path to PKCS#12 file containing client certificate and private key.
       * @param pkcs12_password - PKCS#12 password
       *
       * @returns newly configured TlsContextOptions object
      */
      static create_client_with_mtls_pkcs12_from_path(pkcs12_filepath, pkcs12_password) {
        let opt = new _TlsContextOptions();
        opt.pkcs12_filepath = pkcs12_filepath;
        opt.pkcs12_password = pkcs12_password;
        opt.verify_peer = true;
        return opt;
      }
      /**
       * @deprecated Renamed [[create_client_with_mtls_pkcs12_from_path]]
       */
      static create_client_with_mtls_pkcs_from_path(pkcs12_filepath, pkcs12_password) {
        return this.create_client_with_mtls_pkcs12_from_path(pkcs12_filepath, pkcs12_password);
      }
      /**
       * Create options configured for mutual TLS in client mode,
       * using a PKCS#11 library for private key operations.
       *
       * NOTE: This configuration only works on Unix devices.
       *
       * @param options - PKCS#11 options
       *
       * @returns newly configured TlsContextOptions object
       */
      static create_client_with_mtls_pkcs11(options) {
        let opt = new _TlsContextOptions();
        opt.pkcs11_options = options;
        opt.verify_peer = true;
        return opt;
      }
      /**
       * Create options configured for mutual TLS in client mode,
       * using a certificate in a Windows certificate store.
       *
       * NOTE: Windows only.
       *
       * @param certificate_path - Path to certificate in a Windows certificate store.
       *      The path must use backslashes and end with the certificate's thumbprint.
       *      Example: `CurrentUser\MY\A11F8A9B5DF5B98BA3508FBCA575D09570E0D2C6`
       */
      static create_client_with_mtls_windows_cert_store_path(certificate_path) {
        let opt = new _TlsContextOptions();
        opt.windows_cert_store_path = certificate_path;
        opt.verify_peer = true;
        return opt;
      }
      /**
       * Creates TLS context with peer verification disabled, along with a certificate and private key
       * @param certificate_filepath - Path to certificate, in PEM format
       * @param private_key_filepath - Path to private key, in PEM format
       *
       * @returns newly configured TlsContextOptions object
       */
      static create_server_with_mtls_from_path(certificate_filepath, private_key_filepath) {
        let opt = new _TlsContextOptions();
        opt.certificate_filepath = certificate_filepath;
        opt.private_key_filepath = private_key_filepath;
        opt.verify_peer = false;
        return opt;
      }
      /**
       * Creates TLS context with peer verification disabled, along with a certificate and private key
       * in PKCS#12 format
       * @param pkcs12_filepath - Path to certificate, in PKCS#12 format
       * @param pkcs12_password - PKCS#12 Password
       *
       * @returns newly configured TlsContextOptions object
       */
      static create_server_with_mtls_pkcs_from_path(pkcs12_filepath, pkcs12_password) {
        let opt = new _TlsContextOptions();
        opt.pkcs12_filepath = pkcs12_filepath;
        opt.pkcs12_password = pkcs12_password;
        opt.verify_peer = false;
        return opt;
      }
    };
    exports.TlsContextOptions = TlsContextOptions;
    var TlsContext = class extends native_resource_1.NativeResource {
      static {
        __name(this, "TlsContext");
      }
      constructor(ctx_opt) {
        if (ctx_opt == null || ctx_opt == void 0) {
          throw new error_1.CrtError("TlsContext constructor: ctx_opt not defined");
        }
        super(binding_1.default.io_tls_ctx_new(ctx_opt.min_tls_version, ctx_opt.ca_filepath, ctx_opt.ca_dirpath, ctx_opt.certificate_authority, ctx_opt.alpn_list && ctx_opt.alpn_list.length > 0 ? ctx_opt.alpn_list.join(";") : void 0, ctx_opt.certificate_filepath, ctx_opt.certificate, ctx_opt.private_key_filepath, ctx_opt.private_key, ctx_opt.pkcs12_filepath, ctx_opt.pkcs12_password, ctx_opt.pkcs11_options, ctx_opt.windows_cert_store_path, ctx_opt.verify_peer));
      }
    };
    exports.TlsContext = TlsContext;
    var ClientTlsContext = class extends TlsContext {
      static {
        __name(this, "ClientTlsContext");
      }
      constructor(ctx_opt) {
        if (!ctx_opt) {
          ctx_opt = new TlsContextOptions();
          ctx_opt.verify_peer = true;
        }
        super(ctx_opt);
      }
    };
    exports.ClientTlsContext = ClientTlsContext;
    var ServerTlsContext = class extends TlsContext {
      static {
        __name(this, "ServerTlsContext");
      }
      constructor(ctx_opt) {
        if (!ctx_opt) {
          ctx_opt = new TlsContextOptions();
          ctx_opt.verify_peer = false;
        }
        super(ctx_opt);
      }
    };
    exports.ServerTlsContext = ServerTlsContext;
    var TlsConnectionOptions = class extends native_resource_1.NativeResource {
      static {
        __name(this, "TlsConnectionOptions");
      }
      constructor(tls_ctx, server_name, alpn_list = []) {
        if (tls_ctx == null || tls_ctx == void 0) {
          throw new error_1.CrtError("TlsConnectionOptions constructor: tls_ctx not defined");
        }
        super(binding_1.default.io_tls_connection_options_new(tls_ctx.native_handle(), server_name, alpn_list && alpn_list.length > 0 ? alpn_list.join(";") : void 0));
        this.tls_ctx = tls_ctx;
        this.server_name = server_name;
        this.alpn_list = alpn_list;
      }
    };
    exports.TlsConnectionOptions = TlsConnectionOptions;
    var Pkcs11Lib = class _Pkcs11Lib extends native_resource_1.NativeResource {
      static {
        __name(this, "Pkcs11Lib");
      }
      /**
       * @param path - Path to PKCS#11 library.
       * @param behavior - Specifies how `C_Initialize()` and `C_Finalize()`
       *                   will be called on the PKCS#11 library.
       */
      constructor(path, behavior = _Pkcs11Lib.InitializeFinalizeBehavior.DEFAULT) {
        super(binding_1.default.io_pkcs11_lib_new(path, behavior));
      }
      /**
       * Release the PKCS#11 library immediately, without waiting for the GC.
       */
      close() {
        binding_1.default.io_pkcs11_lib_close(this.native_handle());
      }
    };
    exports.Pkcs11Lib = Pkcs11Lib;
    (function(Pkcs11Lib2) {
      let InitializeFinalizeBehavior;
      (function(InitializeFinalizeBehavior2) {
        InitializeFinalizeBehavior2[InitializeFinalizeBehavior2["DEFAULT"] = 0] = "DEFAULT";
        InitializeFinalizeBehavior2[InitializeFinalizeBehavior2["OMIT"] = 1] = "OMIT";
        InitializeFinalizeBehavior2[InitializeFinalizeBehavior2["STRICT"] = 2] = "STRICT";
      })(InitializeFinalizeBehavior = Pkcs11Lib2.InitializeFinalizeBehavior || (Pkcs11Lib2.InitializeFinalizeBehavior = {}));
    })(Pkcs11Lib = exports.Pkcs11Lib || (exports.Pkcs11Lib = {}));
  }
});

// ../../node_modules/aws-crt/dist/native/auth.js
var require_auth = __commonJS({
  "../../node_modules/aws-crt/dist/native/auth.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aws_verify_sigv4a_signing = exports.aws_sign_request = exports.AwsSignedBodyHeaderType = exports.AwsSignedBodyValue = exports.AwsSignatureType = exports.AwsSigningAlgorithm = exports.AwsCredentialsProvider = void 0;
    var binding_1 = __importDefault2(require_binding());
    var error_1 = require_error();
    var io_1 = require_io2();
    var AwsCredentialsProvider = class extends binding_1.default.AwsCredentialsProvider {
      static {
        __name(this, "AwsCredentialsProvider");
      }
      /**
       * Creates a new default credentials provider to be used internally for AWS credentials resolution:
       *
       *   The CRT's default provider chain currently sources in this order:
       *
       *     1. Environment
       *     2. Profile
       *     3. (conditional, off by default) ECS
       *     4. (conditional, on by default) EC2 Instance Metadata
       *
       * @param bootstrap (optional) client bootstrap to be used to establish any required network connections
       *
       * @returns a new credentials provider using default credentials resolution rules
       */
      static newDefault(bootstrap = void 0) {
        return super.newDefault(bootstrap != null ? bootstrap.native_handle() : null);
      }
      /**
       * Creates a new credentials provider that returns a fixed set of credentials.
       *
       * @param access_key access key to use in the static credentials
       * @param secret_key secret key to use in the static credentials
       * @param session_token (optional) session token to use in the static credentials
       *
       * @returns a new credentials provider that will return a fixed set of AWS credentials
       */
      static newStatic(access_key, secret_key, session_token) {
        return super.newStatic(access_key, secret_key, session_token);
      }
      /**
       * Creates a new credentials provider that sources credentials from the AWS Cognito Identity service via the
       * GetCredentialsForIdentity http API.
       *
       * @param config provider configuration necessary to make GetCredentialsForIdentity web requests
       *
       * @returns a new credentials provider that returns credentials sourced from the AWS Cognito Identity service
       */
      static newCognito(config) {
        if (config == null || config == void 0) {
          throw new error_1.CrtError("AwsCredentialsProvider newCognito: Cognito config not defined");
        }
        return super.newCognito(config, config.tlsContext != null ? config.tlsContext.native_handle() : new io_1.ClientTlsContext().native_handle(), config.bootstrap != null ? config.bootstrap.native_handle() : null, config.httpProxyOptions ? config.httpProxyOptions.create_native_handle() : null);
      }
      /**
       * Creates a new credentials provider that sources credentials from the the X509 service on AWS IoT Core.
       *
       * @param config provider configuration necessary to source credentials via X509
       *
       * @returns a new credentials provider that returns credentials sourced from the AWS X509 service
       */
      static newX509(config) {
        if (config == null || config == void 0) {
          throw new error_1.CrtError("AwsCredentialsProvider newX509: X509 config not defined");
        }
        return super.newX509(config, config.tlsContext.native_handle(), config.httpProxyOptions ? config.httpProxyOptions.create_native_handle() : null);
      }
    };
    exports.AwsCredentialsProvider = AwsCredentialsProvider;
    var AwsSigningAlgorithm;
    (function(AwsSigningAlgorithm2) {
      AwsSigningAlgorithm2[AwsSigningAlgorithm2["SigV4"] = 0] = "SigV4";
      AwsSigningAlgorithm2[AwsSigningAlgorithm2["SigV4Asymmetric"] = 1] = "SigV4Asymmetric";
    })(AwsSigningAlgorithm = exports.AwsSigningAlgorithm || (exports.AwsSigningAlgorithm = {}));
    var AwsSignatureType;
    (function(AwsSignatureType2) {
      AwsSignatureType2[AwsSignatureType2["HttpRequestViaHeaders"] = 0] = "HttpRequestViaHeaders";
      AwsSignatureType2[AwsSignatureType2["HttpRequestViaQueryParams"] = 1] = "HttpRequestViaQueryParams";
      AwsSignatureType2[AwsSignatureType2["HttpRequestChunk"] = 2] = "HttpRequestChunk";
      AwsSignatureType2[AwsSignatureType2["HttpRequestEvent"] = 3] = "HttpRequestEvent";
    })(AwsSignatureType = exports.AwsSignatureType || (exports.AwsSignatureType = {}));
    var AwsSignedBodyValue;
    (function(AwsSignedBodyValue2) {
      AwsSignedBodyValue2["EmptySha256"] = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      AwsSignedBodyValue2["UnsignedPayload"] = "UNSIGNED-PAYLOAD";
      AwsSignedBodyValue2["StreamingAws4HmacSha256Payload"] = "STREAMING-AWS4-HMAC-SHA256-PAYLOAD";
      AwsSignedBodyValue2["StreamingAws4HmacSha256Events"] = "STREAMING-AWS4-HMAC-SHA256-EVENTS";
    })(AwsSignedBodyValue = exports.AwsSignedBodyValue || (exports.AwsSignedBodyValue = {}));
    var AwsSignedBodyHeaderType;
    (function(AwsSignedBodyHeaderType2) {
      AwsSignedBodyHeaderType2[AwsSignedBodyHeaderType2["None"] = 0] = "None";
      AwsSignedBodyHeaderType2[AwsSignedBodyHeaderType2["XAmzContentSha256"] = 1] = "XAmzContentSha256";
    })(AwsSignedBodyHeaderType = exports.AwsSignedBodyHeaderType || (exports.AwsSignedBodyHeaderType = {}));
    function aws_sign_request(request3, config) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          try {
            binding_1.default.aws_sign_request(request3, config, (error_code) => {
              if (error_code == 0) {
                resolve(request3);
              } else {
                reject(new error_1.CrtError(error_code));
              }
            });
          } catch (error) {
            reject(error);
          }
        });
      });
    }
    __name(aws_sign_request, "aws_sign_request");
    exports.aws_sign_request = aws_sign_request;
    function aws_verify_sigv4a_signing(request3, config, expected_canonical_request, signature, ecc_key_pub_x, ecc_key_pub_y) {
      return binding_1.default.aws_verify_sigv4a_signing(request3, config, expected_canonical_request, signature, ecc_key_pub_x, ecc_key_pub_y);
    }
    __name(aws_verify_sigv4a_signing, "aws_verify_sigv4a_signing");
    exports.aws_verify_sigv4a_signing = aws_verify_sigv4a_signing;
  }
});

// ../../node_modules/aws-crt/dist/native/checksums.js
var require_checksums = __commonJS({
  "../../node_modules/aws-crt/dist/native/checksums.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc32c = exports.crc32 = void 0;
    var binding_1 = __importDefault2(require_binding());
    function crc32(data, previous) {
      return binding_1.default.checksums_crc32(data, previous);
    }
    __name(crc32, "crc32");
    exports.crc32 = crc32;
    function crc32c(data, previous) {
      return binding_1.default.checksums_crc32c(data, previous);
    }
    __name(crc32c, "crc32c");
    exports.crc32c = crc32c;
  }
});

// ../../node_modules/aws-crt/dist/native/crt.js
var require_crt = __commonJS({
  "../../node_modules/aws-crt/dist/native/crt.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.native_memory_dump = exports.native_memory = void 0;
    var binding_1 = __importDefault2(require_binding());
    function native_memory() {
      return binding_1.default.native_memory();
    }
    __name(native_memory, "native_memory");
    exports.native_memory = native_memory;
    function native_memory_dump() {
      return binding_1.default.native_memory_dump();
    }
    __name(native_memory_dump, "native_memory_dump");
    exports.native_memory_dump = native_memory_dump;
  }
});

// ../../node_modules/aws-crt/dist/native/crypto.js
var require_crypto = __commonJS({
  "../../node_modules/aws-crt/dist/native/crypto.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha256 = exports.Sha256Hmac = exports.hash_sha1 = exports.Sha1Hash = exports.hash_sha256 = exports.Sha256Hash = exports.hash_md5 = exports.Md5Hash = void 0;
    var binding_1 = __importDefault2(require_binding());
    var native_resource_1 = require_native_resource();
    var Hash2 = class extends native_resource_1.NativeResource {
      static {
        __name(this, "Hash");
      }
      /**
       * Hash additional data.
       * @param data Additional data to hash
       */
      update(data) {
        binding_1.default.hash_update(this.native_handle(), data);
      }
      /**
       * Completes the hash computation and returns the final hash digest.
       *
       * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.
       */
      finalize(truncate_to) {
        return binding_1.default.hash_digest(this.native_handle(), truncate_to);
      }
      constructor(hash_handle) {
        super(hash_handle);
      }
    };
    var Md5Hash = class extends Hash2 {
      static {
        __name(this, "Md5Hash");
      }
      constructor() {
        super(binding_1.default.hash_md5_new());
      }
    };
    exports.Md5Hash = Md5Hash;
    function hash_md5(data, truncate_to) {
      return binding_1.default.hash_md5_compute(data, truncate_to);
    }
    __name(hash_md5, "hash_md5");
    exports.hash_md5 = hash_md5;
    var Sha256Hash = class extends Hash2 {
      static {
        __name(this, "Sha256Hash");
      }
      constructor() {
        super(binding_1.default.hash_sha256_new());
      }
    };
    exports.Sha256Hash = Sha256Hash;
    function hash_sha256(data, truncate_to) {
      return binding_1.default.hash_sha256_compute(data, truncate_to);
    }
    __name(hash_sha256, "hash_sha256");
    exports.hash_sha256 = hash_sha256;
    var Sha1Hash = class extends Hash2 {
      static {
        __name(this, "Sha1Hash");
      }
      constructor() {
        super(binding_1.default.hash_sha1_new());
      }
    };
    exports.Sha1Hash = Sha1Hash;
    function hash_sha1(data, truncate_to) {
      return binding_1.default.hash_sha1_compute(data, truncate_to);
    }
    __name(hash_sha1, "hash_sha1");
    exports.hash_sha1 = hash_sha1;
    var Hmac = class extends native_resource_1.NativeResource {
      static {
        __name(this, "Hmac");
      }
      /**
       * Hash additional data.
       *
       * @param data additional data to hash
       */
      update(data) {
        binding_1.default.hmac_update(this.native_handle(), data);
      }
      /**
       * Completes the hash computation and returns the final hmac digest.
       *
       * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.
       */
      finalize(truncate_to) {
        return binding_1.default.hmac_digest(this.native_handle(), truncate_to);
      }
      constructor(hash_handle) {
        super(hash_handle);
      }
    };
    var Sha256Hmac = class extends Hmac {
      static {
        __name(this, "Sha256Hmac");
      }
      constructor(secret) {
        super(binding_1.default.hmac_sha256_new(secret));
      }
    };
    exports.Sha256Hmac = Sha256Hmac;
    function hmac_sha256(secret, data, truncate_to) {
      return binding_1.default.hmac_sha256_compute(secret, data, truncate_to);
    }
    __name(hmac_sha256, "hmac_sha256");
    exports.hmac_sha256 = hmac_sha256;
  }
});

// ../../node_modules/aws-crt/dist/common/event.js
var require_event = __commonJS({
  "../../node_modules/aws-crt/dist/common/event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedEventEmitter = void 0;
    var events_1 = __require("events");
    var BufferedEvent = class {
      static {
        __name(this, "BufferedEvent");
      }
      constructor(event, args) {
        this.event = event;
        this.args = args;
      }
    };
    var BufferedEventEmitter = class extends events_1.EventEmitter {
      static {
        __name(this, "BufferedEventEmitter");
      }
      constructor() {
        super();
        this.corked = false;
      }
      /**
       * Forces all written events to be buffered in memory. The buffered data will be
       * flushed when {@link BufferedEventEmitter.uncork} is called.
       */
      cork() {
        this.corked = true;
      }
      /**
       * Flushes all data buffered since {@link BufferedEventEmitter.cork} was called.
       *
       * NOTE: It is HIGHLY recommended that uncorking should always be done via
       * ``` process.nextTick```, not during the ```EventEmitter.on()``` call.
       */
      uncork() {
        this.corked = false;
        while (this.eventQueue) {
          const event = this.eventQueue;
          super.emit(event.event, ...event.args);
          this.eventQueue = this.eventQueue.next;
        }
      }
      /**
       * Synchronously calls each of the listeners registered for the event key supplied
       * in registration order. If the {@link BufferedEventEmitter} is currently corked,
       * the event will be buffered until {@link BufferedEventEmitter.uncork} is called.
       * @param event The name of the event
       * @param args Event payload
       */
      emit(event, ...args) {
        if (this.corked) {
          let last = this.lastQueuedEvent;
          this.lastQueuedEvent = new BufferedEvent(event, args);
          if (last) {
            last.next = this.lastQueuedEvent;
          } else {
            this.eventQueue = this.lastQueuedEvent;
          }
          return this.listeners(event).length > 0;
        }
        return super.emit(event, ...args);
      }
    };
    exports.BufferedEventEmitter = BufferedEventEmitter;
  }
});

// ../../node_modules/aws-crt/dist/native/eventstream_utils.js
var require_eventstream_utils = __commonJS({
  "../../node_modules/aws-crt/dist/native/eventstream_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unmarshalInt64BigintFromBuffer = exports.marshalInt64BigintAsBuffer = exports.MIN_INT64 = exports.MAX_INT64 = exports.MIN_INT32 = exports.MAX_INT32 = exports.MIN_INT16 = exports.MAX_INT16 = exports.MIN_INT8 = exports.MAX_INT8 = void 0;
    var error_1 = require_error();
    exports.MAX_INT8 = 127;
    exports.MIN_INT8 = -128;
    exports.MAX_INT16 = 32767;
    exports.MIN_INT16 = -32768;
    exports.MAX_INT32 = 2147483647;
    exports.MIN_INT32 = -2147483648;
    exports.MAX_INT64 = BigInt("9223372036854775807");
    exports.MIN_INT64 = BigInt("-9223372036854775808");
    var MAX_UINT8_AS_BIGINT = BigInt("256");
    function marshalInt64BigintAsBuffer(value) {
      if (value < exports.MIN_INT64 || value > exports.MAX_INT64) {
        throw new error_1.CrtError("marshalInt64BigintAsBuffer expects a value that can fit in 8 bytes");
      }
      let buffer = new Uint8Array(8);
      if (value < 0) {
        value = -value - BigInt(1);
        for (let i10 = 0; i10 < 8; ++i10) {
          buffer[i10] = 255 - Number(value % MAX_UINT8_AS_BIGINT);
          value /= MAX_UINT8_AS_BIGINT;
        }
      } else {
        for (let i10 = 0; i10 < 8; ++i10) {
          buffer[i10] = Number(value % MAX_UINT8_AS_BIGINT);
          value /= MAX_UINT8_AS_BIGINT;
        }
      }
      return buffer;
    }
    __name(marshalInt64BigintAsBuffer, "marshalInt64BigintAsBuffer");
    exports.marshalInt64BigintAsBuffer = marshalInt64BigintAsBuffer;
    function unmarshalInt64BigintFromBuffer(buffer) {
      let value = BigInt(0);
      let byteView = new Uint8Array(buffer);
      if (byteView.length != 8) {
        throw new error_1.CrtError("unmarshalInt64BigintFromBuffer expects a byte buffer of length 8");
      }
      let shift = BigInt(1);
      let isNegative = (byteView[7] & 128) != 0;
      if (isNegative) {
        for (let i10 = 0; i10 < byteView.length; ++i10) {
          let byteValue = BigInt(255 - byteView[i10]);
          value += byteValue * shift;
          shift *= MAX_UINT8_AS_BIGINT;
        }
        value += BigInt(1);
        value = -value;
      } else {
        for (let i10 = 0; i10 < byteView.length; ++i10) {
          let byteValue = BigInt(byteView[i10]);
          value += byteValue * shift;
          shift *= MAX_UINT8_AS_BIGINT;
        }
      }
      return value;
    }
    __name(unmarshalInt64BigintFromBuffer, "unmarshalInt64BigintFromBuffer");
    exports.unmarshalInt64BigintFromBuffer = unmarshalInt64BigintFromBuffer;
  }
});

// ../../node_modules/aws-crt/dist/native/eventstream.js
var require_eventstream = __commonJS({
  "../../node_modules/aws-crt/dist/native/eventstream.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientStream = exports.ClientConnection = exports.MessageType = exports.MessageFlags = exports.Header = exports.HeaderType = void 0;
    var native_resource_1 = require_native_resource();
    var event_1 = require_event();
    var error_1 = require_error();
    var io = __importStar2(require_io2());
    var eventstream_utils = __importStar2(require_eventstream_utils());
    var promise = __importStar2(require_promise());
    var binding_1 = __importDefault2(require_binding());
    var HeaderType;
    (function(HeaderType2) {
      HeaderType2[HeaderType2["BooleanTrue"] = 0] = "BooleanTrue";
      HeaderType2[HeaderType2["BooleanFalse"] = 1] = "BooleanFalse";
      HeaderType2[HeaderType2["Byte"] = 2] = "Byte";
      HeaderType2[HeaderType2["Int16"] = 3] = "Int16";
      HeaderType2[HeaderType2["Int32"] = 4] = "Int32";
      HeaderType2[HeaderType2["Int64"] = 5] = "Int64";
      HeaderType2[HeaderType2["ByteBuffer"] = 6] = "ByteBuffer";
      HeaderType2[HeaderType2["String"] = 7] = "String";
      HeaderType2[HeaderType2["Timestamp"] = 8] = "Timestamp";
      HeaderType2[HeaderType2["UUID"] = 9] = "UUID";
    })(HeaderType = exports.HeaderType || (exports.HeaderType = {}));
    var AWS_MAXIMUM_EVENT_STREAM_HEADER_NAME_LENGTH = 127;
    var Header = class _Header {
      static {
        __name(this, "Header");
      }
      /** @internal */
      constructor(name2, type, value) {
        this.name = name2;
        this.type = type;
        this.value = value;
      }
      static validateHeaderName(name2) {
        if (name2.length == 0 || name2.length > AWS_MAXIMUM_EVENT_STREAM_HEADER_NAME_LENGTH) {
          throw new error_1.CrtError(`Event stream header name (${name2}) is not valid`);
        }
      }
      /**
       * Create a new boolean-valued message header
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newBoolean(name2, value) {
        _Header.validateHeaderName(name2);
        if (value) {
          return new _Header(name2, HeaderType.BooleanTrue);
        } else {
          return new _Header(name2, HeaderType.BooleanFalse);
        }
      }
      /**
       * Create a new byte-valued message header
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newByte(name2, value) {
        _Header.validateHeaderName(name2);
        if (value >= eventstream_utils.MIN_INT8 && value <= eventstream_utils.MAX_INT8 && Number.isSafeInteger(value)) {
          return new _Header(name2, HeaderType.Byte, value);
        }
        throw new error_1.CrtError(`Illegal value for eventstream byte-valued header: ${value}`);
      }
      /**
       * Create a new 16-bit-integer-valued message header
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newInt16(name2, value) {
        _Header.validateHeaderName(name2);
        if (value >= eventstream_utils.MIN_INT16 && value <= eventstream_utils.MAX_INT16 && Number.isSafeInteger(value)) {
          return new _Header(name2, HeaderType.Int16, value);
        }
        throw new error_1.CrtError(`Illegal value for eventstream int16-valued header: ${value}`);
      }
      /**
       * Create a new 32-bit-integer-valued message header
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newInt32(name2, value) {
        _Header.validateHeaderName(name2);
        if (value >= eventstream_utils.MIN_INT32 && value <= eventstream_utils.MAX_INT32 && Number.isSafeInteger(value)) {
          return new _Header(name2, HeaderType.Int32, value);
        }
        throw new error_1.CrtError(`Illegal value for eventstream int32-valued header: ${value}`);
      }
      /**
       * Create a new 64-bit-integer-valued message header.  number cannot represent a full 64-bit integer range but
       * its usage is so common that this exists for convenience.  Internally, we always track 64 bit integers as
       * bigints.
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newInt64FromNumber(name2, value) {
        _Header.validateHeaderName(name2);
        if (Number.isSafeInteger(value)) {
          return new _Header(name2, HeaderType.Int64, eventstream_utils.marshalInt64BigintAsBuffer(BigInt(value)));
        }
        throw new error_1.CrtError(`Illegal value for eventstream int64-valued header: ${value}`);
      }
      /**
       * Create a new 64-bit-integer-valued message header from a big integer.
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newInt64FromBigint(name2, value) {
        _Header.validateHeaderName(name2);
        if (value >= eventstream_utils.MIN_INT64 && value <= eventstream_utils.MAX_INT64) {
          return new _Header(name2, HeaderType.Int64, eventstream_utils.marshalInt64BigintAsBuffer(value));
        }
        throw new error_1.CrtError(`Illegal value for eventstream int64-valued header: ${value}`);
      }
      /**
       * Create a new byte-buffer-valued message header
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newByteBuffer(name2, value) {
        _Header.validateHeaderName(name2);
        return new _Header(name2, HeaderType.ByteBuffer, value);
      }
      /**
       * Create a new string-valued message header
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newString(name2, value) {
        _Header.validateHeaderName(name2);
        return new _Header(name2, HeaderType.String, value);
      }
      /**
       * Create a new timestamp-valued message header from an integral value in seconds since epoch.
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newTimeStampFromSecondsSinceEpoch(name2, secondsSinceEpoch) {
        _Header.validateHeaderName(name2);
        if (Number.isSafeInteger(secondsSinceEpoch) && secondsSinceEpoch >= 0) {
          return new _Header(name2, HeaderType.Timestamp, secondsSinceEpoch);
        }
        throw new error_1.CrtError(`Illegal value for eventstream timestamp-valued header: ${secondsSinceEpoch}`);
      }
      /**
       * Create a new timestamp-valued message header from a date.
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newTimeStampFromDate(name2, date2) {
        _Header.validateHeaderName(name2);
        const secondsSinceEpoch = date2.getTime();
        if (Number.isSafeInteger(secondsSinceEpoch)) {
          return new _Header(name2, HeaderType.Timestamp, secondsSinceEpoch);
        }
        throw new error_1.CrtError(`Illegal value for eventstream timestamp-valued header: ${date2}`);
      }
      /**
       * Create a new UUID-valued message header.
       * WIP
       *
       * @param name name of the header
       * @param value value of the header
       */
      static newUUID(name2, value) {
        _Header.validateHeaderName(name2);
        if (value.byteLength == 16) {
          return new _Header(name2, HeaderType.UUID, value);
        }
        throw new error_1.CrtError(`Illegal value for eventstream uuid-valued header: ${value}`);
      }
      toValue(type) {
        if (type != this.type) {
          throw new error_1.CrtError(`Header of type (${this.type}) cannot be converted to type (${type})`);
        }
        return this.value;
      }
      /**
       * All conversion functions require the header's type to be appropriately matching.  There are no error-prone
       * flexible conversion helpers.
       */
      /**
       * Returns a boolean header's value.
       */
      asBoolean() {
        switch (this.type) {
          case HeaderType.BooleanFalse:
            return false;
          case HeaderType.BooleanTrue:
            return true;
          default:
            throw new error_1.CrtError(`Header of type (${this.type}) cannot be converted to type (boolean)`);
        }
      }
      /**
       * Returns a byte header's value.
       */
      asByte() {
        return this.toValue(HeaderType.Byte);
      }
      /**
       * Returns a 16-bit integer header's value.
       */
      asInt16() {
        return this.toValue(HeaderType.Int16);
      }
      /**
       * Returns a 32-bit integer header's value.
       */
      asInt32() {
        return this.toValue(HeaderType.Int32);
      }
      /**
       * Returns a 64-bit integer header's value.
       */
      asInt64() {
        return eventstream_utils.unmarshalInt64BigintFromBuffer(this.toValue(HeaderType.Int64));
      }
      /**
       * Returns a byte buffer header's value.
       */
      asByteBuffer() {
        return this.toValue(HeaderType.ByteBuffer);
      }
      /**
       * Returns a string header's value.
       */
      asString() {
        return this.toValue(HeaderType.String);
      }
      /**
       * Returns a timestamp header's value (as seconds since epoch).
       */
      asTimestamp() {
        return this.toValue(HeaderType.Timestamp);
      }
      /**
       * Returns a UUID header's value.
       */
      asUUID() {
        return this.toValue(HeaderType.UUID);
      }
    };
    exports.Header = Header;
    var MessageFlags;
    (function(MessageFlags2) {
      MessageFlags2[MessageFlags2["None"] = 0] = "None";
      MessageFlags2[MessageFlags2["ConnectionAccepted"] = 1] = "ConnectionAccepted";
      MessageFlags2[MessageFlags2["TerminateStream"] = 2] = "TerminateStream";
    })(MessageFlags = exports.MessageFlags || (exports.MessageFlags = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["ApplicationMessage"] = 0] = "ApplicationMessage";
      MessageType2[MessageType2["ApplicationError"] = 1] = "ApplicationError";
      MessageType2[MessageType2["Ping"] = 2] = "Ping";
      MessageType2[MessageType2["PingResponse"] = 3] = "PingResponse";
      MessageType2[MessageType2["Connect"] = 4] = "Connect";
      MessageType2[MessageType2["ConnectAck"] = 5] = "ConnectAck";
      MessageType2[MessageType2["ProtocolError"] = 6] = "ProtocolError";
      MessageType2[MessageType2["InternalError"] = 7] = "InternalError";
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    function mapPodHeadersToJSHeaders(headers) {
      return Array.from(headers, (header) => {
        return new Header(header.name, header.type, header.value);
      });
    }
    __name(mapPodHeadersToJSHeaders, "mapPodHeadersToJSHeaders");
    function mapPodMessageToJSMessage(message) {
      let jsMessage = {
        type: message.type,
        flags: message.flags,
        payload: message.payload
      };
      if (message.headers) {
        jsMessage.headers = mapPodHeadersToJSHeaders(message.headers);
      }
      return jsMessage;
    }
    __name(mapPodMessageToJSMessage, "mapPodMessageToJSMessage");
    var ClientConnectionState;
    (function(ClientConnectionState2) {
      ClientConnectionState2[ClientConnectionState2["None"] = 0] = "None";
      ClientConnectionState2[ClientConnectionState2["Connecting"] = 1] = "Connecting";
      ClientConnectionState2[ClientConnectionState2["Connected"] = 2] = "Connected";
      ClientConnectionState2[ClientConnectionState2["Disconnected"] = 3] = "Disconnected";
      ClientConnectionState2[ClientConnectionState2["Closed"] = 4] = "Closed";
    })(ClientConnectionState || (ClientConnectionState = {}));
    var ClientConnection = class _ClientConnection extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {
      static {
        __name(this, "ClientConnection");
      }
      /**
       * Configures and creates a new ClientConnection instance
       *
       * @param config configuration options for the event stream connection
       */
      constructor(config) {
        if (config === void 0) {
          throw new error_1.CrtError("Invalid configuration passed to eventstream ClientConnection constructor");
        }
        super();
        this.state = ClientConnectionState.None;
        this._super(binding_1.default.event_stream_client_connection_new(this, config, (connection, errorCode) => {
          _ClientConnection._s_on_disconnect(connection, errorCode);
        }, (connection, message) => {
          _ClientConnection._s_on_protocol_message(connection, message);
        }, config.socketOptions ? config.socketOptions.native_handle() : null, config.tlsCtx ? config.tlsCtx.native_handle() : null));
      }
      /**
       * Shuts down the connection (if active) and begins the process to release native resources associated with it by
       * having the native binding release the only reference to the extern object representing the connection.  Once
       * close() has been called, no more events will be emitted and all public API invocations will trigger an exception.
       *
       * Ultimately, the native resources will not be released until the connection has fully shut down and that
       * shutdown event has reached the libuv event loop.
       *
       * This function **must** be called for every ClientConnection instance or native resources will leak.
       */
      close() {
        if (this.state != ClientConnectionState.Closed) {
          this.state = ClientConnectionState.Closed;
          binding_1.default.event_stream_client_connection_close(this.native_handle());
        }
      }
      /**
       * Attempts to open a network connection to the configured remote endpoint.  Returned promise will be fulfilled if
       * the transport-level connection is successfully established, and rejected otherwise.
       *
       * connect() may only be called once.
       */
      connect(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let cleanupCancelListener = void 0;
          let connectPromise = new Promise((resolve, reject) => {
            if (!options) {
              reject(new error_1.CrtError("Invalid options passed to event stream ClientConnection.connect"));
              return;
            }
            if (this.state != ClientConnectionState.None) {
              reject(new error_1.CrtError(`Event stream connection in a state (${this.state}) where connect() is not allowed.`));
              return;
            }
            this.state = ClientConnectionState.Connecting;
            if (options.cancelController) {
              let cancel = /* @__PURE__ */ __name(() => {
                reject(new error_1.CrtError(`Event stream connection connect() cancelled by external request.`));
                setImmediate(() => {
                  this.close();
                });
              }, "cancel");
              cleanupCancelListener = options.cancelController.addListener(cancel);
              if (!cleanupCancelListener) {
                return;
              }
            }
            function curriedPromiseCallback(connection, errorCode) {
              return _ClientConnection._s_on_connection_setup(resolve, reject, connection, errorCode);
            }
            __name(curriedPromiseCallback, "curriedPromiseCallback");
            try {
              binding_1.default.event_stream_client_connection_connect(this.native_handle(), curriedPromiseCallback);
            } catch (e10) {
              this.state = ClientConnectionState.Disconnected;
              reject(e10);
            }
          });
          return promise.makeSelfCleaningPromise(connectPromise, cleanupCancelListener);
        });
      }
      /**
       * Attempts to send an event stream protocol message over an open connection.
       *
       * @param options configuration -- including the message itself -- for sending a protocol message
       *
       * Returns a promise that will be fulfilled when the message is successfully flushed to the wire, and rejected if
       * an error occurs prior to that point.
       */
      sendProtocolMessage(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let cleanupCancelListener = void 0;
          let sendProtocolMessagePromise = new Promise((resolve, reject) => {
            try {
              let curriedPromiseCallback = function(errorCode) {
                return _ClientConnection._s_on_connection_send_protocol_message_completion(resolve, reject, errorCode);
              };
              __name(curriedPromiseCallback, "curriedPromiseCallback");
              if (!options) {
                reject(new error_1.CrtError("Invalid options passed to event stream ClientConnection.sendProtocolMessage"));
                return;
              }
              if (!this.isConnected()) {
                reject(new error_1.CrtError(`Event stream connection in a state (${this.state}) where sending protocol messages is not allowed.`));
                return;
              }
              if (options.cancelController) {
                let cancel = /* @__PURE__ */ __name(() => {
                  reject(new error_1.CrtError(`Event stream connection sendProtocolMessage() cancelled by external request.`));
                  setImmediate(() => {
                    this.close();
                  });
                }, "cancel");
                cleanupCancelListener = options.cancelController.addListener(cancel);
                if (!cleanupCancelListener) {
                  return;
                }
              }
              binding_1.default.event_stream_client_connection_send_protocol_message(this.native_handle(), options, curriedPromiseCallback);
            } catch (e10) {
              reject(e10);
            }
          });
          return promise.makeSelfCleaningPromise(sendProtocolMessagePromise, cleanupCancelListener);
        });
      }
      /**
       * Returns true if the connection is currently open and ready-to-use, false otherwise.
       *
       * Internal note: Our notion of "connected" is intentionally not an invocation of
       * aws_event_stream_rpc_client_connection_is_open() (whose status is an out-of-sync race condition vs. our
       * well-defined client state)
       */
      isConnected() {
        return this.state == ClientConnectionState.Connected;
      }
      /**
       * Creates a new stream within the connection.
       */
      newStream() {
        if (!this.isConnected()) {
          throw new error_1.CrtError(`Event stream connection in a state (${this.state}) where creating new streams is forbidden.`);
        }
        return new ClientStream(this);
      }
      on(event, listener) {
        super.on(event, listener);
        return this;
      }
      static _s_on_connection_setup(resolve, reject, connection, errorCode) {
        if (errorCode == 0 && connection.state == ClientConnectionState.Connecting) {
          connection.state = ClientConnectionState.Connected;
          resolve();
        } else {
          if (connection.state != ClientConnectionState.Closed) {
            connection.state = ClientConnectionState.Disconnected;
          }
          reject(io.error_code_to_string(errorCode));
        }
      }
      static _s_on_disconnect(connection, errorCode) {
        if (connection.state != ClientConnectionState.Closed) {
          connection.state = ClientConnectionState.Disconnected;
        }
        process.nextTick(() => {
          connection.emit("disconnection", { errorCode });
        });
      }
      static _s_on_protocol_message(connection, message) {
        process.nextTick(() => {
          connection.emit("protocolMessage", { message: mapPodMessageToJSMessage(message) });
        });
      }
      static _s_on_connection_send_protocol_message_completion(resolve, reject, errorCode) {
        if (errorCode == 0) {
          resolve();
        } else {
          reject(io.error_code_to_string(errorCode));
        }
      }
    };
    exports.ClientConnection = ClientConnection;
    ClientConnection.DISCONNECTION = "disconnection";
    ClientConnection.PROTOCOL_MESSAGE = "protocolMessage";
    var ClientStreamState;
    (function(ClientStreamState2) {
      ClientStreamState2[ClientStreamState2["None"] = 0] = "None";
      ClientStreamState2[ClientStreamState2["Activating"] = 1] = "Activating";
      ClientStreamState2[ClientStreamState2["Activated"] = 2] = "Activated";
      ClientStreamState2[ClientStreamState2["Ended"] = 3] = "Ended";
      ClientStreamState2[ClientStreamState2["Closed"] = 4] = "Closed";
    })(ClientStreamState || (ClientStreamState = {}));
    var ClientStream = class _ClientStream extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {
      static {
        __name(this, "ClientStream");
      }
      constructor(connection) {
        super();
        this._super(binding_1.default.event_stream_client_stream_new(this, connection.native_handle(), (stream) => {
          _ClientStream._s_on_stream_ended(stream);
        }, (stream, message) => {
          _ClientStream._s_on_stream_message(stream, message);
        }));
        this.state = ClientStreamState.None;
      }
      /**
       * Shuts down the stream (if active) and begins the process to release native resources associated with it by
       * having the native binding release the only reference to the extern object representing the stream.  Once
       * close() has been called, no more events will be emitted and all public API invocations will trigger an exception.
       *
       * Ultimately, the native resources will not be released until the native stream has fully shut down and that
       * shutdown event has reached the libuv event loop.
       *
       * This function **must** be called for every ClientStream instance or native resources will leak.
       */
      close() {
        if (this.state != ClientStreamState.Closed) {
          this.state = ClientStreamState.Closed;
          binding_1.default.event_stream_client_stream_close(this.native_handle());
        }
      }
      /**
       * Activates the stream, allowing it to start sending and receiving messages.  The promise completes when
       * the activation message has been written to the wire.
       *
       * activate() may only be called once.
       *
       * @param options -- configuration data for stream activation, including operation name and initial message
       */
      activate(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let cleanupCancelListener = void 0;
          let activatePromise = new Promise((resolve, reject) => {
            try {
              let curriedPromiseCallback = function(stream, errorCode) {
                return _ClientStream._s_on_stream_activated(resolve, reject, stream, errorCode);
              };
              __name(curriedPromiseCallback, "curriedPromiseCallback");
              if (this.state != ClientStreamState.None) {
                reject(new error_1.CrtError(`Event stream in a state (${this.state}) where activation is not allowed.`));
                return;
              }
              if (options === void 0) {
                this.state = ClientStreamState.Ended;
                reject(new error_1.CrtError("Invalid options passed to ClientStream.activate"));
                return;
              }
              this.state = ClientStreamState.Activating;
              if (options.cancelController) {
                let cancel = /* @__PURE__ */ __name(() => {
                  reject(new error_1.CrtError(`Event stream activate() cancelled by external request.`));
                  setImmediate(() => {
                    this.close();
                  });
                }, "cancel");
                cleanupCancelListener = options.cancelController.addListener(cancel);
                if (!cleanupCancelListener) {
                  return;
                }
              }
              binding_1.default.event_stream_client_stream_activate(this.native_handle(), options, curriedPromiseCallback);
            } catch (e10) {
              this.state = ClientStreamState.Ended;
              reject(e10);
            }
          });
          return promise.makeSelfCleaningPromise(activatePromise, cleanupCancelListener);
        });
      }
      /**
       * Attempts to send an event stream message.
       *
       * @param options configuration -- including the message itself -- for sending a message
       *
       * Returns a promise that will be fulfilled when the message is successfully flushed to the wire, and rejected if
       * an error occurs prior to that point.
       */
      sendMessage(options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let cleanupCancelListener = void 0;
          let sendMessagePromise = new Promise((resolve, reject) => {
            try {
              let curriedPromiseCallback = function(errorCode) {
                return _ClientStream._s_on_stream_send_message_completion(resolve, reject, errorCode);
              };
              __name(curriedPromiseCallback, "curriedPromiseCallback");
              if (!options) {
                reject(new error_1.CrtError("Invalid options passed to ClientStream.sendMessage"));
                return;
              }
              if (this.state != ClientStreamState.Activated) {
                reject(new error_1.CrtError(`Event stream in a state (${this.state}) where sending messages is not allowed.`));
                return;
              }
              if (options.cancelController) {
                let cancel = /* @__PURE__ */ __name(() => {
                  reject(new error_1.CrtError(`Event stream sendMessage() cancelled by external request.`));
                  setImmediate(() => {
                    this.close();
                  });
                }, "cancel");
                cleanupCancelListener = options.cancelController.addListener(cancel);
                if (!cleanupCancelListener) {
                  return;
                }
              }
              binding_1.default.event_stream_client_stream_send_message(this.native_handle(), options, curriedPromiseCallback);
            } catch (e10) {
              reject(e10);
            }
          });
          return promise.makeSelfCleaningPromise(sendMessagePromise, cleanupCancelListener);
        });
      }
      /**
       * Returns true if the stream is currently active and ready-to-use, false otherwise.
       */
      isActive() {
        return this.state == ClientStreamState.Activated;
      }
      on(event, listener) {
        super.on(event, listener);
        return this;
      }
      static _s_on_stream_activated(resolve, reject, stream, errorCode) {
        if (errorCode == 0 && stream.state == ClientStreamState.Activating) {
          stream.state = ClientStreamState.Activated;
          resolve();
        } else {
          if (stream.state != ClientStreamState.Closed) {
            stream.state = ClientStreamState.Ended;
          }
          reject(io.error_code_to_string(errorCode));
        }
      }
      static _s_on_stream_send_message_completion(resolve, reject, errorCode) {
        if (errorCode == 0) {
          resolve();
        } else {
          reject(io.error_code_to_string(errorCode));
        }
      }
      static _s_on_stream_ended(stream) {
        process.nextTick(() => {
          stream.emit(_ClientStream.ENDED, {});
        });
      }
      static _s_on_stream_message(stream, message) {
        process.nextTick(() => {
          stream.emit(_ClientStream.MESSAGE, { message: mapPodMessageToJSMessage(message) });
        });
      }
    };
    exports.ClientStream = ClientStream;
    ClientStream.ENDED = "ended";
    ClientStream.MESSAGE = "message";
  }
});

// ../../node_modules/aws-crt/dist/common/http.js
var require_http = __commonJS({
  "../../node_modules/aws-crt/dist/common/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonHttpProxyOptions = exports.HttpProxyAuthenticationType = exports.HttpVersion = void 0;
    var HttpVersion;
    (function(HttpVersion2) {
      HttpVersion2[HttpVersion2["Unknown"] = 0] = "Unknown";
      HttpVersion2[HttpVersion2["Http1_0"] = 1] = "Http1_0";
      HttpVersion2[HttpVersion2["Http1_1"] = 2] = "Http1_1";
      HttpVersion2[HttpVersion2["Http2"] = 3] = "Http2";
    })(HttpVersion = exports.HttpVersion || (exports.HttpVersion = {}));
    var HttpProxyAuthenticationType;
    (function(HttpProxyAuthenticationType2) {
      HttpProxyAuthenticationType2[HttpProxyAuthenticationType2["None"] = 0] = "None";
      HttpProxyAuthenticationType2[HttpProxyAuthenticationType2["Basic"] = 1] = "Basic";
    })(HttpProxyAuthenticationType = exports.HttpProxyAuthenticationType || (exports.HttpProxyAuthenticationType = {}));
    var CommonHttpProxyOptions = class {
      static {
        __name(this, "CommonHttpProxyOptions");
      }
      /**
       *
       * @param host_name endpoint of the proxy to use
       * @param port port of proxy to use
       * @param auth_method type of authentication to use with the proxy
       * @param auth_username (basic authentication only) proxy username
       * @param auth_password (basic authentication only) password associated with the username
       */
      constructor(host_name, port, auth_method = HttpProxyAuthenticationType.None, auth_username, auth_password) {
        this.host_name = host_name;
        this.port = port;
        this.auth_method = auth_method;
        this.auth_username = auth_username;
        this.auth_password = auth_password;
      }
    };
    exports.CommonHttpProxyOptions = CommonHttpProxyOptions;
  }
});

// ../../node_modules/aws-crt/dist/native/http.js
var require_http2 = __commonJS({
  "../../node_modules/aws-crt/dist/native/http.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClientConnectionManager = exports.HttpClientStream = exports.HttpStream = exports.HttpClientConnection = exports.HttpProxyOptions = exports.HttpProxyConnectionType = exports.HttpConnection = exports.HttpRequest = exports.HttpHeaders = exports.HttpProxyAuthenticationType = void 0;
    var binding_1 = __importDefault2(require_binding());
    var native_resource_1 = require_native_resource();
    var error_1 = require_error();
    var http_1 = require_http();
    var http_2 = require_http();
    Object.defineProperty(exports, "HttpProxyAuthenticationType", { enumerable: true, get: function() {
      return http_2.HttpProxyAuthenticationType;
    } });
    var event_1 = require_event();
    exports.HttpHeaders = binding_1.default.HttpHeaders;
    var nativeHttpRequest = binding_1.default.HttpRequest;
    var HttpRequest2 = class extends nativeHttpRequest {
      static {
        __name(this, "HttpRequest");
      }
      constructor(method, path, headers, body) {
        super(method, path, headers, body === null || body === void 0 ? void 0 : body.native_handle());
      }
    };
    exports.HttpRequest = HttpRequest2;
    var HttpConnection = class extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {
      static {
        __name(this, "HttpConnection");
      }
      constructor(native_handle) {
        super();
        this._super(native_handle);
      }
      /**
       * Close the connection.
       * Shutdown is asynchronous. This call has no effect if the connection is already
       * closing.
       */
      close() {
        binding_1.default.http_connection_close(this.native_handle());
      }
      // Overridden to allow uncorking on ready
      on(event, listener) {
        super.on(event, listener);
        if (event == "connect") {
          process.nextTick(() => {
            this.uncork();
          });
        }
        return this;
      }
    };
    exports.HttpConnection = HttpConnection;
    HttpConnection.CONNECT = "connect";
    HttpConnection.ERROR = "error";
    HttpConnection.CLOSE = "close";
    var HttpProxyConnectionType;
    (function(HttpProxyConnectionType2) {
      HttpProxyConnectionType2[HttpProxyConnectionType2["Legacy"] = 0] = "Legacy";
      HttpProxyConnectionType2[HttpProxyConnectionType2["Forwarding"] = 1] = "Forwarding";
      HttpProxyConnectionType2[HttpProxyConnectionType2["Tunneling"] = 2] = "Tunneling";
    })(HttpProxyConnectionType = exports.HttpProxyConnectionType || (exports.HttpProxyConnectionType = {}));
    var HttpProxyOptions = class extends http_1.CommonHttpProxyOptions {
      static {
        __name(this, "HttpProxyOptions");
      }
      /**
       *
       * @param host_name Name of the proxy server to connect through
       * @param port Port number of the proxy server to connect through
       * @param auth_method Type of proxy authentication to use. Default is {@link HttpProxyAuthenticationType.None}
       * @param auth_username Username to use when `auth_type` is {@link HttpProxyAuthenticationType.Basic}
       * @param auth_password Password to use when `auth_type` is {@link HttpProxyAuthenticationType.Basic}
       * @param tls_opts Optional TLS connection options for the connection to the proxy host.
       *                 Must be distinct from the {@link TlsConnectionOptions} provided to
       *                 the HTTP connection
       * @param connection_type Optional Type of connection to make.  If not specified,
       *                 {@link HttpProxyConnectionType.Legacy} will be used.
       */
      constructor(host_name, port, auth_method = http_1.HttpProxyAuthenticationType.None, auth_username, auth_password, tls_opts, connection_type) {
        super(host_name, port, auth_method, auth_username, auth_password);
        this.tls_opts = tls_opts;
        this.connection_type = connection_type;
      }
      /** @internal */
      create_native_handle() {
        return binding_1.default.http_proxy_options_new(this.host_name, this.port, this.auth_method, this.auth_username, this.auth_password, this.tls_opts ? this.tls_opts.native_handle() : void 0, this.connection_type ? this.connection_type : HttpProxyConnectionType.Legacy);
      }
    };
    exports.HttpProxyOptions = HttpProxyOptions;
    var HttpClientConnection = class extends HttpConnection {
      static {
        __name(this, "HttpClientConnection");
      }
      /** Asynchronously establish a new HttpClientConnection.
       * @param bootstrap Client bootstrap to use when initiating socket connection.  Leave undefined to use the
       *          default system-wide bootstrap (recommended).
       * @param host_name Host to connect to
       * @param port Port to connect to on host
       * @param socket_options Socket options
       * @param tls_opts Optional TLS connection options
       * @param proxy_options Optional proxy options
      */
      constructor(bootstrap, host_name, port, socket_options, tls_opts, proxy_options, handle) {
        if (socket_options == null || socket_options == void 0) {
          throw new error_1.CrtError("HttpClientConnection constructor: socket_options not defined");
        }
        super(handle ? handle : binding_1.default.http_connection_new(bootstrap != null ? bootstrap.native_handle() : null, (handle2, error_code) => {
          this._on_setup(handle2, error_code);
        }, (handle2, error_code) => {
          this._on_shutdown(handle2, error_code);
        }, host_name, port, socket_options.native_handle(), tls_opts ? tls_opts.native_handle() : void 0, proxy_options ? proxy_options.create_native_handle() : void 0));
        this.bootstrap = bootstrap;
        this.socket_options = socket_options;
        this.tls_opts = tls_opts;
      }
      _on_setup(native_handle, error_code) {
        if (error_code) {
          this.emit("error", new error_1.CrtError(error_code));
          return;
        }
        this.emit("connect");
      }
      _on_shutdown(native_handle, error_code) {
        if (error_code) {
          this.emit("error", new error_1.CrtError(error_code));
          return;
        }
        this.emit("close");
      }
      /**
       * Create {@link HttpClientStream} to carry out the request/response exchange.
       *
       * NOTE: The stream sends no data until :meth:`HttpClientStream.activate()`
       * is called. Call {@link HttpStream.activate} when you're ready for
       * callbacks and events to fire.
       * @param request - The HttpRequest to attempt on this connection
       * @returns A new stream that will deliver events for the request
       */
      request(request3) {
        let stream;
        const on_response_impl = /* @__PURE__ */ __name((status_code, headers) => {
          stream._on_response(status_code, headers);
        }, "on_response_impl");
        const on_body_impl = /* @__PURE__ */ __name((data) => {
          stream._on_body(data);
        }, "on_body_impl");
        const on_complete_impl = /* @__PURE__ */ __name((error_code) => {
          stream._on_complete(error_code);
        }, "on_complete_impl");
        const native_handle = binding_1.default.http_stream_new(this.native_handle(), request3, on_complete_impl, on_response_impl, on_body_impl);
        return stream = new HttpClientStream(native_handle, this, request3);
      }
    };
    exports.HttpClientConnection = HttpClientConnection;
    var HttpStream2 = class extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {
      static {
        __name(this, "HttpStream");
      }
      constructor(native_handle, connection) {
        super();
        this.connection = connection;
        this._super(native_handle);
        this.cork();
      }
      /**
       * Begin sending the request.
       *
       * The stream does nothing until this is called. Call activate() when you
       * are ready for its callbacks and events to fire.
       */
      activate() {
        binding_1.default.http_stream_activate(this.native_handle());
      }
      /**
       * Closes and ends all communication on this stream. Called automatically after the 'end'
       * event is delivered. Calling this manually is only necessary if you wish to terminate
       * communication mid-request/response.
       */
      close() {
        binding_1.default.http_stream_close(this.native_handle());
      }
      /** @internal */
      _on_body(data) {
        this.emit("data", data);
      }
      /** @internal */
      _on_complete(error_code) {
        if (error_code) {
          this.emit("error", new error_1.CrtError(error_code));
          this.close();
          return;
        }
        this.on("end", () => {
          this.close();
        });
        this.emit("end");
      }
    };
    exports.HttpStream = HttpStream2;
    var HttpClientStream = class extends HttpStream2 {
      static {
        __name(this, "HttpClientStream");
      }
      constructor(native_handle, connection, request3) {
        super(native_handle, connection);
        this.request = request3;
      }
      /**
       * HTTP status code returned from the server.
       * @return Either the status code, or undefined if the server response has not arrived yet.
       */
      status_code() {
        return this.response_status_code;
      }
      // Overridden to allow uncorking on ready and response
      on(event, listener) {
        super.on(event, listener);
        if (event == "response") {
          process.nextTick(() => {
            this.uncork();
          });
        }
        return this;
      }
      /** @internal */
      _on_response(status_code, header_array) {
        this.response_status_code = status_code;
        let headers = new exports.HttpHeaders(header_array);
        this.emit("response", status_code, headers);
      }
    };
    exports.HttpClientStream = HttpClientStream;
    HttpClientStream.RESPONSE = "response";
    HttpClientStream.DATA = "data";
    HttpClientStream.ERROR = "error";
    HttpClientStream.END = "end";
    HttpClientStream.HEADERS = "headers";
    var HttpClientConnectionManager = class extends native_resource_1.NativeResource {
      static {
        __name(this, "HttpClientConnectionManager");
      }
      /**
       * @param bootstrap Client bootstrap to use when initiating socket connections.  Leave undefined to use the
       *          default system-wide bootstrap (recommended).
       * @param host Host to connect to
       * @param port Port to connect to on host
       * @param max_connections Maximum number of connections to pool
       * @param initial_window_size Optional initial window size
       * @param socket_options Socket options to use when initiating socket connections
       * @param tls_opts Optional TLS connection options
       * @param proxy_options Optional proxy options
       */
      constructor(bootstrap, host, port, max_connections, initial_window_size, socket_options, tls_opts, proxy_options) {
        if (socket_options == null || socket_options == void 0) {
          throw new error_1.CrtError("HttpClientConnectionManager constructor: socket_options not defined");
        }
        super(binding_1.default.http_connection_manager_new(
          bootstrap != null ? bootstrap.native_handle() : null,
          host,
          port,
          max_connections,
          initial_window_size,
          socket_options.native_handle(),
          tls_opts ? tls_opts.native_handle() : void 0,
          proxy_options ? proxy_options.create_native_handle() : void 0,
          void 0
          /* on_shutdown */
        ));
        this.bootstrap = bootstrap;
        this.host = host;
        this.port = port;
        this.max_connections = max_connections;
        this.initial_window_size = initial_window_size;
        this.socket_options = socket_options;
        this.tls_opts = tls_opts;
        this.proxy_options = proxy_options;
        this.connections = /* @__PURE__ */ new Map();
      }
      /**
      * Vends a connection from the pool
      * @returns A promise that results in an HttpClientConnection. When done with the connection, return
      *          it via {@link release}
      */
      acquire() {
        return new Promise((resolve, reject) => {
          const on_acquired = /* @__PURE__ */ __name((handle, error_code) => {
            if (error_code) {
              reject(new error_1.CrtError(error_code));
              return;
            }
            let connection = this.connections.get(handle);
            if (!connection) {
              connection = new HttpClientConnection(this.bootstrap, this.host, this.port, this.socket_options, this.tls_opts, this.proxy_options, handle);
              this.connections.set(handle, connection);
              connection.on("close", () => {
                this.connections.delete(handle);
              });
            }
            resolve(connection);
          }, "on_acquired");
          binding_1.default.http_connection_manager_acquire(this.native_handle(), on_acquired);
        });
      }
      /**
       * Returns an unused connection to the pool
       * @param connection - The connection to return
      */
      release(connection) {
        if (connection == null || connection == void 0) {
          throw new error_1.CrtError("HttpClientConnectionManager release: connection not defined");
        }
        binding_1.default.http_connection_manager_release(this.native_handle(), connection.native_handle());
      }
      /** Closes all connections and rejects all pending requests */
      close() {
        binding_1.default.http_connection_manager_close(this.native_handle());
      }
    };
    exports.HttpClientConnectionManager = HttpClientConnectionManager;
  }
});

// ../../node_modules/aws-crt/dist/common/mqtt.js
var require_mqtt = __commonJS({
  "../../node_modules/aws-crt/dist/common/mqtt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_RECONNECT_MIN_SEC = exports.DEFAULT_RECONNECT_MAX_SEC = exports.MqttWill = exports.QoS = void 0;
    var QoS;
    (function(QoS2) {
      QoS2[QoS2["AtMostOnce"] = 0] = "AtMostOnce";
      QoS2[QoS2["AtLeastOnce"] = 1] = "AtLeastOnce";
      QoS2[QoS2["ExactlyOnce"] = 2] = "ExactlyOnce";
    })(QoS = exports.QoS || (exports.QoS = {}));
    var MqttWill = class {
      static {
        __name(this, "MqttWill");
      }
      constructor(topic, qos, payload, retain = false) {
        this.topic = topic;
        this.qos = qos;
        this.payload = payload;
        this.retain = retain;
      }
    };
    exports.MqttWill = MqttWill;
    exports.DEFAULT_RECONNECT_MAX_SEC = 128;
    exports.DEFAULT_RECONNECT_MIN_SEC = 1;
  }
});

// ../../node_modules/aws-crt/dist/common/aws_iot_shared.js
var require_aws_iot_shared = __commonJS({
  "../../node_modules/aws-crt/dist/common/aws_iot_shared.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractRegionFromEndpoint = exports.buildMqtt5FinalUsername = exports.populate_username_string_with_custom_authorizer = exports.is_string_and_not_empty = exports.add_to_username_parameter = void 0;
    var platform3 = __importStar2(require_platform());
    function add_to_username_parameter(current_username, parameter_value, parameter_pre_text) {
      let return_string = current_username;
      if (return_string.indexOf("?") != -1) {
        return_string += "&";
      } else {
        return_string += "?";
      }
      if (parameter_value.indexOf(parameter_pre_text) != -1) {
        return return_string + parameter_value;
      } else {
        return return_string + parameter_pre_text + parameter_value;
      }
    }
    __name(add_to_username_parameter, "add_to_username_parameter");
    exports.add_to_username_parameter = add_to_username_parameter;
    function is_string_and_not_empty(item) {
      return item != void 0 && typeof item == "string" && item != "";
    }
    __name(is_string_and_not_empty, "is_string_and_not_empty");
    exports.is_string_and_not_empty = is_string_and_not_empty;
    function populate_username_string_with_custom_authorizer(current_username, input_username, input_authorizer, input_signature, input_builder_username, input_token_key_name, input_token_value) {
      let username_string = "";
      if (current_username) {
        username_string += current_username;
      }
      if (is_string_and_not_empty(input_username) == false) {
        if (is_string_and_not_empty(input_builder_username) && input_builder_username) {
          username_string += input_builder_username;
        }
      } else {
        username_string += input_username;
      }
      if (is_string_and_not_empty(input_authorizer) && input_authorizer) {
        username_string = add_to_username_parameter(username_string, input_authorizer, "x-amz-customauthorizer-name=");
      }
      if (is_string_and_not_empty(input_signature) && input_signature) {
        username_string = add_to_username_parameter(username_string, input_signature, "x-amz-customauthorizer-signature=");
        if (is_string_and_not_empty(input_token_key_name) && input_token_key_name || is_string_and_not_empty(input_token_value) && input_token_value) {
          console.log("Warning: Signed custom authorizers with signature will not work without a token key name and token value. Your connection may be rejected/stalled on the IoT Core side due to this. Please set the token key name and token value to connect to a signed custom authorizer.");
        }
      }
      if (is_string_and_not_empty(input_signature) || is_string_and_not_empty(input_token_value) || is_string_and_not_empty(input_token_key_name)) {
        if (!input_token_value || !input_token_key_name) {
          throw new Error("Token-based custom authentication requires all token-related properties to be set");
        }
        username_string = add_to_username_parameter(username_string, input_token_value, input_token_key_name + "=");
      }
      return username_string;
    }
    __name(populate_username_string_with_custom_authorizer, "populate_username_string_with_custom_authorizer");
    exports.populate_username_string_with_custom_authorizer = populate_username_string_with_custom_authorizer;
    function addParam(paramName, paramValue, paramSet) {
      if (paramValue) {
        paramSet.push([paramName, paramValue]);
      }
    }
    __name(addParam, "addParam");
    function buildMqtt5FinalUsername(customAuthConfig) {
      let path = "";
      let paramList = [];
      if (customAuthConfig) {
        let usingSigning = false;
        if (customAuthConfig.tokenValue || customAuthConfig.tokenKeyName || customAuthConfig.tokenSignature) {
          usingSigning = true;
          if (!customAuthConfig.tokenValue || !customAuthConfig.tokenKeyName || !customAuthConfig.tokenSignature) {
            throw new Error("Token-based custom authentication requires all token-related properties to be set");
          }
        }
        let username = customAuthConfig.username;
        let pathSplit = (username !== null && username !== void 0 ? username : "").split("?");
        let params = pathSplit.slice(1);
        path = pathSplit[0];
        if (params.length > 1) {
          throw new Error("Custom auth username property value is invalid");
        } else if (params.length == 1) {
          params[0].split("&").forEach((keyValue, index2, array) => {
            var _a2;
            let kvPair = keyValue.split("=");
            paramList.push([kvPair[0], (_a2 = kvPair[1]) !== null && _a2 !== void 0 ? _a2 : ""]);
          });
        }
        addParam("x-amz-customauthorizer-name", customAuthConfig.authorizerName, paramList);
        if (usingSigning) {
          addParam(customAuthConfig.tokenKeyName, customAuthConfig.tokenValue, paramList);
          addParam("x-amz-customauthorizer-signature", customAuthConfig.tokenSignature, paramList);
        }
      }
      paramList.push(["SDK", "NodeJSv2"]);
      paramList.push(["Version", platform3.crt_version()]);
      return (path !== null && path !== void 0 ? path : "") + "?" + paramList.map((value) => `${value[0]}=${value[1]}`).join("&");
    }
    __name(buildMqtt5FinalUsername, "buildMqtt5FinalUsername");
    exports.buildMqtt5FinalUsername = buildMqtt5FinalUsername;
    function extractRegionFromEndpoint(endpoint3) {
      const regexpRegion = /^[\w\-]+\.[\w\-]+\.([\w+\-]+)\./;
      const match = endpoint3.match(regexpRegion);
      if (match) {
        return match[1];
      }
      throw new Error("AWS region could not be extracted from endpoint.  Use 'region' property on WebsocketConfig to set manually.");
    }
    __name(extractRegionFromEndpoint, "extractRegionFromEndpoint");
    exports.extractRegionFromEndpoint = extractRegionFromEndpoint;
  }
});

// ../../node_modules/aws-crt/dist/native/aws_iot.js
var require_aws_iot = __commonJS({
  "../../node_modules/aws-crt/dist/native/aws_iot.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsIotMqttConnectionConfigBuilder = void 0;
    var mqtt_1 = require_mqtt();
    var io = __importStar2(require_io2());
    var io_1 = require_io2();
    var platform3 = __importStar2(require_platform());
    var error_1 = require_error();
    var auth_1 = require_auth();
    var iot_shared = __importStar2(require_aws_iot_shared());
    var AwsIotMqttConnectionConfigBuilder = class _AwsIotMqttConnectionConfigBuilder {
      static {
        __name(this, "AwsIotMqttConnectionConfigBuilder");
      }
      constructor(tls_ctx_options) {
        this.tls_ctx_options = tls_ctx_options;
        this.params = {
          client_id: "",
          host_name: "",
          socket_options: new io.SocketOptions(),
          port: 8883,
          use_websocket: false,
          clean_session: false,
          keep_alive: void 0,
          will: void 0,
          username: "",
          password: void 0,
          tls_ctx: void 0,
          reconnect_min_sec: mqtt_1.DEFAULT_RECONNECT_MIN_SEC,
          reconnect_max_sec: mqtt_1.DEFAULT_RECONNECT_MAX_SEC
        };
        this.is_using_custom_authorizer = false;
      }
      /**
       * Create a new builder with mTLS file paths
       * @param cert_path - Path to certificate, in PEM format
       * @param key_path - Path to private key, in PEM format
       */
      static new_mtls_builder_from_path(cert_path, key_path) {
        let builder = new _AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_from_path(cert_path, key_path));
        builder.params.port = 8883;
        if (io.is_alpn_available()) {
          builder.tls_ctx_options.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new builder with mTLS cert pair in memory
       * @param cert - Certificate, in PEM format
       * @param private_key - Private key, in PEM format
       */
      static new_mtls_builder(cert, private_key) {
        let builder = new _AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls(cert, private_key));
        builder.params.port = 8883;
        if (io.is_alpn_available()) {
          builder.tls_ctx_options.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new builder with mTLS using a PKCS#11 library for private key operations.
       *
       * NOTE: This configuration only works on Unix devices.
       * @param pkcs11_options - PKCS#11 options.
       */
      static new_mtls_pkcs11_builder(pkcs11_options) {
        let builder = new _AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_pkcs11(pkcs11_options));
        builder.params.port = 8883;
        if (io.is_alpn_available()) {
          builder.tls_ctx_options.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new builder with mTLS using a PKCS#12 file for private key operations.
       *
       * Note: This configuration only works on MacOS devices.
       *
       * @param pkcs12_options - The PKCS#12 options to use in the builder.
       */
      static new_mtls_pkcs12_builder(pkcs12_options) {
        let builder = new _AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_pkcs12_from_path(pkcs12_options.pkcs12_file, pkcs12_options.pkcs12_password));
        builder.params.port = 8883;
        if (io.is_alpn_available()) {
          builder.tls_ctx_options.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new builder with mTLS using a certificate in a Windows certificate store.
       *
       * NOTE: This configuration only works on Windows devices.
       * @param certificate_path - Path to certificate in a Windows certificate store.
       *      The path must use backslashes and end with the certificate's thumbprint.
       *      Example: `CurrentUser\MY\A11F8A9B5DF5B98BA3508FBCA575D09570E0D2C6`
       */
      static new_mtls_windows_cert_store_path_builder(certificate_path) {
        let builder = new _AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_windows_cert_store_path(certificate_path));
        builder.params.port = 8883;
        if (io.is_alpn_available()) {
          builder.tls_ctx_options.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Creates a new builder with default Tls options. This requires setting the connection details manually.
       */
      static new_default_builder() {
        let ctx_options = new io.TlsContextOptions();
        let builder = new _AwsIotMqttConnectionConfigBuilder(ctx_options);
        return builder;
      }
      static new_websocket_builder(...args) {
        return this.new_with_websockets(...args);
      }
      static configure_websocket_handshake(builder, options) {
        if (options) {
          if (builder == null || builder == void 0) {
            throw new error_1.CrtError("AwsIotMqttConnectionConfigBuilder configure_websocket_handshake: builder not defined");
          }
          builder.params.websocket_handshake_transform = (request3, done) => __awaiter2(this, void 0, void 0, function* () {
            var _a2, _b, _c;
            const signing_config = (_b = (_a2 = options.create_signing_config) === null || _a2 === void 0 ? void 0 : _a2.call(options)) !== null && _b !== void 0 ? _b : {
              algorithm: auth_1.AwsSigningAlgorithm.SigV4,
              signature_type: auth_1.AwsSignatureType.HttpRequestViaQueryParams,
              provider: options.credentials_provider,
              region: options.region,
              service: (_c = options.service) !== null && _c !== void 0 ? _c : "iotdevicegateway",
              signed_body_value: auth_1.AwsSignedBodyValue.EmptySha256,
              omit_session_token: true
            };
            try {
              yield (0, auth_1.aws_sign_request)(request3, signing_config);
              done();
            } catch (error) {
              if (error instanceof error_1.CrtError) {
                done(error.error_code);
              } else {
                done(3);
              }
            }
          });
        }
        return builder;
      }
      /**
       * Configures the connection to use MQTT over websockets. Forces the port to 443.
       */
      static new_with_websockets(options) {
        let tls_ctx_options = options === null || options === void 0 ? void 0 : options.tls_ctx_options;
        if (!tls_ctx_options) {
          tls_ctx_options = new io_1.TlsContextOptions();
          tls_ctx_options.alpn_list = [];
        }
        let builder = new _AwsIotMqttConnectionConfigBuilder(tls_ctx_options);
        builder.params.use_websocket = true;
        builder.params.proxy_options = options === null || options === void 0 ? void 0 : options.proxy_options;
        if (builder.tls_ctx_options) {
          builder.params.port = 443;
        }
        this.configure_websocket_handshake(builder, options);
        return builder;
      }
      /**
       * For API compatibility with the browser version. Alias for {@link new_with_websockets}.
       *
       * @returns a new websocket connection builder object with default TLS configuration
       */
      static new_builder_for_websocket() {
        return this.new_with_websockets();
      }
      /**
       * Overrides the default system trust store.
       * @param ca_dirpath - Only used on Unix-style systems where all trust anchors are
       * stored in a directory (e.g. /etc/ssl/certs).
       * @param ca_filepath - Single file containing all trust CAs, in PEM format
       */
      with_certificate_authority_from_path(ca_dirpath, ca_filepath) {
        this.tls_ctx_options.override_default_trust_store_from_path(ca_dirpath, ca_filepath);
        return this;
      }
      /**
       * Overrides the default system trust store.
       * @param ca - Buffer containing all trust CAs, in PEM format
       */
      with_certificate_authority(ca) {
        this.tls_ctx_options.override_default_trust_store(ca);
        return this;
      }
      /**
       * Configures the IoT endpoint for this connection
       * @param endpoint The IoT endpoint to connect to
       */
      with_endpoint(endpoint3) {
        this.params.host_name = endpoint3;
        return this;
      }
      /**
       * The port to connect to on the IoT endpoint
       * @param port The port to connect to on the IoT endpoint. Usually 8883 for MQTT, or 443 for websockets
       */
      with_port(port) {
        this.params.port = port;
        return this;
      }
      /**
       * Configures the client_id to use to connect to the IoT Core service
       * @param client_id The client id for this connection. Needs to be unique across all devices/clients.
       */
      with_client_id(client_id) {
        this.params.client_id = client_id;
        return this;
      }
      /**
       * Determines whether or not the service should try to resume prior subscriptions, if it has any
       * @param clean_session true if the session should drop prior subscriptions when this client connects, false to resume the session
       */
      with_clean_session(clean_session) {
        this.params.clean_session = clean_session;
        return this;
      }
      /**
       * Configures MQTT keep-alive via PING messages. Note that this is not TCP keepalive.
       * @param keep_alive How often in seconds to send an MQTT PING message to the service to keep the connection alive
       */
      with_keep_alive_seconds(keep_alive) {
        this.params.keep_alive = keep_alive;
        return this;
      }
      /**
       * Configures the TCP socket timeout (in milliseconds)
       * @param timeout_ms TCP socket timeout
       * @deprecated
       */
      with_timeout_ms(timeout_ms) {
        this.with_ping_timeout_ms(timeout_ms);
        return this;
      }
      /**
       * Configures the PINGREQ response timeout (in milliseconds)
       * @param ping_timeout PINGREQ response timeout
       */
      with_ping_timeout_ms(ping_timeout) {
        this.params.ping_timeout = ping_timeout;
        return this;
      }
      /**
       * Configures the protocol operation timeout (in milliseconds)
       * @param protocol_operation_timeout protocol operation timeout
       */
      with_protocol_operation_timeout_ms(protocol_operation_timeout) {
        this.params.protocol_operation_timeout = protocol_operation_timeout;
        return this;
      }
      /**
       * Configures the will message to be sent when this client disconnects
       * @param will The will topic, qos, and message
       */
      with_will(will) {
        this.params.will = will;
        return this;
      }
      /**
       * Configures the common settings for the socket to use when opening a connection to the server
       * @param socket_options The socket settings
       */
      with_socket_options(socket_options) {
        this.params.socket_options = socket_options;
        return this;
      }
      /**
       * Configures AWS credentials (usually from Cognito) for this connection
       * @param aws_region The service region to connect to
       * @param aws_access_id IAM Access ID
       * @param aws_secret_key IAM Secret Key
       * @param aws_sts_token STS token from Cognito (optional)
       */
      with_credentials(aws_region, aws_access_id, aws_secret_key, aws_sts_token) {
        return _AwsIotMqttConnectionConfigBuilder.configure_websocket_handshake(this, {
          credentials_provider: auth_1.AwsCredentialsProvider.newStatic(aws_access_id, aws_secret_key, aws_sts_token),
          region: aws_region,
          service: "iotdevicegateway"
        });
      }
      /**
       * Configure the http proxy options to use to establish the connection
       * @param proxy_options proxy options to use to establish the mqtt connection
       */
      with_http_proxy_options(proxy_options) {
        this.params.proxy_options = proxy_options;
        return this;
      }
      /**
       * Sets the custom authorizer settings. This function will modify the username, port, and TLS options.
       *
       * @param username The username to use with the custom authorizer. If an empty string is passed, it will
       *                 check to see if a username has already been set (via WithUsername function). If no
       *                 username is set then no username will be passed with the MQTT connection.
       * @param authorizer_name The name of the custom authorizer. If an empty string is passed, then
       *                       'x-amz-customauthorizer-name' will not be added with the MQTT connection.
       * @param authorizer_signature The signature of the custom authorizer. If an empty string is passed, then
       *                            'x-amz-customauthorizer-signature' will not be added with the MQTT connection.
       *                            The signature must be based on the private key associated with the custom authorizer.
       *                            The signature must be base64 encoded.
       *                            Required if the custom authorizer has signing enabled.  It is strongly suggested to URL-encode
       *                            this value; the SDK will not do so for you.
       * @param password The password to use with the custom authorizer. If null is passed, then no password will
       *                 be set.
       * @param token_key_name Key used to extract the custom authorizer token from MQTT username query-string properties.
       *                       Required if the custom authorizer has signing enabled.  It is strongly suggested to URL-encode
       *                       this value; the SDK will not do so for you.
       * @param token_value An opaque token value.
       *                    Required if the custom authorizer has signing enabled. This value must be signed by the private
       *                    key associated with the custom authorizer and the result placed in the token_signature argument.
       */
      with_custom_authorizer(username, authorizer_name, authorizer_signature, password, token_key_name, token_value) {
        this.is_using_custom_authorizer = true;
        let username_string = iot_shared.populate_username_string_with_custom_authorizer("", username, authorizer_name, authorizer_signature, this.params.username, token_key_name, token_value);
        this.params.username = username_string;
        this.params.password = password;
        if (!this.params.use_websocket) {
          this.tls_ctx_options.alpn_list = ["mqtt"];
        }
        this.params.port = 443;
        return this;
      }
      /**
       * Sets username for the connection
       *
       * @param username the username that will be passed with the MQTT connection
       */
      with_username(username) {
        this.params.username = username;
        return this;
      }
      /**
       * Sets password for the connection
       *
       * @param password the password that will be passed with the MQTT connection
       */
      with_password(password) {
        this.params.password = password;
        return this;
      }
      /**
       * Configure the max reconnection period (in second). The reonnection period will
       * be set in range of [reconnect_min_sec,reconnect_max_sec].
       * @param reconnect_max_sec max reconnection period
       */
      with_reconnect_max_sec(max_sec) {
        this.params.reconnect_max_sec = max_sec;
        return this;
      }
      /**
       * Configure the min reconnection period (in second). The reonnection period will
       * be set in range of [reconnect_min_sec,reconnect_max_sec].
       * @param reconnect_min_sec min reconnection period
       */
      with_reconnect_min_sec(min_sec) {
        this.params.reconnect_min_sec = min_sec;
        return this;
      }
      /**
       * Returns the configured MqttConnectionConfig.  On the first invocation of this function, the TLS context is cached
       * and re-used on all subsequent calls to build().
       * @returns The configured MqttConnectionConfig
       */
      build() {
        var _a2, _b, _c;
        if (this.params.client_id === void 0 || this.params.host_name === void 0) {
          throw "client_id and endpoint are required";
        }
        if (this.is_using_custom_authorizer == false) {
          if (iot_shared.is_string_and_not_empty(this.params.username)) {
            if (((_a2 = this.params.username) === null || _a2 === void 0 ? void 0 : _a2.indexOf("x-amz-customauthorizer-name=")) != -1 || ((_b = this.params.username) === null || _b === void 0 ? void 0 : _b.indexOf("x-amz-customauthorizer-signature=")) != -1) {
              this.is_using_custom_authorizer = true;
            }
          }
        }
        if (this.is_using_custom_authorizer == true) {
          if (this.params.port != 443) {
            console.log("Warning: Attempting to connect to authorizer with unsupported port. Port is not 443...");
          }
        }
        if (this.params.tls_ctx === void 0) {
          this.params.tls_ctx = new io.ClientTlsContext(this.tls_ctx_options);
        }
        if (iot_shared.is_string_and_not_empty(this.params.username) == false) {
          this.params.username = "?SDK=NodeJSv2&Version=";
        } else {
          if (((_c = this.params.username) === null || _c === void 0 ? void 0 : _c.indexOf("?")) != -1) {
            this.params.username += "&SDK=NodeJSv2&Version=";
          } else {
            this.params.username += "?SDK=NodeJSv2&Version=";
          }
        }
        this.params.username += platform3.crt_version();
        return this.params;
      }
    };
    exports.AwsIotMqttConnectionConfigBuilder = AwsIotMqttConnectionConfigBuilder;
  }
});

// ../../node_modules/aws-crt/dist/common/mqtt_shared.js
var require_mqtt_shared = __commonJS({
  "../../node_modules/aws-crt/dist/common/mqtt_shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_KEEP_ALIVE = exports.normalize_payload = void 0;
    function normalize_payload(payload) {
      if (payload instanceof Buffer) {
        return payload;
      }
      if (typeof payload === "string") {
        return payload;
      }
      if (ArrayBuffer.isView(payload)) {
        const view2 = payload;
        return Buffer.from(view2.buffer, view2.byteOffset, view2.byteLength);
      }
      if (payload instanceof ArrayBuffer) {
        return Buffer.from(payload);
      }
      if (typeof payload === "object") {
        return JSON.stringify(payload);
      }
      if (!payload) {
        return "";
      }
      throw new TypeError("payload parameter must be a string, object, or DataView.");
    }
    __name(normalize_payload, "normalize_payload");
    exports.normalize_payload = normalize_payload;
    exports.DEFAULT_KEEP_ALIVE = 1200;
  }
});

// ../../node_modules/aws-crt/dist/common/mqtt5.js
var require_mqtt5 = __commonJS({
  "../../node_modules/aws-crt/dist/common/mqtt5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RetryJitterType = exports.ClientSessionBehavior = void 0;
    var ClientSessionBehavior;
    (function(ClientSessionBehavior2) {
      ClientSessionBehavior2[ClientSessionBehavior2["Default"] = 0] = "Default";
      ClientSessionBehavior2[ClientSessionBehavior2["Clean"] = 1] = "Clean";
      ClientSessionBehavior2[ClientSessionBehavior2["RejoinPostSuccess"] = 2] = "RejoinPostSuccess";
      ClientSessionBehavior2[ClientSessionBehavior2["RejoinAlways"] = 3] = "RejoinAlways";
    })(ClientSessionBehavior = exports.ClientSessionBehavior || (exports.ClientSessionBehavior = {}));
    var RetryJitterType;
    (function(RetryJitterType2) {
      RetryJitterType2[RetryJitterType2["Default"] = 0] = "Default";
      RetryJitterType2[RetryJitterType2["None"] = 1] = "None";
      RetryJitterType2[RetryJitterType2["Full"] = 2] = "Full";
      RetryJitterType2[RetryJitterType2["Decorrelated"] = 3] = "Decorrelated";
    })(RetryJitterType = exports.RetryJitterType || (exports.RetryJitterType = {}));
  }
});

// ../../node_modules/aws-crt/dist/common/mqtt5_packet.js
var require_mqtt5_packet = __commonJS({
  "../../node_modules/aws-crt/dist/common/mqtt5_packet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PacketType = exports.RetainHandlingType = exports.QoS = exports.PayloadFormatIndicator = exports.isSuccessfulPubackReasonCode = exports.PubackReasonCode = exports.isSuccessfulUnsubackReasonCode = exports.UnsubackReasonCode = exports.isSuccessfulSubackReasonCode = exports.SubackReasonCode = exports.isSuccessfulDisconnectReasonCode = exports.DisconnectReasonCode = exports.isSuccessfulConnectReasonCode = exports.ConnectReasonCode = void 0;
    var ConnectReasonCode;
    (function(ConnectReasonCode2) {
      ConnectReasonCode2[ConnectReasonCode2["Success"] = 0] = "Success";
      ConnectReasonCode2[ConnectReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      ConnectReasonCode2[ConnectReasonCode2["MalformedPacket"] = 129] = "MalformedPacket";
      ConnectReasonCode2[ConnectReasonCode2["ProtocolError"] = 130] = "ProtocolError";
      ConnectReasonCode2[ConnectReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      ConnectReasonCode2[ConnectReasonCode2["UnsupportedProtocolVersion"] = 132] = "UnsupportedProtocolVersion";
      ConnectReasonCode2[ConnectReasonCode2["ClientIdentifierNotValid"] = 133] = "ClientIdentifierNotValid";
      ConnectReasonCode2[ConnectReasonCode2["BadUsernameOrPassword"] = 134] = "BadUsernameOrPassword";
      ConnectReasonCode2[ConnectReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      ConnectReasonCode2[ConnectReasonCode2["ServerUnavailable"] = 136] = "ServerUnavailable";
      ConnectReasonCode2[ConnectReasonCode2["ServerBusy"] = 137] = "ServerBusy";
      ConnectReasonCode2[ConnectReasonCode2["Banned"] = 138] = "Banned";
      ConnectReasonCode2[ConnectReasonCode2["BadAuthenticationMethod"] = 140] = "BadAuthenticationMethod";
      ConnectReasonCode2[ConnectReasonCode2["TopicNameInvalid"] = 144] = "TopicNameInvalid";
      ConnectReasonCode2[ConnectReasonCode2["PacketTooLarge"] = 149] = "PacketTooLarge";
      ConnectReasonCode2[ConnectReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      ConnectReasonCode2[ConnectReasonCode2["PayloadFormatInvalid"] = 153] = "PayloadFormatInvalid";
      ConnectReasonCode2[ConnectReasonCode2["RetainNotSupported"] = 154] = "RetainNotSupported";
      ConnectReasonCode2[ConnectReasonCode2["QosNotSupported"] = 155] = "QosNotSupported";
      ConnectReasonCode2[ConnectReasonCode2["UseAnotherServer"] = 156] = "UseAnotherServer";
      ConnectReasonCode2[ConnectReasonCode2["ServerMoved"] = 157] = "ServerMoved";
      ConnectReasonCode2[ConnectReasonCode2["ConnectionRateExceeded"] = 159] = "ConnectionRateExceeded";
    })(ConnectReasonCode = exports.ConnectReasonCode || (exports.ConnectReasonCode = {}));
    function isSuccessfulConnectReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    __name(isSuccessfulConnectReasonCode, "isSuccessfulConnectReasonCode");
    exports.isSuccessfulConnectReasonCode = isSuccessfulConnectReasonCode;
    var DisconnectReasonCode;
    (function(DisconnectReasonCode2) {
      DisconnectReasonCode2[DisconnectReasonCode2["NormalDisconnection"] = 0] = "NormalDisconnection";
      DisconnectReasonCode2[DisconnectReasonCode2["DisconnectWithWillMessage"] = 4] = "DisconnectWithWillMessage";
      DisconnectReasonCode2[DisconnectReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      DisconnectReasonCode2[DisconnectReasonCode2["MalformedPacket"] = 129] = "MalformedPacket";
      DisconnectReasonCode2[DisconnectReasonCode2["ProtocolError"] = 130] = "ProtocolError";
      DisconnectReasonCode2[DisconnectReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      DisconnectReasonCode2[DisconnectReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      DisconnectReasonCode2[DisconnectReasonCode2["ServerBusy"] = 137] = "ServerBusy";
      DisconnectReasonCode2[DisconnectReasonCode2["ServerShuttingDown"] = 139] = "ServerShuttingDown";
      DisconnectReasonCode2[DisconnectReasonCode2["KeepAliveTimeout"] = 141] = "KeepAliveTimeout";
      DisconnectReasonCode2[DisconnectReasonCode2["SessionTakenOver"] = 142] = "SessionTakenOver";
      DisconnectReasonCode2[DisconnectReasonCode2["TopicFilterInvalid"] = 143] = "TopicFilterInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["TopicNameInvalid"] = 144] = "TopicNameInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["ReceiveMaximumExceeded"] = 147] = "ReceiveMaximumExceeded";
      DisconnectReasonCode2[DisconnectReasonCode2["TopicAliasInvalid"] = 148] = "TopicAliasInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["PacketTooLarge"] = 149] = "PacketTooLarge";
      DisconnectReasonCode2[DisconnectReasonCode2["MessageRateTooHigh"] = 150] = "MessageRateTooHigh";
      DisconnectReasonCode2[DisconnectReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      DisconnectReasonCode2[DisconnectReasonCode2["AdministrativeAction"] = 152] = "AdministrativeAction";
      DisconnectReasonCode2[DisconnectReasonCode2["PayloadFormatInvalid"] = 153] = "PayloadFormatInvalid";
      DisconnectReasonCode2[DisconnectReasonCode2["RetainNotSupported"] = 154] = "RetainNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["QosNotSupported"] = 155] = "QosNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["UseAnotherServer"] = 156] = "UseAnotherServer";
      DisconnectReasonCode2[DisconnectReasonCode2["ServerMoved"] = 157] = "ServerMoved";
      DisconnectReasonCode2[DisconnectReasonCode2["SharedSubscriptionsNotSupported"] = 158] = "SharedSubscriptionsNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["ConnectionRateExceeded"] = 159] = "ConnectionRateExceeded";
      DisconnectReasonCode2[DisconnectReasonCode2["MaximumConnectTime"] = 160] = "MaximumConnectTime";
      DisconnectReasonCode2[DisconnectReasonCode2["SubscriptionIdentifiersNotSupported"] = 161] = "SubscriptionIdentifiersNotSupported";
      DisconnectReasonCode2[DisconnectReasonCode2["WildcardSubscriptionsNotSupported"] = 162] = "WildcardSubscriptionsNotSupported";
    })(DisconnectReasonCode = exports.DisconnectReasonCode || (exports.DisconnectReasonCode = {}));
    function isSuccessfulDisconnectReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    __name(isSuccessfulDisconnectReasonCode, "isSuccessfulDisconnectReasonCode");
    exports.isSuccessfulDisconnectReasonCode = isSuccessfulDisconnectReasonCode;
    var SubackReasonCode;
    (function(SubackReasonCode2) {
      SubackReasonCode2[SubackReasonCode2["GrantedQoS0"] = 0] = "GrantedQoS0";
      SubackReasonCode2[SubackReasonCode2["GrantedQoS1"] = 1] = "GrantedQoS1";
      SubackReasonCode2[SubackReasonCode2["GrantedQoS2"] = 2] = "GrantedQoS2";
      SubackReasonCode2[SubackReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      SubackReasonCode2[SubackReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      SubackReasonCode2[SubackReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      SubackReasonCode2[SubackReasonCode2["TopicFilterInvalid"] = 143] = "TopicFilterInvalid";
      SubackReasonCode2[SubackReasonCode2["PacketIdentifierInUse"] = 145] = "PacketIdentifierInUse";
      SubackReasonCode2[SubackReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      SubackReasonCode2[SubackReasonCode2["SharedSubscriptionsNotSupported"] = 158] = "SharedSubscriptionsNotSupported";
      SubackReasonCode2[SubackReasonCode2["SubscriptionIdentifiersNotSupported"] = 161] = "SubscriptionIdentifiersNotSupported";
      SubackReasonCode2[SubackReasonCode2["WildcardSubscriptionsNotSupported"] = 162] = "WildcardSubscriptionsNotSupported";
    })(SubackReasonCode = exports.SubackReasonCode || (exports.SubackReasonCode = {}));
    function isSuccessfulSubackReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    __name(isSuccessfulSubackReasonCode, "isSuccessfulSubackReasonCode");
    exports.isSuccessfulSubackReasonCode = isSuccessfulSubackReasonCode;
    var UnsubackReasonCode;
    (function(UnsubackReasonCode2) {
      UnsubackReasonCode2[UnsubackReasonCode2["Success"] = 0] = "Success";
      UnsubackReasonCode2[UnsubackReasonCode2["NoSubscriptionExisted"] = 17] = "NoSubscriptionExisted";
      UnsubackReasonCode2[UnsubackReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      UnsubackReasonCode2[UnsubackReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      UnsubackReasonCode2[UnsubackReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      UnsubackReasonCode2[UnsubackReasonCode2["TopicFilterInvalid"] = 143] = "TopicFilterInvalid";
      UnsubackReasonCode2[UnsubackReasonCode2["PacketIdentifierInUse"] = 145] = "PacketIdentifierInUse";
    })(UnsubackReasonCode = exports.UnsubackReasonCode || (exports.UnsubackReasonCode = {}));
    function isSuccessfulUnsubackReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    __name(isSuccessfulUnsubackReasonCode, "isSuccessfulUnsubackReasonCode");
    exports.isSuccessfulUnsubackReasonCode = isSuccessfulUnsubackReasonCode;
    var PubackReasonCode;
    (function(PubackReasonCode2) {
      PubackReasonCode2[PubackReasonCode2["Success"] = 0] = "Success";
      PubackReasonCode2[PubackReasonCode2["NoMatchingSubscribers"] = 16] = "NoMatchingSubscribers";
      PubackReasonCode2[PubackReasonCode2["UnspecifiedError"] = 128] = "UnspecifiedError";
      PubackReasonCode2[PubackReasonCode2["ImplementationSpecificError"] = 131] = "ImplementationSpecificError";
      PubackReasonCode2[PubackReasonCode2["NotAuthorized"] = 135] = "NotAuthorized";
      PubackReasonCode2[PubackReasonCode2["TopicNameInvalid"] = 144] = "TopicNameInvalid";
      PubackReasonCode2[PubackReasonCode2["PacketIdentifierInUse"] = 145] = "PacketIdentifierInUse";
      PubackReasonCode2[PubackReasonCode2["QuotaExceeded"] = 151] = "QuotaExceeded";
      PubackReasonCode2[PubackReasonCode2["PayloadFormatInvalid"] = 153] = "PayloadFormatInvalid";
    })(PubackReasonCode = exports.PubackReasonCode || (exports.PubackReasonCode = {}));
    function isSuccessfulPubackReasonCode(reasonCode) {
      return reasonCode < 128;
    }
    __name(isSuccessfulPubackReasonCode, "isSuccessfulPubackReasonCode");
    exports.isSuccessfulPubackReasonCode = isSuccessfulPubackReasonCode;
    var PayloadFormatIndicator;
    (function(PayloadFormatIndicator2) {
      PayloadFormatIndicator2[PayloadFormatIndicator2["Bytes"] = 0] = "Bytes";
      PayloadFormatIndicator2[PayloadFormatIndicator2["Utf8"] = 1] = "Utf8";
    })(PayloadFormatIndicator = exports.PayloadFormatIndicator || (exports.PayloadFormatIndicator = {}));
    var QoS;
    (function(QoS2) {
      QoS2[QoS2["AtMostOnce"] = 0] = "AtMostOnce";
      QoS2[QoS2["AtLeastOnce"] = 1] = "AtLeastOnce";
      QoS2[QoS2["ExactlyOnce"] = 2] = "ExactlyOnce";
    })(QoS = exports.QoS || (exports.QoS = {}));
    var RetainHandlingType;
    (function(RetainHandlingType2) {
      RetainHandlingType2[RetainHandlingType2["SendOnSubscribe"] = 0] = "SendOnSubscribe";
      RetainHandlingType2[RetainHandlingType2["SendOnSubscribeIfNew"] = 1] = "SendOnSubscribeIfNew";
      RetainHandlingType2[RetainHandlingType2["DontSend"] = 2] = "DontSend";
    })(RetainHandlingType = exports.RetainHandlingType || (exports.RetainHandlingType = {}));
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["Connect"] = 1] = "Connect";
      PacketType2[PacketType2["Connack"] = 2] = "Connack";
      PacketType2[PacketType2["Publish"] = 3] = "Publish";
      PacketType2[PacketType2["Puback"] = 4] = "Puback";
      PacketType2[PacketType2["Pubrec"] = 5] = "Pubrec";
      PacketType2[PacketType2["Pubrel"] = 6] = "Pubrel";
      PacketType2[PacketType2["Pubcomp"] = 7] = "Pubcomp";
      PacketType2[PacketType2["Subscribe"] = 8] = "Subscribe";
      PacketType2[PacketType2["Suback"] = 9] = "Suback";
      PacketType2[PacketType2["Unsubscribe"] = 10] = "Unsubscribe";
      PacketType2[PacketType2["Unsuback"] = 11] = "Unsuback";
      PacketType2[PacketType2["Pingreq"] = 12] = "Pingreq";
      PacketType2[PacketType2["Pingresp"] = 13] = "Pingresp";
      PacketType2[PacketType2["Disconnect"] = 14] = "Disconnect";
      PacketType2[PacketType2["Auth"] = 15] = "Auth";
    })(PacketType = exports.PacketType || (exports.PacketType = {}));
  }
});

// ../../node_modules/aws-crt/dist/native/mqtt5.js
var require_mqtt52 = __commonJS({
  "../../node_modules/aws-crt/dist/native/mqtt5.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar2 = exports && exports.__exportStar || function(m11, exports2) {
      for (var p11 in m11)
        if (p11 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p11))
          __createBinding2(exports2, m11, p11);
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mqtt5Client = exports.ClientExtendedValidationAndFlowControl = exports.ClientOperationQueueBehavior = exports.HttpProxyOptions = void 0;
    var binding_1 = __importDefault2(require_binding());
    var native_resource_1 = require_native_resource();
    var event_1 = require_event();
    var io = __importStar2(require_io2());
    var mqtt_shared = __importStar2(require_mqtt_shared());
    var error_1 = require_error();
    var http_1 = require_http2();
    Object.defineProperty(exports, "HttpProxyOptions", { enumerable: true, get: function() {
      return http_1.HttpProxyOptions;
    } });
    __exportStar2(require_mqtt5(), exports);
    __exportStar2(require_mqtt5_packet(), exports);
    var ClientOperationQueueBehavior;
    (function(ClientOperationQueueBehavior2) {
      ClientOperationQueueBehavior2[ClientOperationQueueBehavior2["Default"] = 0] = "Default";
      ClientOperationQueueBehavior2[ClientOperationQueueBehavior2["FailNonQos1PublishOnDisconnect"] = 1] = "FailNonQos1PublishOnDisconnect";
      ClientOperationQueueBehavior2[ClientOperationQueueBehavior2["FailQos0PublishOnDisconnect"] = 2] = "FailQos0PublishOnDisconnect";
      ClientOperationQueueBehavior2[ClientOperationQueueBehavior2["FailAllOnDisconnect"] = 3] = "FailAllOnDisconnect";
    })(ClientOperationQueueBehavior = exports.ClientOperationQueueBehavior || (exports.ClientOperationQueueBehavior = {}));
    var ClientExtendedValidationAndFlowControl;
    (function(ClientExtendedValidationAndFlowControl2) {
      ClientExtendedValidationAndFlowControl2[ClientExtendedValidationAndFlowControl2["None"] = 0] = "None";
      ClientExtendedValidationAndFlowControl2[ClientExtendedValidationAndFlowControl2["AwsIotCoreDefaults"] = 1] = "AwsIotCoreDefaults";
    })(ClientExtendedValidationAndFlowControl = exports.ClientExtendedValidationAndFlowControl || (exports.ClientExtendedValidationAndFlowControl = {}));
    var Mqtt5Client = class _Mqtt5Client extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {
      static {
        __name(this, "Mqtt5Client");
      }
      /**
       * Client constructor
       *
       * @param config The configuration for this client
       */
      constructor(config) {
        super();
        this._super(binding_1.default.mqtt5_client_new(this, config, (client10) => {
          _Mqtt5Client._s_on_stopped(client10);
        }, (client10) => {
          _Mqtt5Client._s_on_attempting_connect(client10);
        }, (client10, connack, settings) => {
          _Mqtt5Client._s_on_connection_success(client10, connack, settings);
        }, (client10, errorCode, connack) => {
          _Mqtt5Client._s_on_connection_failure(client10, new error_1.CrtError(errorCode), connack);
        }, (client10, errorCode, disconnect) => {
          _Mqtt5Client._s_on_disconnection(client10, new error_1.CrtError(errorCode), disconnect);
        }, (client10, message) => {
          _Mqtt5Client._s_on_message_received(client10, message);
        }, config.clientBootstrap ? config.clientBootstrap.native_handle() : null, config.socketOptions ? config.socketOptions.native_handle() : null, config.tlsCtx ? config.tlsCtx.native_handle() : null, config.httpProxyOptions ? config.httpProxyOptions.create_native_handle() : null));
      }
      /**
       * Triggers cleanup of native resources associated with the MQTT5 client.  Once this has been invoked, callbacks
       * and events are not guaranteed to be received.
       *
       * This must be called when finished with a client; otherwise, native resources will leak.  It is not safe
       * to invoke any further operations on the client after close() has been called.
       *
       * For a running client, safe and proper shutdown can be accomplished by
       *
       * ```ts
       * const stopped = once(client, "stopped");
       * client.stop();
       * await stopped;
       * client.close();
       * ```
       *
       * This is an asynchronous operation.
       *
       * @group Node-only
       */
      close() {
        binding_1.default.mqtt5_client_close(this.native_handle());
      }
      /**
       * Notifies the MQTT5 client that you want it to maintain connectivity to the configured endpoint.
       * The client will attempt to stay connected using the properties of the reconnect-related parameters
       * in the mqtt5 client configuration.
       *
       * This is an asynchronous operation.
       */
      start() {
        binding_1.default.mqtt5_client_start(this.native_handle());
      }
      /**
       * Notifies the MQTT5 client that you want it to end connectivity to the configured endpoint, disconnecting any
       * existing connection and halting reconnection attempts.
       *
       * This is an asynchronous operation.  Once the process completes, no further events will be emitted until the client
       * has {@link start} invoked.  Invoking {@link start start()} after a {@link stop stop()} will always result in a
       * new MQTT session.
       *
       * @param disconnectPacket (optional) properties of a DISCONNECT packet to send as part of the shutdown process
       */
      stop(disconnectPacket) {
        binding_1.default.mqtt5_client_stop(this.native_handle(), disconnectPacket);
      }
      /**
       * Subscribe to one or more topic filters by queuing a SUBSCRIBE packet to be sent to the server.
       *
       * @param packet SUBSCRIBE packet to send to the server
       * @returns a promise that will be rejected with an error or resolved with the SUBACK response
       */
      subscribe(packet) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function curriedPromiseCallback(client10, errorCode, suback) {
              return _Mqtt5Client._s_on_suback_callback(resolve, reject, client10, errorCode, suback);
            }
            __name(curriedPromiseCallback, "curriedPromiseCallback");
            try {
              binding_1.default.mqtt5_client_subscribe(this.native_handle(), packet, curriedPromiseCallback);
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Unsubscribe from one or more topic filters by queuing an UNSUBSCRIBE packet to be sent to the server.
       *
       * @param packet UNSUBSCRIBE packet to send to the server
       * @returns a promise that will be rejected with an error or resolved with the UNSUBACK response
       */
      unsubscribe(packet) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function curriedPromiseCallback(client10, errorCode, unsuback) {
              return _Mqtt5Client._s_on_unsuback_callback(resolve, reject, client10, errorCode, unsuback);
            }
            __name(curriedPromiseCallback, "curriedPromiseCallback");
            try {
              binding_1.default.mqtt5_client_unsubscribe(this.native_handle(), packet, curriedPromiseCallback);
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Send a message to subscribing clients by queuing a PUBLISH packet to be sent to the server.
       *
       * @param packet PUBLISH packet to send to the server
       * @returns a promise that will be rejected with an error or resolved with the PUBACK response (QoS 1) or
       * undefined (QoS 0)
       */
      publish(packet) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            if (packet && packet.payload) {
              packet.payload = mqtt_shared.normalize_payload(packet.payload);
            }
            function curriedPromiseCallback(client10, errorCode, result) {
              return _Mqtt5Client._s_on_puback_callback(resolve, reject, client10, errorCode, result);
            }
            __name(curriedPromiseCallback, "curriedPromiseCallback");
            try {
              binding_1.default.mqtt5_client_publish(this.native_handle(), packet, curriedPromiseCallback);
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Queries a small set of numerical statistics about the current state of the client's operation queue
       *
       * @group Node-only
       */
      getQueueStatistics() {
        return binding_1.default.mqtt5_client_get_queue_statistics(this.native_handle());
      }
      on(event, listener) {
        super.on(event, listener);
        return this;
      }
      /*
       * Private helper functions
       *
       * Callbacks come through static functions so that the native threadsafe function objects do not
       * capture the client object itself, simplifying the number of strong references to the client floating around.
       */
      static _s_on_stopped(client10) {
        process.nextTick(() => {
          let stoppedEvent = {};
          client10.emit(_Mqtt5Client.STOPPED, stoppedEvent);
        });
      }
      static _s_on_attempting_connect(client10) {
        process.nextTick(() => {
          let attemptingConnectEvent = {};
          client10.emit(_Mqtt5Client.ATTEMPTING_CONNECT, attemptingConnectEvent);
        });
      }
      static _s_on_connection_success(client10, connack, settings) {
        let connectionSuccessEvent = {
          connack,
          settings
        };
        process.nextTick(() => {
          client10.emit(_Mqtt5Client.CONNECTION_SUCCESS, connectionSuccessEvent);
        });
      }
      static _s_on_connection_failure(client10, error, connack) {
        let connectionFailureEvent = {
          error
        };
        if (connack !== null && connack !== void 0) {
          connectionFailureEvent.connack = connack;
        }
        process.nextTick(() => {
          client10.emit(_Mqtt5Client.CONNECTION_FAILURE, connectionFailureEvent);
        });
      }
      static _s_on_disconnection(client10, error, disconnect) {
        let disconnectionEvent = {
          error
        };
        if (disconnect !== null && disconnect !== void 0) {
          disconnectionEvent.disconnect = disconnect;
        }
        process.nextTick(() => {
          client10.emit(_Mqtt5Client.DISCONNECTION, disconnectionEvent);
        });
      }
      static _s_on_suback_callback(resolve, reject, client10, errorCode, suback) {
        if (errorCode == 0 && suback !== void 0) {
          resolve(suback);
        } else {
          reject(io.error_code_to_string(errorCode));
        }
      }
      static _s_on_unsuback_callback(resolve, reject, client10, errorCode, unsuback) {
        if (errorCode == 0 && unsuback !== void 0) {
          resolve(unsuback);
        } else {
          reject(io.error_code_to_string(errorCode));
        }
      }
      static _s_on_puback_callback(resolve, reject, client10, errorCode, result) {
        if (errorCode == 0) {
          resolve(result);
        } else {
          reject(io.error_code_to_string(errorCode));
        }
      }
      static _s_on_message_received(client10, message) {
        let messageReceivedEvent = {
          message
        };
        process.nextTick(() => {
          client10.emit(_Mqtt5Client.MESSAGE_RECEIVED, messageReceivedEvent);
        });
      }
    };
    exports.Mqtt5Client = Mqtt5Client;
    Mqtt5Client.ERROR = "error";
    Mqtt5Client.MESSAGE_RECEIVED = "messageReceived";
    Mqtt5Client.ATTEMPTING_CONNECT = "attemptingConnect";
    Mqtt5Client.CONNECTION_SUCCESS = "connectionSuccess";
    Mqtt5Client.CONNECTION_FAILURE = "connectionFailure";
    Mqtt5Client.DISCONNECTION = "disconnection";
    Mqtt5Client.STOPPED = "stopped";
  }
});

// ../../node_modules/aws-crt/dist/native/aws_iot_mqtt5.js
var require_aws_iot_mqtt5 = __commonJS({
  "../../node_modules/aws-crt/dist/native/aws_iot_mqtt5.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsIotMqtt5ClientConfigBuilder = void 0;
    var mqtt5 = __importStar2(require_mqtt52());
    var io = __importStar2(require_io2());
    var auth2 = __importStar2(require_auth());
    var error_1 = require_error();
    var iot_shared = __importStar2(require_aws_iot_shared());
    var mqtt_shared = __importStar2(require_mqtt_shared());
    var AwsIotMqtt5ClientConfigBuilder = class _AwsIotMqtt5ClientConfigBuilder {
      static {
        __name(this, "AwsIotMqtt5ClientConfigBuilder");
      }
      constructor(hostName, port, tlsContextOptions) {
        this.tlsContextOptions = tlsContextOptions;
        this.config = {
          hostName,
          port,
          connectProperties: {
            keepAliveIntervalSeconds: mqtt_shared.DEFAULT_KEEP_ALIVE
          },
          extendedValidationAndFlowControlOptions: mqtt5.ClientExtendedValidationAndFlowControl.AwsIotCoreDefaults
        };
      }
      /* Builders for different connection methods to AWS IoT Core */
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS
       * using X509 certificate and key at the supplied file paths.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param certPath - Path to certificate, in PEM format
       * @param keyPath - Path to private key, in PEM format
       */
      static newDirectMqttBuilderWithMtlsFromPath(hostName, certPath, keyPath) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_from_path(certPath, keyPath));
        if (io.is_alpn_available()) {
          builder.tlsContextOptions.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS
       * using in-memory X509 certificate and key.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param cert - Certificate, in PEM format
       * @param privateKey - Private key, in PEM format
       */
      static newDirectMqttBuilderWithMtlsFromMemory(hostName, cert, privateKey) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls(cert, privateKey));
        if (io.is_alpn_available()) {
          builder.tlsContextOptions.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS
       * using a PKCS11 library for certificate and private key operations.
       *
       * NOTE: This configuration only works on Unix devices.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param pkcs11Options - PKCS#11 options.
       */
      static newDirectMqttBuilderWithMtlsFromPkcs11(hostName, pkcs11Options) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_pkcs11(pkcs11Options));
        if (io.is_alpn_available()) {
          builder.tlsContextOptions.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS
       * using a PKCS12 file.
       *
       * Note: This configuration only works on MacOS devices.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param pkcs12_options - The PKCS#12 options to use in the builder.
       */
      static newDirectMqttBuilderWithMtlsFromPkcs12(hostName, pkcs12_options) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_pkcs12_from_path(pkcs12_options.pkcs12_file, pkcs12_options.pkcs12_password));
        if (io.is_alpn_available()) {
          builder.tlsContextOptions.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS
       * using a certificate entry in a Windows certificate store.
       *
       * NOTE: This configuration only works on Windows devices.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param certificatePath - Path to certificate in a Windows certificate store.
       *      The path must use backslashes and end with the certificate's thumbprint.
       *      Example: `CurrentUser\MY\A11F8A9B5DF5B98BA3508FBCA575D09570E0D2C6`
       */
      static newDirectMqttBuilderWithMtlsFromWindowsCertStorePath(hostName, certificatePath) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_windows_cert_store_path(certificatePath));
        if (io.is_alpn_available()) {
          builder.tlsContextOptions.alpn_list.unshift("x-amzn-mqtt-ca");
        }
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via TLS,
       * authenticating via a custom authenticator.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param customAuthConfig - AWS IoT custom auth configuration
       */
      static newDirectMqttBuilderWithCustomAuth(hostName, customAuthConfig) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT, new io.TlsContextOptions());
        builder.customAuthConfig = customAuthConfig;
        builder.tlsContextOptions.alpn_list = ["mqtt"];
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via websockets,
       * using AWS Sigv4 signing to establish authenticate.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param options - additional sigv4-oriented options to use
       */
      static newWebsocketMqttBuilderWithSigv4Auth(hostName, options) {
        let tlsContextOptions = new io.TlsContextOptions();
        tlsContextOptions.alpn_list = [];
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT, tlsContextOptions);
        let credentialsProvider = options === null || options === void 0 ? void 0 : options.credentialsProvider;
        if (!credentialsProvider) {
          credentialsProvider = auth2.AwsCredentialsProvider.newDefault();
        }
        builder.config.websocketHandshakeTransform = (request3, done) => __awaiter2(this, void 0, void 0, function* () {
          var _a2;
          try {
            const signingConfig = {
              algorithm: auth2.AwsSigningAlgorithm.SigV4,
              signature_type: auth2.AwsSignatureType.HttpRequestViaQueryParams,
              provider: credentialsProvider,
              region: (_a2 = options === null || options === void 0 ? void 0 : options.region) !== null && _a2 !== void 0 ? _a2 : iot_shared.extractRegionFromEndpoint(hostName),
              service: "iotdevicegateway",
              signed_body_value: auth2.AwsSignedBodyValue.EmptySha256,
              omit_session_token: true
            };
            yield auth2.aws_sign_request(request3, signingConfig);
            done();
          } catch (error) {
            if (error instanceof error_1.CrtError) {
              done(error.error_code);
            } else {
              done(3);
            }
          }
        });
        return builder;
      }
      /**
       * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via websockets,
       * authenticating via a custom authenticator.
       *
       * @param hostName - AWS IoT endpoint to connect to
       * @param customAuthConfig - AWS IoT custom auth configuration
       */
      static newWebsocketMqttBuilderWithCustomAuth(hostName, customAuthConfig) {
        let builder = new _AwsIotMqtt5ClientConfigBuilder(hostName, _AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT, new io.TlsContextOptions());
        builder.customAuthConfig = customAuthConfig;
        builder.config.websocketHandshakeTransform = (request3, done) => __awaiter2(this, void 0, void 0, function* () {
          done(0);
        });
        return builder;
      }
      /* Instance Methods for various config overrides */
      /**
       * Overrides the default system trust store.
       *
       * @param caDirpath - Only used on Unix-style systems where all trust anchors are
       * stored in a directory (e.g. /etc/ssl/certs).
       * @param caFilepath - Single file containing all trust CAs, in PEM format
       */
      withCertificateAuthorityFromPath(caDirpath, caFilepath) {
        this.tlsContextOptions.override_default_trust_store_from_path(caDirpath, caFilepath);
        return this;
      }
      /**
       * Overrides the default system trust store.
       *
       * @param ca - Buffer containing all trust CAs, in PEM format
       */
      withCertificateAuthority(ca) {
        this.tlsContextOptions.override_default_trust_store(ca);
        return this;
      }
      /**
       * Overrides the IoT endpoint port to connect to.
       *
       * @param port The IoT endpoint port to connect to. Usually 8883 for MQTT, or 443 for websockets
       */
      withPort(port) {
        this.config.port = port;
        return this;
      }
      /**
       * Overrides all configurable options with respect to the CONNECT packet sent by the client, including the will.
       * These connect properties will be used for every connection attempt made by the client.  Custom authentication
       * configuration will override the username and password values in this configuration.
       *
       * @param connectPacket all configurable options with respect to the CONNECT packet sent by the client
       */
      withConnectProperties(connectPacket) {
        this.config.connectProperties = connectPacket;
        return this;
      }
      /**
       * Overrides how the MQTT5 client should behave with respect to MQTT sessions.
       *
       * @param sessionBehavior how the MQTT5 client should behave with respect to MQTT sessions.
       */
      withSessionBehavior(sessionBehavior) {
        this.config.sessionBehavior = sessionBehavior;
        return this;
      }
      /**
       * Overrides how the reconnect delay is modified in order to smooth out the distribution of reconnection attempt
       * timepoints for a large set of reconnecting clients.
       *
       * @param retryJitterMode controls how the reconnect delay is modified in order to smooth out the distribution of
       * econnection attempt timepoints for a large set of reconnecting clients.
       */
      withRetryJitterMode(retryJitterMode) {
        this.config.retryJitterMode = retryJitterMode;
        return this;
      }
      /**
       * Overrides the minimum amount of time to wait to reconnect after a disconnect.  Exponential backoff is performed
       * with controllable jitter after each connection failure.
       *
       * @param minReconnectDelayMs minimum amount of time to wait to reconnect after a disconnect.
       */
      withMinReconnectDelayMs(minReconnectDelayMs) {
        this.config.minReconnectDelayMs = minReconnectDelayMs;
        return this;
      }
      /**
       * Overrides the maximum amount of time to wait to reconnect after a disconnect.  Exponential backoff is performed
       * with controllable jitter after each connection failure.
       *
       * @param maxReconnectDelayMs maximum amount of time to wait to reconnect after a disconnect.
       */
      withMaxReconnectDelayMs(maxReconnectDelayMs) {
        this.config.maxReconnectDelayMs = maxReconnectDelayMs;
        return this;
      }
      /**
       * Overrides the amount of time that must elapse with an established connection before the reconnect delay is
       * reset to the minimum.  This helps alleviate bandwidth-waste in fast reconnect cycles due to permission
       * failures on operations.
       *
       * @param minConnectedTimeToResetReconnectDelayMs the amount of time that must elapse with an established
       * connection before the reconnect delay is reset to the minimum
       */
      withMinConnectedTimeToResetReconnectDelayMs(minConnectedTimeToResetReconnectDelayMs) {
        this.config.minConnectedTimeToResetReconnectDelayMs = minConnectedTimeToResetReconnectDelayMs;
        return this;
      }
      /**
       * Overrides the time interval to wait after sending a CONNECT request for a CONNACK to arrive.  If one does not
       * arrive, the connection will be shut down.
       *
       * @param connackTimeoutMs time interval to wait after sending a CONNECT request for a CONNACK to arrive
       */
      withConnackTimeoutMs(connackTimeoutMs) {
        this.config.connackTimeoutMs = connackTimeoutMs;
        return this;
      }
      /**
       * Overrides how disconnects affect the queued and in-progress operations tracked by the client.  Also controls
       * how new operations are handled while the client is not connected.  In particular, if the client is not connected,
       * then any operation that would be failed on disconnect (according to these rules) will also be rejected.
       *
       * @param offlineQueueBehavior how disconnects affect the queued and in-progress operations tracked by the client
       *
       * @group Node-only
       */
      withOfflineQueueBehavior(offlineQueueBehavior) {
        this.config.offlineQueueBehavior = offlineQueueBehavior;
        return this;
      }
      /**
       * Overrides the time interval to wait after sending a PINGREQ for a PINGRESP to arrive.  If one does not arrive,
       * the client will close the current connection.
       *
       * @param pingTimeoutMs time interval to wait after sending a PINGREQ for a PINGRESP to arrive
       *
       * @group Node-only
       */
      withPingTimeoutMs(pingTimeoutMs) {
        this.config.pingTimeoutMs = pingTimeoutMs;
        return this;
      }
      /**
       * Overrides the time interval to wait for an ack after sending a QoS 1+ PUBLISH, SUBSCRIBE, or UNSUBSCRIBE before
       * failing the operation.  Defaults to no timeout.
       *
       * @param ackTimeoutSeconds the time interval to wait for an ack after sending a QoS 1+ PUBLISH, SUBSCRIBE,
       * or UNSUBSCRIBE before failing the operation
       *
       * @group Node-only
       */
      withAckTimeoutSeconds(ackTimeoutSeconds) {
        this.config.ackTimeoutSeconds = ackTimeoutSeconds;
        return this;
      }
      /**
       * Overrides the socket properties of the underlying MQTT connections made by the client.  Leave undefined to use
       * defaults (no TCP keep alive, 10 second socket timeout).
       *
       * @param socketOptions socket properties of the underlying MQTT connections made by the client
       *
       * @group Node-only
       */
      withSocketOptions(socketOptions) {
        this.config.socketOptions = socketOptions;
        return this;
      }
      /**
       * Overrides (tunneling) HTTP proxy usage when establishing MQTT connections.
       *
       * @param httpProxyOptions HTTP proxy options to use when establishing MQTT connections
       *
       * @group Node-only
       */
      withHttpProxyOptions(httpProxyOptions) {
        this.config.httpProxyOptions = httpProxyOptions;
        return this;
      }
      /**
       * Overrides additional controls for client behavior with respect to operation validation and flow control; these
       * checks go beyond the base MQTT5 spec to respect limits of specific MQTT brokers.
       *
       * @param extendedValidationAndFlowControlOptions additional controls for client behavior with respect to operation
       * validation and flow control
       *
       * @group Node-only
       */
      withExtendedValidationAndFlowControlOptions(extendedValidationAndFlowControlOptions) {
        this.config.extendedValidationAndFlowControlOptions = extendedValidationAndFlowControlOptions;
        return this;
      }
      /**
       * Constructs an MQTT5 Client configuration object for creating mqtt5 clients.
       */
      build() {
        var _a2, _b;
        if (this.config.tlsCtx === void 0) {
          this.config.tlsCtx = new io.ClientTlsContext(this.tlsContextOptions);
        }
        if (this.config.connectProperties) {
          this.config.connectProperties.username = iot_shared.buildMqtt5FinalUsername(this.customAuthConfig);
          if ((_a2 = this.customAuthConfig) === null || _a2 === void 0 ? void 0 : _a2.password) {
            this.config.connectProperties.password = (_b = this.customAuthConfig) === null || _b === void 0 ? void 0 : _b.password;
          }
        }
        return this.config;
      }
    };
    exports.AwsIotMqtt5ClientConfigBuilder = AwsIotMqtt5ClientConfigBuilder;
    AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT = 443;
    AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT = 8883;
  }
});

// ../../node_modules/aws-crt/dist/native/iot.js
var require_iot = __commonJS({
  "../../node_modules/aws-crt/dist/native/iot.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m11, exports2) {
      for (var p11 in m11)
        if (p11 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p11))
          __createBinding2(exports2, m11, p11);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_aws_iot(), exports);
    __exportStar2(require_aws_iot_mqtt5(), exports);
  }
});

// ../../node_modules/aws-crt/dist/native/mqtt.js
var require_mqtt2 = __commonJS({
  "../../node_modules/aws-crt/dist/native/mqtt.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e10) {
            reject(e10);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MqttClientConnection = exports.MqttClient = exports.MqttWill = exports.QoS = exports.HttpProxyOptions = void 0;
    var binding_1 = __importDefault2(require_binding());
    var native_resource_1 = require_native_resource();
    var event_1 = require_event();
    var crt = __importStar2(require_mqtt_shared());
    var error_1 = require_error();
    var io = __importStar2(require_io2());
    var http_1 = require_http2();
    Object.defineProperty(exports, "HttpProxyOptions", { enumerable: true, get: function() {
      return http_1.HttpProxyOptions;
    } });
    var mqtt_1 = require_mqtt();
    var mqtt_2 = require_mqtt();
    Object.defineProperty(exports, "QoS", { enumerable: true, get: function() {
      return mqtt_2.QoS;
    } });
    Object.defineProperty(exports, "MqttWill", { enumerable: true, get: function() {
      return mqtt_2.MqttWill;
    } });
    var MqttClient = class extends native_resource_1.NativeResource {
      static {
        __name(this, "MqttClient");
      }
      /**
       * @param bootstrap The {@link ClientBootstrap} to use for socket connections.  Leave undefined to use the
       *          default system-wide bootstrap (recommended).
       */
      constructor(bootstrap = void 0) {
        super(binding_1.default.mqtt_client_new(bootstrap != null ? bootstrap.native_handle() : null));
        this.bootstrap = bootstrap;
      }
      /**
       * Creates a new {@link MqttClientConnection}
       * @param config Configuration for the mqtt connection
       * @returns A new connection
       */
      new_connection(config) {
        return new MqttClientConnection(this, config);
      }
    };
    exports.MqttClient = MqttClient;
    var MqttClientConnection = class extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {
      static {
        __name(this, "MqttClientConnection");
      }
      /**
       * @param client The client that owns this connection
       * @param config The configuration for this connection
       */
      constructor(client10, config) {
        super();
        this.client = client10;
        this.config = config;
        if (config == null || config == void 0) {
          throw new error_1.CrtError("MqttClientConnection constructor: config not defined");
        }
        const will = config.will ? {
          topic: config.will.topic,
          qos: config.will.qos,
          payload: crt.normalize_payload(config.will.payload),
          retain: config.will.retain
        } : void 0;
        var min_sec = mqtt_1.DEFAULT_RECONNECT_MIN_SEC;
        var max_sec = mqtt_1.DEFAULT_RECONNECT_MAX_SEC;
        if (config.reconnect_min_sec) {
          min_sec = config.reconnect_min_sec;
          max_sec = Math.max(min_sec, max_sec);
        }
        if (config.reconnect_max_sec) {
          max_sec = config.reconnect_max_sec;
          min_sec = Math.min(min_sec, max_sec);
        }
        if (client10 == void 0 || client10 == null) {
          throw new error_1.CrtError("MqttClientConnection constructor: client not defined");
        }
        if (config.socket_options == void 0 || config.socket_options == null) {
          throw new error_1.CrtError("MqttClientConnection constructor: socket_options in configuration not defined");
        }
        this._super(binding_1.default.mqtt_client_connection_new(client10.native_handle(), (error_code) => {
          this._on_connection_interrupted(error_code);
        }, (return_code, session_present) => {
          this._on_connection_resumed(return_code, session_present);
        }, config.tls_ctx ? config.tls_ctx.native_handle() : null, will, config.username, config.password, config.use_websocket, config.proxy_options ? config.proxy_options.create_native_handle() : void 0, config.websocket_handshake_transform, min_sec, max_sec));
        this.tls_ctx = config.tls_ctx;
        binding_1.default.mqtt_client_connection_on_message(this.native_handle(), this._on_any_publish.bind(this));
        binding_1.default.mqtt_client_connection_on_closed(this.native_handle(), this._on_connection_closed.bind(this));
        this.on("error", (error) => {
        });
      }
      close() {
        binding_1.default.mqtt_client_connection_close(this.native_handle());
      }
      // Overridden to allow uncorking on ready
      on(event, listener) {
        super.on(event, listener);
        if (event == "connect") {
          process.nextTick(() => {
            this.uncork();
          });
        }
        return this;
      }
      /**
       * Open the actual connection to the server (async).
       * @returns A Promise which completes whether the connection succeeds or fails.
       *          If connection fails, the Promise will reject with an exception.
       *          If connection succeeds, the Promise will return a boolean that is
       *          true for resuming an existing session, or false if the session is new
       */
      connect() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            reject = this._reject(reject);
            if (this.config.socket_options == null || this.config.socket_options == void 0) {
              throw new error_1.CrtError("MqttClientConnection connect: socket_options in configuration not defined");
            }
            try {
              binding_1.default.mqtt_client_connection_connect(this.native_handle(), this.config.client_id, this.config.host_name, this.config.port, this.config.socket_options.native_handle(), this.config.keep_alive, this.config.ping_timeout, this.config.protocol_operation_timeout, this.config.clean_session, this._on_connect_callback.bind(this, resolve, reject));
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * The connection will automatically reconnect when disconnected, removing the need for this function.
       * To cease automatic reconnection attempts, call {@link disconnect}.
       * @deprecated
       */
      reconnect() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            reject = this._reject(reject);
            try {
              binding_1.default.mqtt_client_connection_reconnect(this.native_handle(), this._on_connect_callback.bind(this, resolve, reject));
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Publish message (async).
       * If the device is offline, the PUBLISH packet will be sent once the connection resumes.
       *
       * @param topic Topic name
       * @param payload Contents of message
       * @param qos Quality of Service for delivering this message
       * @param retain If true, the server will store the message and its QoS so that it can be
       *               delivered to future subscribers whose subscriptions match the topic name
       * @returns Promise which returns a {@link MqttRequest} which will contain the packet id of
       *          the PUBLISH packet.
       *
       * * For QoS 0, completes as soon as the packet is sent.
       * * For QoS 1, completes when PUBACK is received.
       * * For QoS 2, completes when PUBCOMP is received.
       */
      publish(topic, payload, qos, retain = false) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof topic !== "string") {
            return Promise.reject("topic is not a string");
          }
          if (typeof qos !== "number") {
            return Promise.reject("qos is not a number");
          }
          if (typeof retain !== "boolean") {
            return Promise.reject("retain is not a boolean");
          }
          return new Promise((resolve, reject) => {
            reject = this._reject(reject);
            try {
              binding_1.default.mqtt_client_connection_publish(this.native_handle(), topic, crt.normalize_payload(payload), qos, retain, this._on_puback_callback.bind(this, resolve, reject));
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Subscribe to a topic filter (async).
       * The client sends a SUBSCRIBE packet and the server responds with a SUBACK.
       *
       * subscribe() may be called while the device is offline, though the async
       * operation cannot complete successfully until the connection resumes.
       *
       * Once subscribed, `callback` is invoked each time a message matching
       * the `topic` is received. It is possible for such messages to arrive before
       * the SUBACK is received.
       *
       * @param topic Subscribe to this topic filter, which may include wildcards
       * @param qos Maximum requested QoS that server may use when sending messages to the client.
       *            The server may grant a lower QoS in the SUBACK
       * @param on_message Optional callback invoked when message received.
       * @returns Promise which returns a {@link MqttSubscribeRequest} which will contain the
       *          result of the SUBSCRIBE. The Promise resolves when a SUBACK is returned
       *          from the server or is rejected when an exception occurs.
       */
      subscribe(topic, qos, on_message) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof topic !== "string") {
            return Promise.reject("topic is not a string");
          }
          if (typeof qos !== "number") {
            return Promise.reject("qos is not a number");
          }
          return new Promise((resolve, reject) => {
            reject = this._reject(reject);
            try {
              binding_1.default.mqtt_client_connection_subscribe(this.native_handle(), topic, qos, on_message, this._on_suback_callback.bind(this, resolve, reject));
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Unsubscribe from a topic filter (async).
       * The client sends an UNSUBSCRIBE packet, and the server responds with an UNSUBACK.
       * @param topic The topic filter to unsubscribe from. May contain wildcards.
       * @returns Promise wihch returns a {@link MqttRequest} which will contain the packet id
       *          of the UNSUBSCRIBE packet being acknowledged. Promise is resolved when an
       *          UNSUBACK is received from the server or is rejected when an exception occurs.
       */
      unsubscribe(topic) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (typeof topic !== "string") {
            return Promise.reject("topic is not a string");
          }
          return new Promise((resolve, reject) => {
            reject = this._reject(reject);
            try {
              binding_1.default.mqtt_client_connection_unsubscribe(this.native_handle(), topic, this._on_unsuback_callback.bind(this, resolve, reject));
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Close the connection (async).
       *
       * Will free all native resources, rendering the connection unusable after the disconnect() call.
       *
       * @returns Promise which completes when the connection is closed.
      */
      disconnect() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            reject = this._reject(reject);
            try {
              binding_1.default.mqtt_client_connection_disconnect(this.native_handle(), this._on_disconnect_callback.bind(this, resolve));
            } catch (e10) {
              reject(e10);
            }
          });
        });
      }
      /**
       * Queries a small set of numerical statistics about the current state of the connection's operation queue
       *
       * @group Node-only
       */
      getQueueStatistics() {
        return binding_1.default.mqtt_client_connection_get_queue_statistics(this.native_handle());
      }
      // Wrap a promise rejection with a function that will also emit the error as an event
      _reject(reject) {
        return (reason) => {
          reject(reason);
          process.nextTick(() => {
            this.emit("error", new error_1.CrtError(reason));
          });
        };
      }
      _on_connection_interrupted(error_code) {
        this.emit("interrupt", new error_1.CrtError(error_code));
      }
      _on_connection_resumed(return_code, session_present) {
        this.emit("resume", return_code, session_present);
        let successCallbackData = { session_present, reason_code: return_code };
        this.emit("connection_success", successCallbackData);
      }
      _on_any_publish(topic, payload, dup, qos, retain) {
        this.emit("message", topic, payload, dup, qos, retain);
      }
      _on_connection_closed() {
        let closedCallbackData = {};
        this.emit("closed", closedCallbackData);
        this.close();
      }
      _on_connect_callback(resolve, reject, error_code, return_code, session_present) {
        if (error_code == 0 && return_code == 0) {
          resolve(session_present);
          this.emit("connect", session_present);
          let successCallbackData = { session_present, reason_code: return_code };
          this.emit("connection_success", successCallbackData);
        } else if (error_code != 0) {
          reject("Failed to connect: " + io.error_code_to_string(error_code));
          let failureCallbackData = { error: new error_1.CrtError(error_code) };
          this.emit("connection_failure", failureCallbackData);
        } else {
          reject("Server rejected connection.");
          let failureCallbackData = { error: new error_1.CrtError(5134) };
          this.emit("connection_failure", failureCallbackData);
        }
      }
      _on_puback_callback(resolve, reject, packet_id, error_code) {
        if (error_code == 0) {
          resolve({ packet_id });
        } else {
          reject("Failed to publish: " + io.error_code_to_string(error_code));
        }
      }
      _on_suback_callback(resolve, reject, packet_id, topic, qos, error_code) {
        if (error_code == 0) {
          resolve({ packet_id, topic, qos, error_code });
        } else {
          reject("Failed to subscribe: " + io.error_code_to_string(error_code));
        }
      }
      _on_unsuback_callback(resolve, reject, packet_id, error_code) {
        if (error_code == 0) {
          resolve({ packet_id });
        } else {
          reject("Failed to unsubscribe: " + io.error_code_to_string(error_code));
        }
      }
      _on_disconnect_callback(resolve) {
        resolve();
        this.emit("disconnect");
      }
    };
    exports.MqttClientConnection = MqttClientConnection;
    MqttClientConnection.CONNECT = "connect";
    MqttClientConnection.DISCONNECT = "disconnect";
    MqttClientConnection.ERROR = "error";
    MqttClientConnection.INTERRUPT = "interrupt";
    MqttClientConnection.RESUME = "resume";
    MqttClientConnection.MESSAGE = "message";
    MqttClientConnection.CONNECTION_SUCCESS = "connection_success";
    MqttClientConnection.CONNECTION_FAILURE = "connection_failure";
    MqttClientConnection.CLOSED = "closed";
  }
});

// ../../node_modules/aws-crt/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/aws-crt/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      var desc2 = Object.getOwnPropertyDescriptor(m11, k10);
      if (!desc2 || ("get" in desc2 ? !m11.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m11[k10];
        } };
      }
      Object.defineProperty(o10, k22, desc2);
    } : function(o10, m11, k10, k22) {
      if (k22 === void 0)
        k22 = k10;
      o10[k22] = m11[k10];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o10, v7) {
      Object.defineProperty(o10, "default", { enumerable: true, value: v7 });
    } : function(o10, v7) {
      o10["default"] = v7;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k10 in mod)
          if (k10 !== "default" && Object.prototype.hasOwnProperty.call(mod, k10))
            __createBinding2(result, mod, k10);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CrtError = exports.resource_safety = exports.promise = exports.platform = exports.mqtt5 = exports.mqtt = exports.iot = exports.io = exports.http = exports.eventstream = exports.crt = exports.crypto = exports.checksums = exports.cancel = exports.auth = void 0;
    var cancel = __importStar2(require_cancel());
    exports.cancel = cancel;
    var platform3 = __importStar2(require_platform());
    exports.platform = platform3;
    var promise = __importStar2(require_promise());
    exports.promise = promise;
    var resource_safety = __importStar2(require_resource_safety());
    exports.resource_safety = resource_safety;
    var auth2 = __importStar2(require_auth());
    exports.auth = auth2;
    var checksums = __importStar2(require_checksums());
    exports.checksums = checksums;
    var crt = __importStar2(require_crt());
    exports.crt = crt;
    var crypto4 = __importStar2(require_crypto());
    exports.crypto = crypto4;
    var eventstream = __importStar2(require_eventstream());
    exports.eventstream = eventstream;
    var http2 = __importStar2(require_http2());
    exports.http = http2;
    var io = __importStar2(require_io2());
    exports.io = io;
    var iot = __importStar2(require_iot());
    exports.iot = iot;
    var mqtt = __importStar2(require_mqtt2());
    exports.mqtt = mqtt;
    var mqtt5 = __importStar2(require_mqtt52());
    exports.mqtt5 = mqtt5;
    var error_1 = require_error();
    Object.defineProperty(exports, "CrtError", { enumerable: true, get: function() {
      return error_1.CrtError;
    } });
  }
});

// ../../node_modules/better-sqlite3/lib/util.js
var require_util2 = __commonJS({
  "../../node_modules/better-sqlite3/lib/util.js"(exports) {
    "use strict";
    exports.getBooleanOption = (options, key) => {
      let value = false;
      if (key in options && typeof (value = options[key]) !== "boolean") {
        throw new TypeError(`Expected the "${key}" option to be a boolean`);
      }
      return value;
    };
    exports.cppdb = Symbol();
    exports.inspect = Symbol.for("nodejs.util.inspect.custom");
  }
});

// ../../node_modules/better-sqlite3/lib/sqlite-error.js
var require_sqlite_error = __commonJS({
  "../../node_modules/better-sqlite3/lib/sqlite-error.js"(exports, module2) {
    "use strict";
    var descriptor = { value: "SqliteError", writable: true, enumerable: false, configurable: true };
    function SqliteError(message, code2) {
      if (new.target !== SqliteError) {
        return new SqliteError(message, code2);
      }
      if (typeof code2 !== "string") {
        throw new TypeError("Expected second argument to be a string");
      }
      Error.call(this, message);
      descriptor.value = "" + message;
      Object.defineProperty(this, "message", descriptor);
      Error.captureStackTrace(this, SqliteError);
      this.code = code2;
    }
    __name(SqliteError, "SqliteError");
    Object.setPrototypeOf(SqliteError, Error);
    Object.setPrototypeOf(SqliteError.prototype, Error.prototype);
    Object.defineProperty(SqliteError.prototype, "name", descriptor);
    module2.exports = SqliteError;
  }
});

// ../../node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "../../node_modules/file-uri-to-path/index.js"(exports, module2) {
    var sep2 = __require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep2 + sep2 + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep2 == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep2 + path;
      }
      return host + path;
    }
    __name(fileUriToPath, "fileUriToPath");
  }
});

// ../../node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "../../node_modules/bindings/bindings.js"(exports, module2) {
    var fs = __require("fs");
    var path = __require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join4 = path.join;
    var dirname = path.dirname;
    var exists2 = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e10) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        // node-waf and gyp_addon (a.k.a node-gyp)
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        // Debug files, for development (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        // Legacy from node-waf, node <= 0.4.x
        ["module_root", "build", "default", "bindings"],
        // Production "Release" buildtype binary (meh...)
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        // node-qbs builds
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i11) {
        if (!(i11 in opts))
          opts[i11] = defaults[i11];
      });
      if (!opts.module_root) {
        opts.module_root = exports.getRoot(exports.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      var tries = [], i10 = 0, l10 = opts.try.length, n10, b11, err;
      for (; i10 < l10; i10++) {
        n10 = join4.apply(
          null,
          opts.try[i10].map(function(p11) {
            return opts[p11] || p11;
          })
        );
        tries.push(n10);
        try {
          b11 = opts.path ? requireFunc.resolve(n10) : requireFunc(n10);
          if (!opts.path) {
            b11.path = n10;
          }
          return b11;
        } catch (e10) {
          if (e10.code !== "MODULE_NOT_FOUND" && e10.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e10.message)) {
            throw e10;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a10) {
          return opts.arrow + a10;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    __name(bindings, "bindings");
    module2.exports = exports = bindings;
    exports.getFileName = /* @__PURE__ */ __name(function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e10, st) {
        for (var i10 = 0, l10 = st.length; i10 < l10; i10++) {
          fileName = st[i10].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    }, "getFileName");
    exports.getRoot = /* @__PURE__ */ __name(function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists2(join4(dir, "package.json")) || exists2(join4(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join4(dir, "..");
      }
    }, "getRoot");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/wrappers.js
var require_wrappers = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/wrappers.js"(exports) {
    "use strict";
    var { cppdb } = require_util2();
    exports.prepare = /* @__PURE__ */ __name(function prepare(sql2) {
      return this[cppdb].prepare(sql2, this, false);
    }, "prepare");
    exports.exec = /* @__PURE__ */ __name(function exec3(sql2) {
      this[cppdb].exec(sql2);
      return this;
    }, "exec");
    exports.close = /* @__PURE__ */ __name(function close() {
      this[cppdb].close();
      return this;
    }, "close");
    exports.loadExtension = /* @__PURE__ */ __name(function loadExtension(...args) {
      this[cppdb].loadExtension(...args);
      return this;
    }, "loadExtension");
    exports.defaultSafeIntegers = /* @__PURE__ */ __name(function defaultSafeIntegers(...args) {
      this[cppdb].defaultSafeIntegers(...args);
      return this;
    }, "defaultSafeIntegers");
    exports.unsafeMode = /* @__PURE__ */ __name(function unsafeMode(...args) {
      this[cppdb].unsafeMode(...args);
      return this;
    }, "unsafeMode");
    exports.getters = {
      name: {
        get: /* @__PURE__ */ __name(function name2() {
          return this[cppdb].name;
        }, "name"),
        enumerable: true
      },
      open: {
        get: /* @__PURE__ */ __name(function open() {
          return this[cppdb].open;
        }, "open"),
        enumerable: true
      },
      inTransaction: {
        get: /* @__PURE__ */ __name(function inTransaction() {
          return this[cppdb].inTransaction;
        }, "inTransaction"),
        enumerable: true
      },
      readonly: {
        get: /* @__PURE__ */ __name(function readonly() {
          return this[cppdb].readonly;
        }, "readonly"),
        enumerable: true
      },
      memory: {
        get: /* @__PURE__ */ __name(function memory() {
          return this[cppdb].memory;
        }, "memory"),
        enumerable: true
      }
    };
  }
});

// ../../node_modules/better-sqlite3/lib/methods/transaction.js
var require_transaction = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/transaction.js"(exports, module2) {
    "use strict";
    var { cppdb } = require_util2();
    var controllers = /* @__PURE__ */ new WeakMap();
    module2.exports = /* @__PURE__ */ __name(function transaction(fn) {
      if (typeof fn !== "function")
        throw new TypeError("Expected first argument to be a function");
      const db8 = this[cppdb];
      const controller = getController(db8, this);
      const { apply } = Function.prototype;
      const properties = {
        default: { value: wrapTransaction(apply, fn, db8, controller.default) },
        deferred: { value: wrapTransaction(apply, fn, db8, controller.deferred) },
        immediate: { value: wrapTransaction(apply, fn, db8, controller.immediate) },
        exclusive: { value: wrapTransaction(apply, fn, db8, controller.exclusive) },
        database: { value: this, enumerable: true }
      };
      Object.defineProperties(properties.default.value, properties);
      Object.defineProperties(properties.deferred.value, properties);
      Object.defineProperties(properties.immediate.value, properties);
      Object.defineProperties(properties.exclusive.value, properties);
      return properties.default.value;
    }, "transaction");
    var getController = /* @__PURE__ */ __name((db8, self2) => {
      let controller = controllers.get(db8);
      if (!controller) {
        const shared = {
          commit: db8.prepare("COMMIT", self2, false),
          rollback: db8.prepare("ROLLBACK", self2, false),
          savepoint: db8.prepare("SAVEPOINT `	_bs3.	`", self2, false),
          release: db8.prepare("RELEASE `	_bs3.	`", self2, false),
          rollbackTo: db8.prepare("ROLLBACK TO `	_bs3.	`", self2, false)
        };
        controllers.set(db8, controller = {
          default: Object.assign({ begin: db8.prepare("BEGIN", self2, false) }, shared),
          deferred: Object.assign({ begin: db8.prepare("BEGIN DEFERRED", self2, false) }, shared),
          immediate: Object.assign({ begin: db8.prepare("BEGIN IMMEDIATE", self2, false) }, shared),
          exclusive: Object.assign({ begin: db8.prepare("BEGIN EXCLUSIVE", self2, false) }, shared)
        });
      }
      return controller;
    }, "getController");
    var wrapTransaction = /* @__PURE__ */ __name((apply, fn, db8, { begin, commit, rollback, savepoint, release: release3, rollbackTo }) => /* @__PURE__ */ __name(function sqliteTransaction() {
      let before, after, undo;
      if (db8.inTransaction) {
        before = savepoint;
        after = release3;
        undo = rollbackTo;
      } else {
        before = begin;
        after = commit;
        undo = rollback;
      }
      before.run();
      try {
        const result = apply.call(fn, this, arguments);
        after.run();
        return result;
      } catch (ex) {
        if (db8.inTransaction) {
          undo.run();
          if (undo !== rollback)
            after.run();
        }
        throw ex;
      }
    }, "sqliteTransaction"), "wrapTransaction");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/pragma.js
var require_pragma = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/pragma.js"(exports, module2) {
    "use strict";
    var { getBooleanOption, cppdb } = require_util2();
    module2.exports = /* @__PURE__ */ __name(function pragma(source, options) {
      if (options == null)
        options = {};
      if (typeof source !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      const simple = getBooleanOption(options, "simple");
      const stmt = this[cppdb].prepare(`PRAGMA ${source}`, this, true);
      return simple ? stmt.pluck().get() : stmt.all();
    }, "pragma");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/backup.js
var require_backup = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/backup.js"(exports, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var { promisify: promisify3 } = __require("util");
    var { cppdb } = require_util2();
    var fsAccess = promisify3(fs.access);
    module2.exports = /* @__PURE__ */ __name(async function backup(filename, options) {
      if (options == null)
        options = {};
      if (typeof filename !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      filename = filename.trim();
      const attachedName = "attached" in options ? options.attached : "main";
      const handler3 = "progress" in options ? options.progress : null;
      if (!filename)
        throw new TypeError("Backup filename cannot be an empty string");
      if (filename === ":memory:")
        throw new TypeError('Invalid backup filename ":memory:"');
      if (typeof attachedName !== "string")
        throw new TypeError('Expected the "attached" option to be a string');
      if (!attachedName)
        throw new TypeError('The "attached" option cannot be an empty string');
      if (handler3 != null && typeof handler3 !== "function")
        throw new TypeError('Expected the "progress" option to be a function');
      await fsAccess(path.dirname(filename)).catch(() => {
        throw new TypeError("Cannot save backup because the directory does not exist");
      });
      const isNewFile = await fsAccess(filename).then(() => false, () => true);
      return runBackup(this[cppdb].backup(this, attachedName, filename, isNewFile), handler3 || null);
    }, "backup");
    var runBackup = /* @__PURE__ */ __name((backup, handler3) => {
      let rate = 0;
      let useDefault = true;
      return new Promise((resolve, reject) => {
        setImmediate(/* @__PURE__ */ __name(function step() {
          try {
            const progress = backup.transfer(rate);
            if (!progress.remainingPages) {
              backup.close();
              resolve(progress);
              return;
            }
            if (useDefault) {
              useDefault = false;
              rate = 100;
            }
            if (handler3) {
              const ret = handler3(progress);
              if (ret !== void 0) {
                if (typeof ret === "number" && ret === ret)
                  rate = Math.max(0, Math.min(2147483647, Math.round(ret)));
                else
                  throw new TypeError("Expected progress callback to return a number or undefined");
              }
            }
            setImmediate(step);
          } catch (err) {
            backup.close();
            reject(err);
          }
        }, "step"));
      });
    }, "runBackup");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/serialize.js
var require_serialize = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/serialize.js"(exports, module2) {
    "use strict";
    var { cppdb } = require_util2();
    module2.exports = /* @__PURE__ */ __name(function serialize(options) {
      if (options == null)
        options = {};
      if (typeof options !== "object")
        throw new TypeError("Expected first argument to be an options object");
      const attachedName = "attached" in options ? options.attached : "main";
      if (typeof attachedName !== "string")
        throw new TypeError('Expected the "attached" option to be a string');
      if (!attachedName)
        throw new TypeError('The "attached" option cannot be an empty string');
      return this[cppdb].serialize(attachedName);
    }, "serialize");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/function.js
var require_function = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/function.js"(exports, module2) {
    "use strict";
    var { getBooleanOption, cppdb } = require_util2();
    module2.exports = /* @__PURE__ */ __name(function defineFunction(name2, options, fn) {
      if (options == null)
        options = {};
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      if (typeof name2 !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof fn !== "function")
        throw new TypeError("Expected last argument to be a function");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      if (!name2)
        throw new TypeError("User-defined function name cannot be an empty string");
      const safeIntegers = "safeIntegers" in options ? +getBooleanOption(options, "safeIntegers") : 2;
      const deterministic = getBooleanOption(options, "deterministic");
      const directOnly = getBooleanOption(options, "directOnly");
      const varargs = getBooleanOption(options, "varargs");
      let argCount = -1;
      if (!varargs) {
        argCount = fn.length;
        if (!Number.isInteger(argCount) || argCount < 0)
          throw new TypeError("Expected function.length to be a positive integer");
        if (argCount > 100)
          throw new RangeError("User-defined functions cannot have more than 100 arguments");
      }
      this[cppdb].function(fn, name2, argCount, safeIntegers, deterministic, directOnly);
      return this;
    }, "defineFunction");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/aggregate.js
var require_aggregate = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/aggregate.js"(exports, module2) {
    "use strict";
    var { getBooleanOption, cppdb } = require_util2();
    module2.exports = /* @__PURE__ */ __name(function defineAggregate(name2, options) {
      if (typeof name2 !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object" || options === null)
        throw new TypeError("Expected second argument to be an options object");
      if (!name2)
        throw new TypeError("User-defined function name cannot be an empty string");
      const start = "start" in options ? options.start : null;
      const step = getFunctionOption(options, "step", true);
      const inverse = getFunctionOption(options, "inverse", false);
      const result = getFunctionOption(options, "result", false);
      const safeIntegers = "safeIntegers" in options ? +getBooleanOption(options, "safeIntegers") : 2;
      const deterministic = getBooleanOption(options, "deterministic");
      const directOnly = getBooleanOption(options, "directOnly");
      const varargs = getBooleanOption(options, "varargs");
      let argCount = -1;
      if (!varargs) {
        argCount = Math.max(getLength(step), inverse ? getLength(inverse) : 0);
        if (argCount > 0)
          argCount -= 1;
        if (argCount > 100)
          throw new RangeError("User-defined functions cannot have more than 100 arguments");
      }
      this[cppdb].aggregate(start, step, inverse, result, name2, argCount, safeIntegers, deterministic, directOnly);
      return this;
    }, "defineAggregate");
    var getFunctionOption = /* @__PURE__ */ __name((options, key, required) => {
      const value = key in options ? options[key] : null;
      if (typeof value === "function")
        return value;
      if (value != null)
        throw new TypeError(`Expected the "${key}" option to be a function`);
      if (required)
        throw new TypeError(`Missing required option "${key}"`);
      return null;
    }, "getFunctionOption");
    var getLength = /* @__PURE__ */ __name(({ length }) => {
      if (Number.isInteger(length) && length >= 0)
        return length;
      throw new TypeError("Expected function.length to be a positive integer");
    }, "getLength");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/table.js
var require_table = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/table.js"(exports, module2) {
    "use strict";
    var { cppdb } = require_util2();
    module2.exports = /* @__PURE__ */ __name(function defineTable(name2, factory) {
      if (typeof name2 !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (!name2)
        throw new TypeError("Virtual table module name cannot be an empty string");
      let eponymous = false;
      if (typeof factory === "object" && factory !== null) {
        eponymous = true;
        factory = defer(parseTableDefinition(factory, "used", name2));
      } else {
        if (typeof factory !== "function")
          throw new TypeError("Expected second argument to be a function or a table definition object");
        factory = wrapFactory(factory);
      }
      this[cppdb].table(factory, name2, eponymous);
      return this;
    }, "defineTable");
    function wrapFactory(factory) {
      return /* @__PURE__ */ __name(function virtualTableFactory(moduleName, databaseName, tableName, ...args) {
        const thisObject = {
          module: moduleName,
          database: databaseName,
          table: tableName
        };
        const def = apply.call(factory, thisObject, args);
        if (typeof def !== "object" || def === null) {
          throw new TypeError(`Virtual table module "${moduleName}" did not return a table definition object`);
        }
        return parseTableDefinition(def, "returned", moduleName);
      }, "virtualTableFactory");
    }
    __name(wrapFactory, "wrapFactory");
    function parseTableDefinition(def, verb, moduleName) {
      if (!hasOwnProperty.call(def, "rows")) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition without a "rows" property`);
      }
      if (!hasOwnProperty.call(def, "columns")) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition without a "columns" property`);
      }
      const rows = def.rows;
      if (typeof rows !== "function" || Object.getPrototypeOf(rows) !== GeneratorFunctionPrototype) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "rows" property (should be a generator function)`);
      }
      let columns = def.columns;
      if (!Array.isArray(columns) || !(columns = [...columns]).every((x4) => typeof x4 === "string")) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "columns" property (should be an array of strings)`);
      }
      if (columns.length !== new Set(columns).size) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with duplicate column names`);
      }
      if (!columns.length) {
        throw new RangeError(`Virtual table module "${moduleName}" ${verb} a table definition with zero columns`);
      }
      let parameters2;
      if (hasOwnProperty.call(def, "parameters")) {
        parameters2 = def.parameters;
        if (!Array.isArray(parameters2) || !(parameters2 = [...parameters2]).every((x4) => typeof x4 === "string")) {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "parameters" property (should be an array of strings)`);
        }
      } else {
        parameters2 = inferParameters(rows);
      }
      if (parameters2.length !== new Set(parameters2).size) {
        throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with duplicate parameter names`);
      }
      if (parameters2.length > 32) {
        throw new RangeError(`Virtual table module "${moduleName}" ${verb} a table definition with more than the maximum number of 32 parameters`);
      }
      for (const parameter of parameters2) {
        if (columns.includes(parameter)) {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with column "${parameter}" which was ambiguously defined as both a column and parameter`);
        }
      }
      let safeIntegers = 2;
      if (hasOwnProperty.call(def, "safeIntegers")) {
        const bool = def.safeIntegers;
        if (typeof bool !== "boolean") {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "safeIntegers" property (should be a boolean)`);
        }
        safeIntegers = +bool;
      }
      let directOnly = false;
      if (hasOwnProperty.call(def, "directOnly")) {
        directOnly = def.directOnly;
        if (typeof directOnly !== "boolean") {
          throw new TypeError(`Virtual table module "${moduleName}" ${verb} a table definition with an invalid "directOnly" property (should be a boolean)`);
        }
      }
      const columnDefinitions = [
        ...parameters2.map(identifier).map((str) => `${str} HIDDEN`),
        ...columns.map(identifier)
      ];
      return [
        `CREATE TABLE x(${columnDefinitions.join(", ")});`,
        wrapGenerator(rows, new Map(columns.map((x4, i10) => [x4, parameters2.length + i10])), moduleName),
        parameters2,
        safeIntegers,
        directOnly
      ];
    }
    __name(parseTableDefinition, "parseTableDefinition");
    function wrapGenerator(generator, columnMap, moduleName) {
      return /* @__PURE__ */ __name(function* virtualTable(...args) {
        const output = args.map((x4) => Buffer.isBuffer(x4) ? Buffer.from(x4) : x4);
        for (let i10 = 0; i10 < columnMap.size; ++i10) {
          output.push(null);
        }
        for (const row of generator(...args)) {
          if (Array.isArray(row)) {
            extractRowArray(row, output, columnMap.size, moduleName);
            yield output;
          } else if (typeof row === "object" && row !== null) {
            extractRowObject(row, output, columnMap, moduleName);
            yield output;
          } else {
            throw new TypeError(`Virtual table module "${moduleName}" yielded something that isn't a valid row object`);
          }
        }
      }, "virtualTable");
    }
    __name(wrapGenerator, "wrapGenerator");
    function extractRowArray(row, output, columnCount, moduleName) {
      if (row.length !== columnCount) {
        throw new TypeError(`Virtual table module "${moduleName}" yielded a row with an incorrect number of columns`);
      }
      const offset = output.length - columnCount;
      for (let i10 = 0; i10 < columnCount; ++i10) {
        output[i10 + offset] = row[i10];
      }
    }
    __name(extractRowArray, "extractRowArray");
    function extractRowObject(row, output, columnMap, moduleName) {
      let count = 0;
      for (const key of Object.keys(row)) {
        const index2 = columnMap.get(key);
        if (index2 === void 0) {
          throw new TypeError(`Virtual table module "${moduleName}" yielded a row with an undeclared column "${key}"`);
        }
        output[index2] = row[key];
        count += 1;
      }
      if (count !== columnMap.size) {
        throw new TypeError(`Virtual table module "${moduleName}" yielded a row with missing columns`);
      }
    }
    __name(extractRowObject, "extractRowObject");
    function inferParameters({ length }) {
      if (!Number.isInteger(length) || length < 0) {
        throw new TypeError("Expected function.length to be a positive integer");
      }
      const params = [];
      for (let i10 = 0; i10 < length; ++i10) {
        params.push(`$${i10 + 1}`);
      }
      return params;
    }
    __name(inferParameters, "inferParameters");
    var { hasOwnProperty } = Object.prototype;
    var { apply } = Function.prototype;
    var GeneratorFunctionPrototype = Object.getPrototypeOf(function* () {
    });
    var identifier = /* @__PURE__ */ __name((str) => `"${str.replace(/"/g, '""')}"`, "identifier");
    var defer = /* @__PURE__ */ __name((x4) => () => x4, "defer");
  }
});

// ../../node_modules/better-sqlite3/lib/methods/inspect.js
var require_inspect = __commonJS({
  "../../node_modules/better-sqlite3/lib/methods/inspect.js"(exports, module2) {
    "use strict";
    var DatabaseInspection = /* @__PURE__ */ __name(function Database2() {
    }, "Database");
    module2.exports = /* @__PURE__ */ __name(function inspect(depth, opts) {
      return Object.assign(new DatabaseInspection(), this);
    }, "inspect");
  }
});

// ../../node_modules/better-sqlite3/lib/database.js
var require_database = __commonJS({
  "../../node_modules/better-sqlite3/lib/database.js"(exports, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var util2 = require_util2();
    var SqliteError = require_sqlite_error();
    var DEFAULT_ADDON;
    function Database2(filenameGiven, options) {
      if (new.target == null) {
        return new Database2(filenameGiven, options);
      }
      let buffer;
      if (Buffer.isBuffer(filenameGiven)) {
        buffer = filenameGiven;
        filenameGiven = ":memory:";
      }
      if (filenameGiven == null)
        filenameGiven = "";
      if (options == null)
        options = {};
      if (typeof filenameGiven !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      if ("readOnly" in options)
        throw new TypeError('Misspelled option "readOnly" should be "readonly"');
      if ("memory" in options)
        throw new TypeError('Option "memory" was removed in v7.0.0 (use ":memory:" filename instead)');
      const filename = filenameGiven.trim();
      const anonymous = filename === "" || filename === ":memory:";
      const readonly = util2.getBooleanOption(options, "readonly");
      const fileMustExist = util2.getBooleanOption(options, "fileMustExist");
      const timeout = "timeout" in options ? options.timeout : 5e3;
      const verbose = "verbose" in options ? options.verbose : null;
      const nativeBinding = "nativeBinding" in options ? options.nativeBinding : null;
      if (readonly && anonymous && !buffer)
        throw new TypeError("In-memory/temporary databases cannot be readonly");
      if (!Number.isInteger(timeout) || timeout < 0)
        throw new TypeError('Expected the "timeout" option to be a positive integer');
      if (timeout > 2147483647)
        throw new RangeError('Option "timeout" cannot be greater than 2147483647');
      if (verbose != null && typeof verbose !== "function")
        throw new TypeError('Expected the "verbose" option to be a function');
      if (nativeBinding != null && typeof nativeBinding !== "string" && typeof nativeBinding !== "object")
        throw new TypeError('Expected the "nativeBinding" option to be a string or addon object');
      let addon;
      if (nativeBinding == null) {
        addon = DEFAULT_ADDON || (DEFAULT_ADDON = require_bindings()("better_sqlite3.node"));
      } else if (typeof nativeBinding === "string") {
        const requireFunc = typeof __non_webpack_require__ === "function" ? __non_webpack_require__ : __require;
        addon = requireFunc(path.resolve(nativeBinding).replace(/(\.node)?$/, ".node"));
      } else {
        addon = nativeBinding;
      }
      if (!addon.isInitialized) {
        addon.setErrorConstructor(SqliteError);
        addon.isInitialized = true;
      }
      if (!anonymous && !fs.existsSync(path.dirname(filename))) {
        throw new TypeError("Cannot open database because the directory does not exist");
      }
      Object.defineProperties(this, {
        [util2.cppdb]: { value: new addon.Database(filename, filenameGiven, anonymous, readonly, fileMustExist, timeout, verbose || null, buffer || null) },
        ...wrappers.getters
      });
    }
    __name(Database2, "Database");
    var wrappers = require_wrappers();
    Database2.prototype.prepare = wrappers.prepare;
    Database2.prototype.transaction = require_transaction();
    Database2.prototype.pragma = require_pragma();
    Database2.prototype.backup = require_backup();
    Database2.prototype.serialize = require_serialize();
    Database2.prototype.function = require_function();
    Database2.prototype.aggregate = require_aggregate();
    Database2.prototype.table = require_table();
    Database2.prototype.loadExtension = wrappers.loadExtension;
    Database2.prototype.exec = wrappers.exec;
    Database2.prototype.close = wrappers.close;
    Database2.prototype.defaultSafeIntegers = wrappers.defaultSafeIntegers;
    Database2.prototype.unsafeMode = wrappers.unsafeMode;
    Database2.prototype[util2.inspect] = require_inspect();
    module2.exports = Database2;
  }
});

// ../../node_modules/better-sqlite3/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/better-sqlite3/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_database();
    module2.exports.SqliteError = require_sqlite_error();
  }
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = __require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    __name(emitClose, "emitClose");
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    __name(duplexOnEnd, "duplexOnEnd");
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    __name(duplexOnError, "duplexOnError");
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", /* @__PURE__ */ __name(function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      }, "message"));
      ws.once("error", /* @__PURE__ */ __name(function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      }, "error"));
      ws.once("close", /* @__PURE__ */ __name(function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      }, "close"));
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", /* @__PURE__ */ __name(function error(err2) {
          called = true;
          callback(err2);
        }, "error"));
        ws.once("close", /* @__PURE__ */ __name(function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        }, "close"));
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", /* @__PURE__ */ __name(function open() {
            duplex._final(callback);
          }, "open"));
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", /* @__PURE__ */ __name(function finish() {
            callback();
          }, "finish"));
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", /* @__PURE__ */ __name(function open() {
            duplex._write(chunk, encoding, callback);
          }, "open"));
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    __name(createWebSocketStream2, "createWebSocketStream");
    module2.exports = createWebSocketStream2;
  }
});

// ../../node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER: EMPTY_BUFFER2 } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat2(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER2;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i10 = 0; i10 < list.length; i10++) {
        const buf = list[i10];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    __name(concat2, "concat");
    function _mask(source, mask, output, offset, length) {
      for (let i10 = 0; i10 < length; i10++) {
        output[offset + i10] = source[i10] ^ mask[i10 & 3];
      }
    }
    __name(_mask, "_mask");
    function _unmask(buffer, mask) {
      for (let i10 = 0; i10 < buffer.length; i10++) {
        buffer[i10] ^= mask[i10 & 3];
      }
    }
    __name(_unmask, "_unmask");
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    __name(toArrayBuffer, "toArrayBuffer");
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    __name(toBuffer, "toBuffer");
    module2.exports = {
      concat: concat2,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = __require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e10) {
      }
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      static {
        __name(this, "Limiter");
      }
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib2 = __require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      static {
        __name(this, "PerMessageDeflate");
      }
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint3 = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint3}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint3}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint3 = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint3}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint3}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    __name(deflateOnData, "deflateOnData");
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    __name(inflateOnData, "inflateOnData");
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
    __name(inflateOnError, "inflateOnError");
  }
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = __require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code2) {
      return code2 >= 1e3 && code2 <= 1014 && code2 !== 1004 && code2 !== 1005 && code2 !== 1006 || code2 >= 3e3 && code2 <= 4999;
    }
    __name(isValidStatusCode, "isValidStatusCode");
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i10 = 0;
      while (i10 < len) {
        if ((buf[i10] & 128) === 0) {
          i10++;
        } else if ((buf[i10] & 224) === 192) {
          if (i10 + 1 === len || (buf[i10 + 1] & 192) !== 128 || (buf[i10] & 254) === 192) {
            return false;
          }
          i10 += 2;
        } else if ((buf[i10] & 240) === 224) {
          if (i10 + 2 >= len || (buf[i10 + 1] & 192) !== 128 || (buf[i10 + 2] & 192) !== 128 || buf[i10] === 224 && (buf[i10 + 1] & 224) === 128 || // Overlong
          buf[i10] === 237 && (buf[i10 + 1] & 224) === 160) {
            return false;
          }
          i10 += 3;
        } else if ((buf[i10] & 248) === 240) {
          if (i10 + 3 >= len || (buf[i10 + 1] & 192) !== 128 || (buf[i10 + 2] & 192) !== 128 || (buf[i10 + 3] & 192) !== 128 || buf[i10] === 240 && (buf[i10 + 1] & 240) === 128 || // Overlong
          buf[i10] === 244 && buf[i10 + 1] > 143 || buf[i10] > 244) {
            return false;
          }
          i10 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    __name(_isValidUTF8, "_isValidUTF8");
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = __require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e10) {
      }
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable: Writable2 } = __require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER: EMPTY_BUFFER2,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat: concat2, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable2 {
      static {
        __name(this, "Receiver");
      }
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n10) {
        this._bufferedBytes -= n10;
        if (n10 === this._buffers[0].length)
          return this._buffers.shift();
        if (n10 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n10,
            buf.length - n10
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n10);
        }
        const dst = Buffer.allocUnsafe(n10);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n10;
          if (n10 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n10), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n10,
              buf.length - n10
            );
          }
          n10 -= buf.length;
        } while (n10 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER2;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat2(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat2(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat2(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER2);
            this.end();
          } else {
            const code2 = data.readUInt16BE(0);
            if (!isValidStatusCode(code2)) {
              return error(
                RangeError,
                `invalid status code ${code2}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code2, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
    __name(error, "error");
  }
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var { randomFillSync: randomFillSync2 } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER: EMPTY_BUFFER2 } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class _Sender {
      static {
        __name(this, "Sender");
      }
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge2 = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync2(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge2 = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge2) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code2, data, mask, cb) {
        let buf;
        if (code2 === void 0) {
          buf = EMPTY_BUFFER2;
        } else if (typeof code2 !== "number" || !isValidStatusCode(code2)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code2, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code2, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength2;
        let readOnly;
        if (typeof data === "string") {
          byteLength2 = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength2 = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength2 > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength2,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength2;
        let readOnly;
        if (typeof data === "string") {
          byteLength2 = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength2 = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength2 > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength2,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength2;
        let readOnly;
        if (typeof data === "string") {
          byteLength2 = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength2 = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength2 >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength2,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength2,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i10 = 0; i10 < this._queue.length; i10++) {
              const params = this._queue[i10];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      static {
        __name(this, "Event");
      }
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      static {
        __name(this, "CloseEvent");
      }
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      static {
        __name(this, "ErrorEvent");
      }
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      static {
        __name(this, "MessageEvent");
      }
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler3, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler3 && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = /* @__PURE__ */ __name(function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler3, this, event);
          }, "onMessage");
        } else if (type === "close") {
          wrapper = /* @__PURE__ */ __name(function onClose(code2, message) {
            const event = new CloseEvent("close", {
              code: code2,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler3, this, event);
          }, "onClose");
        } else if (type === "error") {
          wrapper = /* @__PURE__ */ __name(function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler3, this, event);
          }, "onError");
        } else if (type === "open") {
          wrapper = /* @__PURE__ */ __name(function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler3, this, event);
          }, "onOpen");
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler3;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler3) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler3 && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
    __name(callListener, "callListener");
  }
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name2, elem) {
      if (dest[name2] === void 0)
        dest[name2] = [elem];
      else
        dest[name2].push(elem);
    }
    __name(push, "push");
    function parse5(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code2 = -1;
      let end = -1;
      let i10 = 0;
      for (; i10 < header.length; i10++) {
        code2 = header.charCodeAt(i10);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code2] === 1) {
            if (start === -1)
              start = i10;
          } else if (i10 !== 0 && (code2 === 32 || code2 === 9)) {
            if (end === -1 && start !== -1)
              end = i10;
          } else if (code2 === 59 || code2 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i10}`);
            }
            if (end === -1)
              end = i10;
            const name2 = header.slice(start, end);
            if (code2 === 44) {
              push(offers, name2, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name2;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i10}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code2] === 1) {
            if (start === -1)
              start = i10;
          } else if (code2 === 32 || code2 === 9) {
            if (end === -1 && start !== -1)
              end = i10;
          } else if (code2 === 59 || code2 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i10}`);
            }
            if (end === -1)
              end = i10;
            push(params, header.slice(start, end), true);
            if (code2 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code2 === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i10);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i10}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code2] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i10}`);
            }
            if (start === -1)
              start = i10;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code2] === 1) {
              if (start === -1)
                start = i10;
            } else if (code2 === 34 && start !== -1) {
              inQuotes = false;
              end = i10;
            } else if (code2 === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i10}`);
            }
          } else if (code2 === 34 && header.charCodeAt(i10 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code2] === 1) {
            if (start === -1)
              start = i10;
          } else if (start !== -1 && (code2 === 32 || code2 === 9)) {
            if (end === -1)
              end = i10;
          } else if (code2 === 59 || code2 === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i10}`);
            }
            if (end === -1)
              end = i10;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code2 === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i10}`);
          }
        }
      }
      if (start === -1 || inQuotes || code2 === 32 || code2 === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i10;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    __name(parse5, "parse");
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k10) => {
              let values = params[k10];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v7) => v7 === true ? k10 : `${k10}=${v7}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    __name(format, "format");
    module2.exports = { format, parse: parse5 };
  }
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = __require("events");
    var https2 = __require("https");
    var http2 = __require("http");
    var net = __require("net");
    var tls = __require("tls");
    var { randomBytes, createHash: createHash3 } = __require("crypto");
    var { Readable: Readable3 } = __require("stream");
    var { URL: URL3 } = __require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER: EMPTY_BUFFER2,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse5 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions2 = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      static {
        __name(this, "WebSocket");
      }
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER2;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code2, data) {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code2, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER2, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER2, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER2, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler3) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler3 !== "function")
            return;
          this.addEventListener(method, handler3, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions2[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions2.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions2.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL3) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL3(address);
        } catch (e10) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request3 = isSecure ? https2.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request3(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request3(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL3(location, address);
          } catch (e10) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash3("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse5(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    __name(initAsClient, "initAsClient");
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    __name(emitErrorAndClose, "emitErrorAndClose");
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    __name(netConnect, "netConnect");
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    __name(tlsConnect, "tlsConnect");
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    __name(abortHandshake, "abortHandshake");
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    __name(sendAfterClose, "sendAfterClose");
    function receiverOnConclude(code2, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code2;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code2 === 1005)
        websocket.close();
      else
        websocket.close(code2, reason);
    }
    __name(receiverOnConclude, "receiverOnConclude");
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    __name(receiverOnDrain, "receiverOnDrain");
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    __name(receiverOnError, "receiverOnError");
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    __name(receiverOnFinish, "receiverOnFinish");
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    __name(receiverOnMessage, "receiverOnMessage");
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    __name(receiverOnPing, "receiverOnPing");
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    __name(receiverOnPong, "receiverOnPong");
    function resume(stream) {
      stream.resume();
    }
    __name(resume, "resume");
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    __name(socketOnClose, "socketOnClose");
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    __name(socketOnData, "socketOnData");
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    __name(socketOnEnd, "socketOnEnd");
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
    __name(socketOnError, "socketOnError");
  }
});

// ../../node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../../node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse5(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i10 = 0;
      for (i10; i10 < header.length; i10++) {
        const code2 = header.charCodeAt(i10);
        if (end === -1 && tokenChars[code2] === 1) {
          if (start === -1)
            start = i10;
        } else if (i10 !== 0 && (code2 === 32 || code2 === 9)) {
          if (end === -1 && start !== -1)
            end = i10;
        } else if (code2 === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i10}`);
          }
          if (end === -1)
            end = i10;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i10}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i10);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    __name(parse5, "parse");
    module2.exports = { parse: parse5 };
  }
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = __require("events");
    var http2 = __require("http");
    var https2 = __require("https");
    var net = __require("net");
    var tls = __require("tls");
    var { createHash: createHash3 } = __require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      static {
        __name(this, "WebSocketServer");
      }
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index2 = req.url.indexOf("?");
          const pathname = index2 !== -1 ? req.url.slice(0, index2) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version3 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version3 !== 8 && version3 !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code2, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code2 || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash3("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map2) {
      for (const event of Object.keys(map2))
        server.on(event, map2[event]);
      return /* @__PURE__ */ __name(function removeListeners() {
        for (const event of Object.keys(map2)) {
          server.removeListener(event, map2[event]);
        }
      }, "removeListeners");
    }
    __name(addListeners, "addListeners");
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    __name(emitClose, "emitClose");
    function socketOnError() {
      this.destroy();
    }
    __name(socketOnError, "socketOnError");
    function abortHandshake(socket, code2, message, headers) {
      message = message || http2.STATUS_CODES[code2];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code2} ${http2.STATUS_CODES[code2]}\r
` + Object.keys(headers).map((h10) => `${h10}: ${headers[h10]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    __name(abortHandshake, "abortHandshake");
    function abortHandshakeOrEmitwsClientError(server, req, socket, code2, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code2, message);
      }
    }
    __name(abortHandshakeOrEmitwsClientError, "abortHandshakeOrEmitwsClientError");
  }
});

// ../../node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x4) {
      return x4 < 0 ? -1 : 1;
    }
    __name(sign, "sign");
    function evenRound(x4) {
      if (x4 % 1 === 0.5 && (x4 & 1) === 0) {
        return Math.floor(x4);
      } else {
        return Math.round(x4);
      }
    }
    __name(evenRound, "evenRound");
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x4 = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x4)) {
            throw new TypeError("Argument is not a finite number");
          }
          x4 = sign(x4) * Math.floor(Math.abs(x4));
          if (x4 < lowerBound || x4 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x4;
        }
        if (!isNaN(x4) && opts.clamp) {
          x4 = evenRound(x4);
          if (x4 < lowerBound)
            x4 = lowerBound;
          if (x4 > upperBound)
            x4 = upperBound;
          return x4;
        }
        if (!Number.isFinite(x4) || x4 === 0) {
          return 0;
        }
        x4 = sign(x4) * Math.floor(Math.abs(x4));
        x4 = x4 % moduloVal;
        if (!typeOpts.unsigned && x4 >= moduloBound) {
          return x4 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x4 < 0) {
            x4 += moduloVal;
          } else if (x4 === -0) {
            return 0;
          }
        }
        return x4;
      };
    }
    __name(createNumberConversion, "createNumberConversion");
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val2) {
      return !!val2;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x4 = +V;
      if (!Number.isFinite(x4)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x4;
    };
    conversions["unrestricted double"] = function(V) {
      const x4 = +V;
      if (isNaN(x4)) {
        throw new TypeError("Argument is NaN");
      }
      return x4;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x4 = String(V);
      let c11 = void 0;
      for (let i10 = 0; (c11 = x4.codePointAt(i10)) !== void 0; ++i10) {
        if (c11 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x4;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n10 = S.length;
      const U = [];
      for (let i10 = 0; i10 < n10; ++i10) {
        const c11 = S.charCodeAt(i10);
        if (c11 < 55296 || c11 > 57343) {
          U.push(String.fromCodePoint(c11));
        } else if (56320 <= c11 && c11 <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i10 === n10 - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d10 = S.charCodeAt(i10 + 1);
            if (56320 <= d10 && d10 <= 57343) {
              const a10 = c11 & 1023;
              const b11 = d10 & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a10 + b11));
              ++i10;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// ../../node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = /* @__PURE__ */ __name(function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i10 = 0; i10 < keys.length; ++i10) {
        Object.defineProperty(target, keys[i10], Object.getOwnPropertyDescriptor(source, keys[i10]));
      }
    }, "mixin");
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// ../../node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../../node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../../node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../../node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s10) {
        return s10.normalize("NFC");
      }).join("\0");
    }
    __name(normalize, "normalize");
    function findStatus(val2) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val2 && target[0][1] >= val2) {
          return target;
        } else if (target[0][0] > val2) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    __name(findStatus, "findStatus");
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    __name(countSymbols, "countSymbols");
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i10 = 0; i10 < len; ++i10) {
        var codePoint = domain_name.codePointAt(i10);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    __name(mapChars, "mapChars");
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i10 = 0; i10 < len; ++i10) {
        var status = findStatus(label.codePointAt(i10));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    __name(validateLabel, "validateLabel");
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i10 = 0; i10 < labels.length; ++i10) {
        try {
          var validation = validateLabel(labels[i10]);
          labels[i10] = validation.label;
          result.error = result.error || validation.error;
        } catch (e10) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    __name(processing, "processing");
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l10) {
        try {
          return punycode.toASCII(l10);
        } catch (e10) {
          result.error = true;
          return l10;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i10 = 0; i10 < labels.length; ++i10) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../../node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../../node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    __name(countSymbols, "countSymbols");
    function at(input, idx) {
      const c11 = input[idx];
      return isNaN(c11) ? void 0 : String.fromCodePoint(c11);
    }
    __name(at, "at");
    function isASCIIDigit(c11) {
      return c11 >= 48 && c11 <= 57;
    }
    __name(isASCIIDigit, "isASCIIDigit");
    function isASCIIAlpha(c11) {
      return c11 >= 65 && c11 <= 90 || c11 >= 97 && c11 <= 122;
    }
    __name(isASCIIAlpha, "isASCIIAlpha");
    function isASCIIAlphanumeric(c11) {
      return isASCIIAlpha(c11) || isASCIIDigit(c11);
    }
    __name(isASCIIAlphanumeric, "isASCIIAlphanumeric");
    function isASCIIHex(c11) {
      return isASCIIDigit(c11) || c11 >= 65 && c11 <= 70 || c11 >= 97 && c11 <= 102;
    }
    __name(isASCIIHex, "isASCIIHex");
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    __name(isSingleDot, "isSingleDot");
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    __name(isDoubleDot, "isDoubleDot");
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    __name(isWindowsDriveLetterCodePoints, "isWindowsDriveLetterCodePoints");
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    __name(isWindowsDriveLetterString, "isWindowsDriveLetterString");
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    __name(isNormalizedWindowsDriveLetterString, "isNormalizedWindowsDriveLetterString");
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    __name(containsForbiddenHostCodePoint, "containsForbiddenHostCodePoint");
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    __name(containsForbiddenHostCodePointExcludingPercent, "containsForbiddenHostCodePointExcludingPercent");
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    __name(isSpecialScheme, "isSpecialScheme");
    function isSpecial(url12) {
      return isSpecialScheme(url12.scheme);
    }
    __name(isSpecial, "isSpecial");
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    __name(defaultPort, "defaultPort");
    function percentEncode(c11) {
      let hex = c11.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    __name(percentEncode, "percentEncode");
    function utf8PercentEncode(c11) {
      const buf = new Buffer(c11);
      let str = "";
      for (let i10 = 0; i10 < buf.length; ++i10) {
        str += percentEncode(buf[i10]);
      }
      return str;
    }
    __name(utf8PercentEncode, "utf8PercentEncode");
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i10 = 0; i10 < input.length; ++i10) {
        if (input[i10] !== 37) {
          output.push(input[i10]);
        } else if (input[i10] === 37 && isASCIIHex(input[i10 + 1]) && isASCIIHex(input[i10 + 2])) {
          output.push(parseInt(input.slice(i10 + 1, i10 + 3).toString(), 16));
          i10 += 2;
        } else {
          output.push(input[i10]);
        }
      }
      return new Buffer(output).toString();
    }
    __name(utf8PercentDecode, "utf8PercentDecode");
    function isC0ControlPercentEncode(c11) {
      return c11 <= 31 || c11 > 126;
    }
    __name(isC0ControlPercentEncode, "isC0ControlPercentEncode");
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c11) {
      return isC0ControlPercentEncode(c11) || extraPathPercentEncodeSet.has(c11);
    }
    __name(isPathPercentEncode, "isPathPercentEncode");
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c11) {
      return isPathPercentEncode(c11) || extraUserinfoPercentEncodeSet.has(c11);
    }
    __name(isUserinfoPercentEncode, "isUserinfoPercentEncode");
    function percentEncodeChar(c11, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c11);
      if (encodeSetPredicate(c11)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    __name(percentEncodeChar, "percentEncodeChar");
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    __name(parseIPv4Number, "parseIPv4Number");
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n10 = parseIPv4Number(part);
        if (n10 === failure) {
          return input;
        }
        numbers.push(n10);
      }
      for (let i10 = 0; i10 < numbers.length - 1; ++i10) {
        if (numbers[i10] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n10 of numbers) {
        ipv4 += n10 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    __name(parseIPv4, "parseIPv4");
    function serializeIPv4(address) {
      let output = "";
      let n10 = address;
      for (let i10 = 1; i10 <= 4; ++i10) {
        output = String(n10 % 256) + output;
        if (i10 !== 4) {
          output = "." + output;
        }
        n10 = Math.floor(n10 / 256);
      }
      return output;
    }
    __name(serializeIPv4, "serializeIPv4");
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    __name(parseIPv6, "parseIPv6");
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    __name(serializeIPv6, "serializeIPv6");
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    __name(parseHost, "parseHost");
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i10 = 0; i10 < decoded.length; ++i10) {
        output += percentEncodeChar(decoded[i10], isC0ControlPercentEncode);
      }
      return output;
    }
    __name(parseOpaqueHost, "parseOpaqueHost");
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i10 = 0; i10 < arr.length; ++i10) {
        if (arr[i10] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i10;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    __name(findLongestZeroSequence, "findLongestZeroSequence");
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    __name(serializeHost, "serializeHost");
    function trimControlChars(url12) {
      return url12.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    __name(trimControlChars, "trimControlChars");
    function trimTabAndNewline(url12) {
      return url12.replace(/\u0009|\u000A|\u000D/g, "");
    }
    __name(trimTabAndNewline, "trimTabAndNewline");
    function shortenPath(url12) {
      const path = url12.path;
      if (path.length === 0) {
        return;
      }
      if (url12.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    __name(shortenPath, "shortenPath");
    function includesCredentials(url12) {
      return url12.username !== "" || url12.password !== "";
    }
    __name(includesCredentials, "includesCredentials");
    function cannotHaveAUsernamePasswordPort(url12) {
      return url12.host === null || url12.host === "" || url12.cannotBeABaseURL || url12.scheme === "file";
    }
    __name(cannotHaveAUsernamePasswordPort, "cannotHaveAUsernamePasswordPort");
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    __name(isNormalizedWindowsDriveLetter, "isNormalizedWindowsDriveLetter");
    function URLStateMachine(input, base, encodingOverride, url12, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url12;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c11 = this.input[this.pointer];
        const cStr = isNaN(c11) ? void 0 : String.fromCodePoint(c11);
        const ret = this["parse " + this.state](c11, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    __name(URLStateMachine, "URLStateMachine");
    URLStateMachine.prototype["parse scheme start"] = /* @__PURE__ */ __name(function parseSchemeStart(c11, cStr) {
      if (isASCIIAlpha(c11)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    }, "parseSchemeStart");
    URLStateMachine.prototype["parse scheme"] = /* @__PURE__ */ __name(function parseScheme(c11, cStr) {
      if (isASCIIAlphanumeric(c11) || c11 === 43 || c11 === 45 || c11 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c11 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    }, "parseScheme");
    URLStateMachine.prototype["parse no scheme"] = /* @__PURE__ */ __name(function parseNoScheme(c11) {
      if (this.base === null || this.base.cannotBeABaseURL && c11 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c11 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    }, "parseNoScheme");
    URLStateMachine.prototype["parse special relative or authority"] = /* @__PURE__ */ __name(function parseSpecialRelativeOrAuthority(c11) {
      if (c11 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    }, "parseSpecialRelativeOrAuthority");
    URLStateMachine.prototype["parse path or authority"] = /* @__PURE__ */ __name(function parsePathOrAuthority(c11) {
      if (c11 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    }, "parsePathOrAuthority");
    URLStateMachine.prototype["parse relative"] = /* @__PURE__ */ __name(function parseRelative(c11) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c11)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c11 === 47) {
        this.state = "relative slash";
      } else if (c11 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c11 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c11 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    }, "parseRelative");
    URLStateMachine.prototype["parse relative slash"] = /* @__PURE__ */ __name(function parseRelativeSlash(c11) {
      if (isSpecial(this.url) && (c11 === 47 || c11 === 92)) {
        if (c11 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c11 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    }, "parseRelativeSlash");
    URLStateMachine.prototype["parse special authority slashes"] = /* @__PURE__ */ __name(function parseSpecialAuthoritySlashes(c11) {
      if (c11 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    }, "parseSpecialAuthoritySlashes");
    URLStateMachine.prototype["parse special authority ignore slashes"] = /* @__PURE__ */ __name(function parseSpecialAuthorityIgnoreSlashes(c11) {
      if (c11 !== 47 && c11 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    }, "parseSpecialAuthorityIgnoreSlashes");
    URLStateMachine.prototype["parse authority"] = /* @__PURE__ */ __name(function parseAuthority2(c11, cStr) {
      if (c11 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c11) || c11 === 47 || c11 === 63 || c11 === 35 || isSpecial(this.url) && c11 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    }, "parseAuthority");
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = /* @__PURE__ */ __name(function parseHostName(c11, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c11 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c11) || c11 === 47 || c11 === 63 || c11 === 35 || isSpecial(this.url) && c11 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c11 === 91) {
          this.arrFlag = true;
        } else if (c11 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    }, "parseHostName");
    URLStateMachine.prototype["parse port"] = /* @__PURE__ */ __name(function parsePort(c11, cStr) {
      if (isASCIIDigit(c11)) {
        this.buffer += cStr;
      } else if (isNaN(c11) || c11 === 47 || c11 === 63 || c11 === 35 || isSpecial(this.url) && c11 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    }, "parsePort");
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = /* @__PURE__ */ __name(function parseFile(c11) {
      this.url.scheme = "file";
      if (c11 === 47 || c11 === 92) {
        if (c11 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c11)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c11 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c11 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c11, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    }, "parseFile");
    URLStateMachine.prototype["parse file slash"] = /* @__PURE__ */ __name(function parseFileSlash(c11) {
      if (c11 === 47 || c11 === 92) {
        if (c11 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    }, "parseFileSlash");
    URLStateMachine.prototype["parse file host"] = /* @__PURE__ */ __name(function parseFileHost(c11, cStr) {
      if (isNaN(c11) || c11 === 47 || c11 === 92 || c11 === 63 || c11 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    }, "parseFileHost");
    URLStateMachine.prototype["parse path start"] = /* @__PURE__ */ __name(function parsePathStart(c11) {
      if (isSpecial(this.url)) {
        if (c11 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c11 !== 47 && c11 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c11 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c11 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c11 !== void 0) {
        this.state = "path";
        if (c11 !== 47) {
          --this.pointer;
        }
      }
      return true;
    }, "parsePathStart");
    URLStateMachine.prototype["parse path"] = /* @__PURE__ */ __name(function parsePath(c11) {
      if (isNaN(c11) || c11 === 47 || isSpecial(this.url) && c11 === 92 || !this.stateOverride && (c11 === 63 || c11 === 35)) {
        if (isSpecial(this.url) && c11 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c11 !== 47 && !(isSpecial(this.url) && c11 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c11 !== 47 && !(isSpecial(this.url) && c11 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c11 === void 0 || c11 === 63 || c11 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c11 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c11 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c11 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c11, isPathPercentEncode);
      }
      return true;
    }, "parsePath");
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = /* @__PURE__ */ __name(function parseCannotBeABaseURLPath(c11) {
      if (c11 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c11 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c11) && c11 !== 37) {
          this.parseError = true;
        }
        if (c11 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c11)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c11, isC0ControlPercentEncode);
        }
      }
      return true;
    }, "parseCannotBeABaseURLPath");
    URLStateMachine.prototype["parse query"] = /* @__PURE__ */ __name(function parseQuery2(c11, cStr) {
      if (isNaN(c11) || !this.stateOverride && c11 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i10 = 0; i10 < buffer.length; ++i10) {
          if (buffer[i10] < 33 || buffer[i10] > 126 || buffer[i10] === 34 || buffer[i10] === 35 || buffer[i10] === 60 || buffer[i10] === 62) {
            this.url.query += percentEncode(buffer[i10]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i10]);
          }
        }
        this.buffer = "";
        if (c11 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c11 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    }, "parseQuery");
    URLStateMachine.prototype["parse fragment"] = /* @__PURE__ */ __name(function parseFragment(c11) {
      if (isNaN(c11)) {
      } else if (c11 === 0) {
        this.parseError = true;
      } else {
        if (c11 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c11, isC0ControlPercentEncode);
      }
      return true;
    }, "parseFragment");
    function serializeURL(url12, excludeFragment) {
      let output = url12.scheme + ":";
      if (url12.host !== null) {
        output += "//";
        if (url12.username !== "" || url12.password !== "") {
          output += url12.username;
          if (url12.password !== "") {
            output += ":" + url12.password;
          }
          output += "@";
        }
        output += serializeHost(url12.host);
        if (url12.port !== null) {
          output += ":" + url12.port;
        }
      } else if (url12.host === null && url12.scheme === "file") {
        output += "//";
      }
      if (url12.cannotBeABaseURL) {
        output += url12.path[0];
      } else {
        for (const string of url12.path) {
          output += "/" + string;
        }
      }
      if (url12.query !== null) {
        output += "?" + url12.query;
      }
      if (!excludeFragment && url12.fragment !== null) {
        output += "#" + url12.fragment;
      }
      return output;
    }
    __name(serializeURL, "serializeURL");
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    __name(serializeOrigin, "serializeOrigin");
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url12) {
      switch (url12.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url12.path[0]));
          } catch (e10) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url12.scheme,
            host: url12.host,
            port: url12.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url12, username) {
      url12.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i10 = 0; i10 < decoded.length; ++i10) {
        url12.username += percentEncodeChar(decoded[i10], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url12, password) {
      url12.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i10 = 0; i10 < decoded.length; ++i10) {
        url12.password += percentEncodeChar(decoded[i10], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer2) {
      return String(integer2);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../../node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      static {
        __name(this, "URLImpl");
      }
      constructor(constructorArgs) {
        const url12 = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url12, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v7) {
        const parsedURL = usm.basicURLParse(v7);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v7) {
        usm.basicURLParse(v7 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v7) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v7);
      }
      get password() {
        return this._url.password;
      }
      set password(v7) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v7);
      }
      get host() {
        const url12 = this._url;
        if (url12.host === null) {
          return "";
        }
        if (url12.port === null) {
          return usm.serializeHost(url12.host);
        }
        return usm.serializeHost(url12.host) + ":" + usm.serializeInteger(url12.port);
      }
      set host(v7) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v7, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v7) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v7, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v7) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v7 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v7, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v7) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v7, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v7) {
        const url12 = this._url;
        if (v7 === "") {
          url12.query = null;
          return;
        }
        const input = v7[0] === "?" ? v7.substring(1) : v7;
        url12.query = "";
        usm.basicURLParse(input, { url: url12, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v7) {
        if (v7 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v7[0] === "#" ? v7.substring(1) : v7;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../../node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL3(url12) {
      if (!this || this[impl] || !(this instanceof URL3)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i10 = 0; i10 < arguments.length && i10 < 2; ++i10) {
        args[i10] = arguments[i10];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    __name(URL3, "URL");
    URL3.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i10 = 0; i10 < arguments.length && i10 < 0; ++i10) {
        args[i10] = arguments[i10];
      }
      return this[impl].toJSON.apply(this[impl], args);
    }, "toJSON");
    Object.defineProperty(URL3.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL3.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL3.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL3.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL3,
      expose: {
        Window: { URL: URL3 },
        Worker: { URL: URL3 }
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// ../../node_modules/@aws-sdk/signature-v4-crt/dist-es/constants.js
var AMZ_DATE_QUERY_PARAM2, SIGNATURE_QUERY_PARAM2, TOKEN_QUERY_PARAM2, AMZ_DATE_HEADER2, SIGNATURE_HEADER2, SHA256_HEADER2, TOKEN_HEADER2, MAX_PRESIGNED_TTL2;
var init_constants2 = __esm({
  "../../node_modules/@aws-sdk/signature-v4-crt/dist-es/constants.js"() {
    AMZ_DATE_QUERY_PARAM2 = "X-Amz-Date";
    SIGNATURE_QUERY_PARAM2 = "X-Amz-Signature";
    TOKEN_QUERY_PARAM2 = "X-Amz-Security-Token";
    AMZ_DATE_HEADER2 = AMZ_DATE_QUERY_PARAM2.toLowerCase();
    SIGNATURE_HEADER2 = SIGNATURE_QUERY_PARAM2.toLowerCase();
    SHA256_HEADER2 = "x-amz-content-sha256";
    TOKEN_HEADER2 = TOKEN_QUERY_PARAM2.toLowerCase();
    MAX_PRESIGNED_TTL2 = 60 * 60 * 24 * 7;
  }
});

// ../../node_modules/@aws-sdk/signature-v4-crt/dist-es/headerUtil.js
function deleteHeader(soughtHeader, headers) {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      delete headers[headerName];
    }
  }
}
var init_headerUtil2 = __esm({
  "../../node_modules/@aws-sdk/signature-v4-crt/dist-es/headerUtil.js"() {
    __name(deleteHeader, "deleteHeader");
  }
});

// ../../node_modules/@aws-sdk/signature-v4-crt/dist-es/CrtSignerV4.js
function sdkHttpRequest2crtHttpRequest(sdkRequest) {
  deleteHeader(SHA256_HEADER2, sdkRequest.headers);
  const headersArray = Object.entries(sdkRequest.headers);
  const crtHttpHeaders = new import_aws_crt.http.HttpHeaders(headersArray);
  const queryString = getCanonicalQuery(sdkRequest);
  return new import_aws_crt.http.HttpRequest(sdkRequest.method, sdkRequest.path + "?" + queryString, crtHttpHeaders);
}
function sdk2crtCredentialsProvider(credentials) {
  return import_aws_crt.auth.AwsCredentialsProvider.newStatic(credentials.accessKeyId, credentials.secretAccessKey, credentials.sessionToken);
}
function getHeadersUnsignable(unsignableHeaders, signableHeaders) {
  if (!unsignableHeaders) {
    return [];
  }
  if (!signableHeaders) {
    return [...unsignableHeaders];
  }
  const result = /* @__PURE__ */ new Set([...unsignableHeaders]);
  for (let it = signableHeaders.values(), val2 = null; val2 = it.next().value; ) {
    if (result.has(val2)) {
      result.delete(val2);
    }
  }
  return [...result];
}
var import_aws_crt, CrtSignerV4;
var init_CrtSignerV4 = __esm({
  "../../node_modules/@aws-sdk/signature-v4-crt/dist-es/CrtSignerV4.js"() {
    init_dist_es10();
    init_dist_es9();
    init_dist_es4();
    import_aws_crt = __toESM(require_dist());
    init_constants2();
    init_headerUtil2();
    __name(sdkHttpRequest2crtHttpRequest, "sdkHttpRequest2crtHttpRequest");
    CrtSignerV4 = class {
      static {
        __name(this, "CrtSignerV4");
      }
      constructor({ credentials, region, service, sha256, applyChecksum = true, uriEscapePath = true, signingAlgorithm = import_aws_crt.auth.AwsSigningAlgorithm.SigV4 }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.signingAlgorithm = signingAlgorithm;
        this.applyChecksum = applyChecksum;
        this.regionProvider = normalizeProvider(region);
        this.credentialProvider = normalizeProvider(credentials);
        import_aws_crt.io.enable_logging(import_aws_crt.io.LogLevel.ERROR);
      }
      async options2crtConfigure({ signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}, viaHeader, payloadHash, expiresIn) {
        const credentials = await this.credentialProvider();
        const region = signingRegion ?? await this.regionProvider();
        const service = signingService ?? this.service;
        if (signableHeaders?.has("x-amzn-trace-id") || signableHeaders?.has("user-agent")) {
          throw new Error("internal check (x-amzn-trace-id, user-agent) is not supported to be included to sign with CRT.");
        }
        const headersUnsignable = getHeadersUnsignable(unsignableHeaders, signableHeaders);
        return {
          algorithm: this.signingAlgorithm,
          signature_type: viaHeader ? import_aws_crt.auth.AwsSignatureType.HttpRequestViaHeaders : import_aws_crt.auth.AwsSignatureType.HttpRequestViaQueryParams,
          provider: sdk2crtCredentialsProvider(credentials),
          region,
          service,
          date: new Date(signingDate),
          header_blacklist: headersUnsignable,
          use_double_uri_encode: this.uriEscapePath,
          signed_body_value: payloadHash,
          signed_body_header: this.applyChecksum && viaHeader ? import_aws_crt.auth.AwsSignedBodyHeaderType.XAmzContentSha256 : import_aws_crt.auth.AwsSignedBodyHeaderType.None,
          expiration_in_seconds: expiresIn
        };
      }
      async presign(originalRequest, options = {}) {
        if (options.expiresIn && options.expiresIn > MAX_PRESIGNED_TTL2) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const request3 = moveHeadersToQuery(prepareRequest(originalRequest));
        const crtSignedRequest = await this.signRequest(request3, await this.options2crtConfigure(options, false, await getPayloadHash(originalRequest, this.sha256), options.expiresIn ? options.expiresIn : 3600));
        request3.query = this.getQueryParam(crtSignedRequest.path);
        return request3;
      }
      async sign(toSign, options) {
        const request3 = prepareRequest(toSign);
        const crtSignedRequest = await this.signRequest(request3, await this.options2crtConfigure(options, true, await getPayloadHash(toSign, this.sha256)));
        request3.headers = crtSignedRequest.headers._flatten().reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
        return request3;
      }
      getQueryParam(crtPath) {
        const start = crtPath.search(/\?/);
        const startHash = crtPath.search(/\#/);
        const end = startHash == -1 ? void 0 : startHash;
        const queryParam = {};
        if (start == -1) {
          return queryParam;
        }
        const queryString = crtPath.slice(start + 1, end);
        return parseQueryString(queryString);
      }
      async signRequest(requestToSign, crtConfig) {
        const request3 = sdkHttpRequest2crtHttpRequest(requestToSign);
        try {
          return await import_aws_crt.auth.aws_sign_request(request3, crtConfig);
        } catch (error) {
          throw new Error(error);
        }
      }
      async verifySigv4aSigning(request3, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options = {}) {
        const sdkRequest = prepareRequest(request3);
        const crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
        const payloadHash = await getPayloadHash(request3, this.sha256);
        const crtConfig = await this.options2crtConfigure(options, true, payloadHash);
        return import_aws_crt.auth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY);
      }
      async verifySigv4aPreSigning(request3, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options = {}) {
        if (typeof signature != "string") {
          return false;
        }
        const sdkRequest = prepareRequest(request3);
        const crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
        const crtConfig = await this.options2crtConfigure(options, false, await getPayloadHash(request3, this.sha256), options.expiresIn ? options.expiresIn : 3600);
        return import_aws_crt.auth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY);
      }
    };
    __name(sdk2crtCredentialsProvider, "sdk2crtCredentialsProvider");
    __name(getHeadersUnsignable, "getHeadersUnsignable");
  }
});

// ../../node_modules/@aws-sdk/signature-v4-crt/dist-es/index.js
var dist_es_exports2 = {};
__export(dist_es_exports2, {
  CrtSignerV4: () => CrtSignerV4
});
var init_dist_es11 = __esm({
  "../../node_modules/@aws-sdk/signature-v4-crt/dist-es/index.js"() {
    init_CrtSignerV4();
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});

// ../../node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../../node_modules/has-proto/index.js"(exports, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = /* @__PURE__ */ __name(function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    }, "hasProto");
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      }, "binder");
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i10 = 0; i10 < boundLength; i10++) {
        boundArgs.push("$" + i10);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/has/src/index.js
var require_src = __commonJS({
  "../../node_modules/has/src/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e10) {
      }
    }, "getEvalledConstructor");
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e10) {
        $gOPD = null;
      }
    }
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x4) {
      return x4.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e10) {
        errorProto = getProto(getProto(e10));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    }, "doEval");
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = /* @__PURE__ */ __name(function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    }, "stringToPath");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    }, "getBaseIntrinsic");
    module2.exports = /* @__PURE__ */ __name(function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i10 = 1, isOwn = true; i10 < parts.length; i10 += 1) {
        var part = parts[i10];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i10 + 1 >= parts.length) {
            var desc2 = $gOPD(value, part);
            isOwn = !!desc2;
            if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
              value = desc2.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});

// ../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/call-bind/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e10) {
        $defineProperty = null;
      }
    }
    module2.exports = /* @__PURE__ */ __name(function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc2 = $gOPD(func, "length");
        if (desc2.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    }, "callBind");
    var applyBind = /* @__PURE__ */ __name(function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    }, "applyBind");
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/call-bind/callBound.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = /* @__PURE__ */ __name(function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    }, "callBoundIntrinsic");
  }
});

// ../../node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "../../node_modules/object-inspect/util.inspect.js"(exports, module2) {
    module2.exports = __require("util").inspect;
  }
});

// ../../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/object-inspect/index.js"(exports, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    __name(addNumericSeparator, "addNumericSeparator");
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = /* @__PURE__ */ __name(function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      __name(inspect, "inspect");
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s10 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i10 = 0; i10 < attrs.length; i10++) {
          s10 += " " + attrs[i10].name + "=" + wrapQuotes(quote(attrs[i10].value), "double", opts);
        }
        s10 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s10 += "...";
        }
        s10 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s10;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet3(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    }, "inspect_");
    function wrapQuotes(s10, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s10 + quoteChar;
    }
    __name(wrapQuotes, "wrapQuotes");
    function quote(s10) {
      return $replace.call(String(s10), /"/g, "&quot;");
    }
    __name(quote, "quote");
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isArray, "isArray");
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isDate, "isDate");
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isRegExp, "isRegExp");
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isError, "isError");
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isString, "isString");
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isNumber, "isNumber");
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    __name(isBoolean, "isBoolean");
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e10) {
      }
      return false;
    }
    __name(isSymbol, "isSymbol");
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e10) {
      }
      return false;
    }
    __name(isBigInt, "isBigInt");
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    __name(has, "has");
    function toStr(obj) {
      return objectToString.call(obj);
    }
    __name(toStr, "toStr");
    function nameOf(f11) {
      if (f11.name) {
        return f11.name;
      }
      var m11 = $match.call(functionToString.call(f11), /^function\s*([\w$]+)/);
      if (m11) {
        return m11[1];
      }
      return null;
    }
    __name(nameOf, "nameOf");
    function indexOf(xs, x4) {
      if (xs.indexOf) {
        return xs.indexOf(x4);
      }
      for (var i10 = 0, l10 = xs.length; i10 < l10; i10++) {
        if (xs[i10] === x4) {
          return i10;
        }
      }
      return -1;
    }
    __name(indexOf, "indexOf");
    function isMap(x4) {
      if (!mapSize || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        mapSize.call(x4);
        try {
          setSize.call(x4);
        } catch (s10) {
          return true;
        }
        return x4 instanceof Map;
      } catch (e10) {
      }
      return false;
    }
    __name(isMap, "isMap");
    function isWeakMap(x4) {
      if (!weakMapHas || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x4, weakMapHas);
        try {
          weakSetHas.call(x4, weakSetHas);
        } catch (s10) {
          return true;
        }
        return x4 instanceof WeakMap;
      } catch (e10) {
      }
      return false;
    }
    __name(isWeakMap, "isWeakMap");
    function isWeakRef(x4) {
      if (!weakRefDeref || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x4);
        return true;
      } catch (e10) {
      }
      return false;
    }
    __name(isWeakRef, "isWeakRef");
    function isSet3(x4) {
      if (!setSize || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        setSize.call(x4);
        try {
          mapSize.call(x4);
        } catch (m11) {
          return true;
        }
        return x4 instanceof Set;
      } catch (e10) {
      }
      return false;
    }
    __name(isSet3, "isSet");
    function isWeakSet(x4) {
      if (!weakSetHas || !x4 || typeof x4 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x4, weakSetHas);
        try {
          weakMapHas.call(x4, weakMapHas);
        } catch (s10) {
          return true;
        }
        return x4 instanceof WeakSet;
      } catch (e10) {
      }
      return false;
    }
    __name(isWeakSet, "isWeakSet");
    function isElement(x4) {
      if (!x4 || typeof x4 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x4 instanceof HTMLElement) {
        return true;
      }
      return typeof x4.nodeName === "string" && typeof x4.getAttribute === "function";
    }
    __name(isElement, "isElement");
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s10 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s10, "single", opts);
    }
    __name(inspectString, "inspectString");
    function lowbyte(c11) {
      var n10 = c11.charCodeAt(0);
      var x4 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n10];
      if (x4) {
        return "\\" + x4;
      }
      return "\\x" + (n10 < 16 ? "0" : "") + $toUpperCase.call(n10.toString(16));
    }
    __name(lowbyte, "lowbyte");
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    __name(markBoxed, "markBoxed");
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    __name(weakCollectionOf, "weakCollectionOf");
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    __name(collectionOf, "collectionOf");
    function singleLineValues(xs) {
      for (var i10 = 0; i10 < xs.length; i10++) {
        if (indexOf(xs[i10], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    __name(singleLineValues, "singleLineValues");
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    __name(getIndent, "getIndent");
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    __name(indentedJoin, "indentedJoin");
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i10 = 0; i10 < obj.length; i10++) {
          xs[i10] = has(obj, i10) ? inspect(obj[i10], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k10 = 0; k10 < syms.length; k10++) {
          symMap["$" + syms[k10]] = syms[k10];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j10 = 0; j10 < syms.length; j10++) {
          if (isEnumerable.call(obj, syms[j10])) {
            xs.push("[" + inspect(syms[j10]) + "]: " + inspect(obj[syms[j10]], obj));
          }
        }
      }
      return xs;
    }
    __name(arrObjKeys, "arrObjKeys");
  }
});

// ../../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/side-channel/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = /* @__PURE__ */ __name(function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    }, "listGetNode");
    var listGet = /* @__PURE__ */ __name(function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    }, "listGet");
    var listSet = /* @__PURE__ */ __name(function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    }, "listSet");
    var listHas = /* @__PURE__ */ __name(function(objects, key) {
      return !!listGetNode(objects, key);
    }, "listHas");
    module2.exports = /* @__PURE__ */ __name(function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    }, "getSideChannel");
  }
});

// ../../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/qs/lib/formats.js"(exports, module2) {
    "use strict";
    var replace2 = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace2.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../node_modules/qs/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/qs/lib/utils.js"(exports, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i10 = 0; i10 < 256; ++i10) {
        array.push("%" + ((i10 < 16 ? "0" : "") + i10.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = /* @__PURE__ */ __name(function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j10 = 0; j10 < obj.length; ++j10) {
            if (typeof obj[j10] !== "undefined") {
              compacted.push(obj[j10]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    }, "compactQueue");
    var arrayToObject = /* @__PURE__ */ __name(function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i10 = 0; i10 < source.length; ++i10) {
        if (typeof source[i10] !== "undefined") {
          obj[i10] = source[i10];
        }
      }
      return obj;
    }, "arrayToObject");
    var merge2 = /* @__PURE__ */ __name(function merge3(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i10) {
          if (has.call(target, i10)) {
            var targetItem = target[i10];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i10] = merge3(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i10] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge3(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    }, "merge");
    var assign = /* @__PURE__ */ __name(function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    }, "assignSingleSource");
    var decode5 = /* @__PURE__ */ __name(function(str, decoder2, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e10) {
        return strWithoutPlus;
      }
    }, "decode");
    var encode3 = /* @__PURE__ */ __name(function encode4(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i10 = 0; i10 < string.length; ++i10) {
        var c11 = string.charCodeAt(i10);
        if (c11 === 45 || c11 === 46 || c11 === 95 || c11 === 126 || c11 >= 48 && c11 <= 57 || c11 >= 65 && c11 <= 90 || c11 >= 97 && c11 <= 122 || format === formats.RFC1738 && (c11 === 40 || c11 === 41)) {
          out += string.charAt(i10);
          continue;
        }
        if (c11 < 128) {
          out = out + hexTable[c11];
          continue;
        }
        if (c11 < 2048) {
          out = out + (hexTable[192 | c11 >> 6] + hexTable[128 | c11 & 63]);
          continue;
        }
        if (c11 < 55296 || c11 >= 57344) {
          out = out + (hexTable[224 | c11 >> 12] + hexTable[128 | c11 >> 6 & 63] + hexTable[128 | c11 & 63]);
          continue;
        }
        i10 += 1;
        c11 = 65536 + ((c11 & 1023) << 10 | string.charCodeAt(i10) & 1023);
        out += hexTable[240 | c11 >> 18] + hexTable[128 | c11 >> 12 & 63] + hexTable[128 | c11 >> 6 & 63] + hexTable[128 | c11 & 63];
      }
      return out;
    }, "encode");
    var compact = /* @__PURE__ */ __name(function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i10 = 0; i10 < queue.length; ++i10) {
        var item = queue[i10];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j10 = 0; j10 < keys.length; ++j10) {
          var key = keys[j10];
          var val2 = obj[key];
          if (typeof val2 === "object" && val2 !== null && refs.indexOf(val2) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val2);
          }
        }
      }
      compactQueue(queue);
      return value;
    }, "compact");
    var isRegExp = /* @__PURE__ */ __name(function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }, "isRegExp");
    var isBuffer = /* @__PURE__ */ __name(function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    }, "isBuffer");
    var combine2 = /* @__PURE__ */ __name(function combine3(a10, b11) {
      return [].concat(a10, b11);
    }, "combine");
    var maybeMap = /* @__PURE__ */ __name(function maybeMap2(val2, fn) {
      if (isArray(val2)) {
        var mapped = [];
        for (var i10 = 0; i10 < val2.length; i10 += 1) {
          mapped.push(fn(val2[i10]));
        }
        return mapped;
      }
      return fn(val2);
    }, "maybeMap");
    module2.exports = {
      arrayToObject,
      assign,
      combine: combine2,
      compact,
      decode: decode5,
      encode: encode3,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge2
    };
  }
});

// ../../node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/qs/lib/stringify.js"(exports, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils2();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: /* @__PURE__ */ __name(function brackets(prefix) {
        return prefix + "[]";
      }, "brackets"),
      comma: "comma",
      indices: /* @__PURE__ */ __name(function indices(prefix, key) {
        return prefix + "[" + key + "]";
      }, "indices"),
      repeat: /* @__PURE__ */ __name(function repeat(prefix) {
        return prefix;
      }, "repeat")
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = /* @__PURE__ */ __name(function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    }, "pushToArray");
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: /* @__PURE__ */ __name(function serializeDate(date2) {
        return toISO.call(date2);
      }, "serializeDate"),
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = /* @__PURE__ */ __name(function isNonNullishPrimitive2(v7) {
      return typeof v7 === "string" || typeof v7 === "number" || typeof v7 === "boolean" || typeof v7 === "symbol" || typeof v7 === "bigint";
    }, "isNonNullishPrimitive");
    var sentinel = {};
    var stringify4 = /* @__PURE__ */ __name(function stringify5(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder2, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder2 && !encodeValuesOnly ? encoder2(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder2) {
          var keyValue = encodeValuesOnly ? prefix : encoder2(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder2(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder2) {
          obj = utils.maybeMap(obj, encoder2);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j10 = 0; j10 < objKeys.length; ++j10) {
        var key = objKeys[j10];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify5(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder2,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    }, "stringify");
    var normalizeStringifyOptions = /* @__PURE__ */ __name(function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeStringifyOptions");
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i10 = 0; i10 < objKeys.length; ++i10) {
        var key = objKeys[i10];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify4(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/qs/lib/parse.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = /* @__PURE__ */ __name(function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    }, "interpretNumericEntities");
    var parseArrayValue = /* @__PURE__ */ __name(function(val2, options) {
      if (val2 && typeof val2 === "string" && options.comma && val2.indexOf(",") > -1) {
        return val2.split(",");
      }
      return val2;
    }, "parseArrayValue");
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = /* @__PURE__ */ __name(function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i10;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i10 = 0; i10 < parts.length; ++i10) {
          if (parts[i10].indexOf("utf8=") === 0) {
            if (parts[i10] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i10] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i10;
            i10 = parts.length;
          }
        }
      }
      for (i10 = 0; i10 < parts.length; ++i10) {
        if (i10 === skipIndex) {
          continue;
        }
        var part = parts[i10];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val2;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val2 = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val2 = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val2 && options.interpretNumericEntities && charset === "iso-8859-1") {
          val2 = interpretNumericEntities(val2);
        }
        if (part.indexOf("[]=") > -1) {
          val2 = isArray(val2) ? [val2] : val2;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val2);
        } else {
          obj[key] = val2;
        }
      }
      return obj;
    }, "parseQueryStringValues");
    var parseObject = /* @__PURE__ */ __name(function(chain2, val2, options, valuesParsed) {
      var leaf = valuesParsed ? val2 : parseArrayValue(val2, options);
      for (var i10 = chain2.length - 1; i10 >= 0; --i10) {
        var obj;
        var root = chain2[i10];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    }, "parseObject");
    var parseKeys = /* @__PURE__ */ __name(function parseQueryStringKeys(givenKey, val2, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i10 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i10 < options.depth) {
        i10 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val2, options, valuesParsed);
    }, "parseQueryStringKeys");
    var normalizeParseOptions = /* @__PURE__ */ __name(function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeParseOptions");
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i10 = 0; i10 < keys.length; ++i10) {
        var key = keys[i10];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/qs/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/qs/lib/index.js"(exports, module2) {
    "use strict";
    var stringify4 = require_stringify();
    var parse5 = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse5,
      stringify: stringify4
    };
  }
});

// ../../node_modules/xcase/es5/index.js
var require_es5 = __commonJS({
  "../../node_modules/xcase/es5/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function isLower(char) {
      return char >= 97 && char <= 122;
    }
    __name(isLower, "isLower");
    function isUpper(char) {
      return char >= 65 && char <= 90;
    }
    __name(isUpper, "isUpper");
    function isDigit(char) {
      return char >= 48 && char <= 57;
    }
    __name(isDigit, "isDigit");
    function toUpper(char) {
      return char - 32;
    }
    __name(toUpper, "toUpper");
    function toUpperSafe(char) {
      if (isLower(char)) {
        return char - 32;
      }
      return char;
    }
    __name(toUpperSafe, "toUpperSafe");
    function toLower(char) {
      return char + 32;
    }
    __name(toLower, "toLower");
    function camelize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (isDigit(firstChar) || isUpper(firstChar) || firstChar == separator) {
        return str;
      }
      var out = [];
      var changed = false;
      if (isUpper(firstChar)) {
        changed = true;
        out.push(toLower(firstChar));
      } else {
        out.push(firstChar);
      }
      var length = str.length;
      for (var i10 = 1; i10 < length; ++i10) {
        var c11 = str.charCodeAt(i10);
        if (c11 === separator) {
          changed = true;
          c11 = str.charCodeAt(++i10);
          if (isNaN(c11)) {
            return str;
          }
          out.push(toUpperSafe(c11));
        } else {
          out.push(c11);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    __name(camelize$1, "camelize$1");
    function decamelize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (!isLower(firstChar)) {
        return str;
      }
      var length = str.length;
      var changed = false;
      var out = [];
      for (var i10 = 0; i10 < length; ++i10) {
        var c11 = str.charCodeAt(i10);
        if (isUpper(c11)) {
          out.push(separator);
          out.push(toLower(c11));
          changed = true;
        } else {
          out.push(c11);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    __name(decamelize$1, "decamelize$1");
    function pascalize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (isDigit(firstChar) || firstChar == separator) {
        return str;
      }
      var length = str.length;
      var changed = false;
      var out = [];
      for (var i10 = 0; i10 < length; ++i10) {
        var c11 = str.charCodeAt(i10);
        if (c11 === separator) {
          changed = true;
          c11 = str.charCodeAt(++i10);
          if (isNaN(c11)) {
            return str;
          }
          out.push(toUpperSafe(c11));
        } else if (i10 === 0 && isLower(c11)) {
          changed = true;
          out.push(toUpper(c11));
        } else {
          out.push(c11);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    __name(pascalize$1, "pascalize$1");
    function depascalize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (!isUpper(firstChar)) {
        return str;
      }
      var length = str.length;
      var changed = false;
      var out = [];
      for (var i10 = 0; i10 < length; ++i10) {
        var c11 = str.charCodeAt(i10);
        if (isUpper(c11)) {
          if (i10 > 0) {
            out.push(separator);
          }
          out.push(toLower(c11));
          changed = true;
        } else {
          out.push(c11);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    __name(depascalize$1, "depascalize$1");
    function shouldProcessValue(value) {
      return value && (typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && !(value instanceof Date) && !(value instanceof Function);
    }
    __name(shouldProcessValue, "shouldProcessValue");
    function processKeys(obj, fun, opts) {
      var obj2 = void 0;
      if (obj instanceof Array) {
        obj2 = [];
      } else {
        if (typeof obj.prototype !== "undefined") {
          return obj;
        }
        obj2 = {};
      }
      for (var key in obj) {
        var value = obj[key];
        if (typeof key === "string")
          key = fun(key, opts && opts.separator);
        if (shouldProcessValue(value)) {
          obj2[key] = processKeys(value, fun, opts);
        } else {
          obj2[key] = value;
        }
      }
      return obj2;
    }
    __name(processKeys, "processKeys");
    function processKeysInPlace(obj, fun, opts) {
      var keys = Object.keys(obj);
      for (var idx = 0; idx < keys.length; ++idx) {
        var key = keys[idx];
        var value = obj[key];
        var newKey = fun(key, opts && opts.separator);
        if (newKey !== key) {
          delete obj[key];
        }
        if (shouldProcessValue(value)) {
          obj[newKey] = processKeys(value, fun, opts);
        } else {
          obj[newKey] = value;
        }
      }
      return obj;
    }
    __name(processKeysInPlace, "processKeysInPlace");
    function camelize$$1(str, separator) {
      return camelize$1(
        str,
        separator && separator.charCodeAt(0) || 95
        /* _ */
      );
    }
    __name(camelize$$1, "camelize$$1");
    function decamelize$$1(str, separator) {
      return decamelize$1(
        str,
        separator && separator.charCodeAt(0) || 95
        /* _ */
      );
    }
    __name(decamelize$$1, "decamelize$$1");
    function pascalize$$1(str, separator) {
      return pascalize$1(
        str,
        separator && separator.charCodeAt(0) || 95
        /* _ */
      );
    }
    __name(pascalize$$1, "pascalize$$1");
    function depascalize$$1(str, separator) {
      return depascalize$1(
        str,
        separator && separator.charCodeAt(0) || 95
        /* _ */
      );
    }
    __name(depascalize$$1, "depascalize$$1");
    function camelizeKeys2(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, camelize$$1, opts);
      return processKeys(obj, camelize$$1, opts);
    }
    __name(camelizeKeys2, "camelizeKeys");
    function decamelizeKeys3(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, decamelize$$1, opts);
      return processKeys(obj, decamelize$$1, opts);
    }
    __name(decamelizeKeys3, "decamelizeKeys");
    function pascalizeKeys(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, pascalize$$1, opts);
      return processKeys(obj, pascalize$$1, opts);
    }
    __name(pascalizeKeys, "pascalizeKeys");
    function depascalizeKeys(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, depascalize$$1, opts);
      return processKeys(obj, depascalize$$1, opts);
    }
    __name(depascalizeKeys, "depascalizeKeys");
    exports.camelize = camelize$$1;
    exports.decamelize = decamelize$$1;
    exports.pascalize = pascalize$$1;
    exports.depascalize = depascalize$$1;
    exports.camelizeKeys = camelizeKeys2;
    exports.decamelizeKeys = decamelizeKeys3;
    exports.pascalizeKeys = pascalizeKeys;
    exports.depascalizeKeys = depascalizeKeys;
  }
});

// ../../node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "../../node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name2, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name2)) {
        return name2.reverse().reduce(function(callback, name3) {
          return register.bind(null, state, name3, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name2]) {
          return method(options);
        }
        return state.registry[name2].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
    __name(register, "register");
  }
});

// ../../node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "../../node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name2, hook2) {
      var orig = hook2;
      if (!state.registry[name2]) {
        state.registry[name2] = [];
      }
      if (kind === "before") {
        hook2 = /* @__PURE__ */ __name(function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        }, "hook");
      }
      if (kind === "after") {
        hook2 = /* @__PURE__ */ __name(function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        }, "hook");
      }
      if (kind === "error") {
        hook2 = /* @__PURE__ */ __name(function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
            return orig(error, options);
          });
        }, "hook");
      }
      state.registry[name2].push({
        hook: hook2,
        orig
      });
    }
    __name(addHook, "addHook");
  }
});

// ../../node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "../../node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name2, method) {
      if (!state.registry[name2]) {
        return;
      }
      var index2 = state.registry[name2].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index2 === -1) {
        return;
      }
      state.registry[name2].splice(index2, 1);
    }
    __name(removeHook, "removeHook");
  }
});

// ../../node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "../../node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook2, state, name2) {
      var removeHookRef = bindable(removeHook, null).apply(
        null,
        name2 ? [state, name2] : [state]
      );
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name2 ? [state, kind, name2] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    __name(bindApi, "bindApi");
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    __name(HookSingular, "HookSingular");
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register.bind(null, state);
      bindApi(hook2, state);
      return hook2;
    }
    __name(HookCollection, "HookCollection");
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn(
          '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
        );
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    __name(Hook, "Hook");
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// ../../node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k10) {
        wrapper[k10] = fn[k10];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i10 = 0; i10 < args.length; i10++) {
          args[i10] = arguments[i10];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k10) {
            ret[k10] = cb2[k10];
          });
        }
        return ret;
      }
      __name(wrapper, "wrapper");
    }
    __name(wrappy, "wrappy");
  }
});

// ../../node_modules/once/once.js
var require_once = __commonJS({
  "../../node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f11 = /* @__PURE__ */ __name(function() {
        if (f11.called)
          return f11.value;
        f11.called = true;
        return f11.value = fn.apply(this, arguments);
      }, "f");
      f11.called = false;
      return f11;
    }
    __name(once2, "once");
    function onceStrict(fn) {
      var f11 = /* @__PURE__ */ __name(function() {
        if (f11.called)
          throw new Error(f11.onceError);
        f11.called = true;
        return f11.value = fn.apply(this, arguments);
      }, "f");
      var name2 = fn.name || "Function wrapped with `once`";
      f11.onceError = name2 + " shouldn't be called more than once";
      f11.called = false;
      return f11;
    }
    __name(onceStrict, "onceStrict");
  }
});

// ../../node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "../../node_modules/xtend/immutable.js"(exports, module2) {
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i10 = 0; i10 < arguments.length; i10++) {
        var source = arguments[i10];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    __name(extend, "extend");
  }
});

// ../../node_modules/parse-link-header/index.js
var require_parse_link_header = __commonJS({
  "../../node_modules/parse-link-header/index.js"(exports, module2) {
    "use strict";
    var qs = __require("querystring");
    var url12 = __require("url");
    var xtend = require_immutable();
    var PARSE_LINK_HEADER_MAXLEN = parseInt(process.env.PARSE_LINK_HEADER_MAXLEN) || 2e3;
    var PARSE_LINK_HEADER_THROW_ON_MAXLEN_EXCEEDED = process.env.PARSE_LINK_HEADER_THROW_ON_MAXLEN_EXCEEDED != null;
    function hasRel(x4) {
      return x4 && x4.rel;
    }
    __name(hasRel, "hasRel");
    function intoRels(acc, x4) {
      function splitRel(rel) {
        acc[rel] = xtend(x4, { rel });
      }
      __name(splitRel, "splitRel");
      x4.rel.split(/\s+/).forEach(splitRel);
      return acc;
    }
    __name(intoRels, "intoRels");
    function createObjects(acc, p11) {
      var m11 = p11.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
      if (m11)
        acc[m11[1]] = m11[2];
      return acc;
    }
    __name(createObjects, "createObjects");
    function parseLink(link) {
      try {
        var m11 = link.match(/<?([^>]*)>(.*)/), linkUrl = m11[1], parts = m11[2].split(";"), parsedUrl = url12.parse(linkUrl), qry = qs.parse(parsedUrl.query);
        parts.shift();
        var info = parts.reduce(createObjects, {});
        info = xtend(qry, info);
        info.url = linkUrl;
        return info;
      } catch (e10) {
        return null;
      }
    }
    __name(parseLink, "parseLink");
    function checkHeader(linkHeader) {
      if (!linkHeader)
        return false;
      if (linkHeader.length > PARSE_LINK_HEADER_MAXLEN) {
        if (PARSE_LINK_HEADER_THROW_ON_MAXLEN_EXCEEDED) {
          throw new Error("Input string too long, it should be under " + PARSE_LINK_HEADER_MAXLEN + " characters.");
        } else {
          return false;
        }
      }
      return true;
    }
    __name(checkHeader, "checkHeader");
    module2.exports = function(linkHeader) {
      if (!checkHeader(linkHeader))
        return null;
      return linkHeader.split(/,\s*</).map(parseLink).filter(hasRel).reduce(intoRels, {});
    };
  }
});

// ../../node_modules/pvtsutils/build/index.es.js
function combine(...buf) {
  const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);
  const res = new Uint8Array(totalByteLength);
  let currentPos = 0;
  buf.map((item) => new Uint8Array(item)).forEach((arr) => {
    for (const item2 of arr) {
      res[currentPos++] = item2;
    }
  });
  return res.buffer;
}
var ARRAY_BUFFER_NAME, BufferSourceConverter, Utf8Converter, Utf16Converter, Convert;
var init_index_es = __esm({
  "../../node_modules/pvtsutils/build/index.es.js"() {
    ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
    BufferSourceConverter = class _BufferSourceConverter {
      static {
        __name(this, "BufferSourceConverter");
      }
      static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
      }
      static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
          return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
          return data.buffer;
        }
        return this.toUint8Array(data).slice().buffer;
      }
      static toUint8Array(data) {
        return this.toView(data, Uint8Array);
      }
      static toView(data, type) {
        if (data.constructor === type) {
          return data;
        }
        if (this.isArrayBuffer(data)) {
          return new type(data);
        }
        if (this.isArrayBufferView(data)) {
          return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
      }
      static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
      }
      static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
      }
      static isEqual(a10, b11) {
        const aView = _BufferSourceConverter.toUint8Array(a10);
        const bView = _BufferSourceConverter.toUint8Array(b11);
        if (aView.length !== bView.byteLength) {
          return false;
        }
        for (let i10 = 0; i10 < aView.length; i10++) {
          if (aView[i10] !== bView[i10]) {
            return false;
          }
        }
        return true;
      }
      static concat(...args) {
        if (Array.isArray(args[0])) {
          const buffers = args[0];
          let size = 0;
          for (const buffer of buffers) {
            size += buffer.byteLength;
          }
          const res = new Uint8Array(size);
          let offset = 0;
          for (const buffer of buffers) {
            const view2 = this.toUint8Array(buffer);
            res.set(view2, offset);
            offset += view2.length;
          }
          if (args[1]) {
            return this.toView(res, args[1]);
          }
          return res.buffer;
        } else {
          return this.concat(args);
        }
      }
    };
    Utf8Converter = class {
      static {
        __name(this, "Utf8Converter");
      }
      static fromString(text2) {
        const s10 = unescape(encodeURIComponent(text2));
        const uintArray = new Uint8Array(s10.length);
        for (let i10 = 0; i10 < s10.length; i10++) {
          uintArray[i10] = s10.charCodeAt(i10);
        }
        return uintArray.buffer;
      }
      static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for (let i10 = 0; i10 < buf.length; i10++) {
          encodedString += String.fromCharCode(buf[i10]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
      }
    };
    Utf16Converter = class {
      static {
        __name(this, "Utf16Converter");
      }
      static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for (let i10 = 0; i10 < arrayBuffer.byteLength; i10 += 2) {
          const code2 = dataView.getUint16(i10, littleEndian);
          res += String.fromCharCode(code2);
        }
        return res;
      }
      static fromString(text2, littleEndian = false) {
        const res = new ArrayBuffer(text2.length * 2);
        const dataView = new DataView(res);
        for (let i10 = 0; i10 < text2.length; i10++) {
          dataView.setUint16(i10 * 2, text2.charCodeAt(i10), littleEndian);
        }
        return res;
      }
    };
    Convert = class _Convert {
      static {
        __name(this, "Convert");
      }
      static isHex(data) {
        return typeof data === "string" && /^[a-z0-9]+$/i.test(data);
      }
      static isBase64(data) {
        return typeof data === "string" && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);
      }
      static isBase64Url(data) {
        return typeof data === "string" && /^[a-zA-Z0-9-_]+$/i.test(data);
      }
      static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.ToUtf8String(buf);
          case "binary":
            return this.ToBinary(buf);
          case "hex":
            return this.ToHex(buf);
          case "base64":
            return this.ToBase64(buf);
          case "base64url":
            return this.ToBase64Url(buf);
          case "utf16le":
            return Utf16Converter.toString(buf, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buf);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static FromString(str, enc = "utf8") {
        if (!str) {
          return new ArrayBuffer(0);
        }
        switch (enc.toLowerCase()) {
          case "utf8":
            return this.FromUtf8String(str);
          case "binary":
            return this.FromBinary(str);
          case "hex":
            return this.FromHex(str);
          case "base64":
            return this.FromBase64(str);
          case "base64url":
            return this.FromBase64Url(str);
          case "utf16le":
            return Utf16Converter.fromString(str, true);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(str);
          default:
            throw new Error(`Unknown type of encoding '${enc}'`);
        }
      }
      static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
          const binary = this.ToString(buf, "binary");
          return btoa(binary);
        } else {
          return Buffer.from(buf).toString("base64");
        }
      }
      static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64(formatted)) {
          throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
          return this.FromBinary(atob(formatted));
        } else {
          return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
      }
      static FromBase64Url(base64url2) {
        const formatted = this.formatString(base64url2);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isBase64Url(formatted)) {
          throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
      }
      static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      }
      static FromUtf8String(text2, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.FromBinary(text2);
          case "utf8":
            return Utf8Converter.fromString(text2);
          case "utf16":
          case "utf16be":
            return Utf16Converter.fromString(text2);
          case "utf16le":
          case "usc2":
            return Utf16Converter.fromString(text2, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static ToUtf8String(buffer, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
        switch (encoding) {
          case "ascii":
            return this.ToBinary(buffer);
          case "utf8":
            return Utf8Converter.toString(buffer);
          case "utf16":
          case "utf16be":
            return Utf16Converter.toString(buffer);
          case "utf16le":
          case "usc2":
            return Utf16Converter.toString(buffer, true);
          default:
            throw new Error(`Unknown type of encoding '${encoding}'`);
        }
      }
      static FromBinary(text2) {
        const stringLength = text2.length;
        const resultView = new Uint8Array(stringLength);
        for (let i10 = 0; i10 < stringLength; i10++) {
          resultView[i10] = text2.charCodeAt(i10);
        }
        return resultView.buffer;
      }
      static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for (let i10 = 0; i10 < buf.length; i10++) {
          res += String.fromCharCode(buf[i10]);
        }
        return res;
      }
      static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        const splitter = "";
        const res = [];
        const len = buf.length;
        for (let i10 = 0; i10 < len; i10++) {
          const char = buf[i10].toString(16).padStart(2, "0");
          res.push(char);
        }
        return res.join(splitter);
      }
      static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
          return new ArrayBuffer(0);
        }
        if (!_Convert.isHex(formatted)) {
          throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
          formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for (let i10 = 0; i10 < formatted.length; i10 = i10 + 2) {
          const c11 = formatted.slice(i10, i10 + 2);
          res[i10 / 2] = parseInt(c11, 16);
        }
        return res.buffer;
      }
      static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
      }
      static FromUtf16String(text2, littleEndian = false) {
        return Utf16Converter.fromString(text2, littleEndian);
      }
      static Base64Padding(base64) {
        const padCount = 4 - base64.length % 4;
        if (padCount < 4) {
          for (let i10 = 0; i10 < padCount; i10++) {
            base64 += "=";
          }
        }
        return base64;
      }
      static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
      }
    };
    Convert.DEFAULT_UTF8_ENCODING = "utf8";
    __name(combine, "combine");
  }
});

// ../../node_modules/pvutils/build/utils.es.js
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i10 = inputBuffer.length - 1; i10 >= 0; i10--) {
    result += inputBuffer[inputBuffer.length - 1 - i10] * Math.pow(2, inputBase * i10);
  }
  return result;
}
function utilToBase(value, base, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base);
  for (let i10 = 1; i10 < 8; i10++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i10);
        result = i10;
      } else {
        if (internalReserved < i10) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j10 = i10 - 1; j10 >= 0; j10--) {
        const basis = Math.pow(2, j10 * base);
        retView[result - j10 - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j10 - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view2 of views) {
    outputLength += view2.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view2 of views) {
    retView.set(view2, prevLength);
    prevLength += view2.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i10 = 0; i10 < this.valueHex.byteLength; i10++) {
    bigIntView[i10] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j10 = 0; j10 < this.valueHex.byteLength; j10++) {
    smallIntView[j10] = buf[j10];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i10 = 1; i10 < 8; i10++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i10);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i10);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k10 = 0; k10 < tempBuf.byteLength; k10++) {
          retView[k10 + 1] = tempView[k10];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i10 = 0; i10 < view1.length; i10++) {
    if (view1[i10] !== view2[i10]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding = new Array(dif);
  for (let i10 = 0; i10 < dif; i10++) {
    padding[i10] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str);
}
var log2;
var init_utils_es = __esm({
  "../../node_modules/pvutils/build/utils.es.js"() {
    __name(utilFromBase, "utilFromBase");
    __name(utilToBase, "utilToBase");
    __name(utilConcatView, "utilConcatView");
    __name(utilDecodeTC, "utilDecodeTC");
    __name(utilEncodeTC, "utilEncodeTC");
    __name(isEqualBuffer, "isEqualBuffer");
    __name(padNumber, "padNumber");
    log2 = Math.log(2);
  }
});

// ../../node_modules/asn1js/build/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  Any: () => Any,
  BaseBlock: () => BaseBlock,
  BaseStringBlock: () => BaseStringBlock,
  BitString: () => BitString,
  BmpString: () => BmpString,
  Boolean: () => Boolean2,
  CharacterString: () => CharacterString,
  Choice: () => Choice,
  Constructed: () => Constructed,
  DATE: () => DATE,
  DateTime: () => DateTime,
  Duration: () => Duration,
  EndOfContent: () => EndOfContent,
  Enumerated: () => Enumerated,
  GeneralString: () => GeneralString,
  GeneralizedTime: () => GeneralizedTime,
  GraphicString: () => GraphicString,
  HexBlock: () => HexBlock,
  IA5String: () => IA5String,
  Integer: () => Integer,
  Null: () => Null,
  NumericString: () => NumericString,
  ObjectIdentifier: () => ObjectIdentifier,
  OctetString: () => OctetString,
  Primitive: () => Primitive,
  PrintableString: () => PrintableString,
  RawData: () => RawData,
  RelativeObjectIdentifier: () => RelativeObjectIdentifier,
  Repeated: () => Repeated,
  Sequence: () => Sequence,
  Set: () => Set2,
  TIME: () => TIME,
  TeletexString: () => TeletexString,
  TimeOfDay: () => TimeOfDay,
  UTCTime: () => UTCTime,
  UniversalString: () => UniversalString,
  Utf8String: () => Utf8String,
  ValueBlock: () => ValueBlock,
  VideotexString: () => VideotexString,
  ViewWriter: () => ViewWriter,
  VisibleString: () => VisibleString,
  compareSchema: () => compareSchema,
  fromBER: () => fromBER,
  verifySchema: () => verifySchema
});
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i10 = 0; i10 < buffers.length; i10++) {
    const buffer = buffers[i10];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i10 = 0; i10 < buffers.length; i10++) {
    const buffer = buffers[i10];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
function HexBlock(BaseClass) {
  var _a2;
  return _a2 = class Some extends BaseClass {
    static {
      __name(this, "Some");
    }
    constructor(...args) {
      var _a3;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_a3 = params.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view2 = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view2, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view2.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a2.NAME = "hexBlock", _a2;
}
function prepareIndefiniteForm(baseBlock) {
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!baseBlock.lenBlock.isIndefiniteForm;
}
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}
function viewAdd(first, second) {
  const c11 = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i10 = max; i10 >= 0; i10--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c11[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c11[0];
    }
    c11[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c11[0] > 0)
    firstViewCopy = utilConcatView(c11, firstViewCopy);
  return firstViewCopy;
}
function power2(n10) {
  if (n10 >= powers2.length) {
    for (let p11 = powers2.length; p11 <= n10; p11++) {
      const c11 = new Uint8Array([0]);
      let digits = powers2[p11 - 1].slice(0);
      for (let i10 = digits.length - 1; i10 >= 0; i10--) {
        const newValue = new Uint8Array([(digits[i10] << 1) + c11[0]]);
        c11[0] = newValue[0] / 10;
        digits[i10] = newValue[0] % 10;
      }
      if (c11[0] > 0)
        digits = utilConcatView(c11, digits);
      powers2.push(digits);
    }
  }
  return powers2[n10];
}
function viewSub(first, second) {
  let b11 = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i10 = secondViewCopyLength; i10 >= 0; i10--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b11;
    switch (true) {
      case value < 0:
        b11 = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b11 = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b11 > 0) {
    for (let i10 = firstViewCopyLength - secondViewCopyLength + 1; i10 >= 0; i10--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b11;
      if (value < 0) {
        b11 = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b11 = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
function compareSchema(root, inputData, inputSchema) {
  if (inputSchema instanceof Choice) {
    for (let j10 = 0; j10 < inputSchema.value.length; j10++) {
      const result = compareSchema(root, inputData, inputSchema.value[j10]);
      if (result.verified) {
        return {
          verified: true,
          result: root
        };
      }
    }
    {
      const _result = {
        verified: false,
        result: {
          error: "Wrong values for Choice type"
        }
      };
      if (inputSchema.hasOwnProperty(NAME))
        _result.name = inputSchema.name;
      return _result;
    }
  }
  if (inputSchema instanceof Any) {
    if (inputSchema.hasOwnProperty(NAME))
      root[inputSchema.name] = inputData;
    return {
      verified: true,
      result: root
    };
  }
  if (root instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong root object" }
    };
  }
  if (inputData instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 data" }
    };
  }
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (ID_BLOCK in inputSchema === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (FROM_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (TO_BER in inputSchema.idBlock === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  const encodedId = inputSchema.idBlock.toBER(false);
  if (encodedId.byteLength === 0) {
    return {
      verified: false,
      result: { error: "Error encoding idBlock for ASN.1 schema" }
    };
  }
  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
  if (decodedOffset === -1) {
    return {
      verified: false,
      result: { error: "Error decoding idBlock for ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
    return {
      verified: false,
      result: root
    };
  }
  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema" }
    };
  }
  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
    return {
      verified: false,
      result: root
    };
  }
  if (inputSchema.idBlock.isHexOnly) {
    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
      return {
        verified: false,
        result: { error: "Wrong ASN.1 schema" }
      };
    }
    const schemaView = inputSchema.idBlock.valueHexView;
    const asn1View = inputData.idBlock.valueHexView;
    if (schemaView.length !== asn1View.length) {
      return {
        verified: false,
        result: root
      };
    }
    for (let i10 = 0; i10 < schemaView.length; i10++) {
      if (schemaView[i10] !== asn1View[1]) {
        return {
          verified: false,
          result: root
        };
      }
    }
  }
  if (inputSchema.name) {
    inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
    if (inputSchema.name)
      root[inputSchema.name] = inputData;
  }
  if (inputSchema instanceof typeStore.Constructed) {
    let admission = 0;
    let result = {
      verified: false,
      result: {
        error: "Unknown error"
      }
    };
    let maxLength = inputSchema.valueBlock.value.length;
    if (maxLength > 0) {
      if (inputSchema.valueBlock.value[0] instanceof Repeated) {
        maxLength = inputData.valueBlock.value.length;
      }
    }
    if (maxLength === 0) {
      return {
        verified: true,
        result: root
      };
    }
    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
      let _optional = true;
      for (let i10 = 0; i10 < inputSchema.valueBlock.value.length; i10++)
        _optional = _optional && (inputSchema.valueBlock.value[i10].optional || false);
      if (_optional) {
        return {
          verified: true,
          result: root
        };
      }
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name)
          delete root[inputSchema.name];
      }
      root.error = "Inconsistent object length";
      return {
        verified: false,
        result: root
      };
    }
    for (let i10 = 0; i10 < maxLength; i10++) {
      if (i10 - admission >= inputData.valueBlock.value.length) {
        if (inputSchema.valueBlock.value[i10].optional === false) {
          const _result = {
            verified: false,
            result: root
          };
          root.error = "Inconsistent length between ASN.1 data and schema";
          if (inputSchema.name) {
            inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
            if (inputSchema.name) {
              delete root[inputSchema.name];
              _result.name = inputSchema.name;
            }
          }
          return _result;
        }
      } else {
        if (inputSchema.valueBlock.value[0] instanceof Repeated) {
          result = compareSchema(root, inputData.valueBlock.value[i10], inputSchema.valueBlock.value[0].value);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[0].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
            let arrayRoot = {};
            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)
              arrayRoot = inputData;
            else
              arrayRoot = root;
            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")
              arrayRoot[inputSchema.valueBlock.value[0].name] = [];
            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i10]);
          }
        } else {
          result = compareSchema(root, inputData.valueBlock.value[i10 - admission], inputSchema.valueBlock.value[i10]);
          if (result.verified === false) {
            if (inputSchema.valueBlock.value[i10].optional)
              admission++;
            else {
              if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name)
                  delete root[inputSchema.name];
              }
              return result;
            }
          }
        }
      }
    }
    if (result.verified === false) {
      const _result = {
        verified: false,
        result: root
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return {
      verified: true,
      result: root
    };
  }
  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
    const asn1 = localFromBER(inputData.valueBlock.valueHexView);
    if (asn1.offset === -1) {
      const _result = {
        verified: false,
        result: asn1.result
      };
      if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) {
          delete root[inputSchema.name];
          _result.name = inputSchema.name;
        }
      }
      return _result;
    }
    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
  }
  return {
    verified: true,
    result: root
  };
}
function verifySchema(inputBuffer, inputSchema) {
  if (inputSchema instanceof Object === false) {
    return {
      verified: false,
      result: { error: "Wrong ASN.1 schema type" }
    };
  }
  const asn1 = localFromBER(BufferSourceConverter.toUint8Array(inputBuffer));
  if (asn1.offset === -1) {
    return {
      verified: false,
      result: asn1.result
    };
  }
  return compareSchema(asn1.result, asn1.result, inputSchema);
}
var ViewWriter, powers2, digitsString, NAME, VALUE_HEX_VIEW, IS_HEX_ONLY, ID_BLOCK, TAG_CLASS, TAG_NUMBER, IS_CONSTRUCTED, FROM_BER, TO_BER, LOCAL, EMPTY_STRING, EMPTY_BUFFER, EMPTY_VIEW, END_OF_CONTENT_NAME, OCTET_STRING_NAME, BIT_STRING_NAME, LocalBaseBlock, ValueBlock, LocalIdentificationBlock, LocalLengthBlock, typeStore, BaseBlock, BaseStringBlock, LocalPrimitiveValueBlock, _a$w, Primitive, LocalConstructedValueBlock, _a$v, Constructed, LocalEndOfContentValueBlock, _a$u, EndOfContent, _a$t, Null, LocalBooleanValueBlock, _a$s, Boolean2, LocalOctetStringValueBlock, _a$r, OctetString, LocalBitStringValueBlock, _a$q, BitString, _a$p, LocalIntegerValueBlock, _a$o, Integer, _a$n, Enumerated, LocalSidValueBlock, LocalObjectIdentifierValueBlock, _a$m, ObjectIdentifier, LocalRelativeSidValueBlock, LocalRelativeObjectIdentifierValueBlock, _a$l, RelativeObjectIdentifier, _a$k, Sequence, _a$j, Set2, LocalStringValueBlock, LocalSimpleStringValueBlock, LocalSimpleStringBlock, LocalUtf8StringValueBlock, _a$i, Utf8String, LocalBmpStringValueBlock, _a$h, BmpString, LocalUniversalStringValueBlock, _a$g, UniversalString, _a$f, NumericString, _a$e, PrintableString, _a$d, TeletexString, _a$c, VideotexString, _a$b, IA5String, _a$a, GraphicString, _a$9, VisibleString, _a$8, GeneralString, _a$7, CharacterString, _a$6, UTCTime, _a$5, GeneralizedTime, _a$4, DATE, _a$3, TimeOfDay, _a$2, DateTime, _a$1, Duration, _a, TIME, Any, Choice, Repeated, RawData;
var init_index_es2 = __esm({
  "../../node_modules/asn1js/build/index.es.js"() {
    init_index_es();
    init_utils_es();
    __name(assertBigInt, "assertBigInt");
    __name(concat, "concat");
    __name(checkBufferParams, "checkBufferParams");
    ViewWriter = class {
      static {
        __name(this, "ViewWriter");
      }
      constructor() {
        this.items = [];
      }
      write(buf) {
        this.items.push(buf);
      }
      final() {
        return concat(this.items);
      }
    };
    powers2 = [new Uint8Array([1])];
    digitsString = "0123456789";
    NAME = "name";
    VALUE_HEX_VIEW = "valueHexView";
    IS_HEX_ONLY = "isHexOnly";
    ID_BLOCK = "idBlock";
    TAG_CLASS = "tagClass";
    TAG_NUMBER = "tagNumber";
    IS_CONSTRUCTED = "isConstructed";
    FROM_BER = "fromBER";
    TO_BER = "toBER";
    LOCAL = "local";
    EMPTY_STRING = "";
    EMPTY_BUFFER = new ArrayBuffer(0);
    EMPTY_VIEW = new Uint8Array(0);
    END_OF_CONTENT_NAME = "EndOfContent";
    OCTET_STRING_NAME = "OCTET STRING";
    BIT_STRING_NAME = "BIT STRING";
    __name(HexBlock, "HexBlock");
    LocalBaseBlock = class {
      static {
        __name(this, "LocalBaseBlock");
      }
      constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
        this.blockLength = blockLength;
        this.error = error;
        this.warnings = warnings;
        this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
      }
      static blockName() {
        return this.NAME;
      }
      get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
      }
      set valueBeforeDecode(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
      }
      toJSON() {
        return {
          blockName: this.constructor.NAME,
          blockLength: this.blockLength,
          error: this.error,
          warnings: this.warnings,
          valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
        };
      }
    };
    LocalBaseBlock.NAME = "baseBlock";
    ValueBlock = class extends LocalBaseBlock {
      static {
        __name(this, "ValueBlock");
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
      toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
      }
    };
    ValueBlock.NAME = "valueBlock";
    LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
      static {
        __name(this, "LocalIdentificationBlock");
      }
      constructor({ idBlock = {} } = {}) {
        var _a2, _b, _c, _d;
        super();
        if (idBlock) {
          this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;
          this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
          this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
          this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
          this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        } else {
          this.tagClass = -1;
          this.tagNumber = -1;
          this.isConstructed = false;
        }
      }
      toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch (this.tagClass) {
          case 1:
            firstOctet |= 0;
            break;
          case 2:
            firstOctet |= 64;
            break;
          case 3:
            firstOctet |= 128;
            break;
          case 4:
            firstOctet |= 192;
            break;
          default:
            this.error = "Unknown tag class";
            return EMPTY_BUFFER;
        }
        if (this.isConstructed)
          firstOctet |= 32;
        if (this.tagNumber < 31 && !this.isHexOnly) {
          const retView2 = new Uint8Array(1);
          if (!sizeOnly) {
            let number = this.tagNumber;
            number &= 31;
            firstOctet |= number;
            retView2[0] = firstOctet;
          }
          return retView2.buffer;
        }
        if (!this.isHexOnly) {
          const encodedBuf = utilToBase(this.tagNumber, 7);
          const encodedView = new Uint8Array(encodedBuf);
          const size = encodedBuf.byteLength;
          const retView2 = new Uint8Array(size + 1);
          retView2[0] = firstOctet | 31;
          if (!sizeOnly) {
            for (let i10 = 0; i10 < size - 1; i10++)
              retView2[i10 + 1] = encodedView[i10] | 128;
            retView2[size] = encodedView[size - 1];
          }
          return retView2.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 31;
        if (!sizeOnly) {
          const curView = this.valueHexView;
          for (let i10 = 0; i10 < curView.length - 1; i10++)
            retView[i10 + 1] = curView[i10] | 128;
          retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        const tagClassMask = intBuffer[0] & 192;
        switch (tagClassMask) {
          case 0:
            this.tagClass = 1;
            break;
          case 64:
            this.tagClass = 2;
            break;
          case 128:
            this.tagClass = 3;
            break;
          case 192:
            this.tagClass = 4;
            break;
          default:
            this.error = "Unknown tag class";
            return -1;
        }
        this.isConstructed = (intBuffer[0] & 32) === 32;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 31;
        if (tagNumberMask !== 31) {
          this.tagNumber = tagNumberMask;
          this.blockLength = 1;
        } else {
          let count = 1;
          let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
          let tagNumberBufferMaxLength = 255;
          while (intBuffer[count] & 128) {
            intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
            count++;
            if (count >= intBuffer.length) {
              this.error = "End of input reached before message was fully decoded";
              return -1;
            }
            if (count === tagNumberBufferMaxLength) {
              tagNumberBufferMaxLength += 255;
              const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
              for (let i10 = 0; i10 < intTagNumberBuffer.length; i10++)
                tempBufferView2[i10] = intTagNumberBuffer[i10];
              intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
            }
          }
          this.blockLength = count + 1;
          intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
          const tempBufferView = new Uint8Array(count);
          for (let i10 = 0; i10 < count; i10++)
            tempBufferView[i10] = intTagNumberBuffer[i10];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
          intTagNumberBuffer.set(tempBufferView);
          if (this.blockLength <= 9)
            this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
          else {
            this.isHexOnly = true;
            this.warnings.push("Tag too long, represented as hex-coded");
          }
        }
        if (this.tagClass === 1 && this.isConstructed) {
          switch (this.tagNumber) {
            case 1:
            case 2:
            case 5:
            case 6:
            case 9:
            case 13:
            case 14:
            case 23:
            case 24:
            case 31:
            case 32:
            case 33:
            case 34:
              this.error = "Constructed encoding used for primitive type";
              return -1;
          }
        }
        return inputOffset + this.blockLength;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          tagClass: this.tagClass,
          tagNumber: this.tagNumber,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalIdentificationBlock.NAME = "identificationBlock";
    LocalLengthBlock = class extends LocalBaseBlock {
      static {
        __name(this, "LocalLengthBlock");
      }
      constructor({ lenBlock = {} } = {}) {
        var _a2, _b, _c;
        super();
        this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view2 = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view2, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = view2.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
          this.error = "Zero buffer length";
          return -1;
        }
        if (intBuffer[0] === 255) {
          this.error = "Length block 0xFF is reserved by standard";
          return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 128;
        if (this.isIndefiniteForm) {
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 128);
        if (this.longFormUsed === false) {
          this.length = intBuffer[0];
          this.blockLength = 1;
          return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 127;
        if (count > 8) {
          this.error = "Too big integer";
          return -1;
        }
        if (count + 1 > intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view2.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0)
          this.warnings.push("Needlessly long encoded length");
        this.length = utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127)
          this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127)
          this.longFormUsed = true;
        if (this.isIndefiniteForm) {
          retBuf = new ArrayBuffer(1);
          if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = 128;
          }
          return retBuf;
        }
        if (this.longFormUsed) {
          const encodedBuf = utilToBase(this.length, 8);
          if (encodedBuf.byteLength > 127) {
            this.error = "Too big length";
            return EMPTY_BUFFER;
          }
          retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
          if (sizeOnly)
            return retBuf;
          const encodedView = new Uint8Array(encodedBuf);
          retView = new Uint8Array(retBuf);
          retView[0] = encodedBuf.byteLength | 128;
          for (let i10 = 0; i10 < encodedBuf.byteLength; i10++)
            retView[i10 + 1] = encodedView[i10];
          return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
          retView = new Uint8Array(retBuf);
          retView[0] = this.length;
        }
        return retBuf;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          longFormUsed: this.longFormUsed,
          length: this.length
        };
      }
    };
    LocalLengthBlock.NAME = "lengthBlock";
    typeStore = {};
    BaseBlock = class extends LocalBaseBlock {
      static {
        __name(this, "BaseBlock");
      }
      constructor({ name: name2 = EMPTY_STRING, optional = false, primitiveSchema, ...parameters2 } = {}, valueBlockType) {
        super(parameters2);
        this.name = name2;
        this.optional = optional;
        if (primitiveSchema) {
          this.primitiveSchema = primitiveSchema;
        }
        this.idBlock = new LocalIdentificationBlock(parameters2);
        this.lenBlock = new LocalLengthBlock(parameters2);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters2) : new ValueBlock(parameters2);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) {
          prepareIndefiniteForm(this);
        }
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
          _writer.write(new Uint8Array([128]).buffer);
          this.valueBlock.toBER(sizeOnly, _writer);
          _writer.write(new ArrayBuffer(2));
        } else {
          const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
          this.lenBlock.length = valueBlockBuf.byteLength;
          const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
          _writer.write(lenBlockBuf);
          _writer.write(valueBlockBuf);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          idBlock: this.idBlock.toJSON(),
          lenBlock: this.lenBlock.toJSON(),
          valueBlock: this.valueBlock.toJSON(),
          name: this.name,
          optional: this.optional
        };
        if (this.primitiveSchema)
          object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
      }
      toString(encoding = "ascii") {
        if (encoding === "ascii") {
          return this.onAsciiEncoding();
        }
        return Convert.ToHex(this.toBER());
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
      }
      isEqual(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof this.constructor)) {
          return false;
        }
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return isEqualBuffer(thisRaw, otherRaw);
      }
    };
    BaseBlock.NAME = "BaseBlock";
    __name(prepareIndefiniteForm, "prepareIndefiniteForm");
    BaseStringBlock = class extends BaseBlock {
      static {
        __name(this, "BaseStringBlock");
      }
      constructor({ value = EMPTY_STRING, ...parameters2 } = {}, stringValueBlockType) {
        super(parameters2, stringValueBlockType);
        if (value) {
          this.fromString(value);
        }
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value) {
        this.valueBlock.value = value;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
      }
    };
    BaseStringBlock.NAME = "BaseStringBlock";
    LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
      static {
        __name(this, "LocalPrimitiveValueBlock");
      }
      constructor({ isHexOnly = true, ...parameters2 } = {}) {
        super(parameters2);
        this.isHexOnly = isHexOnly;
      }
    };
    LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
    Primitive = class extends BaseBlock {
      static {
        __name(this, "Primitive");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
      }
    };
    _a$w = Primitive;
    (() => {
      typeStore.Primitive = _a$w;
    })();
    Primitive.NAME = "PRIMITIVE";
    __name(localChangeType, "localChangeType");
    __name(localFromBER, "localFromBER");
    __name(fromBER, "fromBER");
    __name(checkLen, "checkLen");
    LocalConstructedValueBlock = class extends ValueBlock {
      static {
        __name(this, "LocalConstructedValueBlock");
      }
      constructor({ value = [], isIndefiniteForm = false, ...parameters2 } = {}) {
        super(parameters2);
        this.value = value;
        this.isIndefiniteForm = isIndefiniteForm;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const view2 = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view2, inputOffset, inputLength)) {
          return -1;
        }
        this.valueBeforeDecodeView = view2.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
          this.warnings.push("Zero buffer length");
          return inputOffset;
        }
        let currentOffset = inputOffset;
        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
          const returnObject = localFromBER(view2, currentOffset, inputLength);
          if (returnObject.offset === -1) {
            this.error = returnObject.result.error;
            this.warnings.concat(returnObject.result.warnings);
            return -1;
          }
          currentOffset = returnObject.offset;
          this.blockLength += returnObject.result.blockLength;
          inputLength -= returnObject.result.blockLength;
          this.value.push(returnObject.result);
          if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
            break;
          }
        }
        if (this.isIndefiniteForm) {
          if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
            this.value.pop();
          } else {
            this.warnings.push("No EndOfContent block encoded");
          }
        }
        return currentOffset;
      }
      toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for (let i10 = 0; i10 < this.value.length; i10++) {
          this.value[i10].toBER(sizeOnly, _writer);
        }
        if (!writer) {
          return _writer.final();
        }
        return EMPTY_BUFFER;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          isIndefiniteForm: this.isIndefiniteForm,
          value: []
        };
        for (const value of this.value) {
          object.value.push(value.toJSON());
        }
        return object;
      }
    };
    LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
    Constructed = class extends BaseBlock {
      static {
        __name(this, "Constructed");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
          this.error = this.valueBlock.error;
          return resultOffset;
        }
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length)
          this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
      }
      onAsciiEncoding() {
        const values = [];
        for (const value of this.valueBlock.value) {
          values.push(value.toString("ascii").split("\n").map((o10) => `  ${o10}`).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
        return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
      }
    };
    _a$v = Constructed;
    (() => {
      typeStore.Constructed = _a$v;
    })();
    Constructed.NAME = "CONSTRUCTED";
    LocalEndOfContentValueBlock = class extends ValueBlock {
      static {
        __name(this, "LocalEndOfContentValueBlock");
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
      }
      toBER(sizeOnly) {
        return EMPTY_BUFFER;
      }
    };
    LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
    EndOfContent = class extends BaseBlock {
      static {
        __name(this, "EndOfContent");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
      }
    };
    _a$u = EndOfContent;
    (() => {
      typeStore.EndOfContent = _a$u;
    })();
    EndOfContent.NAME = END_OF_CONTENT_NAME;
    Null = class extends BaseBlock {
      static {
        __name(this, "Null");
      }
      constructor(parameters2 = {}) {
        super(parameters2, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0)
          this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length)
          this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length)
          this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
          this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
          return -1;
        }
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
          const retView = new Uint8Array(retBuf);
          retView[0] = 5;
          retView[1] = 0;
        }
        if (writer) {
          writer.write(retBuf);
        }
        return retBuf;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME}`;
      }
    };
    _a$t = Null;
    (() => {
      typeStore.Null = _a$t;
    })();
    Null.NAME = "NULL";
    LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
      static {
        __name(this, "LocalBooleanValueBlock");
      }
      constructor({ value, ...parameters2 } = {}) {
        super(parameters2);
        if (parameters2.valueHex) {
          this.valueHexView = BufferSourceConverter.toUint8Array(parameters2.valueHex);
        } else {
          this.valueHexView = new Uint8Array(1);
        }
        if (value) {
          this.value = value;
        }
      }
      get value() {
        for (const octet of this.valueHexView) {
          if (octet > 0) {
            return true;
          }
        }
        return false;
      }
      set value(value) {
        this.valueHexView[0] = value ? 255 : 0;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1)
          this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
      }
      toBER() {
        return this.valueHexView.slice();
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalBooleanValueBlock.NAME = "BooleanValueBlock";
    Boolean2 = class extends BaseBlock {
      static {
        __name(this, "Boolean");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
      }
      getValue() {
        return this.valueBlock.value;
      }
      setValue(value) {
        this.valueBlock.value = value;
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
      }
    };
    _a$s = Boolean2;
    (() => {
      typeStore.Boolean = _a$s;
    })();
    Boolean2.NAME = "BOOLEAN";
    LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      static {
        __name(this, "LocalOctetStringValueBlock");
      }
      constructor({ isConstructed = false, ...parameters2 } = {}) {
        super(parameters2);
        this.isConstructed = isConstructed;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
          this.isHexOnly = false;
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (let i10 = 0; i10 < this.value.length; i10++) {
            const currentBlockName = this.value[i10].constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== OCTET_STRING_NAME) {
              this.error = "OCTET STRING may consists of OCTET STRINGs only";
              return -1;
            }
          }
        } else {
          this.isHexOnly = true;
          resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
          this.blockLength = inputLength;
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed)
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          isConstructed: this.isConstructed
        };
      }
    };
    LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
    OctetString = class _OctetString extends BaseBlock {
      static {
        __name(this, "OctetString");
      }
      constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
        var _b, _c;
        (_b = parameters2.isConstructed) !== null && _b !== void 0 ? _b : parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters2.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters2.isIndefiniteForm
          },
          ...parameters2
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
          if (this.idBlock.error.length === 0)
            this.blockLength += this.idBlock.blockLength;
          if (this.lenBlock.error.length === 0)
            this.blockLength += this.lenBlock.blockLength;
          return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
          const view2 = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
          const buf = view2.subarray(inputOffset, inputOffset + inputLength);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength) {
                this.valueBlock.value = [asn.result];
              }
            }
          } catch (e10) {
          }
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        }
        return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`;
      }
      getValue() {
        if (!this.idBlock.isConstructed) {
          return this.valueBlock.valueHexView.slice().buffer;
        }
        const array = [];
        for (const content of this.valueBlock.value) {
          if (content instanceof _OctetString) {
            array.push(content.valueBlock.valueHexView);
          }
        }
        return BufferSourceConverter.concat(array);
      }
    };
    _a$r = OctetString;
    (() => {
      typeStore.OctetString = _a$r;
    })();
    OctetString.NAME = OCTET_STRING_NAME;
    LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
      static {
        __name(this, "LocalBitStringValueBlock");
      }
      constructor({ unusedBits = 0, isConstructed = false, ...parameters2 } = {}) {
        super(parameters2);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        let resultOffset = -1;
        if (this.isConstructed) {
          resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
          if (resultOffset === -1)
            return resultOffset;
          for (const value of this.value) {
            const currentBlockName = value.constructor.NAME;
            if (currentBlockName === END_OF_CONTENT_NAME) {
              if (this.isIndefiniteForm)
                break;
              else {
                this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                return -1;
              }
            }
            if (currentBlockName !== BIT_STRING_NAME) {
              this.error = "BIT STRING may consists of BIT STRINGs only";
              return -1;
            }
            const valueBlock = value.valueBlock;
            if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
              this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
              return -1;
            }
            this.unusedBits = valueBlock.unusedBits;
          }
          return resultOffset;
        }
        const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
          this.error = "Unused bits for BitString must be in range 0-7";
          return -1;
        }
        if (!this.unusedBits) {
          const buf = intBuffer.subarray(1);
          try {
            if (buf.byteLength) {
              const asn = localFromBER(buf, 0, buf.byteLength);
              if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                this.value = [asn.result];
              }
            }
          } catch (e10) {
          }
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
      }
      toBER(sizeOnly, writer) {
        if (this.isConstructed) {
          return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
          return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          unusedBits: this.unusedBits,
          isConstructed: this.isConstructed
        };
      }
    };
    LocalBitStringValueBlock.NAME = "BitStringValueBlock";
    BitString = class extends BaseBlock {
      static {
        __name(this, "BitString");
      }
      constructor({ idBlock = {}, lenBlock = {}, ...parameters2 } = {}) {
        var _b, _c;
        (_b = parameters2.isConstructed) !== null && _b !== void 0 ? _b : parameters2.isConstructed = !!((_c = parameters2.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
          idBlock: {
            isConstructed: parameters2.isConstructed,
            ...idBlock
          },
          lenBlock: {
            ...lenBlock,
            isIndefiniteForm: !!parameters2.isIndefiniteForm
          },
          ...parameters2
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
      }
      onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
          return Constructed.prototype.onAsciiEncoding.call(this);
        } else {
          const bits = [];
          const valueHex = this.valueBlock.valueHexView;
          for (const byte of valueHex) {
            bits.push(byte.toString(2).padStart(8, "0"));
          }
          const bitsStr = bits.join("");
          return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
        }
      }
    };
    _a$q = BitString;
    (() => {
      typeStore.BitString = _a$q;
    })();
    BitString.NAME = BIT_STRING_NAME;
    __name(viewAdd, "viewAdd");
    __name(power2, "power2");
    __name(viewSub, "viewSub");
    LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
      static {
        __name(this, "LocalIntegerValueBlock");
      }
      constructor({ value, ...parameters2 } = {}) {
        super(parameters2);
        this._valueDec = 0;
        if (parameters2.valueHex) {
          this.setValueHex();
        }
        if (value !== void 0) {
          this.valueDec = value;
        }
      }
      setValueHex() {
        if (this.valueHexView.length >= 4) {
          this.warnings.push("Too big Integer for decoding, hex only");
          this.isHexOnly = true;
          this._valueDec = 0;
        } else {
          this.isHexOnly = false;
          if (this.valueHexView.length > 0) {
            this._valueDec = utilDecodeTC.call(this);
          }
        }
      }
      set valueDec(v7) {
        this._valueDec = v7;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(utilEncodeTC(v7));
      }
      get valueDec() {
        return this._valueDec;
      }
      fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1)
          return offset;
        const view2 = this.valueHexView;
        if (view2[0] === 0 && (view2[1] & 128) !== 0) {
          this.valueHexView = view2.subarray(1);
        } else {
          if (expectedLength !== 0) {
            if (view2.length < expectedLength) {
              if (expectedLength - view2.length > 1)
                expectedLength = view2.length + 1;
              this.valueHexView = view2.subarray(expectedLength - view2.length);
            }
          }
        }
        return offset;
      }
      toDER(sizeOnly = false) {
        const view2 = this.valueHexView;
        switch (true) {
          case (view2[0] & 128) !== 0:
            {
              const updatedView = new Uint8Array(this.valueHexView.length + 1);
              updatedView[0] = 0;
              updatedView.set(view2, 1);
              this.valueHexView = updatedView;
            }
            break;
          case (view2[0] === 0 && (view2[1] & 128) === 0):
            {
              this.valueHexView = this.valueHexView.subarray(1);
            }
            break;
        }
        return this.toBER(sizeOnly);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) {
          return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
      }
      toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
      toString() {
        const firstBit = this.valueHexView.length * 8 - 1;
        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
          currentByte = asn1View[byteNumber];
          for (let i10 = 0; i10 < 8; i10++) {
            if ((currentByte & 1) === 1) {
              switch (bitNumber) {
                case firstBit:
                  digits = viewSub(power2(bitNumber), digits);
                  result = "-";
                  break;
                default:
                  digits = viewAdd(digits, power2(bitNumber));
              }
            }
            bitNumber++;
            currentByte >>= 1;
          }
        }
        for (let i10 = 0; i10 < digits.length; i10++) {
          if (digits[i10])
            flag = true;
          if (flag)
            result += digitsString.charAt(digits[i10]);
        }
        if (flag === false)
          result += digitsString.charAt(0);
        return result;
      }
    };
    _a$p = LocalIntegerValueBlock;
    LocalIntegerValueBlock.NAME = "IntegerValueBlock";
    (() => {
      Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function(v7) {
          this.valueHexView = new Uint8Array(v7);
          this.setValueHex();
        },
        get: function() {
          return this.valueHexView.slice().buffer;
        }
      });
    })();
    Integer = class _Integer extends BaseBlock {
      static {
        __name(this, "Integer");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
      }
      toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
      }
      static fromBigInt(value) {
        assertBigInt();
        const bigIntValue = BigInt(value);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view2 = new Uint8Array(Convert.FromHex(hex));
        if (bigIntValue < 0) {
          const first = new Uint8Array(view2.length + (view2[0] & 128 ? 1 : 0));
          first[0] |= 128;
          const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
          const secondInt = firstInt + bigIntValue;
          const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
          second[0] |= 128;
          writer.write(second);
        } else {
          if (view2[0] & 128) {
            writer.write(new Uint8Array([0]));
          }
          writer.write(view2);
        }
        const res = new _Integer({
          valueHex: writer.final()
        });
        return res;
      }
      convertToDER() {
        const integer2 = new _Integer({ valueHex: this.valueBlock.valueHexView });
        integer2.valueBlock.toDER();
        return integer2;
      }
      convertFromDER() {
        return new _Integer({
          valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
      }
    };
    _a$o = Integer;
    (() => {
      typeStore.Integer = _a$o;
    })();
    Integer.NAME = "INTEGER";
    Enumerated = class extends Integer {
      static {
        __name(this, "Enumerated");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
      }
    };
    _a$n = Enumerated;
    (() => {
      typeStore.Enumerated = _a$n;
    })();
    Enumerated.NAME = "ENUMERATED";
    LocalSidValueBlock = class extends HexBlock(ValueBlock) {
      static {
        __name(this, "LocalSidValueBlock");
      }
      constructor({ valueDec = -1, isFirstSid = false, ...parameters2 } = {}) {
        super(parameters2);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
          return inputOffset;
        }
        const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
          return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i10 = 0; i10 < inputLength; i10++) {
          this.valueHexView[i10] = intBuffer[i10] & 127;
          this.blockLength++;
          if ((intBuffer[i10] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i10 = 0; i10 < this.blockLength; i10++) {
          tempView[i10] = this.valueHexView[i10];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while (bits.length % 7) {
          bits = "0" + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for (let i10 = 0; i10 < bytes.length; i10++) {
          bytes[i10] = parseInt(bits.slice(i10 * 7, i10 * 7 + 7), 2) + (i10 + 1 < bytes.length ? 128 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i10 = 0; i10 < this.blockLength - 1; i10++)
            retView2[i10] = curView[i10] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i10 = 0; i10 < len; i10++)
            retView[i10] = encodedView[i10] | 128;
          retView[len] = encodedView[len];
        }
        return retView;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = Convert.ToHex(this.valueHexView);
        else {
          if (this.isFirstSid) {
            let sidValue = this.valueDec;
            if (this.valueDec <= 39)
              result = "0.";
            else {
              if (this.valueDec <= 79) {
                result = "1.";
                sidValue -= 40;
              } else {
                result = "2.";
                sidValue -= 80;
              }
            }
            result += sidValue.toString();
          } else
            result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec,
          isFirstSid: this.isFirstSid
        };
      }
    };
    LocalSidValueBlock.NAME = "sidBlock";
    LocalObjectIdentifierValueBlock = class extends ValueBlock {
      static {
        __name(this, "LocalObjectIdentifierValueBlock");
      }
      constructor({ value = EMPTY_STRING, ...parameters2 } = {}) {
        super(parameters2);
        this.value = [];
        if (value) {
          this.fromString(value);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          if (this.value.length === 0)
            sidBlock.isFirstSid = true;
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly) {
        const retBuffers = [];
        for (let i10 = 0; i10 < this.value.length; i10++) {
          const valueBuf = this.value[i10].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i10].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          if (flag) {
            const sidBlock = this.value[0];
            let plus = 0;
            switch (sidBlock.valueDec) {
              case 0:
                break;
              case 1:
                plus = 40;
                break;
              case 2:
                plus = 80;
                break;
              default:
                this.value = [];
                return;
            }
            const parsedSID = parseInt(sid, 10);
            if (isNaN(parsedSID))
              return;
            sidBlock.valueDec = parsedSID + plus;
            flag = false;
          } else {
            const sidBlock = new LocalSidValueBlock();
            if (sid > Number.MAX_SAFE_INTEGER) {
              assertBigInt();
              const sidValue = BigInt(sid);
              sidBlock.valueBigInt = sidValue;
            } else {
              sidBlock.valueDec = parseInt(sid, 10);
              if (isNaN(sidBlock.valueDec))
                return;
            }
            if (!this.value.length) {
              sidBlock.isFirstSid = true;
              flag = true;
            }
            this.value.push(sidBlock);
          }
        } while (pos2 !== -1);
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i10 = 0; i10 < this.value.length; i10++) {
          isHexOnly = this.value[i10].isHexOnly;
          let sidStr = this.value[i10].toString();
          if (i10 !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            if (this.value[i10].isFirstSid)
              result = `2.{${sidStr} - 80}`;
            else
              result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i10 = 0; i10 < this.value.length; i10++) {
          object.sidArray.push(this.value[i10].toJSON());
        }
        return object;
      }
    };
    LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
    ObjectIdentifier = class extends BaseBlock {
      static {
        __name(this, "ObjectIdentifier");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value) {
        this.valueBlock.fromString(value);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$m = ObjectIdentifier;
    (() => {
      typeStore.ObjectIdentifier = _a$m;
    })();
    ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
    LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
      static {
        __name(this, "LocalRelativeSidValueBlock");
      }
      constructor({ valueDec = 0, ...parameters2 } = {}) {
        super(parameters2);
        this.valueDec = valueDec;
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0)
          return inputOffset;
        const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength))
          return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for (let i10 = 0; i10 < inputLength; i10++) {
          this.valueHexView[i10] = intBuffer[i10] & 127;
          this.blockLength++;
          if ((intBuffer[i10] & 128) === 0)
            break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for (let i10 = 0; i10 < this.blockLength; i10++)
          tempView[i10] = this.valueHexView[i10];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (this.valueHexView[0] === 0)
          this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8)
          this.valueDec = utilFromBase(this.valueHexView, 7);
        else {
          this.isHexOnly = true;
          this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
      }
      toBER(sizeOnly) {
        if (this.isHexOnly) {
          if (sizeOnly)
            return new ArrayBuffer(this.valueHexView.byteLength);
          const curView = this.valueHexView;
          const retView2 = new Uint8Array(this.blockLength);
          for (let i10 = 0; i10 < this.blockLength - 1; i10++)
            retView2[i10] = curView[i10] | 128;
          retView2[this.blockLength - 1] = curView[this.blockLength - 1];
          return retView2.buffer;
        }
        const encodedBuf = utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
          this.error = "Error during encoding SID value";
          return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
          const encodedView = new Uint8Array(encodedBuf);
          const len = encodedBuf.byteLength - 1;
          for (let i10 = 0; i10 < len; i10++)
            retView[i10] = encodedView[i10] | 128;
          retView[len] = encodedView[len];
        }
        return retView.buffer;
      }
      toString() {
        let result = "";
        if (this.isHexOnly)
          result = Convert.ToHex(this.valueHexView);
        else {
          result = this.valueDec.toString();
        }
        return result;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          valueDec: this.valueDec
        };
      }
    };
    LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
    LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
      static {
        __name(this, "LocalRelativeObjectIdentifierValueBlock");
      }
      constructor({ value = EMPTY_STRING, ...parameters2 } = {}) {
        super(parameters2);
        this.value = [];
        if (value) {
          this.fromString(value);
        }
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while (inputLength > 0) {
          const sidBlock = new LocalRelativeSidValueBlock();
          resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
          if (resultOffset === -1) {
            this.blockLength = 0;
            this.error = sidBlock.error;
            return resultOffset;
          }
          this.blockLength += sidBlock.blockLength;
          inputLength -= sidBlock.blockLength;
          this.value.push(sidBlock);
        }
        return resultOffset;
      }
      toBER(sizeOnly, writer) {
        const retBuffers = [];
        for (let i10 = 0; i10 < this.value.length; i10++) {
          const valueBuf = this.value[i10].toBER(sizeOnly);
          if (valueBuf.byteLength === 0) {
            this.error = this.value[i10].error;
            return EMPTY_BUFFER;
          }
          retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
      }
      fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
          pos2 = string.indexOf(".", pos1);
          if (pos2 === -1)
            sid = string.substring(pos1);
          else
            sid = string.substring(pos1, pos2);
          pos1 = pos2 + 1;
          const sidBlock = new LocalRelativeSidValueBlock();
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return true;
          this.value.push(sidBlock);
        } while (pos2 !== -1);
        return true;
      }
      toString() {
        let result = "";
        let isHexOnly = false;
        for (let i10 = 0; i10 < this.value.length; i10++) {
          isHexOnly = this.value[i10].isHexOnly;
          let sidStr = this.value[i10].toString();
          if (i10 !== 0)
            result = `${result}.`;
          if (isHexOnly) {
            sidStr = `{${sidStr}}`;
            result += sidStr;
          } else
            result += sidStr;
        }
        return result;
      }
      toJSON() {
        const object = {
          ...super.toJSON(),
          value: this.toString(),
          sidArray: []
        };
        for (let i10 = 0; i10 < this.value.length; i10++)
          object.sidArray.push(this.value[i10].toJSON());
        return object;
      }
    };
    LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
    RelativeObjectIdentifier = class extends BaseBlock {
      static {
        __name(this, "RelativeObjectIdentifier");
      }
      constructor(parameters2 = {}) {
        super(parameters2, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
      }
      getValue() {
        return this.valueBlock.toString();
      }
      setValue(value) {
        this.valueBlock.fromString(value);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.getValue()
        };
      }
    };
    _a$l = RelativeObjectIdentifier;
    (() => {
      typeStore.RelativeObjectIdentifier = _a$l;
    })();
    RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
    Sequence = class extends Constructed {
      static {
        __name(this, "Sequence");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
      }
    };
    _a$k = Sequence;
    (() => {
      typeStore.Sequence = _a$k;
    })();
    Sequence.NAME = "SEQUENCE";
    Set2 = class extends Constructed {
      static {
        __name(this, "Set");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
      }
    };
    _a$j = Set2;
    (() => {
      typeStore.Set = _a$j;
    })();
    Set2.NAME = "SET";
    LocalStringValueBlock = class extends HexBlock(ValueBlock) {
      static {
        __name(this, "LocalStringValueBlock");
      }
      constructor({ ...parameters2 } = {}) {
        super(parameters2);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this.value
        };
      }
    };
    LocalStringValueBlock.NAME = "StringValueBlock";
    LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
      static {
        __name(this, "LocalSimpleStringValueBlock");
      }
    };
    LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
    LocalSimpleStringBlock = class extends BaseStringBlock {
      static {
        __name(this, "LocalSimpleStringBlock");
      }
      constructor({ ...parameters2 } = {}) {
        super(parameters2, LocalSimpleStringValueBlock);
      }
      fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
      }
      fromString(inputString) {
        const strLen = inputString.length;
        const view2 = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for (let i10 = 0; i10 < strLen; i10++)
          view2[i10] = inputString.charCodeAt(i10);
        this.valueBlock.value = inputString;
      }
    };
    LocalSimpleStringBlock.NAME = "SIMPLE STRING";
    LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
      static {
        __name(this, "LocalUtf8StringValueBlock");
      }
      fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
        try {
          this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
          this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
          this.valueBlock.value = Convert.ToBinary(inputBuffer);
        }
      }
      fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
      }
    };
    LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
    Utf8String = class extends LocalUtf8StringValueBlock {
      static {
        __name(this, "Utf8String");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
      }
    };
    _a$i = Utf8String;
    (() => {
      typeStore.Utf8String = _a$i;
    })();
    Utf8String.NAME = "UTF8String";
    LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
      static {
        __name(this, "LocalBmpStringValueBlock");
      }
      fromBuffer(inputBuffer) {
        this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
      }
      fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
      }
    };
    LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
    BmpString = class extends LocalBmpStringValueBlock {
      static {
        __name(this, "BmpString");
      }
      constructor({ ...parameters2 } = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
      }
    };
    _a$h = BmpString;
    (() => {
      typeStore.BmpString = _a$h;
    })();
    BmpString.NAME = "BMPString";
    LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
      static {
        __name(this, "LocalUniversalStringValueBlock");
      }
      fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for (let i10 = 0; i10 < valueView.length; i10 += 4) {
          valueView[i10] = valueView[i10 + 3];
          valueView[i10 + 1] = valueView[i10 + 2];
          valueView[i10 + 2] = 0;
          valueView[i10 + 3] = 0;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
      }
      fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for (let i10 = 0; i10 < strLength; i10++) {
          const codeBuf = utilToBase(inputString.charCodeAt(i10), 8);
          const codeView = new Uint8Array(codeBuf);
          if (codeView.length > 4)
            continue;
          const dif = 4 - codeView.length;
          for (let j10 = codeView.length - 1; j10 >= 0; j10--)
            valueHexView[i10 * 4 + j10 + dif] = codeView[j10];
        }
        this.valueBlock.value = inputString;
      }
    };
    LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
    UniversalString = class extends LocalUniversalStringValueBlock {
      static {
        __name(this, "UniversalString");
      }
      constructor({ ...parameters2 } = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
      }
    };
    _a$g = UniversalString;
    (() => {
      typeStore.UniversalString = _a$g;
    })();
    UniversalString.NAME = "UniversalString";
    NumericString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "NumericString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
      }
    };
    _a$f = NumericString;
    (() => {
      typeStore.NumericString = _a$f;
    })();
    NumericString.NAME = "NumericString";
    PrintableString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "PrintableString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
      }
    };
    _a$e = PrintableString;
    (() => {
      typeStore.PrintableString = _a$e;
    })();
    PrintableString.NAME = "PrintableString";
    TeletexString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "TeletexString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
      }
    };
    _a$d = TeletexString;
    (() => {
      typeStore.TeletexString = _a$d;
    })();
    TeletexString.NAME = "TeletexString";
    VideotexString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "VideotexString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
      }
    };
    _a$c = VideotexString;
    (() => {
      typeStore.VideotexString = _a$c;
    })();
    VideotexString.NAME = "VideotexString";
    IA5String = class extends LocalSimpleStringBlock {
      static {
        __name(this, "IA5String");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
      }
    };
    _a$b = IA5String;
    (() => {
      typeStore.IA5String = _a$b;
    })();
    IA5String.NAME = "IA5String";
    GraphicString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "GraphicString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
      }
    };
    _a$a = GraphicString;
    (() => {
      typeStore.GraphicString = _a$a;
    })();
    GraphicString.NAME = "GraphicString";
    VisibleString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "VisibleString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
      }
    };
    _a$9 = VisibleString;
    (() => {
      typeStore.VisibleString = _a$9;
    })();
    VisibleString.NAME = "VisibleString";
    GeneralString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "GeneralString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
      }
    };
    _a$8 = GeneralString;
    (() => {
      typeStore.GeneralString = _a$8;
    })();
    GeneralString.NAME = "GeneralString";
    CharacterString = class extends LocalSimpleStringBlock {
      static {
        __name(this, "CharacterString");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
      }
    };
    _a$7 = CharacterString;
    (() => {
      typeStore.CharacterString = _a$7;
    })();
    CharacterString.NAME = "CharacterString";
    UTCTime = class extends VisibleString {
      static {
        __name(this, "UTCTime");
      }
      constructor({ value, valueDate, ...parameters2 } = {}) {
        super(parameters2);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value) {
          this.fromString(value);
          this.valueBlock.valueHexView = new Uint8Array(value.length);
          for (let i10 = 0; i10 < value.length; i10++)
            this.valueBlock.valueHexView[i10] = value.charCodeAt(i10);
        }
        if (valueDate) {
          this.fromDate(valueDate);
          this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
      }
      fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
      }
      toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view2 = new Uint8Array(buffer);
        for (let i10 = 0; i10 < str.length; i10++)
          view2[i10] = str.charCodeAt(i10);
        return buffer;
      }
      fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
      }
      fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
          this.error = "Wrong input string for conversion";
          return;
        }
        const year = parseInt(parserArray[1], 10);
        if (year >= 50)
          this.year = 1900 + year;
        else
          this.year = 2e3 + year;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = new Array(7);
          outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
          outputArray[1] = padNumber(this.month, 2);
          outputArray[2] = padNumber(this.day, 2);
          outputArray[3] = padNumber(this.hour, 2);
          outputArray[4] = padNumber(this.minute, 2);
          outputArray[5] = padNumber(this.second, 2);
          outputArray[6] = "Z";
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second
        };
      }
    };
    _a$6 = UTCTime;
    (() => {
      typeStore.UTCTime = _a$6;
    })();
    UTCTime.NAME = "UTCTime";
    GeneralizedTime = class extends UTCTime {
      static {
        __name(this, "GeneralizedTime");
      }
      constructor(parameters2 = {}) {
        var _b;
        super(parameters2);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
      }
      fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
      }
      toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
      }
      fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
          timeString = inputString.substring(0, inputString.length - 1);
          isUTC = true;
        } else {
          const number = new Number(inputString[inputString.length - 1]);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          timeString = inputString;
        }
        if (isUTC) {
          if (timeString.indexOf("+") !== -1)
            throw new Error("Wrong input string for conversion");
          if (timeString.indexOf("-") !== -1)
            throw new Error("Wrong input string for conversion");
        } else {
          let multiplier = 1;
          let differencePosition = timeString.indexOf("+");
          let differenceString = "";
          if (differencePosition === -1) {
            differencePosition = timeString.indexOf("-");
            multiplier = -1;
          }
          if (differencePosition !== -1) {
            differenceString = timeString.substring(differencePosition + 1);
            timeString = timeString.substring(0, differencePosition);
            if (differenceString.length !== 2 && differenceString.length !== 4)
              throw new Error("Wrong input string for conversion");
            let number = parseInt(differenceString.substring(0, 2), 10);
            if (isNaN(number.valueOf()))
              throw new Error("Wrong input string for conversion");
            hourDifference = multiplier * number;
            if (differenceString.length === 4) {
              number = parseInt(differenceString.substring(2, 4), 10);
              if (isNaN(number.valueOf()))
                throw new Error("Wrong input string for conversion");
              minuteDifference = multiplier * number;
            }
          }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1)
          fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
          const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
          if (isNaN(fractionPartCheck.valueOf()))
            throw new Error("Wrong input string for conversion");
          fractionPart = fractionPartCheck.valueOf();
          dateTimeString = timeString.substring(0, fractionPointPosition);
        } else
          dateTimeString = timeString;
        switch (true) {
          case dateTimeString.length === 8:
            parser = /(\d{4})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1)
              throw new Error("Wrong input string for conversion");
            break;
          case dateTimeString.length === 10:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.minute = Math.floor(fractionResult);
              fractionResult = 60 * (fractionResult - this.minute);
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 12:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              let fractionResult = 60 * fractionPart;
              this.second = Math.floor(fractionResult);
              fractionResult = 1e3 * (fractionResult - this.second);
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          case dateTimeString.length === 14:
            parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
            if (fractionPointPosition !== -1) {
              const fractionResult = 1e3 * fractionPart;
              this.millisecond = Math.floor(fractionResult);
            }
            break;
          default:
            throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null)
          throw new Error("Wrong input string for conversion");
        for (let j10 = 1; j10 < parserArray.length; j10++) {
          switch (j10) {
            case 1:
              this.year = parseInt(parserArray[j10], 10);
              break;
            case 2:
              this.month = parseInt(parserArray[j10], 10);
              break;
            case 3:
              this.day = parseInt(parserArray[j10], 10);
              break;
            case 4:
              this.hour = parseInt(parserArray[j10], 10) + hourDifference;
              break;
            case 5:
              this.minute = parseInt(parserArray[j10], 10) + minuteDifference;
              break;
            case 6:
              this.second = parseInt(parserArray[j10], 10);
              break;
            default:
              throw new Error("Wrong input string for conversion");
          }
        }
        if (isUTC === false) {
          const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
          this.year = tempDate.getUTCFullYear();
          this.month = tempDate.getUTCMonth();
          this.day = tempDate.getUTCDay();
          this.hour = tempDate.getUTCHours();
          this.minute = tempDate.getUTCMinutes();
          this.second = tempDate.getUTCSeconds();
          this.millisecond = tempDate.getUTCMilliseconds();
        }
      }
      toString(encoding = "iso") {
        if (encoding === "iso") {
          const outputArray = [];
          outputArray.push(padNumber(this.year, 4));
          outputArray.push(padNumber(this.month, 2));
          outputArray.push(padNumber(this.day, 2));
          outputArray.push(padNumber(this.hour, 2));
          outputArray.push(padNumber(this.minute, 2));
          outputArray.push(padNumber(this.second, 2));
          if (this.millisecond !== 0) {
            outputArray.push(".");
            outputArray.push(padNumber(this.millisecond, 3));
          }
          outputArray.push("Z");
          return outputArray.join("");
        }
        return super.toString(encoding);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          millisecond: this.millisecond
        };
      }
    };
    _a$5 = GeneralizedTime;
    (() => {
      typeStore.GeneralizedTime = _a$5;
    })();
    GeneralizedTime.NAME = "GeneralizedTime";
    DATE = class extends Utf8String {
      static {
        __name(this, "DATE");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
      }
    };
    _a$4 = DATE;
    (() => {
      typeStore.DATE = _a$4;
    })();
    DATE.NAME = "DATE";
    TimeOfDay = class extends Utf8String {
      static {
        __name(this, "TimeOfDay");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
      }
    };
    _a$3 = TimeOfDay;
    (() => {
      typeStore.TimeOfDay = _a$3;
    })();
    TimeOfDay.NAME = "TimeOfDay";
    DateTime = class extends Utf8String {
      static {
        __name(this, "DateTime");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
      }
    };
    _a$2 = DateTime;
    (() => {
      typeStore.DateTime = _a$2;
    })();
    DateTime.NAME = "DateTime";
    Duration = class extends Utf8String {
      static {
        __name(this, "Duration");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
      }
    };
    _a$1 = Duration;
    (() => {
      typeStore.Duration = _a$1;
    })();
    Duration.NAME = "Duration";
    TIME = class extends Utf8String {
      static {
        __name(this, "TIME");
      }
      constructor(parameters2 = {}) {
        super(parameters2);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
      }
    };
    _a = TIME;
    (() => {
      typeStore.TIME = _a;
    })();
    TIME.NAME = "TIME";
    Any = class {
      static {
        __name(this, "Any");
      }
      constructor({ name: name2 = EMPTY_STRING, optional = false } = {}) {
        this.name = name2;
        this.optional = optional;
      }
    };
    Choice = class extends Any {
      static {
        __name(this, "Choice");
      }
      constructor({ value = [], ...parameters2 } = {}) {
        super(parameters2);
        this.value = value;
      }
    };
    Repeated = class extends Any {
      static {
        __name(this, "Repeated");
      }
      constructor({ value = new Any(), local = false, ...parameters2 } = {}) {
        super(parameters2);
        this.value = value;
        this.local = local;
      }
    };
    RawData = class {
      static {
        __name(this, "RawData");
      }
      constructor({ data = EMPTY_VIEW } = {}) {
        this.dataView = BufferSourceConverter.toUint8Array(data);
      }
      get data() {
        return this.dataView.slice().buffer;
      }
      set data(value) {
        this.dataView = BufferSourceConverter.toUint8Array(value);
      }
      fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
      }
      toBER(sizeOnly) {
        return this.dataView.slice().buffer;
      }
    };
    __name(compareSchema, "compareSchema");
    __name(verifySchema, "verifySchema");
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/enums.js
var AsnTypeTypes, AsnPropTypes;
var init_enums = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/enums.js"() {
    (function(AsnTypeTypes2) {
      AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";
      AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";
      AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";
    })(AsnTypeTypes || (AsnTypeTypes = {}));
    (function(AsnPropTypes2) {
      AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";
      AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";
      AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";
      AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";
      AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";
      AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";
      AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";
      AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";
      AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";
      AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";
      AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";
      AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";
      AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";
      AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";
      AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";
      AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";
      AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";
      AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";
      AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";
      AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";
      AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";
      AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";
      AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";
      AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";
      AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";
      AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";
      AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";
    })(AsnPropTypes || (AsnPropTypes = {}));
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js
var init_bit_string = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/types/bit_string.js"() {
    init_index_es2();
    init_index_es();
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js
var init_octet_string = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/types/octet_string.js"() {
    init_index_es2();
    init_index_es();
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/types/index.js
var init_types = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/types/index.js"() {
    init_bit_string();
    init_octet_string();
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/converters.js
function createStringConverter(Asn1Type) {
  return {
    fromASN: (value) => value.valueBlock.value,
    toASN: (value) => new Asn1Type({ value })
  };
}
function defaultConverter(type) {
  switch (type) {
    case AsnPropTypes.Any:
      return AsnAnyConverter;
    case AsnPropTypes.BitString:
      return AsnBitStringConverter;
    case AsnPropTypes.BmpString:
      return AsnBmpStringConverter;
    case AsnPropTypes.Boolean:
      return AsnBooleanConverter;
    case AsnPropTypes.CharacterString:
      return AsnCharacterStringConverter;
    case AsnPropTypes.Enumerated:
      return AsnEnumeratedConverter;
    case AsnPropTypes.GeneralString:
      return AsnGeneralStringConverter;
    case AsnPropTypes.GeneralizedTime:
      return AsnGeneralizedTimeConverter;
    case AsnPropTypes.GraphicString:
      return AsnGraphicStringConverter;
    case AsnPropTypes.IA5String:
      return AsnIA5StringConverter;
    case AsnPropTypes.Integer:
      return AsnIntegerConverter;
    case AsnPropTypes.Null:
      return AsnNullConverter;
    case AsnPropTypes.NumericString:
      return AsnNumericStringConverter;
    case AsnPropTypes.ObjectIdentifier:
      return AsnObjectIdentifierConverter;
    case AsnPropTypes.OctetString:
      return AsnOctetStringConverter;
    case AsnPropTypes.PrintableString:
      return AsnPrintableStringConverter;
    case AsnPropTypes.TeletexString:
      return AsnTeletexStringConverter;
    case AsnPropTypes.UTCTime:
      return AsnUTCTimeConverter;
    case AsnPropTypes.UniversalString:
      return AsnUniversalStringConverter;
    case AsnPropTypes.Utf8String:
      return AsnUtf8StringConverter;
    case AsnPropTypes.VideotexString:
      return AsnVideotexStringConverter;
    case AsnPropTypes.VisibleString:
      return AsnVisibleStringConverter;
    default:
      return null;
  }
}
var AsnAnyConverter, AsnIntegerConverter, AsnEnumeratedConverter, AsnBitStringConverter, AsnObjectIdentifierConverter, AsnBooleanConverter, AsnOctetStringConverter, AsnUtf8StringConverter, AsnBmpStringConverter, AsnUniversalStringConverter, AsnNumericStringConverter, AsnPrintableStringConverter, AsnTeletexStringConverter, AsnVideotexStringConverter, AsnIA5StringConverter, AsnGraphicStringConverter, AsnVisibleStringConverter, AsnGeneralStringConverter, AsnCharacterStringConverter, AsnUTCTimeConverter, AsnGeneralizedTimeConverter, AsnNullConverter;
var init_converters = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/converters.js"() {
    init_index_es2();
    init_enums();
    init_types();
    AsnAnyConverter = {
      fromASN: (value) => value instanceof Null ? null : value.valueBeforeDecodeView,
      toASN: (value) => {
        if (value === null) {
          return new Null();
        }
        const schema = fromBER(value);
        if (schema.result.error) {
          throw new Error(schema.result.error);
        }
        return schema.result;
      }
    };
    AsnIntegerConverter = {
      fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
      toASN: (value) => new Integer({ value: +value })
    };
    AsnEnumeratedConverter = {
      fromASN: (value) => value.valueBlock.valueDec,
      toASN: (value) => new Enumerated({ value })
    };
    AsnBitStringConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new BitString({ valueHex: value })
    };
    AsnObjectIdentifierConverter = {
      fromASN: (value) => value.valueBlock.toString(),
      toASN: (value) => new ObjectIdentifier({ value })
    };
    AsnBooleanConverter = {
      fromASN: (value) => value.valueBlock.value,
      toASN: (value) => new Boolean2({ value })
    };
    AsnOctetStringConverter = {
      fromASN: (value) => value.valueBlock.valueHexView,
      toASN: (value) => new OctetString({ valueHex: value })
    };
    __name(createStringConverter, "createStringConverter");
    AsnUtf8StringConverter = createStringConverter(Utf8String);
    AsnBmpStringConverter = createStringConverter(BmpString);
    AsnUniversalStringConverter = createStringConverter(UniversalString);
    AsnNumericStringConverter = createStringConverter(NumericString);
    AsnPrintableStringConverter = createStringConverter(PrintableString);
    AsnTeletexStringConverter = createStringConverter(TeletexString);
    AsnVideotexStringConverter = createStringConverter(VideotexString);
    AsnIA5StringConverter = createStringConverter(IA5String);
    AsnGraphicStringConverter = createStringConverter(GraphicString);
    AsnVisibleStringConverter = createStringConverter(VisibleString);
    AsnGeneralStringConverter = createStringConverter(GeneralString);
    AsnCharacterStringConverter = createStringConverter(CharacterString);
    AsnUTCTimeConverter = {
      fromASN: (value) => value.toDate(),
      toASN: (value) => new UTCTime({ valueDate: value })
    };
    AsnGeneralizedTimeConverter = {
      fromASN: (value) => value.toDate(),
      toASN: (value) => new GeneralizedTime({ valueDate: value })
    };
    AsnNullConverter = {
      fromASN: () => null,
      toASN: () => {
        return new Null();
      }
    };
    __name(defaultConverter, "defaultConverter");
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/helper.js
function isConvertible(target) {
  if (typeof target === "function" && target.prototype) {
    if (target.prototype.toASN && target.prototype.fromASN) {
      return true;
    } else {
      return isConvertible(target.prototype);
    }
  } else {
    return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);
  }
}
function isTypeOfArray(target) {
  var _a2;
  if (target) {
    const proto = Object.getPrototypeOf(target);
    if (((_a2 = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a2 === void 0 ? void 0 : _a2.constructor) === Array) {
      return true;
    }
    return isTypeOfArray(proto);
  }
  return false;
}
function isArrayEqual(bytes1, bytes2) {
  if (!(bytes1 && bytes2)) {
    return false;
  }
  if (bytes1.byteLength !== bytes2.byteLength) {
    return false;
  }
  const b1 = new Uint8Array(bytes1);
  const b22 = new Uint8Array(bytes2);
  for (let i10 = 0; i10 < bytes1.byteLength; i10++) {
    if (b1[i10] !== b22[i10]) {
      return false;
    }
  }
  return true;
}
var init_helper = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/helper.js"() {
    __name(isConvertible, "isConvertible");
    __name(isTypeOfArray, "isTypeOfArray");
    __name(isArrayEqual, "isArrayEqual");
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/schema.js
var AsnSchemaStorage;
var init_schema = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/schema.js"() {
    init_index_es2();
    init_enums();
    init_helper();
    AsnSchemaStorage = class {
      static {
        __name(this, "AsnSchemaStorage");
      }
      constructor() {
        this.items = /* @__PURE__ */ new WeakMap();
      }
      has(target) {
        return this.items.has(target);
      }
      get(target, checkSchema = false) {
        const schema = this.items.get(target);
        if (!schema) {
          throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
        }
        if (checkSchema && !schema.schema) {
          throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
        }
        return schema;
      }
      cache(target) {
        const schema = this.get(target);
        if (!schema.schema) {
          schema.schema = this.create(target, true);
        }
      }
      createDefault(target) {
        const schema = {
          type: AsnTypeTypes.Sequence,
          items: {}
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
          Object.assign(schema, parentSchema);
          schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
      }
      create(target, useNames) {
        const schema = this.items.get(target) || this.createDefault(target);
        const asn1Value = [];
        for (const key in schema.items) {
          const item = schema.items[key];
          const name2 = useNames ? key : "";
          let asn1Item;
          if (typeof item.type === "number") {
            const Asn1TypeName = AsnPropTypes[item.type];
            const Asn1Type = index_es_exports[Asn1TypeName];
            if (!Asn1Type) {
              throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
            }
            asn1Item = new Asn1Type({ name: name2 });
          } else if (isConvertible(item.type)) {
            const instance = new item.type();
            asn1Item = instance.toSchema(name2);
          } else if (item.optional) {
            const itemSchema = this.get(item.type);
            if (itemSchema.type === AsnTypeTypes.Choice) {
              asn1Item = new Any({ name: name2 });
            } else {
              asn1Item = this.create(item.type, false);
              asn1Item.name = name2;
            }
          } else {
            asn1Item = new Any({ name: name2 });
          }
          const optional = !!item.optional || item.defaultValue !== void 0;
          if (item.repeated) {
            asn1Item.name = "";
            const Container = item.repeated === "set" ? Set2 : Sequence;
            asn1Item = new Container({
              name: "",
              value: [
                new Repeated({
                  name: name2,
                  value: asn1Item
                })
              ]
            });
          }
          if (item.context !== null && item.context !== void 0) {
            if (item.implicit) {
              if (typeof item.type === "number" || isConvertible(item.type)) {
                const Container = item.repeated ? Constructed : Primitive;
                asn1Value.push(new Container({
                  name: name2,
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  }
                }));
              } else {
                this.cache(item.type);
                const isRepeated = !!item.repeated;
                let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
                value = "valueBlock" in value ? value.valueBlock.value : value.value;
                asn1Value.push(new Constructed({
                  name: !isRepeated ? name2 : "",
                  optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: item.context
                  },
                  value
                }));
              }
            } else {
              asn1Value.push(new Constructed({
                optional,
                idBlock: {
                  tagClass: 3,
                  tagNumber: item.context
                },
                value: [asn1Item]
              }));
            }
          } else {
            asn1Item.optional = optional;
            asn1Value.push(asn1Item);
          }
        }
        switch (schema.type) {
          case AsnTypeTypes.Sequence:
            return new Sequence({ value: asn1Value, name: "" });
          case AsnTypeTypes.Set:
            return new Set2({ value: asn1Value, name: "" });
          case AsnTypeTypes.Choice:
            return new Choice({ value: asn1Value, name: "" });
          default:
            throw new Error(`Unsupported ASN1 type in use`);
        }
      }
      set(target, schema) {
        this.items.set(target, schema);
        return this;
      }
      findParentSchema(target) {
        const parent = Object.getPrototypeOf(target);
        if (parent) {
          const schema = this.items.get(parent);
          return schema || this.findParentSchema(parent);
        }
        return null;
      }
    };
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/storage.js
var schemaStorage;
var init_storage = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/storage.js"() {
    init_schema();
    schemaStorage = new AsnSchemaStorage();
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/decorators.js
var AsnType, AsnProp;
var init_decorators = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/decorators.js"() {
    init_converters();
    init_enums();
    init_storage();
    AsnType = /* @__PURE__ */ __name((options) => (target) => {
      let schema;
      if (!schemaStorage.has(target)) {
        schema = schemaStorage.createDefault(target);
        schemaStorage.set(target, schema);
      } else {
        schema = schemaStorage.get(target);
      }
      Object.assign(schema, options);
    }, "AsnType");
    AsnProp = /* @__PURE__ */ __name((options) => (target, propertyKey) => {
      let schema;
      if (!schemaStorage.has(target.constructor)) {
        schema = schemaStorage.createDefault(target.constructor);
        schemaStorage.set(target.constructor, schema);
      } else {
        schema = schemaStorage.get(target.constructor);
      }
      const copyOptions = Object.assign({}, options);
      if (typeof copyOptions.type === "number" && !copyOptions.converter) {
        const defaultConverter2 = defaultConverter(options.type);
        if (!defaultConverter2) {
          throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
        }
        copyOptions.converter = defaultConverter2;
      }
      schema.items[propertyKey] = copyOptions;
    }, "AsnProp");
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js
var AsnSchemaValidationError;
var init_schema_validation = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js"() {
    AsnSchemaValidationError = class extends Error {
      static {
        __name(this, "AsnSchemaValidationError");
      }
      constructor() {
        super(...arguments);
        this.schemas = [];
      }
    };
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js
var init_errors = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/errors/index.js"() {
    init_schema_validation();
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/parser.js
var AsnParser;
var init_parser = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/parser.js"() {
    init_index_es2();
    init_enums();
    init_converters();
    init_errors();
    init_helper();
    init_storage();
    AsnParser = class {
      static {
        __name(this, "AsnParser");
      }
      static parse(data, target) {
        const asn1Parsed = fromBER(data);
        if (asn1Parsed.result.error) {
          throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target);
        return res;
      }
      static fromASN(asn1Schema, target) {
        var _a2;
        try {
          if (isConvertible(target)) {
            const value = new target();
            return value.fromASN(asn1Schema);
          }
          const schema = schemaStorage.get(target);
          schemaStorage.cache(target);
          let targetSchema = schema.schema;
          if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {
            targetSchema = new Constructed({
              idBlock: {
                tagClass: 3,
                tagNumber: asn1Schema.idBlock.tagNumber
              },
              value: schema.schema.valueBlock.value
            });
            for (const key in schema.items) {
              delete asn1Schema[key];
            }
          }
          const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);
          if (!asn1ComparedSchema.verified) {
            throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
          }
          const res = new target();
          if (isTypeOfArray(target)) {
            if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
              throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
            }
            const itemType = schema.itemType;
            if (typeof itemType === "number") {
              const converter = defaultConverter(itemType);
              if (!converter) {
                throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
              }
              return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));
            } else {
              return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));
            }
          }
          for (const key in schema.items) {
            const asn1SchemaValue = asn1ComparedSchema.result[key];
            if (!asn1SchemaValue) {
              continue;
            }
            const schemaItem = schema.items[key];
            const schemaItemType = schemaItem.type;
            if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {
              const converter = (_a2 = schemaItem.converter) !== null && _a2 !== void 0 ? _a2 : isConvertible(schemaItemType) ? new schemaItemType() : null;
              if (!converter) {
                throw new Error("Converter is empty");
              }
              if (schemaItem.repeated) {
                if (schemaItem.implicit) {
                  const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
                  const newItem = new Container();
                  newItem.valueBlock = asn1SchemaValue.valueBlock;
                  const newItemAsn = fromBER(newItem.toBER(false));
                  if (newItemAsn.offset === -1) {
                    throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
                  }
                  if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {
                    throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
                  }
                  const value = newItemAsn.result.valueBlock.value;
                  res[key] = Array.from(value, (element) => converter.fromASN(element));
                } else {
                  res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));
                }
              } else {
                let value = asn1SchemaValue;
                if (schemaItem.implicit) {
                  let newItem;
                  if (isConvertible(schemaItemType)) {
                    newItem = new schemaItemType().toSchema("");
                  } else {
                    const Asn1TypeName = AsnPropTypes[schemaItemType];
                    const Asn1Type = index_es_exports[Asn1TypeName];
                    if (!Asn1Type) {
                      throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                    }
                    newItem = new Asn1Type();
                  }
                  newItem.valueBlock = value.valueBlock;
                  value = fromBER(newItem.toBER(false)).result;
                }
                res[key] = converter.fromASN(value);
              }
            } else {
              if (schemaItem.repeated) {
                if (!Array.isArray(asn1SchemaValue)) {
                  throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
                }
                res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));
              } else {
                res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
              }
            }
          }
          return res;
        } catch (error) {
          if (error instanceof AsnSchemaValidationError) {
            error.schemas.push(target.name);
          }
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/serializer.js
var AsnSerializer;
var init_serializer = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/serializer.js"() {
    init_index_es2();
    init_converters();
    init_enums();
    init_helper();
    init_storage();
    AsnSerializer = class _AsnSerializer {
      static {
        __name(this, "AsnSerializer");
      }
      static serialize(obj) {
        if (obj instanceof BaseBlock) {
          return obj.toBER(false);
        }
        return this.toASN(obj).toBER(false);
      }
      static toASN(obj) {
        if (obj && typeof obj === "object" && isConvertible(obj)) {
          return obj.toASN();
        }
        if (!(obj && typeof obj === "object")) {
          throw new TypeError("Parameter 1 should be type of Object.");
        }
        const target = obj.constructor;
        const schema = schemaStorage.get(target);
        schemaStorage.cache(target);
        let asn1Value = [];
        if (schema.itemType) {
          if (!Array.isArray(obj)) {
            throw new TypeError("Parameter 1 should be type of Array.");
          }
          if (typeof schema.itemType === "number") {
            const converter = defaultConverter(schema.itemType);
            if (!converter) {
              throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
            }
            asn1Value = obj.map((o10) => converter.toASN(o10));
          } else {
            asn1Value = obj.map((o10) => this.toAsnItem({ type: schema.itemType }, "[]", target, o10));
          }
        } else {
          for (const key in schema.items) {
            const schemaItem = schema.items[key];
            const objProp = obj[key];
            if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
              continue;
            }
            const asn1Item = _AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
            if (typeof schemaItem.context === "number") {
              if (schemaItem.implicit) {
                if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {
                  const value = {};
                  value.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
                  asn1Value.push(new Primitive({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    ...value
                  }));
                } else {
                  asn1Value.push(new Constructed({
                    optional: schemaItem.optional,
                    idBlock: {
                      tagClass: 3,
                      tagNumber: schemaItem.context
                    },
                    value: asn1Item.valueBlock.value
                  }));
                }
              } else {
                asn1Value.push(new Constructed({
                  optional: schemaItem.optional,
                  idBlock: {
                    tagClass: 3,
                    tagNumber: schemaItem.context
                  },
                  value: [asn1Item]
                }));
              }
            } else if (schemaItem.repeated) {
              asn1Value = asn1Value.concat(asn1Item);
            } else {
              asn1Value.push(asn1Item);
            }
          }
        }
        let asnSchema;
        switch (schema.type) {
          case AsnTypeTypes.Sequence:
            asnSchema = new Sequence({ value: asn1Value });
            break;
          case AsnTypeTypes.Set:
            asnSchema = new Set2({ value: asn1Value });
            break;
          case AsnTypeTypes.Choice:
            if (!asn1Value[0]) {
              throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
            }
            asnSchema = asn1Value[0];
            break;
        }
        return asnSchema;
      }
      static toAsnItem(schemaItem, key, target, objProp) {
        let asn1Item;
        if (typeof schemaItem.type === "number") {
          const converter = schemaItem.converter;
          if (!converter) {
            throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
          }
          if (schemaItem.repeated) {
            if (!Array.isArray(objProp)) {
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            }
            const items = Array.from(objProp, (element) => converter.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = converter.toASN(objProp);
          }
        } else {
          if (schemaItem.repeated) {
            if (!Array.isArray(objProp)) {
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            }
            const items = Array.from(objProp, (element) => this.toASN(element));
            const Container = schemaItem.repeated === "sequence" ? Sequence : Set2;
            asn1Item = new Container({
              value: items
            });
          } else {
            asn1Item = this.toASN(objProp);
          }
        }
        return asn1Item;
      }
    };
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/objects.js
var init_objects = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/objects.js"() {
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/convert.js
var AsnConvert;
var init_convert = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/convert.js"() {
    init_index_es2();
    init_index_es();
    init_parser();
    init_serializer();
    AsnConvert = class _AsnConvert {
      static {
        __name(this, "AsnConvert");
      }
      static serialize(obj) {
        return AsnSerializer.serialize(obj);
      }
      static parse(data, target) {
        return AsnParser.parse(data, target);
      }
      static toString(data) {
        const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : _AsnConvert.serialize(data);
        const asn = fromBER(buf);
        if (asn.offset === -1) {
          throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
        }
        return asn.result.toString();
      }
    };
  }
});

// ../../node_modules/@peculiar/asn1-schema/build/es2015/index.js
var init_es2015 = __esm({
  "../../node_modules/@peculiar/asn1-schema/build/es2015/index.js"() {
    init_converters();
    init_types();
    init_decorators();
    init_enums();
    init_parser();
    init_serializer();
    init_errors();
    init_objects();
    init_convert();
  }
});

// ../../node_modules/tslib/tslib.es6.mjs
function __decorate2(decorators, target, key, desc2) {
  var c11 = arguments.length, r10 = c11 < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d10;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r10 = Reflect.decorate(decorators, target, key, desc2);
  else
    for (var i10 = decorators.length - 1; i10 >= 0; i10--)
      if (d10 = decorators[i10])
        r10 = (c11 < 3 ? d10(r10) : c11 > 3 ? d10(target, key, r10) : d10(target, key)) || r10;
  return c11 > 3 && r10 && Object.defineProperty(target, key, r10), r10;
}
var __assign2;
var init_tslib_es62 = __esm({
  "../../node_modules/tslib/tslib.es6.mjs"() {
    __assign2 = /* @__PURE__ */ __name(function() {
      __assign2 = Object.assign || /* @__PURE__ */ __name(function __assign3(t6) {
        for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
          s10 = arguments[i10];
          for (var p11 in s10)
            if (Object.prototype.hasOwnProperty.call(s10, p11))
              t6[p11] = s10[p11];
        }
        return t6;
      }, "__assign");
      return __assign2.apply(this, arguments);
    }, "__assign");
    __name(__decorate2, "__decorate");
  }
});

// ../../node_modules/@peculiar/json-schema/build/index.es.js
function checkType(value, type) {
  switch (type) {
    case JsonPropTypes.Boolean:
      return typeof value === "boolean";
    case JsonPropTypes.Number:
      return typeof value === "number";
    case JsonPropTypes.String:
      return typeof value === "string";
  }
  return true;
}
function throwIfTypeIsWrong(value, type) {
  if (!checkType(value, type)) {
    throw new TypeError(`Value must be ${JsonPropTypes[type]}`);
  }
}
function isConvertible2(target) {
  if (target && target.prototype) {
    if (target.prototype.toJSON && target.prototype.fromJSON) {
      return true;
    } else {
      return isConvertible2(target.prototype);
    }
  } else {
    return !!(target && target.toJSON && target.fromJSON);
  }
}
function getValidations(item) {
  const validations = [];
  if (item.pattern) {
    validations.push(new PatternValidation(item.pattern));
  }
  if (item.type === JsonPropTypes.Number || item.type === JsonPropTypes.Any) {
    if (item.minInclusive !== void 0 || item.maxInclusive !== void 0) {
      validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));
    }
    if (item.minExclusive !== void 0 || item.maxExclusive !== void 0) {
      validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));
    }
    if (item.enumeration !== void 0) {
      validations.push(new EnumerationValidation(item.enumeration));
    }
  }
  if (item.type === JsonPropTypes.String || item.repeated || item.type === JsonPropTypes.Any) {
    if (item.length !== void 0 || item.minLength !== void 0 || item.maxLength !== void 0) {
      validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));
    }
  }
  return validations;
}
var JsonError, TransformError, ParserError, ValidationError, SerializerError, KeyError, JsonPropTypes, JsonSchemaStorage, DEFAULT_SCHEMA, schemaStorage2, PatternValidation, InclusiveValidation, ExclusiveValidation, LengthValidation, EnumerationValidation, JsonTransform, JsonSerializer, JsonParser, JsonProp;
var init_index_es3 = __esm({
  "../../node_modules/@peculiar/json-schema/build/index.es.js"() {
    JsonError = class extends Error {
      static {
        __name(this, "JsonError");
      }
      constructor(message, innerError) {
        super(innerError ? `${message}. See the inner exception for more details.` : message);
        this.message = message;
        this.innerError = innerError;
      }
    };
    TransformError = class extends JsonError {
      static {
        __name(this, "TransformError");
      }
      constructor(schema, message, innerError) {
        super(message, innerError);
        this.schema = schema;
      }
    };
    ParserError = class extends TransformError {
      static {
        __name(this, "ParserError");
      }
      constructor(schema, message, innerError) {
        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);
      }
    };
    ValidationError = class extends JsonError {
      static {
        __name(this, "ValidationError");
      }
    };
    SerializerError = class extends JsonError {
      static {
        __name(this, "SerializerError");
      }
      constructor(schemaName, message, innerError) {
        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);
        this.schemaName = schemaName;
      }
    };
    KeyError = class extends ParserError {
      static {
        __name(this, "KeyError");
      }
      constructor(schema, keys, errors = {}) {
        super(schema, "Some keys doesn't match to schema");
        this.keys = keys;
        this.errors = errors;
      }
    };
    (function(JsonPropTypes2) {
      JsonPropTypes2[JsonPropTypes2["Any"] = 0] = "Any";
      JsonPropTypes2[JsonPropTypes2["Boolean"] = 1] = "Boolean";
      JsonPropTypes2[JsonPropTypes2["Number"] = 2] = "Number";
      JsonPropTypes2[JsonPropTypes2["String"] = 3] = "String";
    })(JsonPropTypes || (JsonPropTypes = {}));
    __name(checkType, "checkType");
    __name(throwIfTypeIsWrong, "throwIfTypeIsWrong");
    __name(isConvertible2, "isConvertible");
    JsonSchemaStorage = class {
      static {
        __name(this, "JsonSchemaStorage");
      }
      constructor() {
        this.items = /* @__PURE__ */ new Map();
      }
      has(target) {
        return this.items.has(target) || !!this.findParentSchema(target);
      }
      get(target) {
        const schema = this.items.get(target) || this.findParentSchema(target);
        if (!schema) {
          throw new Error("Cannot get schema for current target");
        }
        return schema;
      }
      create(target) {
        const schema = { names: {} };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
          Object.assign(schema, parentSchema);
          schema.names = {};
          for (const name2 in parentSchema.names) {
            schema.names[name2] = Object.assign({}, parentSchema.names[name2]);
          }
        }
        schema.target = target;
        return schema;
      }
      set(target, schema) {
        this.items.set(target, schema);
        return this;
      }
      findParentSchema(target) {
        const parent = target.__proto__;
        if (parent) {
          const schema = this.items.get(parent);
          return schema || this.findParentSchema(parent);
        }
        return null;
      }
    };
    DEFAULT_SCHEMA = "default";
    schemaStorage2 = new JsonSchemaStorage();
    PatternValidation = class {
      static {
        __name(this, "PatternValidation");
      }
      constructor(pattern) {
        this.pattern = new RegExp(pattern);
      }
      validate(value) {
        const pattern = new RegExp(this.pattern.source, this.pattern.flags);
        if (typeof value !== "string") {
          throw new ValidationError("Incoming value must be string");
        }
        if (!pattern.exec(value)) {
          throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);
        }
      }
    };
    InclusiveValidation = class {
      static {
        __name(this, "InclusiveValidation");
      }
      constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
        this.min = min;
        this.max = max;
      }
      validate(value) {
        throwIfTypeIsWrong(value, JsonPropTypes.Number);
        if (!(this.min <= value && value <= this.max)) {
          const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
          const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
          throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);
        }
      }
    };
    ExclusiveValidation = class {
      static {
        __name(this, "ExclusiveValidation");
      }
      constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
        this.min = min;
        this.max = max;
      }
      validate(value) {
        throwIfTypeIsWrong(value, JsonPropTypes.Number);
        if (!(this.min < value && value < this.max)) {
          const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
          const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
          throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);
        }
      }
    };
    LengthValidation = class {
      static {
        __name(this, "LengthValidation");
      }
      constructor(length, minLength, maxLength) {
        this.length = length;
        this.minLength = minLength;
        this.maxLength = maxLength;
      }
      validate(value) {
        if (this.length !== void 0) {
          if (value.length !== this.length) {
            throw new ValidationError(`Value length must be exactly ${this.length}.`);
          }
          return;
        }
        if (this.minLength !== void 0) {
          if (value.length < this.minLength) {
            throw new ValidationError(`Value length must be more than ${this.minLength}.`);
          }
        }
        if (this.maxLength !== void 0) {
          if (value.length > this.maxLength) {
            throw new ValidationError(`Value length must be less than ${this.maxLength}.`);
          }
        }
      }
    };
    EnumerationValidation = class {
      static {
        __name(this, "EnumerationValidation");
      }
      constructor(enumeration) {
        this.enumeration = enumeration;
      }
      validate(value) {
        throwIfTypeIsWrong(value, JsonPropTypes.String);
        if (!this.enumeration.includes(value)) {
          throw new ValidationError(`Value must be one of ${this.enumeration.map((v7) => `'${v7}'`).join(", ")}`);
        }
      }
    };
    JsonTransform = class {
      static {
        __name(this, "JsonTransform");
      }
      static checkValues(data, schemaItem) {
        const values = Array.isArray(data) ? data : [data];
        for (const value of values) {
          for (const validation of schemaItem.validations) {
            if (validation instanceof LengthValidation && schemaItem.repeated) {
              validation.validate(data);
            } else {
              validation.validate(value);
            }
          }
        }
      }
      static checkTypes(value, schemaItem) {
        if (schemaItem.repeated && !Array.isArray(value)) {
          throw new TypeError("Value must be Array");
        }
        if (typeof schemaItem.type === "number") {
          const values = Array.isArray(value) ? value : [value];
          for (const v7 of values) {
            throwIfTypeIsWrong(v7, schemaItem.type);
          }
        }
      }
      static getSchemaByName(schema, name2 = DEFAULT_SCHEMA) {
        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name2] };
      }
    };
    JsonSerializer = class extends JsonTransform {
      static {
        __name(this, "JsonSerializer");
      }
      static serialize(obj, options, replacer, space) {
        const json2 = this.toJSON(obj, options);
        return JSON.stringify(json2, replacer, space);
      }
      static toJSON(obj, options = {}) {
        let res;
        let targetSchema = options.targetSchema;
        const schemaName = options.schemaName || DEFAULT_SCHEMA;
        if (isConvertible2(obj)) {
          return obj.toJSON();
        }
        if (Array.isArray(obj)) {
          res = [];
          for (const item of obj) {
            res.push(this.toJSON(item, options));
          }
        } else if (typeof obj === "object") {
          if (targetSchema && !schemaStorage2.has(targetSchema)) {
            throw new JsonError("Cannot get schema for `targetSchema` param");
          }
          targetSchema = targetSchema || obj.constructor;
          if (schemaStorage2.has(targetSchema)) {
            const schema = schemaStorage2.get(targetSchema);
            res = {};
            const namedSchema = this.getSchemaByName(schema, schemaName);
            for (const key in namedSchema) {
              try {
                const item = namedSchema[key];
                const objItem = obj[key];
                let value;
                if (item.optional && objItem === void 0 || item.defaultValue !== void 0 && objItem === item.defaultValue) {
                  continue;
                }
                if (!item.optional && objItem === void 0) {
                  throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);
                }
                if (typeof item.type === "number") {
                  if (item.converter) {
                    if (item.repeated) {
                      value = objItem.map((el) => item.converter.toJSON(el, obj));
                    } else {
                      value = item.converter.toJSON(objItem, obj);
                    }
                  } else {
                    value = objItem;
                  }
                } else {
                  if (item.repeated) {
                    value = objItem.map((el) => this.toJSON(el, { schemaName }));
                  } else {
                    value = this.toJSON(objItem, { schemaName });
                  }
                }
                this.checkTypes(value, item);
                this.checkValues(value, item);
                res[item.name || key] = value;
              } catch (e10) {
                if (e10 instanceof SerializerError) {
                  throw e10;
                } else {
                  throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e10.message}`, e10);
                }
              }
            }
          } else {
            res = {};
            for (const key in obj) {
              res[key] = this.toJSON(obj[key], { schemaName });
            }
          }
        } else {
          res = obj;
        }
        return res;
      }
    };
    JsonParser = class _JsonParser extends JsonTransform {
      static {
        __name(this, "JsonParser");
      }
      static parse(data, options) {
        const obj = JSON.parse(data);
        return this.fromJSON(obj, options);
      }
      static fromJSON(target, options) {
        const targetSchema = options.targetSchema;
        const schemaName = options.schemaName || DEFAULT_SCHEMA;
        const obj = new targetSchema();
        if (isConvertible2(obj)) {
          return obj.fromJSON(target);
        }
        const schema = schemaStorage2.get(targetSchema);
        const namedSchema = this.getSchemaByName(schema, schemaName);
        const keyErrors = {};
        if (options.strictProperty && !Array.isArray(target)) {
          _JsonParser.checkStrictProperty(target, namedSchema, schema);
        }
        for (const key in namedSchema) {
          try {
            const item = namedSchema[key];
            const name2 = item.name || key;
            const value = target[name2];
            if (value === void 0 && (item.optional || item.defaultValue !== void 0)) {
              continue;
            }
            if (!item.optional && value === void 0) {
              throw new ParserError(schema, `Property '${name2}' is required.`);
            }
            this.checkTypes(value, item);
            this.checkValues(value, item);
            if (typeof item.type === "number") {
              if (item.converter) {
                if (item.repeated) {
                  obj[key] = value.map((el) => item.converter.fromJSON(el, obj));
                } else {
                  obj[key] = item.converter.fromJSON(value, obj);
                }
              } else {
                obj[key] = value;
              }
            } else {
              const newOptions = {
                ...options,
                targetSchema: item.type,
                schemaName
              };
              if (item.repeated) {
                obj[key] = value.map((el) => this.fromJSON(el, newOptions));
              } else {
                obj[key] = this.fromJSON(value, newOptions);
              }
            }
          } catch (e10) {
            if (!(e10 instanceof ParserError)) {
              e10 = new ParserError(schema, `Property '${key}' is wrong. ${e10.message}`, e10);
            }
            if (options.strictAllKeys) {
              keyErrors[key] = e10;
            } else {
              throw e10;
            }
          }
        }
        const keys = Object.keys(keyErrors);
        if (keys.length) {
          throw new KeyError(schema, keys, keyErrors);
        }
        return obj;
      }
      static checkStrictProperty(target, namedSchema, schema) {
        const jsonProps = Object.keys(target);
        const schemaProps = Object.keys(namedSchema);
        const keys = [];
        for (const key of jsonProps) {
          if (schemaProps.indexOf(key) === -1) {
            keys.push(key);
          }
        }
        if (keys.length) {
          throw new KeyError(schema, keys);
        }
      }
    };
    __name(getValidations, "getValidations");
    JsonProp = /* @__PURE__ */ __name((options = {}) => (target, propertyKey) => {
      const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;
      let schema;
      if (!schemaStorage2.has(target.constructor)) {
        schema = schemaStorage2.create(target.constructor);
        schemaStorage2.set(target.constructor, schema);
      } else {
        schema = schemaStorage2.get(target.constructor);
        if (schema.target !== target.constructor) {
          schema = schemaStorage2.create(target.constructor);
          schemaStorage2.set(target.constructor, schema);
        }
      }
      const defaultSchema = {
        type: JsonPropTypes.Any,
        validations: []
      };
      const copyOptions = Object.assign(defaultSchema, options);
      copyOptions.validations = getValidations(copyOptions);
      if (typeof copyOptions.type !== "number") {
        if (!schemaStorage2.has(copyOptions.type) && !isConvertible2(copyOptions.type)) {
          throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);
        }
      }
      let schemaNames;
      if (Array.isArray(options.schema)) {
        schemaNames = options.schema;
      } else {
        schemaNames = [options.schema || DEFAULT_SCHEMA];
      }
      for (const schemaName of schemaNames) {
        if (!schema.names[schemaName]) {
          schema.names[schemaName] = {};
        }
        const namedSchema = schema.names[schemaName];
        namedSchema[propertyKey] = copyOptions;
      }
    }, "JsonProp");
  }
});

// ../../node_modules/webcrypto-core/build/webcrypto-core.es.js
function isJWK(data) {
  return typeof data === "object" && "kty" in data;
}
var CryptoError, AlgorithmError, UnsupportedOperationError, OperationError, RequiredPropertyError, ProviderCrypto, AesProvider, AesCbcProvider, AesCmacProvider, AesCtrProvider, AesEcbProvider, AesGcmProvider, AesKwProvider, DesProvider, RsaProvider, RsaSsaProvider, RsaPssProvider, RsaOaepProvider, EllipticProvider, EcdsaProvider, KEY_TYPES, CryptoKey, EcdhProvider, EcdhEsProvider, EdDsaProvider, ObjectIdentifier2, AlgorithmIdentifier, PrivateKeyInfo, PublicKeyInfo, JsonBase64UrlArrayBufferConverter, AsnIntegerArrayBufferConverter, RsaPrivateKey, RsaPublicKey, EcPublicKey, EcPrivateKey, AsnIntegerWithoutPaddingConverter, index$2, EcUtils, EcDsaSignature, OneAsymmetricKey, EdPrivateKey, EdPublicKey, CurvePrivateKey, idSecp256r1, idEllipticCurve, idSecp384r1, idSecp521r1, idSecp256k1, idVersionOne, idBrainpoolP160r1, idBrainpoolP160t1, idBrainpoolP192r1, idBrainpoolP192t1, idBrainpoolP224r1, idBrainpoolP224t1, idBrainpoolP256r1, idBrainpoolP256t1, idBrainpoolP320r1, idBrainpoolP320t1, idBrainpoolP384r1, idBrainpoolP384t1, idBrainpoolP512r1, idBrainpoolP512t1, idX25519, idX448, idEd25519, idEd448, index$1, EcCurves, HmacProvider, Pbkdf2Provider, HkdfProvider, ShakeProvider, Shake128Provider, Shake256Provider, Crypto, ProviderStorage, SubtleCrypto;
var init_webcrypto_core_es = __esm({
  "../../node_modules/webcrypto-core/build/webcrypto-core.es.js"() {
    init_index_es();
    init_index_es();
    init_es2015();
    init_tslib_es62();
    init_index_es3();
    init_index_es2();
    CryptoError = class extends Error {
      static {
        __name(this, "CryptoError");
      }
    };
    AlgorithmError = class extends CryptoError {
      static {
        __name(this, "AlgorithmError");
      }
    };
    UnsupportedOperationError = class extends CryptoError {
      static {
        __name(this, "UnsupportedOperationError");
      }
      constructor(methodName) {
        super(`Unsupported operation: ${methodName ? `${methodName}` : ""}`);
      }
    };
    OperationError = class extends CryptoError {
      static {
        __name(this, "OperationError");
      }
    };
    RequiredPropertyError = class extends CryptoError {
      static {
        __name(this, "RequiredPropertyError");
      }
      constructor(propName) {
        super(`${propName}: Missing required property`);
      }
    };
    __name(isJWK, "isJWK");
    ProviderCrypto = class {
      static {
        __name(this, "ProviderCrypto");
      }
      async digest(...args) {
        this.checkDigest.apply(this, args);
        return this.onDigest.apply(this, args);
      }
      checkDigest(algorithm, data) {
        this.checkAlgorithmName(algorithm);
      }
      async onDigest(algorithm, data) {
        throw new UnsupportedOperationError("digest");
      }
      async generateKey(...args) {
        this.checkGenerateKey.apply(this, args);
        return this.onGenerateKey.apply(this, args);
      }
      checkGenerateKey(algorithm, extractable, keyUsages, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkGenerateKeyParams(algorithm);
        if (!(keyUsages && keyUsages.length)) {
          throw new TypeError(`Usages cannot be empty when creating a key.`);
        }
        let allowedUsages;
        if (Array.isArray(this.usages)) {
          allowedUsages = this.usages;
        } else {
          allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);
        }
        this.checkKeyUsages(keyUsages, allowedUsages);
      }
      checkGenerateKeyParams(algorithm) {
      }
      async onGenerateKey(algorithm, extractable, keyUsages, ...args) {
        throw new UnsupportedOperationError("generateKey");
      }
      async sign(...args) {
        this.checkSign.apply(this, args);
        return this.onSign.apply(this, args);
      }
      checkSign(algorithm, key, data, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, "sign");
      }
      async onSign(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("sign");
      }
      async verify(...args) {
        this.checkVerify.apply(this, args);
        return this.onVerify.apply(this, args);
      }
      checkVerify(algorithm, key, signature, data, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, "verify");
      }
      async onVerify(algorithm, key, signature, data, ...args) {
        throw new UnsupportedOperationError("verify");
      }
      async encrypt(...args) {
        this.checkEncrypt.apply(this, args);
        return this.onEncrypt.apply(this, args);
      }
      checkEncrypt(algorithm, key, data, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? "encrypt" : void 0);
      }
      async onEncrypt(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("encrypt");
      }
      async decrypt(...args) {
        this.checkDecrypt.apply(this, args);
        return this.onDecrypt.apply(this, args);
      }
      checkDecrypt(algorithm, key, data, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? "decrypt" : void 0);
      }
      async onDecrypt(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("decrypt");
      }
      async deriveBits(...args) {
        this.checkDeriveBits.apply(this, args);
        return this.onDeriveBits.apply(this, args);
      }
      checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(baseKey, options.keyUsage ? "deriveBits" : void 0);
        if (length % 8 !== 0) {
          throw new OperationError("length: Is not multiple of 8");
        }
      }
      async onDeriveBits(algorithm, baseKey, length, ...args) {
        throw new UnsupportedOperationError("deriveBits");
      }
      async exportKey(...args) {
        this.checkExportKey.apply(this, args);
        return this.onExportKey.apply(this, args);
      }
      checkExportKey(format, key, ...args) {
        this.checkKeyFormat(format);
        this.checkCryptoKey(key);
        if (!key.extractable) {
          throw new CryptoError("key: Is not extractable");
        }
      }
      async onExportKey(format, key, ...args) {
        throw new UnsupportedOperationError("exportKey");
      }
      async importKey(...args) {
        this.checkImportKey.apply(this, args);
        return this.onImportKey.apply(this, args);
      }
      checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        this.checkKeyFormat(format);
        this.checkKeyData(format, keyData);
        this.checkAlgorithmName(algorithm);
        this.checkImportParams(algorithm);
        if (Array.isArray(this.usages)) {
          this.checkKeyUsages(keyUsages, this.usages);
        }
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        throw new UnsupportedOperationError("importKey");
      }
      checkAlgorithmName(algorithm) {
        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {
          throw new AlgorithmError("Unrecognized name");
        }
      }
      checkAlgorithmParams(algorithm) {
      }
      checkDerivedKeyParams(algorithm) {
      }
      checkKeyUsages(usages, allowed) {
        for (const usage of usages) {
          if (allowed.indexOf(usage) === -1) {
            throw new TypeError("Cannot create a key using the specified key usages");
          }
        }
      }
      checkCryptoKey(key, keyUsage) {
        this.checkAlgorithmName(key.algorithm);
        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {
          throw new CryptoError(`key does not match that of operation`);
        }
      }
      checkRequiredProperty(data, propName) {
        if (!(propName in data)) {
          throw new RequiredPropertyError(propName);
        }
      }
      checkHashAlgorithm(algorithm, hashAlgorithms) {
        for (const item of hashAlgorithms) {
          if (item.toLowerCase() === algorithm.name.toLowerCase()) {
            return;
          }
        }
        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(", ")}`);
      }
      checkImportParams(algorithm) {
      }
      checkKeyFormat(format) {
        switch (format) {
          case "raw":
          case "pkcs8":
          case "spki":
          case "jwk":
            break;
          default:
            throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'");
        }
      }
      checkKeyData(format, keyData) {
        if (!keyData) {
          throw new TypeError("keyData: Cannot be empty on empty on key importing");
        }
        if (format === "jwk") {
          if (!isJWK(keyData)) {
            throw new TypeError("keyData: Is not JsonWebToken");
          }
        } else if (!BufferSourceConverter.isBufferSource(keyData)) {
          throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");
        }
      }
      prepareData(data) {
        return BufferSourceConverter.toArrayBuffer(data);
      }
    };
    AesProvider = class extends ProviderCrypto {
      static {
        __name(this, "AesProvider");
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not of type Number");
        }
        switch (algorithm.length) {
          case 128:
          case 192:
          case 256:
            break;
          default:
            throw new TypeError("length: Must be 128, 192, or 256");
        }
      }
      checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
      }
    };
    AesCbcProvider = class extends AesProvider {
      static {
        __name(this, "AesCbcProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "AES-CBC";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "iv");
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
          throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.iv.byteLength !== 16) {
          throw new TypeError("iv: Must have length 16 bytes");
        }
      }
    };
    AesCmacProvider = class extends AesProvider {
      static {
        __name(this, "AesCmacProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "AES-CMAC";
        this.usages = ["sign", "verify"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not a Number");
        }
        if (algorithm.length < 1) {
          throw new OperationError("length: Must be more than 0");
        }
      }
    };
    AesCtrProvider = class extends AesProvider {
      static {
        __name(this, "AesCtrProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "AES-CTR";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "counter");
        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {
          throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.counter.byteLength !== 16) {
          throw new TypeError("iv: Must have length 16 bytes");
        }
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not a Number");
        }
        if (algorithm.length < 1) {
          throw new OperationError("length: Must be more than 0");
        }
      }
    };
    AesEcbProvider = class extends AesProvider {
      static {
        __name(this, "AesEcbProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "AES-ECB";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
    };
    AesGcmProvider = class extends AesProvider {
      static {
        __name(this, "AesGcmProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "AES-GCM";
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "iv");
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
          throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.iv.byteLength < 1) {
          throw new OperationError("iv: Must have length more than 0 and less than 2^64 - 1");
        }
        if (!("tagLength" in algorithm)) {
          algorithm.tagLength = 128;
        }
        switch (algorithm.tagLength) {
          case 32:
          case 64:
          case 96:
          case 104:
          case 112:
          case 120:
          case 128:
            break;
          default:
            throw new OperationError("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128");
        }
      }
    };
    AesKwProvider = class extends AesProvider {
      static {
        __name(this, "AesKwProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "AES-KW";
        this.usages = ["wrapKey", "unwrapKey"];
      }
    };
    DesProvider = class extends ProviderCrypto {
      static {
        __name(this, "DesProvider");
      }
      constructor() {
        super(...arguments);
        this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
      }
      checkAlgorithmParams(algorithm) {
        if (this.ivSize) {
          this.checkRequiredProperty(algorithm, "iv");
          if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
            throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
          }
          if (algorithm.iv.byteLength !== this.ivSize) {
            throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);
          }
        }
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
          throw new TypeError("length: Is not of type Number");
        }
        if (algorithm.length !== this.keySizeBits) {
          throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);
        }
      }
      checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
      }
    };
    RsaProvider = class extends ProviderCrypto {
      static {
        __name(this, "RsaProvider");
      }
      constructor() {
        super(...arguments);
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "publicExponent");
        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
          throw new TypeError("publicExponent: Missing or not a Uint8Array");
        }
        const publicExponent = Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
          throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
        }
        this.checkRequiredProperty(algorithm, "modulusLength");
        if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {
          throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384");
        }
      }
      checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
      }
    };
    RsaSsaProvider = class extends RsaProvider {
      static {
        __name(this, "RsaSsaProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "RSASSA-PKCS1-v1_5";
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
      }
    };
    RsaPssProvider = class extends RsaProvider {
      static {
        __name(this, "RsaPssProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "RSA-PSS";
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "saltLength");
        if (typeof algorithm.saltLength !== "number") {
          throw new TypeError("saltLength: Is not a Number");
        }
        if (algorithm.saltLength < 0) {
          throw new RangeError("saltLength: Must be positive number");
        }
      }
    };
    RsaOaepProvider = class extends RsaProvider {
      static {
        __name(this, "RsaOaepProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "RSA-OAEP";
        this.usages = {
          privateKey: ["decrypt", "unwrapKey"],
          publicKey: ["encrypt", "wrapKey"]
        };
      }
      checkAlgorithmParams(algorithm) {
        if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {
          throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
      }
    };
    EllipticProvider = class extends ProviderCrypto {
      static {
        __name(this, "EllipticProvider");
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "namedCurve");
        this.checkNamedCurve(algorithm.namedCurve);
      }
      checkNamedCurve(namedCurve) {
        for (const item of this.namedCurves) {
          if (item.toLowerCase() === namedCurve.toLowerCase()) {
            return;
          }
        }
        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`);
      }
    };
    EcdsaProvider = class extends EllipticProvider {
      static {
        __name(this, "EcdsaProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "ECDSA";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
      }
    };
    KEY_TYPES = ["secret", "private", "public"];
    CryptoKey = class {
      static {
        __name(this, "CryptoKey");
      }
      static create(algorithm, type, extractable, usages) {
        const key = new this();
        key.algorithm = algorithm;
        key.type = type;
        key.extractable = extractable;
        key.usages = usages;
        return key;
      }
      static isKeyType(data) {
        return KEY_TYPES.indexOf(data) !== -1;
      }
      get [Symbol.toStringTag]() {
        return "CryptoKey";
      }
    };
    EcdhProvider = class extends EllipticProvider {
      static {
        __name(this, "EcdhProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "ECDH";
        this.usages = {
          privateKey: ["deriveBits", "deriveKey"],
          publicKey: []
        };
        this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "public");
        if (!(algorithm.public instanceof CryptoKey)) {
          throw new TypeError("public: Is not a CryptoKey");
        }
        if (algorithm.public.type !== "public") {
          throw new OperationError("public: Is not a public key");
        }
        if (algorithm.public.algorithm.name !== this.name) {
          throw new OperationError(`public: Is not ${this.name} key`);
        }
      }
    };
    EcdhEsProvider = class extends EcdhProvider {
      static {
        __name(this, "EcdhEsProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "ECDH-ES";
        this.namedCurves = ["X25519", "X448"];
      }
    };
    EdDsaProvider = class extends EllipticProvider {
      static {
        __name(this, "EdDsaProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "EdDSA";
        this.usages = {
          privateKey: ["sign"],
          publicKey: ["verify"]
        };
        this.namedCurves = ["Ed25519", "Ed448"];
      }
    };
    ObjectIdentifier2 = class ObjectIdentifier3 {
      static {
        __name(this, "ObjectIdentifier");
      }
      constructor(value) {
        if (value) {
          this.value = value;
        }
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.ObjectIdentifier })
    ], ObjectIdentifier2.prototype, "value", void 0);
    ObjectIdentifier2 = __decorate2([
      AsnType({ type: AsnTypeTypes.Choice })
    ], ObjectIdentifier2);
    AlgorithmIdentifier = class {
      static {
        __name(this, "AlgorithmIdentifier");
      }
      constructor(params) {
        Object.assign(this, params);
      }
    };
    __decorate2([
      AsnProp({
        type: AsnPropTypes.ObjectIdentifier
      })
    ], AlgorithmIdentifier.prototype, "algorithm", void 0);
    __decorate2([
      AsnProp({
        type: AsnPropTypes.Any,
        optional: true
      })
    ], AlgorithmIdentifier.prototype, "parameters", void 0);
    PrivateKeyInfo = class {
      static {
        __name(this, "PrivateKeyInfo");
      }
      constructor() {
        this.version = 0;
        this.privateKeyAlgorithm = new AlgorithmIdentifier();
        this.privateKey = new ArrayBuffer(0);
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer })
    ], PrivateKeyInfo.prototype, "version", void 0);
    __decorate2([
      AsnProp({ type: AlgorithmIdentifier })
    ], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.OctetString })
    ], PrivateKeyInfo.prototype, "privateKey", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Any, optional: true })
    ], PrivateKeyInfo.prototype, "attributes", void 0);
    PublicKeyInfo = class {
      static {
        __name(this, "PublicKeyInfo");
      }
      constructor() {
        this.publicKeyAlgorithm = new AlgorithmIdentifier();
        this.publicKey = new ArrayBuffer(0);
      }
    };
    __decorate2([
      AsnProp({ type: AlgorithmIdentifier })
    ], PublicKeyInfo.prototype, "publicKeyAlgorithm", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.BitString })
    ], PublicKeyInfo.prototype, "publicKey", void 0);
    JsonBase64UrlArrayBufferConverter = {
      fromJSON: (value) => Convert.FromBase64Url(value),
      toJSON: (value) => Convert.ToBase64Url(new Uint8Array(value))
    };
    AsnIntegerArrayBufferConverter = {
      fromASN: (value) => {
        const valueHex = value.valueBlock.valueHex;
        return !new Uint8Array(valueHex)[0] ? value.valueBlock.valueHex.slice(1) : value.valueBlock.valueHex;
      },
      toASN: (value) => {
        const valueHex = new Uint8Array(value)[0] > 127 ? combine(new Uint8Array([0]).buffer, value) : value;
        return new Integer({ valueHex });
      }
    };
    RsaPrivateKey = class {
      static {
        __name(this, "RsaPrivateKey");
      }
      constructor() {
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerConverter })
    ], RsaPrivateKey.prototype, "version", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "n", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "modulus", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "e", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "publicExponent", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "d", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "privateExponent", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "p", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "prime1", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "q", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "prime2", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "dp", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "exponent1", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "dq", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "exponent2", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "qi", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPrivateKey.prototype, "coefficient", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Any, optional: true })
    ], RsaPrivateKey.prototype, "otherPrimeInfos", void 0);
    RsaPublicKey = class {
      static {
        __name(this, "RsaPublicKey");
      }
      constructor() {
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "n", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPublicKey.prototype, "modulus", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),
      JsonProp({ name: "e", converter: JsonBase64UrlArrayBufferConverter })
    ], RsaPublicKey.prototype, "publicExponent", void 0);
    EcPublicKey = class EcPublicKey2 {
      static {
        __name(this, "EcPublicKey");
      }
      constructor(value) {
        this.value = new ArrayBuffer(0);
        if (value) {
          this.value = value;
        }
      }
      toJSON() {
        let bytes = new Uint8Array(this.value);
        if (bytes[0] !== 4) {
          throw new CryptoError("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");
        }
        bytes = new Uint8Array(this.value.slice(1));
        const size = bytes.length / 2;
        const offset = 0;
        const json2 = {
          x: Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),
          y: Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))
        };
        return json2;
      }
      fromJSON(json2) {
        if (!("x" in json2)) {
          throw new Error("x: Missing required property");
        }
        if (!("y" in json2)) {
          throw new Error("y: Missing required property");
        }
        const x4 = Convert.FromBase64Url(json2.x);
        const y4 = Convert.FromBase64Url(json2.y);
        const value = combine(new Uint8Array([4]).buffer, x4, y4);
        this.value = new Uint8Array(value).buffer;
        return this;
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.OctetString })
    ], EcPublicKey.prototype, "value", void 0);
    EcPublicKey = __decorate2([
      AsnType({ type: AsnTypeTypes.Choice })
    ], EcPublicKey);
    EcPrivateKey = class {
      static {
        __name(this, "EcPrivateKey");
      }
      constructor() {
        this.version = 1;
        this.privateKey = new ArrayBuffer(0);
      }
      fromJSON(json2) {
        if (!("d" in json2)) {
          throw new Error("d: Missing required property");
        }
        this.privateKey = Convert.FromBase64Url(json2.d);
        if ("x" in json2) {
          const publicKey = new EcPublicKey();
          publicKey.fromJSON(json2);
          const asn = AsnSerializer.toASN(publicKey);
          if ("valueHex" in asn.valueBlock) {
            this.publicKey = asn.valueBlock.valueHex;
          }
        }
        return this;
      }
      toJSON() {
        const jwk = {};
        jwk.d = Convert.ToBase64Url(this.privateKey);
        if (this.publicKey) {
          Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());
        }
        return jwk;
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerConverter })
    ], EcPrivateKey.prototype, "version", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.OctetString })
    ], EcPrivateKey.prototype, "privateKey", void 0);
    __decorate2([
      AsnProp({ context: 0, type: AsnPropTypes.Any, optional: true })
    ], EcPrivateKey.prototype, "parameters", void 0);
    __decorate2([
      AsnProp({ context: 1, type: AsnPropTypes.BitString, optional: true })
    ], EcPrivateKey.prototype, "publicKey", void 0);
    AsnIntegerWithoutPaddingConverter = {
      fromASN: (value) => {
        const bytes = new Uint8Array(value.valueBlock.valueHex);
        return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;
      },
      toASN: (value) => {
        const bytes = new Uint8Array(value);
        if (bytes[0] > 127) {
          const newValue = new Uint8Array(bytes.length + 1);
          newValue.set(bytes, 1);
          return new Integer({ valueHex: newValue.buffer });
        }
        return new Integer({ valueHex: value });
      }
    };
    index$2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AsnIntegerWithoutPaddingConverter
    });
    EcUtils = class {
      static {
        __name(this, "EcUtils");
      }
      static decodePoint(data, pointSize) {
        const view2 = BufferSourceConverter.toUint8Array(data);
        if (view2.length === 0 || view2[0] !== 4) {
          throw new Error("Only uncompressed point format supported");
        }
        const n10 = (view2.length - 1) / 2;
        if (n10 !== Math.ceil(pointSize / 8)) {
          throw new Error("Point does not match field size");
        }
        const xb = view2.slice(1, n10 + 1);
        const yb = view2.slice(n10 + 1, n10 + 1 + n10);
        return { x: xb, y: yb };
      }
      static encodePoint(point, pointSize) {
        const size = Math.ceil(pointSize / 8);
        if (point.x.byteLength !== size || point.y.byteLength !== size) {
          throw new Error("X,Y coordinates don't match point size criteria");
        }
        const x4 = BufferSourceConverter.toUint8Array(point.x);
        const y4 = BufferSourceConverter.toUint8Array(point.y);
        const res = new Uint8Array(size * 2 + 1);
        res[0] = 4;
        res.set(x4, 1);
        res.set(y4, size + 1);
        return res;
      }
      static getSize(pointSize) {
        return Math.ceil(pointSize / 8);
      }
      static encodeSignature(signature, pointSize) {
        const size = this.getSize(pointSize);
        const r10 = BufferSourceConverter.toUint8Array(signature.r);
        const s10 = BufferSourceConverter.toUint8Array(signature.s);
        const res = new Uint8Array(size * 2);
        res.set(this.padStart(r10, size));
        res.set(this.padStart(s10, size), size);
        return res;
      }
      static decodeSignature(data, pointSize) {
        const size = this.getSize(pointSize);
        const view2 = BufferSourceConverter.toUint8Array(data);
        if (view2.length !== size * 2) {
          throw new Error("Incorrect size of the signature");
        }
        const r10 = view2.slice(0, size);
        const s10 = view2.slice(size);
        return {
          r: this.trimStart(r10),
          s: this.trimStart(s10)
        };
      }
      static trimStart(data) {
        let i10 = 0;
        while (i10 < data.length - 1 && data[i10] === 0) {
          i10++;
        }
        if (i10 === 0) {
          return data;
        }
        return data.slice(i10, data.length);
      }
      static padStart(data, size) {
        if (size === data.length) {
          return data;
        }
        const res = new Uint8Array(size);
        res.set(data, size - data.length);
        return res;
      }
    };
    EcDsaSignature = class _EcDsaSignature {
      static {
        __name(this, "EcDsaSignature");
      }
      constructor() {
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
      }
      static fromWebCryptoSignature(value) {
        const pointSize = value.byteLength / 2;
        const point = EcUtils.decodeSignature(value, pointSize * 8);
        const ecSignature = new _EcDsaSignature();
        ecSignature.r = BufferSourceConverter.toArrayBuffer(point.r);
        ecSignature.s = BufferSourceConverter.toArrayBuffer(point.s);
        return ecSignature;
      }
      toWebCryptoSignature(pointSize) {
        pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;
        const signature = EcUtils.encodeSignature(this, pointSize);
        return signature.buffer;
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })
    ], EcDsaSignature.prototype, "r", void 0);
    __decorate2([
      AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })
    ], EcDsaSignature.prototype, "s", void 0);
    OneAsymmetricKey = class extends PrivateKeyInfo {
      static {
        __name(this, "OneAsymmetricKey");
      }
    };
    __decorate2([
      AsnProp({ context: 1, implicit: true, type: AsnPropTypes.BitString, optional: true })
    ], OneAsymmetricKey.prototype, "publicKey", void 0);
    EdPrivateKey = class EdPrivateKey2 {
      static {
        __name(this, "EdPrivateKey");
      }
      constructor() {
        this.value = new ArrayBuffer(0);
      }
      fromJSON(json2) {
        if (!json2.d) {
          throw new Error("d: Missing required property");
        }
        this.value = Convert.FromBase64Url(json2.d);
        return this;
      }
      toJSON() {
        const jwk = {
          d: Convert.ToBase64Url(this.value)
        };
        return jwk;
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.OctetString })
    ], EdPrivateKey.prototype, "value", void 0);
    EdPrivateKey = __decorate2([
      AsnType({ type: AsnTypeTypes.Choice })
    ], EdPrivateKey);
    EdPublicKey = class EdPublicKey2 {
      static {
        __name(this, "EdPublicKey");
      }
      constructor(value) {
        this.value = new ArrayBuffer(0);
        if (value) {
          this.value = value;
        }
      }
      toJSON() {
        const json2 = {
          x: Convert.ToBase64Url(this.value)
        };
        return json2;
      }
      fromJSON(json2) {
        if (!("x" in json2)) {
          throw new Error("x: Missing required property");
        }
        this.value = Convert.FromBase64Url(json2.x);
        return this;
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.BitString })
    ], EdPublicKey.prototype, "value", void 0);
    EdPublicKey = __decorate2([
      AsnType({ type: AsnTypeTypes.Choice })
    ], EdPublicKey);
    CurvePrivateKey = class CurvePrivateKey2 {
      static {
        __name(this, "CurvePrivateKey");
      }
    };
    __decorate2([
      AsnProp({ type: AsnPropTypes.OctetString }),
      JsonProp({ type: JsonPropTypes.String, converter: JsonBase64UrlArrayBufferConverter })
    ], CurvePrivateKey.prototype, "d", void 0);
    CurvePrivateKey = __decorate2([
      AsnType({ type: AsnTypeTypes.Choice })
    ], CurvePrivateKey);
    idSecp256r1 = "1.2.840.10045.3.1.7";
    idEllipticCurve = "1.3.132.0";
    idSecp384r1 = `${idEllipticCurve}.34`;
    idSecp521r1 = `${idEllipticCurve}.35`;
    idSecp256k1 = `${idEllipticCurve}.10`;
    idVersionOne = "1.3.36.3.3.2.8.1.1";
    idBrainpoolP160r1 = `${idVersionOne}.1`;
    idBrainpoolP160t1 = `${idVersionOne}.2`;
    idBrainpoolP192r1 = `${idVersionOne}.3`;
    idBrainpoolP192t1 = `${idVersionOne}.4`;
    idBrainpoolP224r1 = `${idVersionOne}.5`;
    idBrainpoolP224t1 = `${idVersionOne}.6`;
    idBrainpoolP256r1 = `${idVersionOne}.7`;
    idBrainpoolP256t1 = `${idVersionOne}.8`;
    idBrainpoolP320r1 = `${idVersionOne}.9`;
    idBrainpoolP320t1 = `${idVersionOne}.10`;
    idBrainpoolP384r1 = `${idVersionOne}.11`;
    idBrainpoolP384t1 = `${idVersionOne}.12`;
    idBrainpoolP512r1 = `${idVersionOne}.13`;
    idBrainpoolP512t1 = `${idVersionOne}.14`;
    idX25519 = "1.3.101.110";
    idX448 = "1.3.101.111";
    idEd25519 = "1.3.101.112";
    idEd448 = "1.3.101.113";
    index$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AlgorithmIdentifier,
      get CurvePrivateKey() {
        return CurvePrivateKey;
      },
      EcDsaSignature,
      EcPrivateKey,
      get EcPublicKey() {
        return EcPublicKey;
      },
      get EdPrivateKey() {
        return EdPrivateKey;
      },
      get EdPublicKey() {
        return EdPublicKey;
      },
      get ObjectIdentifier() {
        return ObjectIdentifier2;
      },
      OneAsymmetricKey,
      PrivateKeyInfo,
      PublicKeyInfo,
      RsaPrivateKey,
      RsaPublicKey,
      converters: index$2,
      idBrainpoolP160r1,
      idBrainpoolP160t1,
      idBrainpoolP192r1,
      idBrainpoolP192t1,
      idBrainpoolP224r1,
      idBrainpoolP224t1,
      idBrainpoolP256r1,
      idBrainpoolP256t1,
      idBrainpoolP320r1,
      idBrainpoolP320t1,
      idBrainpoolP384r1,
      idBrainpoolP384t1,
      idBrainpoolP512r1,
      idBrainpoolP512t1,
      idEd25519,
      idEd448,
      idEllipticCurve,
      idSecp256k1,
      idSecp256r1,
      idSecp384r1,
      idSecp521r1,
      idVersionOne,
      idX25519,
      idX448
    });
    EcCurves = class {
      static {
        __name(this, "EcCurves");
      }
      constructor() {
      }
      static register(item) {
        const oid = new ObjectIdentifier2();
        oid.value = item.id;
        const raw = AsnConvert.serialize(oid);
        this.items.push({
          ...item,
          raw
        });
        this.names.push(item.name);
      }
      static find(nameOrId) {
        nameOrId = nameOrId.toUpperCase();
        for (const item of this.items) {
          if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {
            return item;
          }
        }
        return null;
      }
      static get(nameOrId) {
        const res = this.find(nameOrId);
        if (!res) {
          throw new Error(`Unsupported EC named curve '${nameOrId}'`);
        }
        return res;
      }
    };
    EcCurves.items = [];
    EcCurves.names = [];
    EcCurves.register({ name: "P-256", id: idSecp256r1, size: 256 });
    EcCurves.register({ name: "P-384", id: idSecp384r1, size: 384 });
    EcCurves.register({ name: "P-521", id: idSecp521r1, size: 521 });
    EcCurves.register({ name: "K-256", id: idSecp256k1, size: 256 });
    EcCurves.register({ name: "brainpoolP160r1", id: idBrainpoolP160r1, size: 160 });
    EcCurves.register({ name: "brainpoolP160t1", id: idBrainpoolP160t1, size: 160 });
    EcCurves.register({ name: "brainpoolP192r1", id: idBrainpoolP192r1, size: 192 });
    EcCurves.register({ name: "brainpoolP192t1", id: idBrainpoolP192t1, size: 192 });
    EcCurves.register({ name: "brainpoolP224r1", id: idBrainpoolP224r1, size: 224 });
    EcCurves.register({ name: "brainpoolP224t1", id: idBrainpoolP224t1, size: 224 });
    EcCurves.register({ name: "brainpoolP256r1", id: idBrainpoolP256r1, size: 256 });
    EcCurves.register({ name: "brainpoolP256t1", id: idBrainpoolP256t1, size: 256 });
    EcCurves.register({ name: "brainpoolP320r1", id: idBrainpoolP320r1, size: 320 });
    EcCurves.register({ name: "brainpoolP320t1", id: idBrainpoolP320t1, size: 320 });
    EcCurves.register({ name: "brainpoolP384r1", id: idBrainpoolP384r1, size: 384 });
    EcCurves.register({ name: "brainpoolP384t1", id: idBrainpoolP384t1, size: 384 });
    EcCurves.register({ name: "brainpoolP512r1", id: idBrainpoolP512r1, size: 512 });
    EcCurves.register({ name: "brainpoolP512t1", id: idBrainpoolP512t1, size: 512 });
    HmacProvider = class extends ProviderCrypto {
      static {
        __name(this, "HmacProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "HMAC";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = ["sign", "verify"];
      }
      getDefaultLength(algName) {
        switch (algName.toUpperCase()) {
          case "SHA-1":
          case "SHA-256":
          case "SHA-384":
          case "SHA-512":
            return 512;
          default:
            throw new Error(`Unknown algorithm name '${algName}'`);
        }
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        if ("length" in algorithm) {
          if (typeof algorithm.length !== "number") {
            throw new TypeError("length: Is not a Number");
          }
          if (algorithm.length < 1) {
            throw new RangeError("length: Number is out of range");
          }
        }
      }
      checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
      }
    };
    Pbkdf2Provider = class extends ProviderCrypto {
      static {
        __name(this, "Pbkdf2Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "PBKDF2";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = ["deriveBits", "deriveKey"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "salt");
        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {
          throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        this.checkRequiredProperty(algorithm, "iterations");
        if (typeof algorithm.iterations !== "number") {
          throw new TypeError("iterations: Is not a Number");
        }
        if (algorithm.iterations < 1) {
          throw new TypeError("iterations: Is less than 1");
        }
      }
      checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
        if (extractable) {
          throw new SyntaxError("extractable: Must be 'false'");
        }
      }
    };
    HkdfProvider = class extends ProviderCrypto {
      static {
        __name(this, "HkdfProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "HKDF";
        this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];
        this.usages = ["deriveKey", "deriveBits"];
      }
      checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "salt");
        if (!BufferSourceConverter.isBufferSource(algorithm.salt)) {
          throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        this.checkRequiredProperty(algorithm, "info");
        if (!BufferSourceConverter.isBufferSource(algorithm.info)) {
          throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
      }
      checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
        if (extractable) {
          throw new SyntaxError("extractable: Must be 'false'");
        }
      }
    };
    ShakeProvider = class extends ProviderCrypto {
      static {
        __name(this, "ShakeProvider");
      }
      constructor() {
        super(...arguments);
        this.usages = [];
        this.defaultLength = 0;
      }
      digest(...args) {
        args[0] = { length: this.defaultLength, ...args[0] };
        return super.digest.apply(this, args);
      }
      checkDigest(algorithm, data) {
        super.checkDigest(algorithm, data);
        const length = algorithm.length || 0;
        if (typeof length !== "number") {
          throw new TypeError("length: Is not a Number");
        }
        if (length < 0) {
          throw new TypeError("length: Is negative");
        }
      }
    };
    Shake128Provider = class extends ShakeProvider {
      static {
        __name(this, "Shake128Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "shake128";
        this.defaultLength = 16;
      }
    };
    Shake256Provider = class extends ShakeProvider {
      static {
        __name(this, "Shake256Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "shake256";
        this.defaultLength = 32;
      }
    };
    Crypto = class {
      static {
        __name(this, "Crypto");
      }
      get [Symbol.toStringTag]() {
        return "Crypto";
      }
      randomUUID() {
        const b11 = this.getRandomValues(new Uint8Array(16));
        b11[6] = b11[6] & 15 | 64;
        b11[8] = b11[8] & 63 | 128;
        const uuid2 = Convert.ToHex(b11).toLowerCase();
        return `${uuid2.substring(0, 8)}-${uuid2.substring(8, 12)}-${uuid2.substring(12, 16)}-${uuid2.substring(16, 20)}-${uuid2.substring(20)}`;
      }
    };
    ProviderStorage = class {
      static {
        __name(this, "ProviderStorage");
      }
      constructor() {
        this.items = {};
      }
      get(algorithmName) {
        return this.items[algorithmName.toLowerCase()] || null;
      }
      set(provider) {
        this.items[provider.name.toLowerCase()] = provider;
      }
      removeAt(algorithmName) {
        const provider = this.get(algorithmName.toLowerCase());
        if (provider) {
          delete this.items[algorithmName];
        }
        return provider;
      }
      has(name2) {
        return !!this.get(name2);
      }
      get length() {
        return Object.keys(this.items).length;
      }
      get algorithms() {
        const algorithms = [];
        for (const key in this.items) {
          const provider = this.items[key];
          algorithms.push(provider.name);
        }
        return algorithms.sort();
      }
    };
    SubtleCrypto = class _SubtleCrypto {
      static {
        __name(this, "SubtleCrypto");
      }
      constructor() {
        this.providers = new ProviderStorage();
      }
      static isHashedAlgorithm(data) {
        return data && typeof data === "object" && "name" in data && "hash" in data ? true : false;
      }
      get [Symbol.toStringTag]() {
        return "SubtleCrypto";
      }
      async digest(...args) {
        this.checkRequiredArguments(args, 2, "digest");
        const [algorithm, data, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);
        return result;
      }
      async generateKey(...args) {
        this.checkRequiredArguments(args, 3, "generateKey");
        const [algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.generateKey({ ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
        return result;
      }
      async sign(...args) {
        this.checkRequiredArguments(args, 3, "sign");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.sign({ ...preparedAlgorithm, name: provider.name }, key, preparedData, ...params);
        return result;
      }
      async verify(...args) {
        this.checkRequiredArguments(args, 4, "verify");
        const [algorithm, key, signature, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const preparedSignature = BufferSourceConverter.toArrayBuffer(signature);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.verify({ ...preparedAlgorithm, name: provider.name }, key, preparedSignature, preparedData, ...params);
        return result;
      }
      async encrypt(...args) {
        this.checkRequiredArguments(args, 3, "encrypt");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.encrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);
        return result;
      }
      async decrypt(...args) {
        this.checkRequiredArguments(args, 3, "decrypt");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);
        return result;
      }
      async deriveBits(...args) {
        this.checkRequiredArguments(args, 3, "deriveBits");
        const [algorithm, baseKey, length, ...params] = args;
        this.checkCryptoKey(baseKey);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, length, { keyUsage: true }, ...params);
        return result;
      }
      async deriveKey(...args) {
        this.checkRequiredArguments(args, 5, "deriveKey");
        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;
        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);
        const importProvider = this.getProvider(preparedDerivedKeyType.name);
        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        provider.checkCryptoKey(baseKey, "deriveKey");
        const derivedBits = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, derivedKeyType.length || 512, { keyUsage: false }, ...params);
        return this.importKey("raw", derivedBits, derivedKeyType, extractable, keyUsages, ...params);
      }
      async exportKey(...args) {
        this.checkRequiredArguments(args, 2, "exportKey");
        const [format, key, ...params] = args;
        this.checkCryptoKey(key);
        const provider = this.getProvider(key.algorithm.name);
        const result = await provider.exportKey(format, key, ...params);
        return result;
      }
      async importKey(...args) {
        this.checkRequiredArguments(args, 5, "importKey");
        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        if (["pkcs8", "spki", "raw"].indexOf(format) !== -1) {
          const preparedData = BufferSourceConverter.toArrayBuffer(keyData);
          return provider.importKey(format, preparedData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
        } else {
          if (!keyData.kty) {
            throw new TypeError("keyData: Is not JSON");
          }
        }
        return provider.importKey(format, keyData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);
      }
      async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {
        let keyData = await this.exportKey(format, key, ...args);
        if (format === "jwk") {
          const json2 = JSON.stringify(keyData);
          keyData = Convert.FromUtf8String(json2);
        }
        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(keyData);
        const provider = this.getProvider(preparedAlgorithm.name);
        return provider.encrypt({ ...preparedAlgorithm, name: provider.name }, wrappingKey, preparedData, { keyUsage: false }, ...args);
      }
      async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {
        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);
        const preparedData = BufferSourceConverter.toArrayBuffer(wrappedKey);
        const provider = this.getProvider(preparedAlgorithm.name);
        let keyData = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, unwrappingKey, preparedData, { keyUsage: false }, ...args);
        if (format === "jwk") {
          try {
            keyData = JSON.parse(Convert.ToUtf8String(keyData));
          } catch (e10) {
            const error = new TypeError("wrappedKey: Is not a JSON");
            error.internal = e10;
            throw error;
          }
        }
        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);
      }
      checkRequiredArguments(args, size, methodName) {
        if (args.length < size) {
          throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);
        }
      }
      prepareAlgorithm(algorithm) {
        if (typeof algorithm === "string") {
          return {
            name: algorithm
          };
        }
        if (_SubtleCrypto.isHashedAlgorithm(algorithm)) {
          const preparedAlgorithm = { ...algorithm };
          preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);
          return preparedAlgorithm;
        }
        return { ...algorithm };
      }
      getProvider(name2) {
        const provider = this.providers.get(name2);
        if (!provider) {
          throw new AlgorithmError("Unrecognized name");
        }
        return provider;
      }
      checkCryptoKey(key) {
        if (!(key instanceof CryptoKey)) {
          throw new TypeError(`Key is not of type 'CryptoKey'`);
        }
      }
    };
  }
});

// ../../node_modules/@peculiar/webcrypto/build/webcrypto.es.js
var webcrypto_es_exports = {};
__export(webcrypto_es_exports, {
  Crypto: () => Crypto2,
  CryptoKey: () => CryptoKey
});
import * as crypto2 from "crypto";
import crypto__default from "crypto";
import * as process2 from "process";
function getCryptoKey(key) {
  const res = keyStorage.get(key);
  if (!res) {
    throw new OperationError("Cannot get CryptoKey from secure storage");
  }
  return res;
}
function setCryptoKey(value) {
  const key = CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);
  Object.freeze(key);
  keyStorage.set(key, value);
  return key;
}
function bitShiftLeft(buffer) {
  const shifted = Buffer.alloc(buffer.length);
  const last = buffer.length - 1;
  for (let index2 = 0; index2 < last; index2++) {
    shifted[index2] = buffer[index2] << 1;
    if (buffer[index2 + 1] & 128) {
      shifted[index2] += 1;
    }
  }
  shifted[last] = buffer[last] << 1;
  return shifted;
}
function xor(a10, b11) {
  const length = Math.min(a10.length, b11.length);
  const output = Buffer.alloc(length);
  for (let index2 = 0; index2 < length; index2++) {
    output[index2] = a10[index2] ^ b11[index2];
  }
  return output;
}
function aes(key, message) {
  const cipher = crypto2.createCipheriv(`aes${key.length << 3}`, key, zero);
  const result = cipher.update(message);
  cipher.final();
  return result;
}
function getMessageBlock(message, blockIndex) {
  const block = Buffer.alloc(blockSize);
  const start = blockIndex * blockSize;
  const end = start + blockSize;
  message.copy(block, 0, start, end);
  return block;
}
function getPaddedMessageBlock(message, blockIndex) {
  const block = Buffer.alloc(blockSize);
  const start = blockIndex * blockSize;
  const end = message.length;
  block.fill(0);
  message.copy(block, 0, start, end);
  block[end - start] = 128;
  return block;
}
function generateSubkeys(key) {
  const l10 = aes(key, zero);
  let subkey1 = bitShiftLeft(l10);
  if (l10[0] & 128) {
    subkey1 = xor(subkey1, rb);
  }
  let subkey2 = bitShiftLeft(subkey1);
  if (subkey1[0] & 128) {
    subkey2 = xor(subkey2, rb);
  }
  return { subkey1, subkey2 };
}
function aesCmac(key, message) {
  const subkeys = generateSubkeys(key);
  let blockCount = Math.ceil(message.length / blockSize);
  let lastBlockCompleteFlag;
  let lastBlock;
  if (blockCount === 0) {
    blockCount = 1;
    lastBlockCompleteFlag = false;
  } else {
    lastBlockCompleteFlag = message.length % blockSize === 0;
  }
  const lastBlockIndex = blockCount - 1;
  if (lastBlockCompleteFlag) {
    lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);
  } else {
    lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);
  }
  let x4 = zero;
  let y4;
  for (let index2 = 0; index2 < lastBlockIndex; index2++) {
    y4 = xor(x4, getMessageBlock(message, index2));
    x4 = aes(key, y4);
  }
  y4 = xor(lastBlock, x4);
  return aes(key, y4);
}
function getJwkAlgorithm(algorithm) {
  switch (algorithm.name.toUpperCase()) {
    case "RSA-OAEP": {
      const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
      return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
    }
    case "RSASSA-PKCS1-V1_5":
      return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
    case "RSA-PSS":
      return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
    case "RSA-PKCS1":
      return `RS1`;
    default:
      throw new OperationError("algorithm: Is not recognized");
  }
}
function getOidByNamedCurve$1(namedCurve) {
  const oid = namedOIDs[namedCurve];
  if (!oid) {
    throw new OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
  }
  return oid;
}
function getOidByNamedCurve(namedCurve) {
  const oid = edOIDs[namedCurve.toLowerCase()];
  if (!oid) {
    throw new OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
  }
  return oid;
}
var JsonBase64UrlConverter, CryptoKey2, SymmetricKey, AsymmetricKey, AesCryptoKey, keyStorage, AesCrypto, AesCbcProvider2, zero, rb, blockSize, AesCmacProvider2, AesCtrProvider2, AesGcmProvider2, AesKwProvider2, AesEcbProvider2, DesCryptoKey, DesCrypto, DesCbcProvider, DesEde3CbcProvider, RsaPrivateKey2, RsaPublicKey2, RsaCrypto, RsaSsaProvider2, RsaPssProvider2, ShaCrypto, RsaOaepProvider2, RsaEsProvider, namedOIDs, EcPrivateKey2, EcPublicKey3, Sha1Provider, Sha256Provider, Sha384Provider, Sha512Provider, Sha3256Provider, Sha3384Provider, Sha3512Provider, EcCrypto, EcdsaProvider2, EcdhProvider2, edOIDs, EdPrivateKey3, EdPublicKey3, EdCrypto, EdDsaProvider2, EcdhEsProvider2, PbkdfCryptoKey, Pbkdf2Provider2, HmacCryptoKey, HmacProvider2, HkdfCryptoKey, HkdfProvider2, ShakeCrypto, Shake128Provider2, Shake256Provider2, SubtleCrypto2, Crypto2;
var init_webcrypto_es = __esm({
  "../../node_modules/@peculiar/webcrypto/build/webcrypto.es.js"() {
    init_webcrypto_core_es();
    init_webcrypto_core_es();
    init_webcrypto_core_es();
    init_tslib_es62();
    init_index_es3();
    init_index_es();
    init_es2015();
    JsonBase64UrlConverter = {
      fromJSON: (value) => Buffer.from(Convert.FromBase64Url(value)),
      toJSON: (value) => Convert.ToBase64Url(value)
    };
    CryptoKey2 = class extends CryptoKey {
      static {
        __name(this, "CryptoKey");
      }
      constructor() {
        super(...arguments);
        this.data = Buffer.alloc(0);
        this.algorithm = { name: "" };
        this.extractable = false;
        this.type = "secret";
        this.usages = [];
        this.kty = "oct";
        this.alg = "";
      }
    };
    __decorate2([
      JsonProp({ name: "ext", type: JsonPropTypes.Boolean, optional: true })
    ], CryptoKey2.prototype, "extractable", void 0);
    __decorate2([
      JsonProp({ name: "key_ops", type: JsonPropTypes.String, repeated: true, optional: true })
    ], CryptoKey2.prototype, "usages", void 0);
    __decorate2([
      JsonProp({ type: JsonPropTypes.String })
    ], CryptoKey2.prototype, "kty", void 0);
    __decorate2([
      JsonProp({ type: JsonPropTypes.String, optional: true })
    ], CryptoKey2.prototype, "alg", void 0);
    SymmetricKey = class extends CryptoKey2 {
      static {
        __name(this, "SymmetricKey");
      }
      constructor() {
        super(...arguments);
        this.kty = "oct";
        this.type = "secret";
      }
    };
    AsymmetricKey = class extends CryptoKey2 {
      static {
        __name(this, "AsymmetricKey");
      }
    };
    AesCryptoKey = class extends SymmetricKey {
      static {
        __name(this, "AesCryptoKey");
      }
      get alg() {
        switch (this.algorithm.name.toUpperCase()) {
          case "AES-CBC":
            return `A${this.algorithm.length}CBC`;
          case "AES-CTR":
            return `A${this.algorithm.length}CTR`;
          case "AES-GCM":
            return `A${this.algorithm.length}GCM`;
          case "AES-KW":
            return `A${this.algorithm.length}KW`;
          case "AES-CMAC":
            return `A${this.algorithm.length}CMAC`;
          case "AES-ECB":
            return `A${this.algorithm.length}ECB`;
          default:
            throw new AlgorithmError("Unsupported algorithm name");
        }
      }
      set alg(value) {
      }
    };
    __decorate2([
      JsonProp({ name: "k", converter: JsonBase64UrlConverter })
    ], AesCryptoKey.prototype, "data", void 0);
    keyStorage = /* @__PURE__ */ new WeakMap();
    __name(getCryptoKey, "getCryptoKey");
    __name(setCryptoKey, "setCryptoKey");
    AesCrypto = class {
      static {
        __name(this, "AesCrypto");
      }
      static async generateKey(algorithm, extractable, keyUsages) {
        const key = new AesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto__default.randomBytes(algorithm.length >> 3);
        return key;
      }
      static async exportKey(format, key) {
        if (!(key instanceof AesCryptoKey)) {
          throw new Error("key: Is not AesCryptoKey");
        }
        switch (format.toLowerCase()) {
          case "jwk":
            return JsonSerializer.toJSON(key);
          case "raw":
            return new Uint8Array(key.data).buffer;
          default:
            throw new OperationError("format: Must be 'jwk' or 'raw'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
          case "jwk":
            key = JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });
            break;
          case "raw":
            key = new AesCryptoKey();
            key.data = Buffer.from(keyData);
            break;
          default:
            throw new OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = algorithm;
        key.algorithm.length = key.data.length << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        switch (key.algorithm.length) {
          case 128:
          case 192:
          case 256:
            break;
          default:
            throw new OperationError("keyData: Is wrong key length");
        }
        return key;
      }
      static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "AES-CBC":
            return this.encryptAesCBC(algorithm, key, Buffer.from(data));
          case "AES-CTR":
            return this.encryptAesCTR(algorithm, key, Buffer.from(data));
          case "AES-GCM":
            return this.encryptAesGCM(algorithm, key, Buffer.from(data));
          case "AES-KW":
            return this.encryptAesKW(algorithm, key, Buffer.from(data));
          case "AES-ECB":
            return this.encryptAesECB(algorithm, key, Buffer.from(data));
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async decrypt(algorithm, key, data) {
        if (!(key instanceof AesCryptoKey)) {
          throw new Error("key: Is not AesCryptoKey");
        }
        switch (algorithm.name.toUpperCase()) {
          case "AES-CBC":
            return this.decryptAesCBC(algorithm, key, Buffer.from(data));
          case "AES-CTR":
            return this.decryptAesCTR(algorithm, key, Buffer.from(data));
          case "AES-GCM":
            return this.decryptAesGCM(algorithm, key, Buffer.from(data));
          case "AES-KW":
            return this.decryptAesKW(algorithm, key, Buffer.from(data));
          case "AES-ECB":
            return this.decryptAesECB(algorithm, key, Buffer.from(data));
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async encryptAesCBC(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesCBC(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesCTR(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesCTR(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesGCM(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {
          authTagLength: (algorithm.tagLength || 128) >> 3
        });
        if (algorithm.additionalData) {
          cipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesGCM(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));
        const tagLength = (algorithm.tagLength || 128) >> 3;
        const enc = data.slice(0, data.length - tagLength);
        const tag = data.slice(data.length - tagLength);
        if (algorithm.additionalData) {
          decipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        decipher.setAuthTag(tag);
        let dec = decipher.update(enc);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesKW(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        return new Uint8Array(enc).buffer;
      }
      static async decryptAesKW(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptAesECB(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptAesECB(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
    };
    AesCrypto.AES_KW_IV = Buffer.from("A6A6A6A6A6A6A6A6", "hex");
    AesCbcProvider2 = class extends AesCbcProvider {
      static {
        __name(this, "AesCbcProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);
    blockSize = 16;
    __name(bitShiftLeft, "bitShiftLeft");
    __name(xor, "xor");
    __name(aes, "aes");
    __name(getMessageBlock, "getMessageBlock");
    __name(getPaddedMessageBlock, "getPaddedMessageBlock");
    __name(generateSubkeys, "generateSubkeys");
    __name(aesCmac, "aesCmac");
    AesCmacProvider2 = class extends AesCmacProvider {
      static {
        __name(this, "AesCmacProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onSign(algorithm, key, data) {
        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));
        return new Uint8Array(result).buffer;
      }
      async onVerify(algorithm, key, signature, data) {
        const signature2 = await this.sign(algorithm, key, data);
        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    AesCtrProvider2 = class extends AesCtrProvider {
      static {
        __name(this, "AesCtrProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    AesGcmProvider2 = class extends AesGcmProvider {
      static {
        __name(this, "AesGcmProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    AesKwProvider2 = class extends AesKwProvider {
      static {
        __name(this, "AesKwProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const res = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    AesEcbProvider2 = class extends AesEcbProvider {
      static {
        __name(this, "AesEcbProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
          name: this.name,
          length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);
        return setCryptoKey(res);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
          throw new TypeError("key: Is not a AesCryptoKey");
        }
      }
    };
    DesCryptoKey = class extends SymmetricKey {
      static {
        __name(this, "DesCryptoKey");
      }
      get alg() {
        switch (this.algorithm.name.toUpperCase()) {
          case "DES-CBC":
            return `DES-CBC`;
          case "DES-EDE3-CBC":
            return `3DES-CBC`;
          default:
            throw new AlgorithmError("Unsupported algorithm name");
        }
      }
      set alg(value) {
      }
    };
    __decorate2([
      JsonProp({ name: "k", converter: JsonBase64UrlConverter })
    ], DesCryptoKey.prototype, "data", void 0);
    DesCrypto = class {
      static {
        __name(this, "DesCrypto");
      }
      static async generateKey(algorithm, extractable, keyUsages) {
        const key = new DesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto__default.randomBytes(algorithm.length >> 3);
        return key;
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return JsonSerializer.toJSON(key);
          case "raw":
            return new Uint8Array(key.data).buffer;
          default:
            throw new OperationError("format: Must be 'jwk' or 'raw'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
          case "jwk":
            key = JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });
            break;
          case "raw":
            key = new DesCryptoKey();
            key.data = Buffer.from(keyData);
            break;
          default:
            throw new OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "DES-CBC":
            return this.encryptDesCBC(algorithm, key, Buffer.from(data));
          case "DES-EDE3-CBC":
            return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async decrypt(algorithm, key, data) {
        if (!(key instanceof DesCryptoKey)) {
          throw new Error("key: Is not DesCryptoKey");
        }
        switch (algorithm.name.toUpperCase()) {
          case "DES-CBC":
            return this.decryptDesCBC(algorithm, key, Buffer.from(data));
          case "DES-EDE3-CBC":
            return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async encryptDesCBC(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptDesCBC(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
      static async encryptDesEDE3CBC(algorithm, key, data) {
        const cipher = crypto__default.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([enc, cipher.final()]);
        const res = new Uint8Array(enc).buffer;
        return res;
      }
      static async decryptDesEDE3CBC(algorithm, key, data) {
        const decipher = crypto__default.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([dec, decipher.final()]);
        return new Uint8Array(dec).buffer;
      }
    };
    DesCbcProvider = class extends DesProvider {
      static {
        __name(this, "DesCbcProvider");
      }
      constructor() {
        super(...arguments);
        this.keySizeBits = 64;
        this.ivSize = 8;
        this.name = "DES-CBC";
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
          name: this.name,
          length: this.keySizeBits
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
        if (key.data.length !== this.keySizeBits >> 3) {
          throw new OperationError("keyData: Wrong key size");
        }
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
          throw new TypeError("key: Is not a DesCryptoKey");
        }
      }
    };
    DesEde3CbcProvider = class extends DesProvider {
      static {
        __name(this, "DesEde3CbcProvider");
      }
      constructor() {
        super(...arguments);
        this.keySizeBits = 192;
        this.ivSize = 8;
        this.name = "DES-EDE3-CBC";
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
          name: this.name,
          length: this.keySizeBits
        }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);
        if (key.data.length !== this.keySizeBits >> 3) {
          throw new OperationError("keyData: Wrong key size");
        }
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
          throw new TypeError("key: Is not a DesCryptoKey");
        }
      }
    };
    __name(getJwkAlgorithm, "getJwkAlgorithm");
    RsaPrivateKey2 = class extends AsymmetricKey {
      static {
        __name(this, "RsaPrivateKey");
      }
      constructor() {
        super(...arguments);
        this.type = "private";
      }
      getKey() {
        const keyInfo = AsnParser.parse(this.data, index$1.PrivateKeyInfo);
        return AsnParser.parse(keyInfo.privateKey, index$1.RsaPrivateKey);
      }
      toJSON() {
        const key = this.getKey();
        const json2 = {
          kty: "RSA",
          alg: getJwkAlgorithm(this.algorithm),
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json2, JsonSerializer.toJSON(key));
      }
      fromJSON(json2) {
        const key = JsonParser.fromJSON(json2, { targetSchema: index$1.RsaPrivateKey });
        const keyInfo = new index$1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = AsnSerializer.serialize(key);
        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));
      }
    };
    RsaPublicKey2 = class extends AsymmetricKey {
      static {
        __name(this, "RsaPublicKey");
      }
      constructor() {
        super(...arguments);
        this.type = "public";
      }
      getKey() {
        const keyInfo = AsnParser.parse(this.data, index$1.PublicKeyInfo);
        return AsnParser.parse(keyInfo.publicKey, index$1.RsaPublicKey);
      }
      toJSON() {
        const key = this.getKey();
        const json2 = {
          kty: "RSA",
          alg: getJwkAlgorithm(this.algorithm),
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json2, JsonSerializer.toJSON(key));
      }
      fromJSON(json2) {
        const key = JsonParser.fromJSON(json2, { targetSchema: index$1.RsaPublicKey });
        const keyInfo = new index$1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = AsnSerializer.serialize(key);
        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));
      }
    };
    RsaCrypto = class {
      static {
        __name(this, "RsaCrypto");
      }
      static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new RsaPrivateKey2();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new RsaPublicKey2();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);
        const publicExponent = Buffer.concat([
          Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),
          Buffer.from(algorithm.publicExponent)
        ]).readInt32BE(0);
        const keys = crypto__default.generateKeyPairSync("rsa", {
          modulusLength: algorithm.modulusLength,
          publicExponent,
          publicKeyEncoding: {
            format: "der",
            type: "spki"
          },
          privateKeyEncoding: {
            format: "der",
            type: "pkcs8"
          }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
          privateKey,
          publicKey
        };
        return res;
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return JsonSerializer.toJSON(key);
          case "pkcs8":
          case "spki":
            return new Uint8Array(key.data).buffer;
          default:
            throw new OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
          case "jwk": {
            const jwk = keyData;
            if (jwk.d) {
              const asnKey = JsonParser.fromJSON(keyData, { targetSchema: index$1.RsaPrivateKey });
              return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            } else {
              const asnKey = JsonParser.fromJSON(keyData, { targetSchema: index$1.RsaPublicKey });
              return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
          }
          case "spki": {
            const keyInfo = AsnParser.parse(new Uint8Array(keyData), index$1.PublicKeyInfo);
            const asnKey = AsnParser.parse(keyInfo.publicKey, index$1.RsaPublicKey);
            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
          }
          case "pkcs8": {
            const keyInfo = AsnParser.parse(new Uint8Array(keyData), index$1.PrivateKeyInfo);
            const asnKey = AsnParser.parse(keyInfo.privateKey, index$1.RsaPrivateKey);
            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
          }
          default:
            throw new OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
      }
      static async sign(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-PSS":
          case "RSASSA-PKCS1-V1_5":
            return this.signRsa(algorithm, key, data);
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async verify(algorithm, key, signature, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-PSS":
          case "RSASSA-PKCS1-V1_5":
            return this.verifySSA(algorithm, key, data, signature);
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async encrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-OAEP":
            return this.encryptOAEP(algorithm, key, data);
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static async decrypt(algorithm, key, data) {
        switch (algorithm.name.toUpperCase()) {
          case "RSA-OAEP":
            return this.decryptOAEP(algorithm, key, data);
          default:
            throw new OperationError("algorithm: Is not recognized");
        }
      }
      static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new index$1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = AsnSerializer.serialize(asnKey);
        const key = new RsaPrivateKey2();
        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new index$1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = AsnSerializer.serialize(asnKey);
        const key = new RsaPublicKey2();
        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static getCryptoAlgorithm(alg) {
        switch (alg.hash.name.toUpperCase()) {
          case "SHA-1":
            return "RSA-SHA1";
          case "SHA-256":
            return "RSA-SHA256";
          case "SHA-384":
            return "RSA-SHA384";
          case "SHA-512":
            return "RSA-SHA512";
          case "SHA3-256":
            return "RSA-SHA3-256";
          case "SHA3-384":
            return "RSA-SHA3-384";
          case "SHA3-512":
            return "RSA-SHA3-512";
          default:
            throw new OperationError("algorithm.hash: Is not recognized");
        }
      }
      static signRsa(algorithm, key, data) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto__default.createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        const options = {
          key: key.pem
        };
        if (algorithm.name.toUpperCase() === "RSA-PSS") {
          options.padding = crypto__default.constants.RSA_PKCS1_PSS_PADDING;
          options.saltLength = algorithm.saltLength;
        }
        const signature = signer.sign(options);
        return new Uint8Array(signature).buffer;
      }
      static verifySSA(algorithm, key, data, signature) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto__default.createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const options = {
          key: key.pem
        };
        if (algorithm.name.toUpperCase() === "RSA-PSS") {
          options.padding = crypto__default.constants.RSA_PKCS1_PSS_PADDING;
          options.saltLength = algorithm.saltLength;
        }
        const ok = signer.verify(options, signature);
        return ok;
      }
      static encryptOAEP(algorithm, key, data) {
        const options = {
          key: `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`,
          padding: crypto__default.constants.RSA_PKCS1_OAEP_PADDING
        };
        if (algorithm.label)
          ;
        return new Uint8Array(crypto__default.publicEncrypt(options, data)).buffer;
      }
      static decryptOAEP(algorithm, key, data) {
        const options = {
          key: `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`,
          padding: crypto__default.constants.RSA_PKCS1_OAEP_PADDING
        };
        if (algorithm.label)
          ;
        return new Uint8Array(crypto__default.privateDecrypt(options, data)).buffer;
      }
    };
    RsaCrypto.publicKeyUsages = ["verify", "encrypt", "wrapKey"];
    RsaCrypto.privateKeyUsages = ["sign", "decrypt", "unwrapKey"];
    RsaSsaProvider2 = class extends RsaSsaProvider {
      static {
        __name(this, "RsaSsaProvider");
      }
      constructor() {
        super(...arguments);
        this.hashAlgorithms = [
          "SHA-1",
          "SHA-256",
          "SHA-384",
          "SHA-512",
          "shake128",
          "shake256",
          "SHA3-256",
          "SHA3-384",
          "SHA3-512"
        ];
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey2 || internalKey instanceof RsaPublicKey2)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
    };
    RsaPssProvider2 = class extends RsaPssProvider {
      static {
        __name(this, "RsaPssProvider");
      }
      constructor() {
        super(...arguments);
        this.hashAlgorithms = [
          "SHA-1",
          "SHA-256",
          "SHA-384",
          "SHA-512",
          "shake128",
          "shake256",
          "SHA3-256",
          "SHA3-384",
          "SHA3-512"
        ];
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey2 || internalKey instanceof RsaPublicKey2)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
    };
    ShaCrypto = class {
      static {
        __name(this, "ShaCrypto");
      }
      static size(algorithm) {
        switch (algorithm.name.toUpperCase()) {
          case "SHA-1":
            return 160;
          case "SHA-256":
          case "SHA3-256":
            return 256;
          case "SHA-384":
          case "SHA3-384":
            return 384;
          case "SHA-512":
          case "SHA3-512":
            return 512;
          default:
            throw new Error("Unrecognized name");
        }
      }
      static getAlgorithmName(algorithm) {
        switch (algorithm.name.toUpperCase()) {
          case "SHA-1":
            return "sha1";
          case "SHA-256":
            return "sha256";
          case "SHA-384":
            return "sha384";
          case "SHA-512":
            return "sha512";
          case "SHA3-256":
            return "sha3-256";
          case "SHA3-384":
            return "sha3-384";
          case "SHA3-512":
            return "sha3-512";
          default:
            throw new Error("Unrecognized name");
        }
      }
      static digest(algorithm, data) {
        const hashAlg = this.getAlgorithmName(algorithm);
        const hash = crypto__default.createHash(hashAlg).update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
      }
    };
    RsaOaepProvider2 = class extends RsaOaepProvider {
      static {
        __name(this, "RsaOaepProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onEncrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const dataView = new Uint8Array(data);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;
        const dataLength = dataView.byteLength;
        const psLength = keySize - dataLength - 2 * hashSize - 2;
        if (dataLength > keySize - 2 * hashSize - 2) {
          throw new Error("Data too large");
        }
        const message = new Uint8Array(keySize);
        const seed = message.subarray(1, hashSize + 1);
        const dataBlock = message.subarray(hashSize + 1);
        dataBlock.set(dataView, hashSize + psLength + 1);
        const labelHash = crypto__default.createHash(internalKey.algorithm.hash.name.replace("-", "")).update(BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();
        dataBlock.set(labelHash, 0);
        dataBlock[hashSize + psLength] = 1;
        crypto__default.randomFillSync(seed);
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for (let i10 = 0; i10 < dataBlock.length; i10++) {
          dataBlock[i10] ^= dataBlockMask[i10];
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for (let i10 = 0; i10 < seed.length; i10++) {
          seed[i10] ^= seedMask[i10];
        }
        if (!internalKey.pem) {
          internalKey.pem = `-----BEGIN PUBLIC KEY-----
${internalKey.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const pkcs0 = crypto__default.publicEncrypt({
          key: internalKey.pem,
          padding: crypto__default.constants.RSA_NO_PADDING
        }, Buffer.from(message));
        return new Uint8Array(pkcs0).buffer;
      }
      async onDecrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;
        const dataLength = data.byteLength;
        if (dataLength !== keySize) {
          throw new Error("Bad data");
        }
        if (!internalKey.pem) {
          internalKey.pem = `-----BEGIN PRIVATE KEY-----
${internalKey.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        let pkcs0 = crypto__default.privateDecrypt({
          key: internalKey.pem,
          padding: crypto__default.constants.RSA_NO_PADDING
        }, Buffer.from(data));
        const z5 = pkcs0[0];
        const seed = pkcs0.subarray(1, hashSize + 1);
        const dataBlock = pkcs0.subarray(hashSize + 1);
        if (z5 !== 0) {
          throw new Error("Decryption failed");
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for (let i10 = 0; i10 < seed.length; i10++) {
          seed[i10] ^= seedMask[i10];
        }
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for (let i10 = 0; i10 < dataBlock.length; i10++) {
          dataBlock[i10] ^= dataBlockMask[i10];
        }
        const labelHash = crypto__default.createHash(internalKey.algorithm.hash.name.replace("-", "")).update(BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();
        for (let i10 = 0; i10 < hashSize; i10++) {
          if (labelHash[i10] !== dataBlock[i10]) {
            throw new Error("Decryption failed");
          }
        }
        let psEnd = hashSize;
        for (; psEnd < dataBlock.length; psEnd++) {
          const psz = dataBlock[psEnd];
          if (psz === 1) {
            break;
          }
          if (psz !== 0) {
            throw new Error("Decryption failed");
          }
        }
        if (psEnd === dataBlock.length) {
          throw new Error("Decryption failed");
        }
        pkcs0 = dataBlock.subarray(psEnd + 1);
        return new Uint8Array(pkcs0).buffer;
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey2 || internalKey instanceof RsaPublicKey2)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
      mgf1(algorithm, seed, length = 0) {
        const hashSize = ShaCrypto.size(algorithm) >> 3;
        const mask = new Uint8Array(length);
        const counter = new Uint8Array(4);
        const chunks = Math.ceil(length / hashSize);
        for (let i10 = 0; i10 < chunks; i10++) {
          counter[0] = i10 >>> 24;
          counter[1] = i10 >>> 16 & 255;
          counter[2] = i10 >>> 8 & 255;
          counter[3] = i10 & 255;
          const submask = mask.subarray(i10 * hashSize);
          let chunk = crypto__default.createHash(algorithm.name.replace("-", "")).update(seed).update(counter).digest();
          if (chunk.length > submask.length) {
            chunk = chunk.subarray(0, submask.length);
          }
          submask.set(chunk);
        }
        return mask;
      }
    };
    RsaEsProvider = class extends ProviderCrypto {
      static {
        __name(this, "RsaEsProvider");
      }
      constructor() {
        super(...arguments);
        this.name = "RSAES-PKCS1-v1_5";
        this.usages = {
          publicKey: ["encrypt", "wrapKey"],
          privateKey: ["decrypt", "unwrapKey"]
        };
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "publicExponent");
        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
          throw new TypeError("publicExponent: Missing or not a Uint8Array");
        }
        const publicExponent = Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
          throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
        }
        this.checkRequiredProperty(algorithm, "modulusLength");
        switch (algorithm.modulusLength) {
          case 1024:
          case 2048:
          case 4096:
            break;
          default:
            throw new TypeError("modulusLength: Must be 1024, 2048, or 4096");
        }
      }
      async onEncrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const enc = crypto2.publicEncrypt(options, new Uint8Array(data));
        return new Uint8Array(enc).buffer;
      }
      async onDecrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const dec = crypto2.privateDecrypt(options, new Uint8Array(data));
        return new Uint8Array(dec).buffer;
      }
      async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey2 || internalKey instanceof RsaPublicKey2)) {
          throw new TypeError("key: Is not RSA CryptoKey");
        }
      }
      toCryptoOptions(key) {
        const type = key.type.toUpperCase();
        return {
          key: `-----BEGIN ${type} KEY-----
${getCryptoKey(key).data.toString("base64")}
-----END ${type} KEY-----`,
          padding: crypto2.constants.RSA_PKCS1_PADDING
        };
      }
    };
    namedOIDs = {
      "1.2.840.10045.3.1.7": "P-256",
      "P-256": "1.2.840.10045.3.1.7",
      "1.3.132.0.34": "P-384",
      "P-384": "1.3.132.0.34",
      "1.3.132.0.35": "P-521",
      "P-521": "1.3.132.0.35",
      "1.3.132.0.10": "K-256",
      "K-256": "1.3.132.0.10",
      "brainpoolP160r1": "1.3.36.3.3.2.8.1.1.1",
      "1.3.36.3.3.2.8.1.1.1": "brainpoolP160r1",
      "brainpoolP160t1": "1.3.36.3.3.2.8.1.1.2",
      "1.3.36.3.3.2.8.1.1.2": "brainpoolP160t1",
      "brainpoolP192r1": "1.3.36.3.3.2.8.1.1.3",
      "1.3.36.3.3.2.8.1.1.3": "brainpoolP192r1",
      "brainpoolP192t1": "1.3.36.3.3.2.8.1.1.4",
      "1.3.36.3.3.2.8.1.1.4": "brainpoolP192t1",
      "brainpoolP224r1": "1.3.36.3.3.2.8.1.1.5",
      "1.3.36.3.3.2.8.1.1.5": "brainpoolP224r1",
      "brainpoolP224t1": "1.3.36.3.3.2.8.1.1.6",
      "1.3.36.3.3.2.8.1.1.6": "brainpoolP224t1",
      "brainpoolP256r1": "1.3.36.3.3.2.8.1.1.7",
      "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1",
      "brainpoolP256t1": "1.3.36.3.3.2.8.1.1.8",
      "1.3.36.3.3.2.8.1.1.8": "brainpoolP256t1",
      "brainpoolP320r1": "1.3.36.3.3.2.8.1.1.9",
      "1.3.36.3.3.2.8.1.1.9": "brainpoolP320r1",
      "brainpoolP320t1": "1.3.36.3.3.2.8.1.1.10",
      "1.3.36.3.3.2.8.1.1.10": "brainpoolP320t1",
      "brainpoolP384r1": "1.3.36.3.3.2.8.1.1.11",
      "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1",
      "brainpoolP384t1": "1.3.36.3.3.2.8.1.1.12",
      "1.3.36.3.3.2.8.1.1.12": "brainpoolP384t1",
      "brainpoolP512r1": "1.3.36.3.3.2.8.1.1.13",
      "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1",
      "brainpoolP512t1": "1.3.36.3.3.2.8.1.1.14",
      "1.3.36.3.3.2.8.1.1.14": "brainpoolP512t1"
    };
    __name(getOidByNamedCurve$1, "getOidByNamedCurve$1");
    EcPrivateKey2 = class extends AsymmetricKey {
      static {
        __name(this, "EcPrivateKey");
      }
      constructor() {
        super(...arguments);
        this.type = "private";
      }
      getKey() {
        const keyInfo = AsnParser.parse(this.data, index$1.PrivateKeyInfo);
        return AsnParser.parse(keyInfo.privateKey, index$1.EcPrivateKey);
      }
      toJSON() {
        const key = this.getKey();
        const json2 = {
          kty: "EC",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json2, JsonSerializer.toJSON(key));
      }
      fromJSON(json2) {
        if (!json2.crv) {
          throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const keyInfo = new index$1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new index$1.ObjectIdentifier(getOidByNamedCurve$1(json2.crv)));
        const key = JsonParser.fromJSON(json2, { targetSchema: index$1.EcPrivateKey });
        keyInfo.privateKey = AsnSerializer.serialize(key);
        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    EcPublicKey3 = class extends AsymmetricKey {
      static {
        __name(this, "EcPublicKey");
      }
      constructor() {
        super(...arguments);
        this.type = "public";
      }
      getKey() {
        const keyInfo = AsnParser.parse(this.data, index$1.PublicKeyInfo);
        return new index$1.EcPublicKey(keyInfo.publicKey);
      }
      toJSON() {
        const key = this.getKey();
        const json2 = {
          kty: "EC",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json2, JsonSerializer.toJSON(key));
      }
      fromJSON(json2) {
        if (!json2.crv) {
          throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const key = JsonParser.fromJSON(json2, { targetSchema: index$1.EcPublicKey });
        const keyInfo = new index$1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new index$1.ObjectIdentifier(getOidByNamedCurve$1(json2.crv)));
        keyInfo.publicKey = AsnSerializer.toASN(key).valueHex;
        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    Sha1Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha1Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA-1";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    Sha256Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha256Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA-256";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    Sha384Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha384Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA-384";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    Sha512Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha512Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA-512";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    Sha3256Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha3256Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA3-256";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    Sha3384Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha3384Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA3-384";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    Sha3512Provider = class extends ProviderCrypto {
      static {
        __name(this, "Sha3512Provider");
      }
      constructor() {
        super(...arguments);
        this.name = "SHA3-512";
        this.usages = [];
      }
      async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
      }
    };
    EcCrypto = class {
      static {
        __name(this, "EcCrypto");
      }
      static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EcPrivateKey2();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EcPublicKey3();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);
        const keys = crypto__default.generateKeyPairSync("ec", {
          namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),
          publicKeyEncoding: {
            format: "der",
            type: "spki"
          },
          privateKeyEncoding: {
            format: "der",
            type: "pkcs8"
          }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
          privateKey,
          publicKey
        };
        return res;
      }
      static async sign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto__default.createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const signature = signer.sign(options);
        const ecSignature = AsnParser.parse(signature, index$1.EcDsaSignature);
        const signatureRaw = EcUtils.encodeSignature(ecSignature, EcCurves.get(key.algorithm.namedCurve).size);
        return signatureRaw.buffer;
      }
      static async verify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto__default.createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
          key.pem = `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const ecSignature = new index$1.EcDsaSignature();
        const namedCurve = EcCurves.get(key.algorithm.namedCurve);
        const signaturePoint = EcUtils.decodeSignature(signature, namedCurve.size);
        ecSignature.r = BufferSourceConverter.toArrayBuffer(signaturePoint.r);
        ecSignature.s = BufferSourceConverter.toArrayBuffer(signaturePoint.s);
        const ecSignatureRaw = Buffer.from(AsnSerializer.serialize(ecSignature));
        const ok = signer.verify(options, ecSignatureRaw);
        return ok;
      }
      static async deriveBits(algorithm, baseKey, length) {
        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);
        const ecdh = crypto__default.createECDH(cryptoAlg);
        const asnPrivateKey = AsnParser.parse(baseKey.data, index$1.PrivateKeyInfo);
        const asnEcPrivateKey = AsnParser.parse(asnPrivateKey.privateKey, index$1.EcPrivateKey);
        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));
        const asnPublicKey = AsnParser.parse(algorithm.public.data, index$1.PublicKeyInfo);
        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));
        if (length === null) {
          return bits;
        }
        return new Uint8Array(bits).buffer.slice(0, length >> 3);
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return JsonSerializer.toJSON(key);
          case "pkcs8":
          case "spki":
            return new Uint8Array(key.data).buffer;
          case "raw": {
            const publicKeyInfo = AsnParser.parse(key.data, index$1.PublicKeyInfo);
            return publicKeyInfo.publicKey;
          }
          default:
            throw new OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
          case "jwk": {
            const jwk = keyData;
            if (jwk.d) {
              const asnKey = JsonParser.fromJSON(keyData, { targetSchema: index$1.EcPrivateKey });
              return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            } else {
              const asnKey = JsonParser.fromJSON(keyData, { targetSchema: index$1.EcPublicKey });
              return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
            }
          }
          case "raw": {
            const asnKey = new index$1.EcPublicKey(keyData);
            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
          }
          case "spki": {
            const keyInfo = AsnParser.parse(new Uint8Array(keyData), index$1.PublicKeyInfo);
            const asnKey = new index$1.EcPublicKey(keyInfo.publicKey);
            this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);
            return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
          }
          case "pkcs8": {
            const keyInfo = AsnParser.parse(new Uint8Array(keyData), index$1.PrivateKeyInfo);
            const asnKey = AsnParser.parse(keyInfo.privateKey, index$1.EcPrivateKey);
            this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);
            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
          }
          default:
            throw new OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
      }
      static assertKeyParameters(parameters2, namedCurve) {
        if (!parameters2) {
          throw new CryptoError("Key info doesn't have required parameters");
        }
        let namedCurveIdentifier = "";
        try {
          namedCurveIdentifier = AsnParser.parse(parameters2, index$1.ObjectIdentifier).value;
        } catch (e10) {
          throw new CryptoError("Cannot read key info parameters");
        }
        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {
          throw new CryptoError("Key info parameter doesn't match to named curve");
        }
      }
      static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new index$1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new index$1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));
        keyInfo.privateKey = AsnSerializer.serialize(asnKey);
        const key = new EcPrivateKey2();
        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new index$1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);
        keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new index$1.ObjectIdentifier(namedCurve));
        keyInfo.publicKey = asnKey.value;
        const key = new EcPublicKey3();
        key.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static getOpenSSLNamedCurve(curve) {
        switch (curve.toUpperCase()) {
          case "P-256":
            return "prime256v1";
          case "K-256":
            return "secp256k1";
          case "P-384":
            return "secp384r1";
          case "P-521":
            return "secp521r1";
          default:
            return curve;
        }
      }
    };
    EcCrypto.publicKeyUsages = ["verify"];
    EcCrypto.privateKeyUsages = ["sign", "deriveKey", "deriveBits"];
    EcdsaProvider2 = class extends EcdsaProvider {
      static {
        __name(this, "EcdsaProvider");
      }
      constructor() {
        super(...arguments);
        this.namedCurves = EcCurves.names;
        this.hashAlgorithms = [
          "SHA-1",
          "SHA-256",
          "SHA-384",
          "SHA-512",
          "shake128",
          "shake256",
          "SHA3-256",
          "SHA3-384",
          "SHA3-512"
        ];
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey2 || internalKey instanceof EcPublicKey3)) {
          throw new TypeError("key: Is not EC CryptoKey");
        }
      }
    };
    EcdhProvider2 = class extends EcdhProvider {
      static {
        __name(this, "EcdhProvider");
      }
      constructor() {
        super(...arguments);
        this.namedCurves = EcCurves.names;
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
          ...algorithm,
          name: this.name
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey2 || internalKey instanceof EcPublicKey3)) {
          throw new TypeError("key: Is not EC CryptoKey");
        }
      }
      async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);
        return bits;
      }
    };
    edOIDs = {
      [index$1.idEd448]: "Ed448",
      "ed448": index$1.idEd448,
      [index$1.idX448]: "X448",
      "x448": index$1.idX448,
      [index$1.idEd25519]: "Ed25519",
      "ed25519": index$1.idEd25519,
      [index$1.idX25519]: "X25519",
      "x25519": index$1.idX25519
    };
    __name(getOidByNamedCurve, "getOidByNamedCurve");
    EdPrivateKey3 = class extends AsymmetricKey {
      static {
        __name(this, "EdPrivateKey");
      }
      constructor() {
        super(...arguments);
        this.type = "private";
      }
      getKey() {
        const keyInfo = AsnParser.parse(this.data, index$1.PrivateKeyInfo);
        return AsnParser.parse(keyInfo.privateKey, index$1.CurvePrivateKey);
      }
      toJSON() {
        const key = this.getKey();
        const json2 = {
          kty: "OKP",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json2, JsonSerializer.toJSON(key));
      }
      fromJSON(json2) {
        if (!json2.crv) {
          throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const keyInfo = new index$1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json2.crv);
        const key = JsonParser.fromJSON(json2, { targetSchema: index$1.CurvePrivateKey });
        keyInfo.privateKey = AsnSerializer.serialize(key);
        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    EdPublicKey3 = class extends AsymmetricKey {
      static {
        __name(this, "EdPublicKey");
      }
      constructor() {
        super(...arguments);
        this.type = "public";
      }
      getKey() {
        const keyInfo = AsnParser.parse(this.data, index$1.PublicKeyInfo);
        return keyInfo.publicKey;
      }
      toJSON() {
        const key = this.getKey();
        const json2 = {
          kty: "OKP",
          crv: this.algorithm.namedCurve,
          key_ops: this.usages,
          ext: this.extractable
        };
        return Object.assign(json2, {
          x: Convert.ToBase64Url(key)
        });
      }
      fromJSON(json2) {
        if (!json2.crv) {
          throw new OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        if (!json2.x) {
          throw new OperationError(`Cannot get property from JWK. Property 'x' is required`);
        }
        const keyInfo = new index$1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json2.crv);
        keyInfo.publicKey = Convert.FromBase64Url(json2.x);
        this.data = Buffer.from(AsnSerializer.serialize(keyInfo));
        return this;
      }
    };
    EdCrypto = class {
      static {
        __name(this, "EdCrypto");
      }
      static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EdPrivateKey3();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EdPublicKey3();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);
        const type = algorithm.namedCurve.toLowerCase();
        const keys = crypto__default.generateKeyPairSync(type, {
          publicKeyEncoding: {
            format: "der",
            type: "spki"
          },
          privateKeyEncoding: {
            format: "der",
            type: "pkcs8"
          }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
          privateKey,
          publicKey
        };
        return res;
      }
      static async sign(algorithm, key, data) {
        if (!key.pem) {
          key.pem = `-----BEGIN PRIVATE KEY-----
${key.data.toString("base64")}
-----END PRIVATE KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const signature = crypto__default.sign(null, Buffer.from(data), options);
        return BufferSourceConverter.toArrayBuffer(signature);
      }
      static async verify(algorithm, key, signature, data) {
        if (!key.pem) {
          key.pem = `-----BEGIN PUBLIC KEY-----
${key.data.toString("base64")}
-----END PUBLIC KEY-----`;
        }
        const options = {
          key: key.pem
        };
        const ok = crypto__default.verify(null, Buffer.from(data), options, Buffer.from(signature));
        return ok;
      }
      static async deriveBits(algorithm, baseKey, length) {
        const publicKey = crypto__default.createPublicKey({
          key: algorithm.public.data,
          format: "der",
          type: "spki"
        });
        const privateKey = crypto__default.createPrivateKey({
          key: baseKey.data,
          format: "der",
          type: "pkcs8"
        });
        const bits = crypto__default.diffieHellman({
          publicKey,
          privateKey
        });
        return new Uint8Array(bits).buffer.slice(0, length >> 3);
      }
      static async exportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return JsonSerializer.toJSON(key);
          case "pkcs8":
          case "spki":
            return new Uint8Array(key.data).buffer;
          case "raw": {
            const publicKeyInfo = AsnParser.parse(key.data, index$1.PublicKeyInfo);
            return publicKeyInfo.publicKey;
          }
          default:
            throw new OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
      }
      static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch (format.toLowerCase()) {
          case "jwk": {
            const jwk = keyData;
            if (jwk.d) {
              const asnKey = JsonParser.fromJSON(keyData, { targetSchema: index$1.CurvePrivateKey });
              return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
            } else {
              if (!jwk.x) {
                throw new TypeError("keyData: Cannot get required 'x' filed");
              }
              return this.importPublicKey(Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);
            }
          }
          case "raw": {
            return this.importPublicKey(keyData, algorithm, extractable, keyUsages);
          }
          case "spki": {
            const keyInfo = AsnParser.parse(new Uint8Array(keyData), index$1.PublicKeyInfo);
            return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);
          }
          case "pkcs8": {
            const keyInfo = AsnParser.parse(new Uint8Array(keyData), index$1.PrivateKeyInfo);
            const asnKey = AsnParser.parse(keyInfo.privateKey, index$1.CurvePrivateKey);
            return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
          }
          default:
            throw new OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
      }
      static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPrivateKey3();
        key.fromJSON({
          crv: algorithm.namedCurve,
          d: Convert.ToBase64Url(asnKey.d)
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
      static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPublicKey3();
        key.fromJSON({
          crv: algorithm.namedCurve,
          x: Convert.ToBase64Url(asnKey)
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
      }
    };
    EdCrypto.publicKeyUsages = ["verify"];
    EdCrypto.privateKeyUsages = ["sign", "deriveKey", "deriveBits"];
    EdDsaProvider2 = class extends EdDsaProvider {
      static {
        __name(this, "EdDsaProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
          name: this.name,
          namedCurve: algorithm.namedCurve.replace(/^ed/i, "Ed")
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onSign(algorithm, key, data) {
        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
      }
      async onVerify(algorithm, key, signature, data) {
        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
      }
      async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
    };
    EcdhEsProvider2 = class extends EcdhEsProvider {
      static {
        __name(this, "EcdhEsProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
          name: this.name,
          namedCurve: algorithm.namedCurve.toUpperCase()
        }, extractable, keyUsages);
        return {
          privateKey: setCryptoKey(keys.privateKey),
          publicKey: setCryptoKey(keys.publicKey)
        };
      }
      async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);
        return bits;
      }
      async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);
        return setCryptoKey(key);
      }
    };
    PbkdfCryptoKey = class extends CryptoKey2 {
      static {
        __name(this, "PbkdfCryptoKey");
      }
    };
    Pbkdf2Provider2 = class extends Pbkdf2Provider {
      static {
        __name(this, "Pbkdf2Provider");
      }
      async onDeriveBits(algorithm, baseKey, length) {
        return new Promise((resolve, reject) => {
          const salt = BufferSourceConverter.toArrayBuffer(algorithm.salt);
          const hash = algorithm.hash.name.replace("-", "");
          crypto__default.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {
            if (err) {
              reject(err);
            } else {
              resolve(new Uint8Array(derivedBits).buffer);
            }
          });
        });
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format === "raw") {
          const key = new PbkdfCryptoKey();
          key.data = Buffer.from(keyData);
          key.algorithm = { name: this.name };
          key.extractable = false;
          key.usages = keyUsages;
          return setCryptoKey(key);
        }
        throw new OperationError("format: Must be 'raw'");
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {
          throw new TypeError("key: Is not PBKDF CryptoKey");
        }
      }
    };
    HmacCryptoKey = class extends CryptoKey2 {
      static {
        __name(this, "HmacCryptoKey");
      }
      get alg() {
        const hash = this.algorithm.hash.name.toUpperCase();
        return `HS${hash.replace("SHA-", "")}`;
      }
      set alg(value) {
      }
    };
    __decorate2([
      JsonProp({ name: "k", converter: JsonBase64UrlConverter })
    ], HmacCryptoKey.prototype, "data", void 0);
    HmacProvider2 = class extends HmacProvider {
      static {
        __name(this, "HmacProvider");
      }
      async onGenerateKey(algorithm, extractable, keyUsages) {
        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;
        const key = new HmacCryptoKey();
        key.algorithm = {
          ...algorithm,
          length,
          name: this.name
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto__default.randomBytes(length >> 3);
        return setCryptoKey(key);
      }
      async onSign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac2 = crypto__default.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();
        return new Uint8Array(hmac2).buffer;
      }
      async onVerify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac2 = crypto__default.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();
        return hmac2.compare(Buffer.from(signature)) === 0;
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch (format.toLowerCase()) {
          case "jwk":
            key = JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });
            break;
          case "raw":
            key = new HmacCryptoKey();
            key.data = Buffer.from(keyData);
            break;
          default:
            throw new OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = {
          hash: { name: algorithm.hash.name },
          name: this.name,
          length: key.data.length << 3
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
      }
      async onExportKey(format, key) {
        switch (format.toLowerCase()) {
          case "jwk":
            return JsonSerializer.toJSON(getCryptoKey(key));
          case "raw":
            return new Uint8Array(getCryptoKey(key).data).buffer;
          default:
            throw new OperationError("format: Must be 'jwk' or 'raw'");
        }
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {
          throw new TypeError("key: Is not HMAC CryptoKey");
        }
      }
    };
    HkdfCryptoKey = class extends CryptoKey2 {
      static {
        __name(this, "HkdfCryptoKey");
      }
    };
    HkdfProvider2 = class extends HkdfProvider {
      static {
        __name(this, "HkdfProvider");
      }
      async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format.toLowerCase() !== "raw") {
          throw new OperationError("Operation not supported");
        }
        const key = new HkdfCryptoKey();
        key.data = Buffer.from(keyData);
        key.algorithm = { name: this.name };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
      }
      async onDeriveBits(params, baseKey, length) {
        const hash = params.hash.name.replace("-", "");
        const hashLength = crypto__default.createHash(hash).digest().length;
        const byteLength2 = length / 8;
        const info = BufferSourceConverter.toUint8Array(params.info);
        const PRK = crypto__default.createHmac(hash, BufferSourceConverter.toUint8Array(params.salt)).update(BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();
        const blocks = [Buffer.alloc(0)];
        const blockCount = Math.ceil(byteLength2 / hashLength) + 1;
        for (let i10 = 1; i10 < blockCount; ++i10) {
          blocks.push(crypto__default.createHmac(hash, PRK).update(Buffer.concat([blocks[i10 - 1], info, Buffer.from([i10])])).digest());
        }
        return Buffer.concat(blocks).slice(0, byteLength2);
      }
      checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {
          throw new TypeError("key: Is not HKDF CryptoKey");
        }
      }
    };
    ShakeCrypto = class {
      static {
        __name(this, "ShakeCrypto");
      }
      static digest(algorithm, data) {
        const hash = crypto__default.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length }).update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
      }
    };
    Shake128Provider2 = class extends Shake128Provider {
      static {
        __name(this, "Shake128Provider");
      }
      async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
      }
    };
    Shake256Provider2 = class extends Shake256Provider {
      static {
        __name(this, "Shake256Provider");
      }
      async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
      }
    };
    SubtleCrypto2 = class extends SubtleCrypto {
      static {
        __name(this, "SubtleCrypto");
      }
      constructor() {
        var _a2;
        super();
        this.providers.set(new AesCbcProvider2());
        this.providers.set(new AesCtrProvider2());
        this.providers.set(new AesGcmProvider2());
        this.providers.set(new AesCmacProvider2());
        this.providers.set(new AesKwProvider2());
        this.providers.set(new AesEcbProvider2());
        this.providers.set(new DesCbcProvider());
        this.providers.set(new DesEde3CbcProvider());
        this.providers.set(new RsaSsaProvider2());
        this.providers.set(new RsaPssProvider2());
        this.providers.set(new RsaOaepProvider2());
        this.providers.set(new RsaEsProvider());
        this.providers.set(new EcdsaProvider2());
        this.providers.set(new EcdhProvider2());
        this.providers.set(new Sha1Provider());
        this.providers.set(new Sha256Provider());
        this.providers.set(new Sha384Provider());
        this.providers.set(new Sha512Provider());
        this.providers.set(new Pbkdf2Provider2());
        this.providers.set(new HmacProvider2());
        this.providers.set(new HkdfProvider2());
        const nodeMajorVersion = (_a2 = /^v(\d+)/.exec(process2.version)) === null || _a2 === void 0 ? void 0 : _a2[1];
        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {
          this.providers.set(new Shake128Provider2());
          this.providers.set(new Shake256Provider2());
        }
        const hashes = crypto2.getHashes();
        if (hashes.includes("sha3-256")) {
          this.providers.set(new Sha3256Provider());
        }
        if (hashes.includes("sha3-384")) {
          this.providers.set(new Sha3384Provider());
        }
        if (hashes.includes("sha3-512")) {
          this.providers.set(new Sha3512Provider());
        }
        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {
          this.providers.set(new EdDsaProvider2());
          this.providers.set(new EcdhEsProvider2());
        }
      }
    };
    Crypto2 = class extends Crypto {
      static {
        __name(this, "Crypto");
      }
      constructor() {
        super(...arguments);
        this.subtle = new SubtleCrypto2();
      }
      getRandomValues(array) {
        if (!ArrayBuffer.isView(array)) {
          throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");
        }
        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);
        crypto__default.randomFillSync(buffer);
        return array;
      }
    };
  }
});

// ../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/dist/runtime/node/crypto.js
var require_crypto2 = __commonJS({
  "../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/dist/runtime/node/crypto.js"(exports, module2) {
    var webcrypto;
    try {
      webcrypto = __require("node:crypto").webcrypto;
      if (!webcrypto) {
        webcrypto = new (init_webcrypto_es(), __toCommonJS(webcrypto_es_exports)).Crypto();
      }
    } catch (e10) {
      webcrypto = new (init_webcrypto_es(), __toCommonJS(webcrypto_es_exports)).Crypto();
    }
    module2.exports = webcrypto;
  }
});

// ../../node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs
var require_multipart_parser = __commonJS({
  "../../node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs"(exports) {
    "use strict";
    __require("node:fs");
    __require("node:path");
    var abortController = require_node_fetch_native_8afd3fea();
    __require("node:http");
    __require("node:https");
    __require("node:zlib");
    __require("node:stream");
    __require("node:buffer");
    __require("node:util");
    __require("node:url");
    __require("node:net");
    var s10 = 0;
    var S = {
      START_BOUNDARY: s10++,
      HEADER_FIELD_START: s10++,
      HEADER_FIELD: s10++,
      HEADER_VALUE_START: s10++,
      HEADER_VALUE: s10++,
      HEADER_VALUE_ALMOST_DONE: s10++,
      HEADERS_ALMOST_DONE: s10++,
      PART_DATA_START: s10++,
      PART_DATA: s10++,
      END: s10++
    };
    var f11 = 1;
    var F4 = {
      PART_BOUNDARY: f11,
      LAST_BOUNDARY: f11 *= 2
    };
    var LF = 10;
    var CR = 13;
    var SPACE3 = 32;
    var HYPHEN = 45;
    var COLON = 58;
    var A4 = 97;
    var Z = 122;
    var lower = /* @__PURE__ */ __name((c11) => c11 | 32, "lower");
    var noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    var MultipartParser = class {
      static {
        __name(this, "MultipartParser");
      }
      /**
       * @param {string} boundary
       */
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i10 = 0; i10 < boundary.length; i10++) {
          ui8a[i10] = boundary.charCodeAt(i10);
          this.boundaryChars[ui8a[i10]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      /**
       * @param {Uint8Array} data
       */
      write(data) {
        let i10 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index: index2, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c11;
        let cl;
        const mark = /* @__PURE__ */ __name((name2) => {
          this[name2 + "Mark"] = i10;
        }, "mark");
        const clear = /* @__PURE__ */ __name((name2) => {
          delete this[name2 + "Mark"];
        }, "clear");
        const callback = /* @__PURE__ */ __name((callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        }, "callback");
        const dataCallback = /* @__PURE__ */ __name((name2, clear2) => {
          const markSymbol = name2 + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name2, this[markSymbol], i10, data);
            delete this[markSymbol];
          } else {
            callback(name2, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        }, "dataCallback");
        for (i10 = 0; i10 < length_; i10++) {
          c11 = data[i10];
          switch (state) {
            case S.START_BOUNDARY:
              if (index2 === boundary.length - 2) {
                if (c11 === HYPHEN) {
                  flags |= F4.LAST_BOUNDARY;
                } else if (c11 !== CR) {
                  return;
                }
                index2++;
                break;
              } else if (index2 - 1 === boundary.length - 2) {
                if (flags & F4.LAST_BOUNDARY && c11 === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F4.LAST_BOUNDARY) && c11 === LF) {
                  index2 = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c11 !== boundary[index2 + 2]) {
                index2 = -2;
              }
              if (c11 === boundary[index2 + 2]) {
                index2++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index2 = 0;
            case S.HEADER_FIELD:
              if (c11 === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index2++;
              if (c11 === HYPHEN) {
                break;
              }
              if (c11 === COLON) {
                if (index2 === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c11);
              if (cl < A4 || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c11 === SPACE3) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c11 === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c11 !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c11 !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index2;
              if (index2 === 0) {
                i10 += boundaryEnd;
                while (i10 < bufferLength && !(data[i10] in boundaryChars)) {
                  i10 += boundaryLength;
                }
                i10 -= boundaryEnd;
                c11 = data[i10];
              }
              if (index2 < boundary.length) {
                if (boundary[index2] === c11) {
                  if (index2 === 0) {
                    dataCallback("onPartData", true);
                  }
                  index2++;
                } else {
                  index2 = 0;
                }
              } else if (index2 === boundary.length) {
                index2++;
                if (c11 === CR) {
                  flags |= F4.PART_BOUNDARY;
                } else if (c11 === HYPHEN) {
                  flags |= F4.LAST_BOUNDARY;
                } else {
                  index2 = 0;
                }
              } else if (index2 - 1 === boundary.length) {
                if (flags & F4.PART_BOUNDARY) {
                  index2 = 0;
                  if (c11 === LF) {
                    flags &= ~F4.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F4.LAST_BOUNDARY) {
                  if (c11 === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index2 = 0;
                  }
                } else {
                  index2 = 0;
                }
              }
              if (index2 > 0) {
                lookbehind[index2 - 1] = c11;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i10--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index2;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
    function _fileName(headerValue) {
      const m11 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
      if (!m11) {
        return;
      }
      const match = m11[2] || m11[3] || "";
      let filename = match.slice(match.lastIndexOf("\\") + 1);
      filename = filename.replace(/%22/g, '"');
      filename = filename.replace(/&#(\d{4});/g, (m12, code2) => {
        return String.fromCharCode(code2);
      });
      return filename;
    }
    __name(_fileName, "_fileName");
    async function toFormData(Body2, ct) {
      if (!/multipart/i.test(ct)) {
        throw new TypeError("Failed to fetch");
      }
      const m11 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
      if (!m11) {
        throw new TypeError("no or bad content-type header, no multipart boundary");
      }
      const parser = new MultipartParser(m11[1] || m11[2]);
      let headerField;
      let headerValue;
      let entryValue;
      let entryName;
      let contentType;
      let filename;
      const entryChunks = [];
      const formData = new abortController.FormData();
      const onPartData = /* @__PURE__ */ __name((ui8a) => {
        entryValue += decoder2.decode(ui8a, { stream: true });
      }, "onPartData");
      const appendToFile = /* @__PURE__ */ __name((ui8a) => {
        entryChunks.push(ui8a);
      }, "appendToFile");
      const appendFileToFormData = /* @__PURE__ */ __name(() => {
        const file = new abortController.File(entryChunks, filename, { type: contentType });
        formData.append(entryName, file);
      }, "appendFileToFormData");
      const appendEntryToFormData = /* @__PURE__ */ __name(() => {
        formData.append(entryName, entryValue);
      }, "appendEntryToFormData");
      const decoder2 = new TextDecoder("utf-8");
      decoder2.decode();
      parser.onPartBegin = function() {
        parser.onPartData = onPartData;
        parser.onPartEnd = appendEntryToFormData;
        headerField = "";
        headerValue = "";
        entryValue = "";
        entryName = "";
        contentType = "";
        filename = null;
        entryChunks.length = 0;
      };
      parser.onHeaderField = function(ui8a) {
        headerField += decoder2.decode(ui8a, { stream: true });
      };
      parser.onHeaderValue = function(ui8a) {
        headerValue += decoder2.decode(ui8a, { stream: true });
      };
      parser.onHeaderEnd = function() {
        headerValue += decoder2.decode();
        headerField = headerField.toLowerCase();
        if (headerField === "content-disposition") {
          const m12 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
          if (m12) {
            entryName = m12[2] || m12[3] || "";
          }
          filename = _fileName(headerValue);
          if (filename) {
            parser.onPartData = appendToFile;
            parser.onPartEnd = appendFileToFormData;
          }
        } else if (headerField === "content-type") {
          contentType = headerValue;
        }
        headerValue = "";
        headerField = "";
      };
      for await (const chunk of Body2) {
        parser.write(chunk);
      }
      parser.end();
      return formData;
    }
    __name(toFormData, "toFormData");
    exports.toFormData = toFormData;
  }
});

// ../../node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs
var require_node_fetch_native_8afd3fea = __commonJS({
  "../../node_modules/node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs"(exports) {
    "use strict";
    var http2 = __require("node:http");
    var https2 = __require("node:https");
    var zlib2 = __require("node:zlib");
    var Stream3 = __require("node:stream");
    var node_buffer = __require("node:buffer");
    var node_util = __require("node:util");
    var node_url = __require("node:url");
    var node_net = __require("node:net");
    __require("node:fs");
    __require("node:path");
    function dataUriToBuffer(uri) {
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base64 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i11 = 1; i11 < meta.length; i11++) {
        if (meta[i11] === "base64") {
          base64 = true;
        } else {
          typeFull += `;${meta[i11]}`;
          if (meta[i11].indexOf("charset=") === 0) {
            charset = meta[i11].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const encoding = base64 ? "base64" : "ascii";
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = Buffer.from(data, encoding);
      buffer.type = type;
      buffer.typeFull = typeFull;
      buffer.charset = charset;
      return buffer;
    }
    __name(dataUriToBuffer, "dataUriToBuffer");
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var ponyfill_es2018 = { exports: {} };
    var hasRequiredPonyfill_es2018;
    function requirePonyfill_es2018() {
      if (hasRequiredPonyfill_es2018)
        return ponyfill_es2018.exports;
      hasRequiredPonyfill_es2018 = 1;
      (function(module3, exports2) {
        (function(global2, factory) {
          factory(exports2);
        })(commonjsGlobal, function(exports3) {
          const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
          function noop() {
            return void 0;
          }
          __name(noop, "noop");
          function getGlobals() {
            if (typeof self !== "undefined") {
              return self;
            } else if (typeof window !== "undefined") {
              return window;
            } else if (typeof commonjsGlobal !== "undefined") {
              return commonjsGlobal;
            }
            return void 0;
          }
          __name(getGlobals, "getGlobals");
          const globals = getGlobals();
          function typeIsObject(x5) {
            return typeof x5 === "object" && x5 !== null || typeof x5 === "function";
          }
          __name(typeIsObject, "typeIsObject");
          const rethrowAssertionErrorRejection = noop;
          const originalPromise = Promise;
          const originalPromiseThen = Promise.prototype.then;
          const originalPromiseResolve = Promise.resolve.bind(originalPromise);
          const originalPromiseReject = Promise.reject.bind(originalPromise);
          function newPromise(executor) {
            return new originalPromise(executor);
          }
          __name(newPromise, "newPromise");
          function promiseResolvedWith(value) {
            return originalPromiseResolve(value);
          }
          __name(promiseResolvedWith, "promiseResolvedWith");
          function promiseRejectedWith(reason) {
            return originalPromiseReject(reason);
          }
          __name(promiseRejectedWith, "promiseRejectedWith");
          function PerformPromiseThen(promise, onFulfilled, onRejected) {
            return originalPromiseThen.call(promise, onFulfilled, onRejected);
          }
          __name(PerformPromiseThen, "PerformPromiseThen");
          function uponPromise(promise, onFulfilled, onRejected) {
            PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
          }
          __name(uponPromise, "uponPromise");
          function uponFulfillment(promise, onFulfilled) {
            uponPromise(promise, onFulfilled);
          }
          __name(uponFulfillment, "uponFulfillment");
          function uponRejection(promise, onRejected) {
            uponPromise(promise, void 0, onRejected);
          }
          __name(uponRejection, "uponRejection");
          function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
            return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
          }
          __name(transformPromiseWith, "transformPromiseWith");
          function setPromiseIsHandledToTrue(promise) {
            PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
          }
          __name(setPromiseIsHandledToTrue, "setPromiseIsHandledToTrue");
          const queueMicrotask2 = (() => {
            const globalQueueMicrotask = globals && globals.queueMicrotask;
            if (typeof globalQueueMicrotask === "function") {
              return globalQueueMicrotask;
            }
            const resolvedPromise = promiseResolvedWith(void 0);
            return (fn) => PerformPromiseThen(resolvedPromise, fn);
          })();
          function reflectCall(F4, V, args) {
            if (typeof F4 !== "function") {
              throw new TypeError("Argument is not a function");
            }
            return Function.prototype.apply.call(F4, V, args);
          }
          __name(reflectCall, "reflectCall");
          function promiseCall(F4, V, args) {
            try {
              return promiseResolvedWith(reflectCall(F4, V, args));
            } catch (value) {
              return promiseRejectedWith(value);
            }
          }
          __name(promiseCall, "promiseCall");
          const QUEUE_MAX_ARRAY_SIZE = 16384;
          class SimpleQueue {
            static {
              __name(this, "SimpleQueue");
            }
            constructor() {
              this._cursor = 0;
              this._size = 0;
              this._front = {
                _elements: [],
                _next: void 0
              };
              this._back = this._front;
              this._cursor = 0;
              this._size = 0;
            }
            get length() {
              return this._size;
            }
            // For exception safety, this method is structured in order:
            // 1. Read state
            // 2. Calculate required state mutations
            // 3. Perform state mutations
            push(element) {
              const oldBack = this._back;
              let newBack = oldBack;
              if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                  _elements: [],
                  _next: void 0
                };
              }
              oldBack._elements.push(element);
              if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
              }
              ++this._size;
            }
            // Like push(), shift() follows the read -> calculate -> mutate pattern for
            // exception safety.
            shift() {
              const oldFront = this._front;
              let newFront = oldFront;
              const oldCursor = this._cursor;
              let newCursor = oldCursor + 1;
              const elements = oldFront._elements;
              const element = elements[oldCursor];
              if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
              }
              --this._size;
              this._cursor = newCursor;
              if (oldFront !== newFront) {
                this._front = newFront;
              }
              elements[oldCursor] = void 0;
              return element;
            }
            // The tricky thing about forEach() is that it can be called
            // re-entrantly. The queue may be mutated inside the callback. It is easy to
            // see that push() within the callback has no negative effects since the end
            // of the queue is checked for on every iteration. If shift() is called
            // repeatedly within the callback then the next iteration may return an
            // element that has been removed. In this case the callback will be called
            // with undefined values until we either "catch up" with elements that still
            // exist or reach the back of the queue.
            forEach(callback) {
              let i11 = this._cursor;
              let node = this._front;
              let elements = node._elements;
              while (i11 !== elements.length || node._next !== void 0) {
                if (i11 === elements.length) {
                  node = node._next;
                  elements = node._elements;
                  i11 = 0;
                  if (elements.length === 0) {
                    break;
                  }
                }
                callback(elements[i11]);
                ++i11;
              }
            }
            // Return the element that would be returned if shift() was called now,
            // without modifying the queue.
            peek() {
              const front = this._front;
              const cursor = this._cursor;
              return front._elements[cursor];
            }
          }
          function ReadableStreamReaderGenericInitialize(reader, stream) {
            reader._ownerReadableStream = stream;
            stream._reader = reader;
            if (stream._state === "readable") {
              defaultReaderClosedPromiseInitialize(reader);
            } else if (stream._state === "closed") {
              defaultReaderClosedPromiseInitializeAsResolved(reader);
            } else {
              defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
            }
          }
          __name(ReadableStreamReaderGenericInitialize, "ReadableStreamReaderGenericInitialize");
          function ReadableStreamReaderGenericCancel(reader, reason) {
            const stream = reader._ownerReadableStream;
            return ReadableStreamCancel(stream, reason);
          }
          __name(ReadableStreamReaderGenericCancel, "ReadableStreamReaderGenericCancel");
          function ReadableStreamReaderGenericRelease(reader) {
            if (reader._ownerReadableStream._state === "readable") {
              defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
            } else {
              defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
            }
            reader._ownerReadableStream._reader = void 0;
            reader._ownerReadableStream = void 0;
          }
          __name(ReadableStreamReaderGenericRelease, "ReadableStreamReaderGenericRelease");
          function readerLockException(name2) {
            return new TypeError("Cannot " + name2 + " a stream using a released reader");
          }
          __name(readerLockException, "readerLockException");
          function defaultReaderClosedPromiseInitialize(reader) {
            reader._closedPromise = newPromise((resolve, reject) => {
              reader._closedPromise_resolve = resolve;
              reader._closedPromise_reject = reject;
            });
          }
          __name(defaultReaderClosedPromiseInitialize, "defaultReaderClosedPromiseInitialize");
          function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
            defaultReaderClosedPromiseInitialize(reader);
            defaultReaderClosedPromiseReject(reader, reason);
          }
          __name(defaultReaderClosedPromiseInitializeAsRejected, "defaultReaderClosedPromiseInitializeAsRejected");
          function defaultReaderClosedPromiseInitializeAsResolved(reader) {
            defaultReaderClosedPromiseInitialize(reader);
            defaultReaderClosedPromiseResolve(reader);
          }
          __name(defaultReaderClosedPromiseInitializeAsResolved, "defaultReaderClosedPromiseInitializeAsResolved");
          function defaultReaderClosedPromiseReject(reader, reason) {
            if (reader._closedPromise_reject === void 0) {
              return;
            }
            setPromiseIsHandledToTrue(reader._closedPromise);
            reader._closedPromise_reject(reason);
            reader._closedPromise_resolve = void 0;
            reader._closedPromise_reject = void 0;
          }
          __name(defaultReaderClosedPromiseReject, "defaultReaderClosedPromiseReject");
          function defaultReaderClosedPromiseResetToRejected(reader, reason) {
            defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
          }
          __name(defaultReaderClosedPromiseResetToRejected, "defaultReaderClosedPromiseResetToRejected");
          function defaultReaderClosedPromiseResolve(reader) {
            if (reader._closedPromise_resolve === void 0) {
              return;
            }
            reader._closedPromise_resolve(void 0);
            reader._closedPromise_resolve = void 0;
            reader._closedPromise_reject = void 0;
          }
          __name(defaultReaderClosedPromiseResolve, "defaultReaderClosedPromiseResolve");
          const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
          const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
          const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
          const PullSteps = SymbolPolyfill("[[PullSteps]]");
          const NumberIsFinite = Number.isFinite || function(x5) {
            return typeof x5 === "number" && isFinite(x5);
          };
          const MathTrunc = Math.trunc || function(v7) {
            return v7 < 0 ? Math.ceil(v7) : Math.floor(v7);
          };
          function isDictionary(x5) {
            return typeof x5 === "object" || typeof x5 === "function";
          }
          __name(isDictionary, "isDictionary");
          function assertDictionary(obj, context8) {
            if (obj !== void 0 && !isDictionary(obj)) {
              throw new TypeError(`${context8} is not an object.`);
            }
          }
          __name(assertDictionary, "assertDictionary");
          function assertFunction(x5, context8) {
            if (typeof x5 !== "function") {
              throw new TypeError(`${context8} is not a function.`);
            }
          }
          __name(assertFunction, "assertFunction");
          function isObject3(x5) {
            return typeof x5 === "object" && x5 !== null || typeof x5 === "function";
          }
          __name(isObject3, "isObject");
          function assertObject(x5, context8) {
            if (!isObject3(x5)) {
              throw new TypeError(`${context8} is not an object.`);
            }
          }
          __name(assertObject, "assertObject");
          function assertRequiredArgument(x5, position, context8) {
            if (x5 === void 0) {
              throw new TypeError(`Parameter ${position} is required in '${context8}'.`);
            }
          }
          __name(assertRequiredArgument, "assertRequiredArgument");
          function assertRequiredField(x5, field, context8) {
            if (x5 === void 0) {
              throw new TypeError(`${field} is required in '${context8}'.`);
            }
          }
          __name(assertRequiredField, "assertRequiredField");
          function convertUnrestrictedDouble(value) {
            return Number(value);
          }
          __name(convertUnrestrictedDouble, "convertUnrestrictedDouble");
          function censorNegativeZero(x5) {
            return x5 === 0 ? 0 : x5;
          }
          __name(censorNegativeZero, "censorNegativeZero");
          function integerPart(x5) {
            return censorNegativeZero(MathTrunc(x5));
          }
          __name(integerPart, "integerPart");
          function convertUnsignedLongLongWithEnforceRange(value, context8) {
            const lowerBound = 0;
            const upperBound = Number.MAX_SAFE_INTEGER;
            let x5 = Number(value);
            x5 = censorNegativeZero(x5);
            if (!NumberIsFinite(x5)) {
              throw new TypeError(`${context8} is not a finite number`);
            }
            x5 = integerPart(x5);
            if (x5 < lowerBound || x5 > upperBound) {
              throw new TypeError(`${context8} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
            }
            if (!NumberIsFinite(x5) || x5 === 0) {
              return 0;
            }
            return x5;
          }
          __name(convertUnsignedLongLongWithEnforceRange, "convertUnsignedLongLongWithEnforceRange");
          function assertReadableStream(x5, context8) {
            if (!IsReadableStream(x5)) {
              throw new TypeError(`${context8} is not a ReadableStream.`);
            }
          }
          __name(assertReadableStream, "assertReadableStream");
          function AcquireReadableStreamDefaultReader(stream) {
            return new ReadableStreamDefaultReader(stream);
          }
          __name(AcquireReadableStreamDefaultReader, "AcquireReadableStreamDefaultReader");
          function ReadableStreamAddReadRequest(stream, readRequest) {
            stream._reader._readRequests.push(readRequest);
          }
          __name(ReadableStreamAddReadRequest, "ReadableStreamAddReadRequest");
          function ReadableStreamFulfillReadRequest(stream, chunk, done) {
            const reader = stream._reader;
            const readRequest = reader._readRequests.shift();
            if (done) {
              readRequest._closeSteps();
            } else {
              readRequest._chunkSteps(chunk);
            }
          }
          __name(ReadableStreamFulfillReadRequest, "ReadableStreamFulfillReadRequest");
          function ReadableStreamGetNumReadRequests(stream) {
            return stream._reader._readRequests.length;
          }
          __name(ReadableStreamGetNumReadRequests, "ReadableStreamGetNumReadRequests");
          function ReadableStreamHasDefaultReader(stream) {
            const reader = stream._reader;
            if (reader === void 0) {
              return false;
            }
            if (!IsReadableStreamDefaultReader(reader)) {
              return false;
            }
            return true;
          }
          __name(ReadableStreamHasDefaultReader, "ReadableStreamHasDefaultReader");
          class ReadableStreamDefaultReader {
            static {
              __name(this, "ReadableStreamDefaultReader");
            }
            constructor(stream) {
              assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
              assertReadableStream(stream, "First parameter");
              if (IsReadableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              }
              ReadableStreamReaderGenericInitialize(this, stream);
              this._readRequests = new SimpleQueue();
            }
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get closed() {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            }
            /**
             * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
             */
            cancel(reason = void 0) {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
              }
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("cancel"));
              }
              return ReadableStreamReaderGenericCancel(this, reason);
            }
            /**
             * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
             *
             * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
             */
            read() {
              if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("read"));
              }
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("read from"));
              }
              let resolvePromise;
              let rejectPromise;
              const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
              });
              const readRequest = {
                _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
                _closeSteps: () => resolvePromise({ value: void 0, done: true }),
                _errorSteps: (e11) => rejectPromise(e11)
              };
              ReadableStreamDefaultReaderRead(this, readRequest);
              return promise;
            }
            /**
             * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
             * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
             * from now on; otherwise, the reader will appear closed.
             *
             * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
             * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
             * do so will throw a `TypeError` and leave the reader locked to the stream.
             */
            releaseLock() {
              if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException("releaseLock");
              }
              if (this._ownerReadableStream === void 0) {
                return;
              }
              if (this._readRequests.length > 0) {
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              }
              ReadableStreamReaderGenericRelease(this);
            }
          }
          Object.defineProperties(ReadableStreamDefaultReader.prototype, {
            cancel: { enumerable: true },
            read: { enumerable: true },
            releaseLock: { enumerable: true },
            closed: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
              value: "ReadableStreamDefaultReader",
              configurable: true
            });
          }
          function IsReadableStreamDefaultReader(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_readRequests")) {
              return false;
            }
            return x5 instanceof ReadableStreamDefaultReader;
          }
          __name(IsReadableStreamDefaultReader, "IsReadableStreamDefaultReader");
          function ReadableStreamDefaultReaderRead(reader, readRequest) {
            const stream = reader._ownerReadableStream;
            stream._disturbed = true;
            if (stream._state === "closed") {
              readRequest._closeSteps();
            } else if (stream._state === "errored") {
              readRequest._errorSteps(stream._storedError);
            } else {
              stream._readableStreamController[PullSteps](readRequest);
            }
          }
          __name(ReadableStreamDefaultReaderRead, "ReadableStreamDefaultReaderRead");
          function defaultReaderBrandCheckException(name2) {
            return new TypeError(`ReadableStreamDefaultReader.prototype.${name2} can only be used on a ReadableStreamDefaultReader`);
          }
          __name(defaultReaderBrandCheckException, "defaultReaderBrandCheckException");
          const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
          }).prototype);
          class ReadableStreamAsyncIteratorImpl {
            static {
              __name(this, "ReadableStreamAsyncIteratorImpl");
            }
            constructor(reader, preventCancel) {
              this._ongoingPromise = void 0;
              this._isFinished = false;
              this._reader = reader;
              this._preventCancel = preventCancel;
            }
            next() {
              const nextSteps = /* @__PURE__ */ __name(() => this._nextSteps(), "nextSteps");
              this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
              return this._ongoingPromise;
            }
            return(value) {
              const returnSteps = /* @__PURE__ */ __name(() => this._returnSteps(value), "returnSteps");
              return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
            }
            _nextSteps() {
              if (this._isFinished) {
                return Promise.resolve({ value: void 0, done: true });
              }
              const reader = this._reader;
              if (reader._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("iterate"));
              }
              let resolvePromise;
              let rejectPromise;
              const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
              });
              const readRequest = {
                _chunkSteps: (chunk) => {
                  this._ongoingPromise = void 0;
                  queueMicrotask2(() => resolvePromise({ value: chunk, done: false }));
                },
                _closeSteps: () => {
                  this._ongoingPromise = void 0;
                  this._isFinished = true;
                  ReadableStreamReaderGenericRelease(reader);
                  resolvePromise({ value: void 0, done: true });
                },
                _errorSteps: (reason) => {
                  this._ongoingPromise = void 0;
                  this._isFinished = true;
                  ReadableStreamReaderGenericRelease(reader);
                  rejectPromise(reason);
                }
              };
              ReadableStreamDefaultReaderRead(reader, readRequest);
              return promise;
            }
            _returnSteps(value) {
              if (this._isFinished) {
                return Promise.resolve({ value, done: true });
              }
              this._isFinished = true;
              const reader = this._reader;
              if (reader._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("finish iterating"));
              }
              if (!this._preventCancel) {
                const result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, () => ({ value, done: true }));
              }
              ReadableStreamReaderGenericRelease(reader);
              return promiseResolvedWith({ value, done: true });
            }
          }
          const ReadableStreamAsyncIteratorPrototype = {
            next() {
              if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
              }
              return this._asyncIteratorImpl.next();
            },
            return(value) {
              if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
              }
              return this._asyncIteratorImpl.return(value);
            }
          };
          if (AsyncIteratorPrototype !== void 0) {
            Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
          }
          function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
            const reader = AcquireReadableStreamDefaultReader(stream);
            const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
            const iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype);
            iterator2._asyncIteratorImpl = impl;
            return iterator2;
          }
          __name(AcquireReadableStreamAsyncIterator, "AcquireReadableStreamAsyncIterator");
          function IsReadableStreamAsyncIterator(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_asyncIteratorImpl")) {
              return false;
            }
            try {
              return x5._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
            } catch (_a2) {
              return false;
            }
          }
          __name(IsReadableStreamAsyncIterator, "IsReadableStreamAsyncIterator");
          function streamAsyncIteratorBrandCheckException(name2) {
            return new TypeError(`ReadableStreamAsyncIterator.${name2} can only be used on a ReadableSteamAsyncIterator`);
          }
          __name(streamAsyncIteratorBrandCheckException, "streamAsyncIteratorBrandCheckException");
          const NumberIsNaN = Number.isNaN || function(x5) {
            return x5 !== x5;
          };
          function CreateArrayFromList(elements) {
            return elements.slice();
          }
          __name(CreateArrayFromList, "CreateArrayFromList");
          function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n10) {
            new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n10), destOffset);
          }
          __name(CopyDataBlockBytes, "CopyDataBlockBytes");
          function TransferArrayBuffer(O) {
            return O;
          }
          __name(TransferArrayBuffer, "TransferArrayBuffer");
          function IsDetachedBuffer(O) {
            return false;
          }
          __name(IsDetachedBuffer, "IsDetachedBuffer");
          function ArrayBufferSlice(buffer, begin, end) {
            if (buffer.slice) {
              return buffer.slice(begin, end);
            }
            const length = end - begin;
            const slice = new ArrayBuffer(length);
            CopyDataBlockBytes(slice, 0, buffer, begin, length);
            return slice;
          }
          __name(ArrayBufferSlice, "ArrayBufferSlice");
          function IsNonNegativeNumber(v7) {
            if (typeof v7 !== "number") {
              return false;
            }
            if (NumberIsNaN(v7)) {
              return false;
            }
            if (v7 < 0) {
              return false;
            }
            return true;
          }
          __name(IsNonNegativeNumber, "IsNonNegativeNumber");
          function CloneAsUint8Array(O) {
            const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
            return new Uint8Array(buffer);
          }
          __name(CloneAsUint8Array, "CloneAsUint8Array");
          function DequeueValue(container) {
            const pair = container._queue.shift();
            container._queueTotalSize -= pair.size;
            if (container._queueTotalSize < 0) {
              container._queueTotalSize = 0;
            }
            return pair.value;
          }
          __name(DequeueValue, "DequeueValue");
          function EnqueueValueWithSize(container, value, size) {
            if (!IsNonNegativeNumber(size) || size === Infinity) {
              throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
            }
            container._queue.push({ value, size });
            container._queueTotalSize += size;
          }
          __name(EnqueueValueWithSize, "EnqueueValueWithSize");
          function PeekQueueValue(container) {
            const pair = container._queue.peek();
            return pair.value;
          }
          __name(PeekQueueValue, "PeekQueueValue");
          function ResetQueue(container) {
            container._queue = new SimpleQueue();
            container._queueTotalSize = 0;
          }
          __name(ResetQueue, "ResetQueue");
          class ReadableStreamBYOBRequest {
            static {
              __name(this, "ReadableStreamBYOBRequest");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get view() {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("view");
              }
              return this._view;
            }
            respond(bytesWritten) {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("respond");
              }
              assertRequiredArgument(bytesWritten, 1, "respond");
              bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
              if (this._associatedReadableByteStreamController === void 0) {
                throw new TypeError("This BYOB request has been invalidated");
              }
              if (IsDetachedBuffer(this._view.buffer))
                ;
              ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
            }
            respondWithNewView(view2) {
              if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("respondWithNewView");
              }
              assertRequiredArgument(view2, 1, "respondWithNewView");
              if (!ArrayBuffer.isView(view2)) {
                throw new TypeError("You can only respond with array buffer views");
              }
              if (this._associatedReadableByteStreamController === void 0) {
                throw new TypeError("This BYOB request has been invalidated");
              }
              if (IsDetachedBuffer(view2.buffer))
                ;
              ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view2);
            }
          }
          Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
            respond: { enumerable: true },
            respondWithNewView: { enumerable: true },
            view: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
              value: "ReadableStreamBYOBRequest",
              configurable: true
            });
          }
          class ReadableByteStreamController {
            static {
              __name(this, "ReadableByteStreamController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get byobRequest() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("byobRequest");
              }
              return ReadableByteStreamControllerGetBYOBRequest(this);
            }
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get desiredSize() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("desiredSize");
              }
              return ReadableByteStreamControllerGetDesiredSize(this);
            }
            /**
             * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
             * the stream, but once those are read, the stream will become closed.
             */
            close() {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("close");
              }
              if (this._closeRequested) {
                throw new TypeError("The stream has already been closed; do not close it again!");
              }
              const state = this._controlledReadableByteStream._state;
              if (state !== "readable") {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
              }
              ReadableByteStreamControllerClose(this);
            }
            enqueue(chunk) {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("enqueue");
              }
              assertRequiredArgument(chunk, 1, "enqueue");
              if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError("chunk must be an array buffer view");
              }
              if (chunk.byteLength === 0) {
                throw new TypeError("chunk must have non-zero byteLength");
              }
              if (chunk.buffer.byteLength === 0) {
                throw new TypeError(`chunk's buffer must have non-zero byteLength`);
              }
              if (this._closeRequested) {
                throw new TypeError("stream is closed or draining");
              }
              const state = this._controlledReadableByteStream._state;
              if (state !== "readable") {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
              }
              ReadableByteStreamControllerEnqueue(this, chunk);
            }
            /**
             * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
             */
            error(e11 = void 0) {
              if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("error");
              }
              ReadableByteStreamControllerError(this, e11);
            }
            /** @internal */
            [CancelSteps](reason) {
              ReadableByteStreamControllerClearPendingPullIntos(this);
              ResetQueue(this);
              const result = this._cancelAlgorithm(reason);
              ReadableByteStreamControllerClearAlgorithms(this);
              return result;
            }
            /** @internal */
            [PullSteps](readRequest) {
              const stream = this._controlledReadableByteStream;
              if (this._queueTotalSize > 0) {
                const entry = this._queue.shift();
                this._queueTotalSize -= entry.byteLength;
                ReadableByteStreamControllerHandleQueueDrain(this);
                const view2 = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                readRequest._chunkSteps(view2);
                return;
              }
              const autoAllocateChunkSize = this._autoAllocateChunkSize;
              if (autoAllocateChunkSize !== void 0) {
                let buffer;
                try {
                  buffer = new ArrayBuffer(autoAllocateChunkSize);
                } catch (bufferE) {
                  readRequest._errorSteps(bufferE);
                  return;
                }
                const pullIntoDescriptor = {
                  buffer,
                  bufferByteLength: autoAllocateChunkSize,
                  byteOffset: 0,
                  byteLength: autoAllocateChunkSize,
                  bytesFilled: 0,
                  elementSize: 1,
                  viewConstructor: Uint8Array,
                  readerType: "default"
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
              }
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableByteStreamControllerCallPullIfNeeded(this);
            }
          }
          Object.defineProperties(ReadableByteStreamController.prototype, {
            close: { enumerable: true },
            enqueue: { enumerable: true },
            error: { enumerable: true },
            byobRequest: { enumerable: true },
            desiredSize: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
              value: "ReadableByteStreamController",
              configurable: true
            });
          }
          function IsReadableByteStreamController(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_controlledReadableByteStream")) {
              return false;
            }
            return x5 instanceof ReadableByteStreamController;
          }
          __name(IsReadableByteStreamController, "IsReadableByteStreamController");
          function IsReadableStreamBYOBRequest(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_associatedReadableByteStreamController")) {
              return false;
            }
            return x5 instanceof ReadableStreamBYOBRequest;
          }
          __name(IsReadableStreamBYOBRequest, "IsReadableStreamBYOBRequest");
          function ReadableByteStreamControllerCallPullIfNeeded(controller) {
            const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
            if (!shouldPull) {
              return;
            }
            if (controller._pulling) {
              controller._pullAgain = true;
              return;
            }
            controller._pulling = true;
            const pullPromise = controller._pullAlgorithm();
            uponPromise(pullPromise, () => {
              controller._pulling = false;
              if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableByteStreamControllerCallPullIfNeeded(controller);
              }
            }, (e11) => {
              ReadableByteStreamControllerError(controller, e11);
            });
          }
          __name(ReadableByteStreamControllerCallPullIfNeeded, "ReadableByteStreamControllerCallPullIfNeeded");
          function ReadableByteStreamControllerClearPendingPullIntos(controller) {
            ReadableByteStreamControllerInvalidateBYOBRequest(controller);
            controller._pendingPullIntos = new SimpleQueue();
          }
          __name(ReadableByteStreamControllerClearPendingPullIntos, "ReadableByteStreamControllerClearPendingPullIntos");
          function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
            let done = false;
            if (stream._state === "closed") {
              done = true;
            }
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            if (pullIntoDescriptor.readerType === "default") {
              ReadableStreamFulfillReadRequest(stream, filledView, done);
            } else {
              ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
            }
          }
          __name(ReadableByteStreamControllerCommitPullIntoDescriptor, "ReadableByteStreamControllerCommitPullIntoDescriptor");
          function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
            const bytesFilled = pullIntoDescriptor.bytesFilled;
            const elementSize = pullIntoDescriptor.elementSize;
            return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
          }
          __name(ReadableByteStreamControllerConvertPullIntoDescriptor, "ReadableByteStreamControllerConvertPullIntoDescriptor");
          function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength2) {
            controller._queue.push({ buffer, byteOffset, byteLength: byteLength2 });
            controller._queueTotalSize += byteLength2;
          }
          __name(ReadableByteStreamControllerEnqueueChunkToQueue, "ReadableByteStreamControllerEnqueueChunkToQueue");
          function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
            const elementSize = pullIntoDescriptor.elementSize;
            const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
            const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
            const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
            const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
            let totalBytesToCopyRemaining = maxBytesToCopy;
            let ready = false;
            if (maxAlignedBytes > currentAlignedBytes) {
              totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
              ready = true;
            }
            const queue = controller._queue;
            while (totalBytesToCopyRemaining > 0) {
              const headOfQueue = queue.peek();
              const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
              const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
              CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
              if (headOfQueue.byteLength === bytesToCopy) {
                queue.shift();
              } else {
                headOfQueue.byteOffset += bytesToCopy;
                headOfQueue.byteLength -= bytesToCopy;
              }
              controller._queueTotalSize -= bytesToCopy;
              ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
              totalBytesToCopyRemaining -= bytesToCopy;
            }
            return ready;
          }
          __name(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue, "ReadableByteStreamControllerFillPullIntoDescriptorFromQueue");
          function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
            pullIntoDescriptor.bytesFilled += size;
          }
          __name(ReadableByteStreamControllerFillHeadPullIntoDescriptor, "ReadableByteStreamControllerFillHeadPullIntoDescriptor");
          function ReadableByteStreamControllerHandleQueueDrain(controller) {
            if (controller._queueTotalSize === 0 && controller._closeRequested) {
              ReadableByteStreamControllerClearAlgorithms(controller);
              ReadableStreamClose(controller._controlledReadableByteStream);
            } else {
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }
          __name(ReadableByteStreamControllerHandleQueueDrain, "ReadableByteStreamControllerHandleQueueDrain");
          function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
            if (controller._byobRequest === null) {
              return;
            }
            controller._byobRequest._associatedReadableByteStreamController = void 0;
            controller._byobRequest._view = null;
            controller._byobRequest = null;
          }
          __name(ReadableByteStreamControllerInvalidateBYOBRequest, "ReadableByteStreamControllerInvalidateBYOBRequest");
          function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
            while (controller._pendingPullIntos.length > 0) {
              if (controller._queueTotalSize === 0) {
                return;
              }
              const pullIntoDescriptor = controller._pendingPullIntos.peek();
              if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
              }
            }
          }
          __name(ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue, "ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue");
          function ReadableByteStreamControllerPullInto(controller, view2, readIntoRequest) {
            const stream = controller._controlledReadableByteStream;
            let elementSize = 1;
            if (view2.constructor !== DataView) {
              elementSize = view2.constructor.BYTES_PER_ELEMENT;
            }
            const ctor = view2.constructor;
            const buffer = TransferArrayBuffer(view2.buffer);
            const pullIntoDescriptor = {
              buffer,
              bufferByteLength: buffer.byteLength,
              byteOffset: view2.byteOffset,
              byteLength: view2.byteLength,
              bytesFilled: 0,
              elementSize,
              viewConstructor: ctor,
              readerType: "byob"
            };
            if (controller._pendingPullIntos.length > 0) {
              controller._pendingPullIntos.push(pullIntoDescriptor);
              ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
              return;
            }
            if (stream._state === "closed") {
              const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
              readIntoRequest._closeSteps(emptyView);
              return;
            }
            if (controller._queueTotalSize > 0) {
              if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                ReadableByteStreamControllerHandleQueueDrain(controller);
                readIntoRequest._chunkSteps(filledView);
                return;
              }
              if (controller._closeRequested) {
                const e11 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                ReadableByteStreamControllerError(controller, e11);
                readIntoRequest._errorSteps(e11);
                return;
              }
            }
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          __name(ReadableByteStreamControllerPullInto, "ReadableByteStreamControllerPullInto");
          function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
            const stream = controller._controlledReadableByteStream;
            if (ReadableStreamHasBYOBReader(stream)) {
              while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
              }
            }
          }
          __name(ReadableByteStreamControllerRespondInClosedState, "ReadableByteStreamControllerRespondInClosedState");
          function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
            if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
              return;
            }
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
            if (remainderSize > 0) {
              const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
              const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
            }
            pullIntoDescriptor.bytesFilled -= remainderSize;
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          }
          __name(ReadableByteStreamControllerRespondInReadableState, "ReadableByteStreamControllerRespondInReadableState");
          function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            ReadableByteStreamControllerInvalidateBYOBRequest(controller);
            const state = controller._controlledReadableByteStream._state;
            if (state === "closed") {
              ReadableByteStreamControllerRespondInClosedState(controller);
            } else {
              ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
            }
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          __name(ReadableByteStreamControllerRespondInternal, "ReadableByteStreamControllerRespondInternal");
          function ReadableByteStreamControllerShiftPendingPullInto(controller) {
            const descriptor = controller._pendingPullIntos.shift();
            return descriptor;
          }
          __name(ReadableByteStreamControllerShiftPendingPullInto, "ReadableByteStreamControllerShiftPendingPullInto");
          function ReadableByteStreamControllerShouldCallPull(controller) {
            const stream = controller._controlledReadableByteStream;
            if (stream._state !== "readable") {
              return false;
            }
            if (controller._closeRequested) {
              return false;
            }
            if (!controller._started) {
              return false;
            }
            if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
              return true;
            }
            if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              return true;
            }
            const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
            if (desiredSize > 0) {
              return true;
            }
            return false;
          }
          __name(ReadableByteStreamControllerShouldCallPull, "ReadableByteStreamControllerShouldCallPull");
          function ReadableByteStreamControllerClearAlgorithms(controller) {
            controller._pullAlgorithm = void 0;
            controller._cancelAlgorithm = void 0;
          }
          __name(ReadableByteStreamControllerClearAlgorithms, "ReadableByteStreamControllerClearAlgorithms");
          function ReadableByteStreamControllerClose(controller) {
            const stream = controller._controlledReadableByteStream;
            if (controller._closeRequested || stream._state !== "readable") {
              return;
            }
            if (controller._queueTotalSize > 0) {
              controller._closeRequested = true;
              return;
            }
            if (controller._pendingPullIntos.length > 0) {
              const firstPendingPullInto = controller._pendingPullIntos.peek();
              if (firstPendingPullInto.bytesFilled > 0) {
                const e11 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                ReadableByteStreamControllerError(controller, e11);
                throw e11;
              }
            }
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
          __name(ReadableByteStreamControllerClose, "ReadableByteStreamControllerClose");
          function ReadableByteStreamControllerEnqueue(controller, chunk) {
            const stream = controller._controlledReadableByteStream;
            if (controller._closeRequested || stream._state !== "readable") {
              return;
            }
            const buffer = chunk.buffer;
            const byteOffset = chunk.byteOffset;
            const byteLength2 = chunk.byteLength;
            const transferredBuffer = TransferArrayBuffer(buffer);
            if (controller._pendingPullIntos.length > 0) {
              const firstPendingPullInto = controller._pendingPullIntos.peek();
              if (IsDetachedBuffer(firstPendingPullInto.buffer))
                ;
              firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
            }
            ReadableByteStreamControllerInvalidateBYOBRequest(controller);
            if (ReadableStreamHasDefaultReader(stream)) {
              if (ReadableStreamGetNumReadRequests(stream) === 0) {
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength2);
              } else {
                if (controller._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerShiftPendingPullInto(controller);
                }
                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength2);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
              }
            } else if (ReadableStreamHasBYOBReader(stream)) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength2);
              ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
            } else {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength2);
            }
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          __name(ReadableByteStreamControllerEnqueue, "ReadableByteStreamControllerEnqueue");
          function ReadableByteStreamControllerError(controller, e11) {
            const stream = controller._controlledReadableByteStream;
            if (stream._state !== "readable") {
              return;
            }
            ReadableByteStreamControllerClearPendingPullIntos(controller);
            ResetQueue(controller);
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamError(stream, e11);
          }
          __name(ReadableByteStreamControllerError, "ReadableByteStreamControllerError");
          function ReadableByteStreamControllerGetBYOBRequest(controller) {
            if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
              const firstDescriptor = controller._pendingPullIntos.peek();
              const view2 = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
              const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
              SetUpReadableStreamBYOBRequest(byobRequest, controller, view2);
              controller._byobRequest = byobRequest;
            }
            return controller._byobRequest;
          }
          __name(ReadableByteStreamControllerGetBYOBRequest, "ReadableByteStreamControllerGetBYOBRequest");
          function ReadableByteStreamControllerGetDesiredSize(controller) {
            const state = controller._controlledReadableByteStream._state;
            if (state === "errored") {
              return null;
            }
            if (state === "closed") {
              return 0;
            }
            return controller._strategyHWM - controller._queueTotalSize;
          }
          __name(ReadableByteStreamControllerGetDesiredSize, "ReadableByteStreamControllerGetDesiredSize");
          function ReadableByteStreamControllerRespond(controller, bytesWritten) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const state = controller._controlledReadableByteStream._state;
            if (state === "closed") {
              if (bytesWritten !== 0) {
                throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
              }
            } else {
              if (bytesWritten === 0) {
                throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
              }
              if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
                throw new RangeError("bytesWritten out of range");
              }
            }
            firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
            ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
          }
          __name(ReadableByteStreamControllerRespond, "ReadableByteStreamControllerRespond");
          function ReadableByteStreamControllerRespondWithNewView(controller, view2) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const state = controller._controlledReadableByteStream._state;
            if (state === "closed") {
              if (view2.byteLength !== 0) {
                throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
              }
            } else {
              if (view2.byteLength === 0) {
                throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
              }
            }
            if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view2.byteOffset) {
              throw new RangeError("The region specified by view does not match byobRequest");
            }
            if (firstDescriptor.bufferByteLength !== view2.buffer.byteLength) {
              throw new RangeError("The buffer of view has different capacity than byobRequest");
            }
            if (firstDescriptor.bytesFilled + view2.byteLength > firstDescriptor.byteLength) {
              throw new RangeError("The region specified by view is larger than byobRequest");
            }
            const viewByteLength = view2.byteLength;
            firstDescriptor.buffer = TransferArrayBuffer(view2.buffer);
            ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
          }
          __name(ReadableByteStreamControllerRespondWithNewView, "ReadableByteStreamControllerRespondWithNewView");
          function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
            controller._controlledReadableByteStream = stream;
            controller._pullAgain = false;
            controller._pulling = false;
            controller._byobRequest = null;
            controller._queue = controller._queueTotalSize = void 0;
            ResetQueue(controller);
            controller._closeRequested = false;
            controller._started = false;
            controller._strategyHWM = highWaterMark;
            controller._pullAlgorithm = pullAlgorithm;
            controller._cancelAlgorithm = cancelAlgorithm;
            controller._autoAllocateChunkSize = autoAllocateChunkSize;
            controller._pendingPullIntos = new SimpleQueue();
            stream._readableStreamController = controller;
            const startResult = startAlgorithm();
            uponPromise(promiseResolvedWith(startResult), () => {
              controller._started = true;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }, (r11) => {
              ReadableByteStreamControllerError(controller, r11);
            });
          }
          __name(SetUpReadableByteStreamController, "SetUpReadableByteStreamController");
          function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
            const controller = Object.create(ReadableByteStreamController.prototype);
            let startAlgorithm = /* @__PURE__ */ __name(() => void 0, "startAlgorithm");
            let pullAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "pullAlgorithm");
            let cancelAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "cancelAlgorithm");
            if (underlyingByteSource.start !== void 0) {
              startAlgorithm = /* @__PURE__ */ __name(() => underlyingByteSource.start(controller), "startAlgorithm");
            }
            if (underlyingByteSource.pull !== void 0) {
              pullAlgorithm = /* @__PURE__ */ __name(() => underlyingByteSource.pull(controller), "pullAlgorithm");
            }
            if (underlyingByteSource.cancel !== void 0) {
              cancelAlgorithm = /* @__PURE__ */ __name((reason) => underlyingByteSource.cancel(reason), "cancelAlgorithm");
            }
            const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
            if (autoAllocateChunkSize === 0) {
              throw new TypeError("autoAllocateChunkSize must be greater than 0");
            }
            SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
          }
          __name(SetUpReadableByteStreamControllerFromUnderlyingSource, "SetUpReadableByteStreamControllerFromUnderlyingSource");
          function SetUpReadableStreamBYOBRequest(request3, controller, view2) {
            request3._associatedReadableByteStreamController = controller;
            request3._view = view2;
          }
          __name(SetUpReadableStreamBYOBRequest, "SetUpReadableStreamBYOBRequest");
          function byobRequestBrandCheckException(name2) {
            return new TypeError(`ReadableStreamBYOBRequest.prototype.${name2} can only be used on a ReadableStreamBYOBRequest`);
          }
          __name(byobRequestBrandCheckException, "byobRequestBrandCheckException");
          function byteStreamControllerBrandCheckException(name2) {
            return new TypeError(`ReadableByteStreamController.prototype.${name2} can only be used on a ReadableByteStreamController`);
          }
          __name(byteStreamControllerBrandCheckException, "byteStreamControllerBrandCheckException");
          function AcquireReadableStreamBYOBReader(stream) {
            return new ReadableStreamBYOBReader(stream);
          }
          __name(AcquireReadableStreamBYOBReader, "AcquireReadableStreamBYOBReader");
          function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
            stream._reader._readIntoRequests.push(readIntoRequest);
          }
          __name(ReadableStreamAddReadIntoRequest, "ReadableStreamAddReadIntoRequest");
          function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
            const reader = stream._reader;
            const readIntoRequest = reader._readIntoRequests.shift();
            if (done) {
              readIntoRequest._closeSteps(chunk);
            } else {
              readIntoRequest._chunkSteps(chunk);
            }
          }
          __name(ReadableStreamFulfillReadIntoRequest, "ReadableStreamFulfillReadIntoRequest");
          function ReadableStreamGetNumReadIntoRequests(stream) {
            return stream._reader._readIntoRequests.length;
          }
          __name(ReadableStreamGetNumReadIntoRequests, "ReadableStreamGetNumReadIntoRequests");
          function ReadableStreamHasBYOBReader(stream) {
            const reader = stream._reader;
            if (reader === void 0) {
              return false;
            }
            if (!IsReadableStreamBYOBReader(reader)) {
              return false;
            }
            return true;
          }
          __name(ReadableStreamHasBYOBReader, "ReadableStreamHasBYOBReader");
          class ReadableStreamBYOBReader {
            static {
              __name(this, "ReadableStreamBYOBReader");
            }
            constructor(stream) {
              assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
              assertReadableStream(stream, "First parameter");
              if (IsReadableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              }
              if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
              }
              ReadableStreamReaderGenericInitialize(this, stream);
              this._readIntoRequests = new SimpleQueue();
            }
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get closed() {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("closed"));
              }
              return this._closedPromise;
            }
            /**
             * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
             */
            cancel(reason = void 0) {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
              }
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("cancel"));
              }
              return ReadableStreamReaderGenericCancel(this, reason);
            }
            /**
             * Attempts to reads bytes into view, and returns a promise resolved with the result.
             *
             * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
             */
            read(view2) {
              if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("read"));
              }
              if (!ArrayBuffer.isView(view2)) {
                return promiseRejectedWith(new TypeError("view must be an array buffer view"));
              }
              if (view2.byteLength === 0) {
                return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
              }
              if (view2.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
              }
              if (IsDetachedBuffer(view2.buffer))
                ;
              if (this._ownerReadableStream === void 0) {
                return promiseRejectedWith(readerLockException("read from"));
              }
              let resolvePromise;
              let rejectPromise;
              const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
              });
              const readIntoRequest = {
                _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
                _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
                _errorSteps: (e11) => rejectPromise(e11)
              };
              ReadableStreamBYOBReaderRead(this, view2, readIntoRequest);
              return promise;
            }
            /**
             * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
             * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
             * from now on; otherwise, the reader will appear closed.
             *
             * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
             * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
             * do so will throw a `TypeError` and leave the reader locked to the stream.
             */
            releaseLock() {
              if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException("releaseLock");
              }
              if (this._ownerReadableStream === void 0) {
                return;
              }
              if (this._readIntoRequests.length > 0) {
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              }
              ReadableStreamReaderGenericRelease(this);
            }
          }
          Object.defineProperties(ReadableStreamBYOBReader.prototype, {
            cancel: { enumerable: true },
            read: { enumerable: true },
            releaseLock: { enumerable: true },
            closed: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
              value: "ReadableStreamBYOBReader",
              configurable: true
            });
          }
          function IsReadableStreamBYOBReader(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_readIntoRequests")) {
              return false;
            }
            return x5 instanceof ReadableStreamBYOBReader;
          }
          __name(IsReadableStreamBYOBReader, "IsReadableStreamBYOBReader");
          function ReadableStreamBYOBReaderRead(reader, view2, readIntoRequest) {
            const stream = reader._ownerReadableStream;
            stream._disturbed = true;
            if (stream._state === "errored") {
              readIntoRequest._errorSteps(stream._storedError);
            } else {
              ReadableByteStreamControllerPullInto(stream._readableStreamController, view2, readIntoRequest);
            }
          }
          __name(ReadableStreamBYOBReaderRead, "ReadableStreamBYOBReaderRead");
          function byobReaderBrandCheckException(name2) {
            return new TypeError(`ReadableStreamBYOBReader.prototype.${name2} can only be used on a ReadableStreamBYOBReader`);
          }
          __name(byobReaderBrandCheckException, "byobReaderBrandCheckException");
          function ExtractHighWaterMark(strategy, defaultHWM) {
            const { highWaterMark } = strategy;
            if (highWaterMark === void 0) {
              return defaultHWM;
            }
            if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
              throw new RangeError("Invalid highWaterMark");
            }
            return highWaterMark;
          }
          __name(ExtractHighWaterMark, "ExtractHighWaterMark");
          function ExtractSizeAlgorithm(strategy) {
            const { size } = strategy;
            if (!size) {
              return () => 1;
            }
            return size;
          }
          __name(ExtractSizeAlgorithm, "ExtractSizeAlgorithm");
          function convertQueuingStrategy(init2, context8) {
            assertDictionary(init2, context8);
            const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
            const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
            return {
              highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
              size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context8} has member 'size' that`)
            };
          }
          __name(convertQueuingStrategy, "convertQueuingStrategy");
          function convertQueuingStrategySize(fn, context8) {
            assertFunction(fn, context8);
            return (chunk) => convertUnrestrictedDouble(fn(chunk));
          }
          __name(convertQueuingStrategySize, "convertQueuingStrategySize");
          function convertUnderlyingSink(original, context8) {
            assertDictionary(original, context8);
            const abort = original === null || original === void 0 ? void 0 : original.abort;
            const close = original === null || original === void 0 ? void 0 : original.close;
            const start = original === null || original === void 0 ? void 0 : original.start;
            const type = original === null || original === void 0 ? void 0 : original.type;
            const write = original === null || original === void 0 ? void 0 : original.write;
            return {
              abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context8} has member 'abort' that`),
              close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context8} has member 'close' that`),
              start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context8} has member 'start' that`),
              write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context8} has member 'write' that`),
              type
            };
          }
          __name(convertUnderlyingSink, "convertUnderlyingSink");
          function convertUnderlyingSinkAbortCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (reason) => promiseCall(fn, original, [reason]);
          }
          __name(convertUnderlyingSinkAbortCallback, "convertUnderlyingSinkAbortCallback");
          function convertUnderlyingSinkCloseCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return () => promiseCall(fn, original, []);
          }
          __name(convertUnderlyingSinkCloseCallback, "convertUnderlyingSinkCloseCallback");
          function convertUnderlyingSinkStartCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (controller) => reflectCall(fn, original, [controller]);
          }
          __name(convertUnderlyingSinkStartCallback, "convertUnderlyingSinkStartCallback");
          function convertUnderlyingSinkWriteCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
          }
          __name(convertUnderlyingSinkWriteCallback, "convertUnderlyingSinkWriteCallback");
          function assertWritableStream(x5, context8) {
            if (!IsWritableStream(x5)) {
              throw new TypeError(`${context8} is not a WritableStream.`);
            }
          }
          __name(assertWritableStream, "assertWritableStream");
          function isAbortSignal3(value) {
            if (typeof value !== "object" || value === null) {
              return false;
            }
            try {
              return typeof value.aborted === "boolean";
            } catch (_a2) {
              return false;
            }
          }
          __name(isAbortSignal3, "isAbortSignal");
          const supportsAbortController = typeof AbortController === "function";
          function createAbortController() {
            if (supportsAbortController) {
              return new AbortController();
            }
            return void 0;
          }
          __name(createAbortController, "createAbortController");
          class WritableStream {
            static {
              __name(this, "WritableStream");
            }
            constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
              if (rawUnderlyingSink === void 0) {
                rawUnderlyingSink = null;
              } else {
                assertObject(rawUnderlyingSink, "First parameter");
              }
              const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
              const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
              InitializeWritableStream(this);
              const type = underlyingSink.type;
              if (type !== void 0) {
                throw new RangeError("Invalid type is specified");
              }
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
            }
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get locked() {
              if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("locked");
              }
              return IsWritableStreamLocked(this);
            }
            /**
             * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
             * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
             * mechanism of the underlying sink.
             *
             * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
             * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
             * the stream) if the stream is currently locked.
             */
            abort(reason = void 0) {
              if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2("abort"));
              }
              if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
              }
              return WritableStreamAbort(this, reason);
            }
            /**
             * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
             * close behavior. During this time any further attempts to write will fail (without erroring the stream).
             *
             * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
             * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
             * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
             */
            close() {
              if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2("close"));
              }
              if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
              }
              if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
              }
              return WritableStreamClose(this);
            }
            /**
             * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
             * is locked, no other writer can be acquired until this one is released.
             *
             * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
             * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
             * the same time, which would cause the resulting written data to be unpredictable and probably useless.
             */
            getWriter() {
              if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("getWriter");
              }
              return AcquireWritableStreamDefaultWriter(this);
            }
          }
          Object.defineProperties(WritableStream.prototype, {
            abort: { enumerable: true },
            close: { enumerable: true },
            getWriter: { enumerable: true },
            locked: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
              value: "WritableStream",
              configurable: true
            });
          }
          function AcquireWritableStreamDefaultWriter(stream) {
            return new WritableStreamDefaultWriter(stream);
          }
          __name(AcquireWritableStreamDefaultWriter, "AcquireWritableStreamDefaultWriter");
          function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
            const stream = Object.create(WritableStream.prototype);
            InitializeWritableStream(stream);
            const controller = Object.create(WritableStreamDefaultController.prototype);
            SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
            return stream;
          }
          __name(CreateWritableStream, "CreateWritableStream");
          function InitializeWritableStream(stream) {
            stream._state = "writable";
            stream._storedError = void 0;
            stream._writer = void 0;
            stream._writableStreamController = void 0;
            stream._writeRequests = new SimpleQueue();
            stream._inFlightWriteRequest = void 0;
            stream._closeRequest = void 0;
            stream._inFlightCloseRequest = void 0;
            stream._pendingAbortRequest = void 0;
            stream._backpressure = false;
          }
          __name(InitializeWritableStream, "InitializeWritableStream");
          function IsWritableStream(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_writableStreamController")) {
              return false;
            }
            return x5 instanceof WritableStream;
          }
          __name(IsWritableStream, "IsWritableStream");
          function IsWritableStreamLocked(stream) {
            if (stream._writer === void 0) {
              return false;
            }
            return true;
          }
          __name(IsWritableStreamLocked, "IsWritableStreamLocked");
          function WritableStreamAbort(stream, reason) {
            var _a2;
            if (stream._state === "closed" || stream._state === "errored") {
              return promiseResolvedWith(void 0);
            }
            stream._writableStreamController._abortReason = reason;
            (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
            const state = stream._state;
            if (state === "closed" || state === "errored") {
              return promiseResolvedWith(void 0);
            }
            if (stream._pendingAbortRequest !== void 0) {
              return stream._pendingAbortRequest._promise;
            }
            let wasAlreadyErroring = false;
            if (state === "erroring") {
              wasAlreadyErroring = true;
              reason = void 0;
            }
            const promise = newPromise((resolve, reject) => {
              stream._pendingAbortRequest = {
                _promise: void 0,
                _resolve: resolve,
                _reject: reject,
                _reason: reason,
                _wasAlreadyErroring: wasAlreadyErroring
              };
            });
            stream._pendingAbortRequest._promise = promise;
            if (!wasAlreadyErroring) {
              WritableStreamStartErroring(stream, reason);
            }
            return promise;
          }
          __name(WritableStreamAbort, "WritableStreamAbort");
          function WritableStreamClose(stream) {
            const state = stream._state;
            if (state === "closed" || state === "errored") {
              return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
            }
            const promise = newPromise((resolve, reject) => {
              const closeRequest = {
                _resolve: resolve,
                _reject: reject
              };
              stream._closeRequest = closeRequest;
            });
            const writer = stream._writer;
            if (writer !== void 0 && stream._backpressure && state === "writable") {
              defaultWriterReadyPromiseResolve(writer);
            }
            WritableStreamDefaultControllerClose(stream._writableStreamController);
            return promise;
          }
          __name(WritableStreamClose, "WritableStreamClose");
          function WritableStreamAddWriteRequest(stream) {
            const promise = newPromise((resolve, reject) => {
              const writeRequest = {
                _resolve: resolve,
                _reject: reject
              };
              stream._writeRequests.push(writeRequest);
            });
            return promise;
          }
          __name(WritableStreamAddWriteRequest, "WritableStreamAddWriteRequest");
          function WritableStreamDealWithRejection(stream, error) {
            const state = stream._state;
            if (state === "writable") {
              WritableStreamStartErroring(stream, error);
              return;
            }
            WritableStreamFinishErroring(stream);
          }
          __name(WritableStreamDealWithRejection, "WritableStreamDealWithRejection");
          function WritableStreamStartErroring(stream, reason) {
            const controller = stream._writableStreamController;
            stream._state = "erroring";
            stream._storedError = reason;
            const writer = stream._writer;
            if (writer !== void 0) {
              WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
            }
            if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
              WritableStreamFinishErroring(stream);
            }
          }
          __name(WritableStreamStartErroring, "WritableStreamStartErroring");
          function WritableStreamFinishErroring(stream) {
            stream._state = "errored";
            stream._writableStreamController[ErrorSteps]();
            const storedError = stream._storedError;
            stream._writeRequests.forEach((writeRequest) => {
              writeRequest._reject(storedError);
            });
            stream._writeRequests = new SimpleQueue();
            if (stream._pendingAbortRequest === void 0) {
              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
              return;
            }
            const abortRequest = stream._pendingAbortRequest;
            stream._pendingAbortRequest = void 0;
            if (abortRequest._wasAlreadyErroring) {
              abortRequest._reject(storedError);
              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
              return;
            }
            const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
            uponPromise(promise, () => {
              abortRequest._resolve();
              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            }, (reason) => {
              abortRequest._reject(reason);
              WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            });
          }
          __name(WritableStreamFinishErroring, "WritableStreamFinishErroring");
          function WritableStreamFinishInFlightWrite(stream) {
            stream._inFlightWriteRequest._resolve(void 0);
            stream._inFlightWriteRequest = void 0;
          }
          __name(WritableStreamFinishInFlightWrite, "WritableStreamFinishInFlightWrite");
          function WritableStreamFinishInFlightWriteWithError(stream, error) {
            stream._inFlightWriteRequest._reject(error);
            stream._inFlightWriteRequest = void 0;
            WritableStreamDealWithRejection(stream, error);
          }
          __name(WritableStreamFinishInFlightWriteWithError, "WritableStreamFinishInFlightWriteWithError");
          function WritableStreamFinishInFlightClose(stream) {
            stream._inFlightCloseRequest._resolve(void 0);
            stream._inFlightCloseRequest = void 0;
            const state = stream._state;
            if (state === "erroring") {
              stream._storedError = void 0;
              if (stream._pendingAbortRequest !== void 0) {
                stream._pendingAbortRequest._resolve();
                stream._pendingAbortRequest = void 0;
              }
            }
            stream._state = "closed";
            const writer = stream._writer;
            if (writer !== void 0) {
              defaultWriterClosedPromiseResolve(writer);
            }
          }
          __name(WritableStreamFinishInFlightClose, "WritableStreamFinishInFlightClose");
          function WritableStreamFinishInFlightCloseWithError(stream, error) {
            stream._inFlightCloseRequest._reject(error);
            stream._inFlightCloseRequest = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._reject(error);
              stream._pendingAbortRequest = void 0;
            }
            WritableStreamDealWithRejection(stream, error);
          }
          __name(WritableStreamFinishInFlightCloseWithError, "WritableStreamFinishInFlightCloseWithError");
          function WritableStreamCloseQueuedOrInFlight(stream) {
            if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
              return false;
            }
            return true;
          }
          __name(WritableStreamCloseQueuedOrInFlight, "WritableStreamCloseQueuedOrInFlight");
          function WritableStreamHasOperationMarkedInFlight(stream) {
            if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
              return false;
            }
            return true;
          }
          __name(WritableStreamHasOperationMarkedInFlight, "WritableStreamHasOperationMarkedInFlight");
          function WritableStreamMarkCloseRequestInFlight(stream) {
            stream._inFlightCloseRequest = stream._closeRequest;
            stream._closeRequest = void 0;
          }
          __name(WritableStreamMarkCloseRequestInFlight, "WritableStreamMarkCloseRequestInFlight");
          function WritableStreamMarkFirstWriteRequestInFlight(stream) {
            stream._inFlightWriteRequest = stream._writeRequests.shift();
          }
          __name(WritableStreamMarkFirstWriteRequestInFlight, "WritableStreamMarkFirstWriteRequestInFlight");
          function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
            if (stream._closeRequest !== void 0) {
              stream._closeRequest._reject(stream._storedError);
              stream._closeRequest = void 0;
            }
            const writer = stream._writer;
            if (writer !== void 0) {
              defaultWriterClosedPromiseReject(writer, stream._storedError);
            }
          }
          __name(WritableStreamRejectCloseAndClosedPromiseIfNeeded, "WritableStreamRejectCloseAndClosedPromiseIfNeeded");
          function WritableStreamUpdateBackpressure(stream, backpressure) {
            const writer = stream._writer;
            if (writer !== void 0 && backpressure !== stream._backpressure) {
              if (backpressure) {
                defaultWriterReadyPromiseReset(writer);
              } else {
                defaultWriterReadyPromiseResolve(writer);
              }
            }
            stream._backpressure = backpressure;
          }
          __name(WritableStreamUpdateBackpressure, "WritableStreamUpdateBackpressure");
          class WritableStreamDefaultWriter {
            static {
              __name(this, "WritableStreamDefaultWriter");
            }
            constructor(stream) {
              assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
              assertWritableStream(stream, "First parameter");
              if (IsWritableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive writing by another writer");
              }
              this._ownerWritableStream = stream;
              stream._writer = this;
              const state = stream._state;
              if (state === "writable") {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                  defaultWriterReadyPromiseInitialize(this);
                } else {
                  defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
              } else if (state === "erroring") {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
              } else if (state === "closed") {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
              } else {
                const storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
              }
            }
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writers lock is released before the stream finishes closing.
             */
            get closed() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
              }
              return this._closedPromise;
            }
            /**
             * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writers lock is released.
             */
            get desiredSize() {
              if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("desiredSize");
              }
              if (this._ownerWritableStream === void 0) {
                throw defaultWriterLockException("desiredSize");
              }
              return WritableStreamDefaultWriterGetDesiredSize(this);
            }
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
             * rejected.
             */
            get ready() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
              }
              return this._readyPromise;
            }
            /**
             * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
             */
            abort(reason = void 0) {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
              }
              if (this._ownerWritableStream === void 0) {
                return promiseRejectedWith(defaultWriterLockException("abort"));
              }
              return WritableStreamDefaultWriterAbort(this, reason);
            }
            /**
             * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
             */
            close() {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("close"));
              }
              const stream = this._ownerWritableStream;
              if (stream === void 0) {
                return promiseRejectedWith(defaultWriterLockException("close"));
              }
              if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
              }
              return WritableStreamDefaultWriterClose(this);
            }
            /**
             * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
             * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
             * now on; otherwise, the writer will appear closed.
             *
             * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
             * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
             * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
             * other producers from writing in an interleaved manner.
             */
            releaseLock() {
              if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("releaseLock");
              }
              const stream = this._ownerWritableStream;
              if (stream === void 0) {
                return;
              }
              WritableStreamDefaultWriterRelease(this);
            }
            write(chunk = void 0) {
              if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("write"));
              }
              if (this._ownerWritableStream === void 0) {
                return promiseRejectedWith(defaultWriterLockException("write to"));
              }
              return WritableStreamDefaultWriterWrite(this, chunk);
            }
          }
          Object.defineProperties(WritableStreamDefaultWriter.prototype, {
            abort: { enumerable: true },
            close: { enumerable: true },
            releaseLock: { enumerable: true },
            write: { enumerable: true },
            closed: { enumerable: true },
            desiredSize: { enumerable: true },
            ready: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
              value: "WritableStreamDefaultWriter",
              configurable: true
            });
          }
          function IsWritableStreamDefaultWriter(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_ownerWritableStream")) {
              return false;
            }
            return x5 instanceof WritableStreamDefaultWriter;
          }
          __name(IsWritableStreamDefaultWriter, "IsWritableStreamDefaultWriter");
          function WritableStreamDefaultWriterAbort(writer, reason) {
            const stream = writer._ownerWritableStream;
            return WritableStreamAbort(stream, reason);
          }
          __name(WritableStreamDefaultWriterAbort, "WritableStreamDefaultWriterAbort");
          function WritableStreamDefaultWriterClose(writer) {
            const stream = writer._ownerWritableStream;
            return WritableStreamClose(stream);
          }
          __name(WritableStreamDefaultWriterClose, "WritableStreamDefaultWriterClose");
          function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
            const stream = writer._ownerWritableStream;
            const state = stream._state;
            if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
              return promiseResolvedWith(void 0);
            }
            if (state === "errored") {
              return promiseRejectedWith(stream._storedError);
            }
            return WritableStreamDefaultWriterClose(writer);
          }
          __name(WritableStreamDefaultWriterCloseWithErrorPropagation, "WritableStreamDefaultWriterCloseWithErrorPropagation");
          function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
            if (writer._closedPromiseState === "pending") {
              defaultWriterClosedPromiseReject(writer, error);
            } else {
              defaultWriterClosedPromiseResetToRejected(writer, error);
            }
          }
          __name(WritableStreamDefaultWriterEnsureClosedPromiseRejected, "WritableStreamDefaultWriterEnsureClosedPromiseRejected");
          function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
            if (writer._readyPromiseState === "pending") {
              defaultWriterReadyPromiseReject(writer, error);
            } else {
              defaultWriterReadyPromiseResetToRejected(writer, error);
            }
          }
          __name(WritableStreamDefaultWriterEnsureReadyPromiseRejected, "WritableStreamDefaultWriterEnsureReadyPromiseRejected");
          function WritableStreamDefaultWriterGetDesiredSize(writer) {
            const stream = writer._ownerWritableStream;
            const state = stream._state;
            if (state === "errored" || state === "erroring") {
              return null;
            }
            if (state === "closed") {
              return 0;
            }
            return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
          }
          __name(WritableStreamDefaultWriterGetDesiredSize, "WritableStreamDefaultWriterGetDesiredSize");
          function WritableStreamDefaultWriterRelease(writer) {
            const stream = writer._ownerWritableStream;
            const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
            WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
            stream._writer = void 0;
            writer._ownerWritableStream = void 0;
          }
          __name(WritableStreamDefaultWriterRelease, "WritableStreamDefaultWriterRelease");
          function WritableStreamDefaultWriterWrite(writer, chunk) {
            const stream = writer._ownerWritableStream;
            const controller = stream._writableStreamController;
            const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
            if (stream !== writer._ownerWritableStream) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            const state = stream._state;
            if (state === "errored") {
              return promiseRejectedWith(stream._storedError);
            }
            if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
              return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
            }
            if (state === "erroring") {
              return promiseRejectedWith(stream._storedError);
            }
            const promise = WritableStreamAddWriteRequest(stream);
            WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
            return promise;
          }
          __name(WritableStreamDefaultWriterWrite, "WritableStreamDefaultWriterWrite");
          const closeSentinel = {};
          class WritableStreamDefaultController {
            static {
              __name(this, "WritableStreamDefaultController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get abortReason() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("abortReason");
              }
              return this._abortReason;
            }
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get signal() {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("signal");
              }
              if (this._abortController === void 0) {
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              }
              return this._abortController.signal;
            }
            /**
             * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
             *
             * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
             * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
             * normal lifecycle of interactions with the underlying sink.
             */
            error(e11 = void 0) {
              if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("error");
              }
              const state = this._controlledWritableStream._state;
              if (state !== "writable") {
                return;
              }
              WritableStreamDefaultControllerError(this, e11);
            }
            /** @internal */
            [AbortSteps](reason) {
              const result = this._abortAlgorithm(reason);
              WritableStreamDefaultControllerClearAlgorithms(this);
              return result;
            }
            /** @internal */
            [ErrorSteps]() {
              ResetQueue(this);
            }
          }
          Object.defineProperties(WritableStreamDefaultController.prototype, {
            abortReason: { enumerable: true },
            signal: { enumerable: true },
            error: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
              value: "WritableStreamDefaultController",
              configurable: true
            });
          }
          function IsWritableStreamDefaultController(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_controlledWritableStream")) {
              return false;
            }
            return x5 instanceof WritableStreamDefaultController;
          }
          __name(IsWritableStreamDefaultController, "IsWritableStreamDefaultController");
          function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
            controller._controlledWritableStream = stream;
            stream._writableStreamController = controller;
            controller._queue = void 0;
            controller._queueTotalSize = void 0;
            ResetQueue(controller);
            controller._abortReason = void 0;
            controller._abortController = createAbortController();
            controller._started = false;
            controller._strategySizeAlgorithm = sizeAlgorithm;
            controller._strategyHWM = highWaterMark;
            controller._writeAlgorithm = writeAlgorithm;
            controller._closeAlgorithm = closeAlgorithm;
            controller._abortAlgorithm = abortAlgorithm;
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
            const startResult = startAlgorithm();
            const startPromise = promiseResolvedWith(startResult);
            uponPromise(startPromise, () => {
              controller._started = true;
              WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            }, (r11) => {
              controller._started = true;
              WritableStreamDealWithRejection(stream, r11);
            });
          }
          __name(SetUpWritableStreamDefaultController, "SetUpWritableStreamDefaultController");
          function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
            const controller = Object.create(WritableStreamDefaultController.prototype);
            let startAlgorithm = /* @__PURE__ */ __name(() => void 0, "startAlgorithm");
            let writeAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "writeAlgorithm");
            let closeAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "closeAlgorithm");
            let abortAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "abortAlgorithm");
            if (underlyingSink.start !== void 0) {
              startAlgorithm = /* @__PURE__ */ __name(() => underlyingSink.start(controller), "startAlgorithm");
            }
            if (underlyingSink.write !== void 0) {
              writeAlgorithm = /* @__PURE__ */ __name((chunk) => underlyingSink.write(chunk, controller), "writeAlgorithm");
            }
            if (underlyingSink.close !== void 0) {
              closeAlgorithm = /* @__PURE__ */ __name(() => underlyingSink.close(), "closeAlgorithm");
            }
            if (underlyingSink.abort !== void 0) {
              abortAlgorithm = /* @__PURE__ */ __name((reason) => underlyingSink.abort(reason), "abortAlgorithm");
            }
            SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          }
          __name(SetUpWritableStreamDefaultControllerFromUnderlyingSink, "SetUpWritableStreamDefaultControllerFromUnderlyingSink");
          function WritableStreamDefaultControllerClearAlgorithms(controller) {
            controller._writeAlgorithm = void 0;
            controller._closeAlgorithm = void 0;
            controller._abortAlgorithm = void 0;
            controller._strategySizeAlgorithm = void 0;
          }
          __name(WritableStreamDefaultControllerClearAlgorithms, "WritableStreamDefaultControllerClearAlgorithms");
          function WritableStreamDefaultControllerClose(controller) {
            EnqueueValueWithSize(controller, closeSentinel, 0);
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }
          __name(WritableStreamDefaultControllerClose, "WritableStreamDefaultControllerClose");
          function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
            try {
              return controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
              return 1;
            }
          }
          __name(WritableStreamDefaultControllerGetChunkSize, "WritableStreamDefaultControllerGetChunkSize");
          function WritableStreamDefaultControllerGetDesiredSize(controller) {
            return controller._strategyHWM - controller._queueTotalSize;
          }
          __name(WritableStreamDefaultControllerGetDesiredSize, "WritableStreamDefaultControllerGetDesiredSize");
          function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
              return;
            }
            const stream = controller._controlledWritableStream;
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }
          __name(WritableStreamDefaultControllerWrite, "WritableStreamDefaultControllerWrite");
          function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
            const stream = controller._controlledWritableStream;
            if (!controller._started) {
              return;
            }
            if (stream._inFlightWriteRequest !== void 0) {
              return;
            }
            const state = stream._state;
            if (state === "erroring") {
              WritableStreamFinishErroring(stream);
              return;
            }
            if (controller._queue.length === 0) {
              return;
            }
            const value = PeekQueueValue(controller);
            if (value === closeSentinel) {
              WritableStreamDefaultControllerProcessClose(controller);
            } else {
              WritableStreamDefaultControllerProcessWrite(controller, value);
            }
          }
          __name(WritableStreamDefaultControllerAdvanceQueueIfNeeded, "WritableStreamDefaultControllerAdvanceQueueIfNeeded");
          function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
            if (controller._controlledWritableStream._state === "writable") {
              WritableStreamDefaultControllerError(controller, error);
            }
          }
          __name(WritableStreamDefaultControllerErrorIfNeeded, "WritableStreamDefaultControllerErrorIfNeeded");
          function WritableStreamDefaultControllerProcessClose(controller) {
            const stream = controller._controlledWritableStream;
            WritableStreamMarkCloseRequestInFlight(stream);
            DequeueValue(controller);
            const sinkClosePromise = controller._closeAlgorithm();
            WritableStreamDefaultControllerClearAlgorithms(controller);
            uponPromise(sinkClosePromise, () => {
              WritableStreamFinishInFlightClose(stream);
            }, (reason) => {
              WritableStreamFinishInFlightCloseWithError(stream, reason);
            });
          }
          __name(WritableStreamDefaultControllerProcessClose, "WritableStreamDefaultControllerProcessClose");
          function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
            const stream = controller._controlledWritableStream;
            WritableStreamMarkFirstWriteRequestInFlight(stream);
            const sinkWritePromise = controller._writeAlgorithm(chunk);
            uponPromise(sinkWritePromise, () => {
              WritableStreamFinishInFlightWrite(stream);
              const state = stream._state;
              DequeueValue(controller);
              if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
              }
              WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            }, (reason) => {
              if (stream._state === "writable") {
                WritableStreamDefaultControllerClearAlgorithms(controller);
              }
              WritableStreamFinishInFlightWriteWithError(stream, reason);
            });
          }
          __name(WritableStreamDefaultControllerProcessWrite, "WritableStreamDefaultControllerProcessWrite");
          function WritableStreamDefaultControllerGetBackpressure(controller) {
            const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
            return desiredSize <= 0;
          }
          __name(WritableStreamDefaultControllerGetBackpressure, "WritableStreamDefaultControllerGetBackpressure");
          function WritableStreamDefaultControllerError(controller, error) {
            const stream = controller._controlledWritableStream;
            WritableStreamDefaultControllerClearAlgorithms(controller);
            WritableStreamStartErroring(stream, error);
          }
          __name(WritableStreamDefaultControllerError, "WritableStreamDefaultControllerError");
          function streamBrandCheckException$2(name2) {
            return new TypeError(`WritableStream.prototype.${name2} can only be used on a WritableStream`);
          }
          __name(streamBrandCheckException$2, "streamBrandCheckException$2");
          function defaultControllerBrandCheckException$2(name2) {
            return new TypeError(`WritableStreamDefaultController.prototype.${name2} can only be used on a WritableStreamDefaultController`);
          }
          __name(defaultControllerBrandCheckException$2, "defaultControllerBrandCheckException$2");
          function defaultWriterBrandCheckException(name2) {
            return new TypeError(`WritableStreamDefaultWriter.prototype.${name2} can only be used on a WritableStreamDefaultWriter`);
          }
          __name(defaultWriterBrandCheckException, "defaultWriterBrandCheckException");
          function defaultWriterLockException(name2) {
            return new TypeError("Cannot " + name2 + " a stream using a released writer");
          }
          __name(defaultWriterLockException, "defaultWriterLockException");
          function defaultWriterClosedPromiseInitialize(writer) {
            writer._closedPromise = newPromise((resolve, reject) => {
              writer._closedPromise_resolve = resolve;
              writer._closedPromise_reject = reject;
              writer._closedPromiseState = "pending";
            });
          }
          __name(defaultWriterClosedPromiseInitialize, "defaultWriterClosedPromiseInitialize");
          function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
            defaultWriterClosedPromiseInitialize(writer);
            defaultWriterClosedPromiseReject(writer, reason);
          }
          __name(defaultWriterClosedPromiseInitializeAsRejected, "defaultWriterClosedPromiseInitializeAsRejected");
          function defaultWriterClosedPromiseInitializeAsResolved(writer) {
            defaultWriterClosedPromiseInitialize(writer);
            defaultWriterClosedPromiseResolve(writer);
          }
          __name(defaultWriterClosedPromiseInitializeAsResolved, "defaultWriterClosedPromiseInitializeAsResolved");
          function defaultWriterClosedPromiseReject(writer, reason) {
            if (writer._closedPromise_reject === void 0) {
              return;
            }
            setPromiseIsHandledToTrue(writer._closedPromise);
            writer._closedPromise_reject(reason);
            writer._closedPromise_resolve = void 0;
            writer._closedPromise_reject = void 0;
            writer._closedPromiseState = "rejected";
          }
          __name(defaultWriterClosedPromiseReject, "defaultWriterClosedPromiseReject");
          function defaultWriterClosedPromiseResetToRejected(writer, reason) {
            defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
          }
          __name(defaultWriterClosedPromiseResetToRejected, "defaultWriterClosedPromiseResetToRejected");
          function defaultWriterClosedPromiseResolve(writer) {
            if (writer._closedPromise_resolve === void 0) {
              return;
            }
            writer._closedPromise_resolve(void 0);
            writer._closedPromise_resolve = void 0;
            writer._closedPromise_reject = void 0;
            writer._closedPromiseState = "resolved";
          }
          __name(defaultWriterClosedPromiseResolve, "defaultWriterClosedPromiseResolve");
          function defaultWriterReadyPromiseInitialize(writer) {
            writer._readyPromise = newPromise((resolve, reject) => {
              writer._readyPromise_resolve = resolve;
              writer._readyPromise_reject = reject;
            });
            writer._readyPromiseState = "pending";
          }
          __name(defaultWriterReadyPromiseInitialize, "defaultWriterReadyPromiseInitialize");
          function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
            defaultWriterReadyPromiseInitialize(writer);
            defaultWriterReadyPromiseReject(writer, reason);
          }
          __name(defaultWriterReadyPromiseInitializeAsRejected, "defaultWriterReadyPromiseInitializeAsRejected");
          function defaultWriterReadyPromiseInitializeAsResolved(writer) {
            defaultWriterReadyPromiseInitialize(writer);
            defaultWriterReadyPromiseResolve(writer);
          }
          __name(defaultWriterReadyPromiseInitializeAsResolved, "defaultWriterReadyPromiseInitializeAsResolved");
          function defaultWriterReadyPromiseReject(writer, reason) {
            if (writer._readyPromise_reject === void 0) {
              return;
            }
            setPromiseIsHandledToTrue(writer._readyPromise);
            writer._readyPromise_reject(reason);
            writer._readyPromise_resolve = void 0;
            writer._readyPromise_reject = void 0;
            writer._readyPromiseState = "rejected";
          }
          __name(defaultWriterReadyPromiseReject, "defaultWriterReadyPromiseReject");
          function defaultWriterReadyPromiseReset(writer) {
            defaultWriterReadyPromiseInitialize(writer);
          }
          __name(defaultWriterReadyPromiseReset, "defaultWriterReadyPromiseReset");
          function defaultWriterReadyPromiseResetToRejected(writer, reason) {
            defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
          }
          __name(defaultWriterReadyPromiseResetToRejected, "defaultWriterReadyPromiseResetToRejected");
          function defaultWriterReadyPromiseResolve(writer) {
            if (writer._readyPromise_resolve === void 0) {
              return;
            }
            writer._readyPromise_resolve(void 0);
            writer._readyPromise_resolve = void 0;
            writer._readyPromise_reject = void 0;
            writer._readyPromiseState = "fulfilled";
          }
          __name(defaultWriterReadyPromiseResolve, "defaultWriterReadyPromiseResolve");
          const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
          function isDOMExceptionConstructor(ctor) {
            if (!(typeof ctor === "function" || typeof ctor === "object")) {
              return false;
            }
            try {
              new ctor();
              return true;
            } catch (_a2) {
              return false;
            }
          }
          __name(isDOMExceptionConstructor, "isDOMExceptionConstructor");
          function createDOMExceptionPolyfill() {
            const ctor = /* @__PURE__ */ __name(function DOMException2(message, name2) {
              this.message = message || "";
              this.name = name2 || "Error";
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              }
            }, "DOMException");
            ctor.prototype = Object.create(Error.prototype);
            Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
            return ctor;
          }
          __name(createDOMExceptionPolyfill, "createDOMExceptionPolyfill");
          const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
          function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
            const reader = AcquireReadableStreamDefaultReader(source);
            const writer = AcquireWritableStreamDefaultWriter(dest);
            source._disturbed = true;
            let shuttingDown = false;
            let currentWrite = promiseResolvedWith(void 0);
            return newPromise((resolve, reject) => {
              let abortAlgorithm;
              if (signal !== void 0) {
                abortAlgorithm = /* @__PURE__ */ __name(() => {
                  const error = new DOMException$1("Aborted", "AbortError");
                  const actions = [];
                  if (!preventAbort) {
                    actions.push(() => {
                      if (dest._state === "writable") {
                        return WritableStreamAbort(dest, error);
                      }
                      return promiseResolvedWith(void 0);
                    });
                  }
                  if (!preventCancel) {
                    actions.push(() => {
                      if (source._state === "readable") {
                        return ReadableStreamCancel(source, error);
                      }
                      return promiseResolvedWith(void 0);
                    });
                  }
                  shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
                }, "abortAlgorithm");
                if (signal.aborted) {
                  abortAlgorithm();
                  return;
                }
                signal.addEventListener("abort", abortAlgorithm);
              }
              function pipeLoop() {
                return newPromise((resolveLoop, rejectLoop) => {
                  function next(done) {
                    if (done) {
                      resolveLoop();
                    } else {
                      PerformPromiseThen(pipeStep(), next, rejectLoop);
                    }
                  }
                  __name(next, "next");
                  next(false);
                });
              }
              __name(pipeLoop, "pipeLoop");
              function pipeStep() {
                if (shuttingDown) {
                  return promiseResolvedWith(true);
                }
                return PerformPromiseThen(writer._readyPromise, () => {
                  return newPromise((resolveRead, rejectRead) => {
                    ReadableStreamDefaultReaderRead(reader, {
                      _chunkSteps: (chunk) => {
                        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop);
                        resolveRead(false);
                      },
                      _closeSteps: () => resolveRead(true),
                      _errorSteps: rejectRead
                    });
                  });
                });
              }
              __name(pipeStep, "pipeStep");
              isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
                if (!preventAbort) {
                  shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
                } else {
                  shutdown(true, storedError);
                }
              });
              isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
                if (!preventCancel) {
                  shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
                } else {
                  shutdown(true, storedError);
                }
              });
              isOrBecomesClosed(source, reader._closedPromise, () => {
                if (!preventClose) {
                  shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
                } else {
                  shutdown();
                }
              });
              if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
                const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
                if (!preventCancel) {
                  shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
                } else {
                  shutdown(true, destClosed);
                }
              }
              setPromiseIsHandledToTrue(pipeLoop());
              function waitForWritesToFinish() {
                const oldCurrentWrite = currentWrite;
                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
              }
              __name(waitForWritesToFinish, "waitForWritesToFinish");
              function isOrBecomesErrored(stream, promise, action) {
                if (stream._state === "errored") {
                  action(stream._storedError);
                } else {
                  uponRejection(promise, action);
                }
              }
              __name(isOrBecomesErrored, "isOrBecomesErrored");
              function isOrBecomesClosed(stream, promise, action) {
                if (stream._state === "closed") {
                  action();
                } else {
                  uponFulfillment(promise, action);
                }
              }
              __name(isOrBecomesClosed, "isOrBecomesClosed");
              function shutdownWithAction(action, originalIsError, originalError) {
                if (shuttingDown) {
                  return;
                }
                shuttingDown = true;
                if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                  uponFulfillment(waitForWritesToFinish(), doTheRest);
                } else {
                  doTheRest();
                }
                function doTheRest() {
                  uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
                }
                __name(doTheRest, "doTheRest");
              }
              __name(shutdownWithAction, "shutdownWithAction");
              function shutdown(isError, error) {
                if (shuttingDown) {
                  return;
                }
                shuttingDown = true;
                if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                  uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
                } else {
                  finalize(isError, error);
                }
              }
              __name(shutdown, "shutdown");
              function finalize(isError, error) {
                WritableStreamDefaultWriterRelease(writer);
                ReadableStreamReaderGenericRelease(reader);
                if (signal !== void 0) {
                  signal.removeEventListener("abort", abortAlgorithm);
                }
                if (isError) {
                  reject(error);
                } else {
                  resolve(void 0);
                }
              }
              __name(finalize, "finalize");
            });
          }
          __name(ReadableStreamPipeTo, "ReadableStreamPipeTo");
          class ReadableStreamDefaultController {
            static {
              __name(this, "ReadableStreamDefaultController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get desiredSize() {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("desiredSize");
              }
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            }
            /**
             * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
             * the stream, but once those are read, the stream will become closed.
             */
            close() {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("close");
              }
              if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError("The stream is not in a state that permits close");
              }
              ReadableStreamDefaultControllerClose(this);
            }
            enqueue(chunk = void 0) {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("enqueue");
              }
              if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError("The stream is not in a state that permits enqueue");
              }
              return ReadableStreamDefaultControllerEnqueue(this, chunk);
            }
            /**
             * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
             */
            error(e11 = void 0) {
              if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("error");
              }
              ReadableStreamDefaultControllerError(this, e11);
            }
            /** @internal */
            [CancelSteps](reason) {
              ResetQueue(this);
              const result = this._cancelAlgorithm(reason);
              ReadableStreamDefaultControllerClearAlgorithms(this);
              return result;
            }
            /** @internal */
            [PullSteps](readRequest) {
              const stream = this._controlledReadableStream;
              if (this._queue.length > 0) {
                const chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                  ReadableStreamDefaultControllerClearAlgorithms(this);
                  ReadableStreamClose(stream);
                } else {
                  ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
              } else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
            }
          }
          Object.defineProperties(ReadableStreamDefaultController.prototype, {
            close: { enumerable: true },
            enqueue: { enumerable: true },
            error: { enumerable: true },
            desiredSize: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
              value: "ReadableStreamDefaultController",
              configurable: true
            });
          }
          function IsReadableStreamDefaultController(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_controlledReadableStream")) {
              return false;
            }
            return x5 instanceof ReadableStreamDefaultController;
          }
          __name(IsReadableStreamDefaultController, "IsReadableStreamDefaultController");
          function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
            const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
            if (!shouldPull) {
              return;
            }
            if (controller._pulling) {
              controller._pullAgain = true;
              return;
            }
            controller._pulling = true;
            const pullPromise = controller._pullAlgorithm();
            uponPromise(pullPromise, () => {
              controller._pulling = false;
              if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
              }
            }, (e11) => {
              ReadableStreamDefaultControllerError(controller, e11);
            });
          }
          __name(ReadableStreamDefaultControllerCallPullIfNeeded, "ReadableStreamDefaultControllerCallPullIfNeeded");
          function ReadableStreamDefaultControllerShouldCallPull(controller) {
            const stream = controller._controlledReadableStream;
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
              return false;
            }
            if (!controller._started) {
              return false;
            }
            if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
              return true;
            }
            const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
            if (desiredSize > 0) {
              return true;
            }
            return false;
          }
          __name(ReadableStreamDefaultControllerShouldCallPull, "ReadableStreamDefaultControllerShouldCallPull");
          function ReadableStreamDefaultControllerClearAlgorithms(controller) {
            controller._pullAlgorithm = void 0;
            controller._cancelAlgorithm = void 0;
            controller._strategySizeAlgorithm = void 0;
          }
          __name(ReadableStreamDefaultControllerClearAlgorithms, "ReadableStreamDefaultControllerClearAlgorithms");
          function ReadableStreamDefaultControllerClose(controller) {
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
              return;
            }
            const stream = controller._controlledReadableStream;
            controller._closeRequested = true;
            if (controller._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(controller);
              ReadableStreamClose(stream);
            }
          }
          __name(ReadableStreamDefaultControllerClose, "ReadableStreamDefaultControllerClose");
          function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
              return;
            }
            const stream = controller._controlledReadableStream;
            if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
              ReadableStreamFulfillReadRequest(stream, chunk, false);
            } else {
              let chunkSize;
              try {
                chunkSize = controller._strategySizeAlgorithm(chunk);
              } catch (chunkSizeE) {
                ReadableStreamDefaultControllerError(controller, chunkSizeE);
                throw chunkSizeE;
              }
              try {
                EnqueueValueWithSize(controller, chunk, chunkSize);
              } catch (enqueueE) {
                ReadableStreamDefaultControllerError(controller, enqueueE);
                throw enqueueE;
              }
            }
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          __name(ReadableStreamDefaultControllerEnqueue, "ReadableStreamDefaultControllerEnqueue");
          function ReadableStreamDefaultControllerError(controller, e11) {
            const stream = controller._controlledReadableStream;
            if (stream._state !== "readable") {
              return;
            }
            ResetQueue(controller);
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamError(stream, e11);
          }
          __name(ReadableStreamDefaultControllerError, "ReadableStreamDefaultControllerError");
          function ReadableStreamDefaultControllerGetDesiredSize(controller) {
            const state = controller._controlledReadableStream._state;
            if (state === "errored") {
              return null;
            }
            if (state === "closed") {
              return 0;
            }
            return controller._strategyHWM - controller._queueTotalSize;
          }
          __name(ReadableStreamDefaultControllerGetDesiredSize, "ReadableStreamDefaultControllerGetDesiredSize");
          function ReadableStreamDefaultControllerHasBackpressure(controller) {
            if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
              return false;
            }
            return true;
          }
          __name(ReadableStreamDefaultControllerHasBackpressure, "ReadableStreamDefaultControllerHasBackpressure");
          function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
            const state = controller._controlledReadableStream._state;
            if (!controller._closeRequested && state === "readable") {
              return true;
            }
            return false;
          }
          __name(ReadableStreamDefaultControllerCanCloseOrEnqueue, "ReadableStreamDefaultControllerCanCloseOrEnqueue");
          function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
            controller._controlledReadableStream = stream;
            controller._queue = void 0;
            controller._queueTotalSize = void 0;
            ResetQueue(controller);
            controller._started = false;
            controller._closeRequested = false;
            controller._pullAgain = false;
            controller._pulling = false;
            controller._strategySizeAlgorithm = sizeAlgorithm;
            controller._strategyHWM = highWaterMark;
            controller._pullAlgorithm = pullAlgorithm;
            controller._cancelAlgorithm = cancelAlgorithm;
            stream._readableStreamController = controller;
            const startResult = startAlgorithm();
            uponPromise(promiseResolvedWith(startResult), () => {
              controller._started = true;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }, (r11) => {
              ReadableStreamDefaultControllerError(controller, r11);
            });
          }
          __name(SetUpReadableStreamDefaultController, "SetUpReadableStreamDefaultController");
          function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
            const controller = Object.create(ReadableStreamDefaultController.prototype);
            let startAlgorithm = /* @__PURE__ */ __name(() => void 0, "startAlgorithm");
            let pullAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "pullAlgorithm");
            let cancelAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "cancelAlgorithm");
            if (underlyingSource.start !== void 0) {
              startAlgorithm = /* @__PURE__ */ __name(() => underlyingSource.start(controller), "startAlgorithm");
            }
            if (underlyingSource.pull !== void 0) {
              pullAlgorithm = /* @__PURE__ */ __name(() => underlyingSource.pull(controller), "pullAlgorithm");
            }
            if (underlyingSource.cancel !== void 0) {
              cancelAlgorithm = /* @__PURE__ */ __name((reason) => underlyingSource.cancel(reason), "cancelAlgorithm");
            }
            SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          }
          __name(SetUpReadableStreamDefaultControllerFromUnderlyingSource, "SetUpReadableStreamDefaultControllerFromUnderlyingSource");
          function defaultControllerBrandCheckException$1(name2) {
            return new TypeError(`ReadableStreamDefaultController.prototype.${name2} can only be used on a ReadableStreamDefaultController`);
          }
          __name(defaultControllerBrandCheckException$1, "defaultControllerBrandCheckException$1");
          function ReadableStreamTee(stream, cloneForBranch2) {
            if (IsReadableByteStreamController(stream._readableStreamController)) {
              return ReadableByteStreamTee(stream);
            }
            return ReadableStreamDefaultTee(stream);
          }
          __name(ReadableStreamTee, "ReadableStreamTee");
          function ReadableStreamDefaultTee(stream, cloneForBranch2) {
            const reader = AcquireReadableStreamDefaultReader(stream);
            let reading = false;
            let readAgain = false;
            let canceled1 = false;
            let canceled2 = false;
            let reason1;
            let reason2;
            let branch1;
            let branch2;
            let resolveCancelPromise;
            const cancelPromise = newPromise((resolve) => {
              resolveCancelPromise = resolve;
            });
            function pullAlgorithm() {
              if (reading) {
                readAgain = true;
                return promiseResolvedWith(void 0);
              }
              reading = true;
              const readRequest = {
                _chunkSteps: (chunk) => {
                  queueMicrotask2(() => {
                    readAgain = false;
                    const chunk1 = chunk;
                    const chunk2 = chunk;
                    if (!canceled1) {
                      ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                    }
                    if (!canceled2) {
                      ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                    }
                    reading = false;
                    if (readAgain) {
                      pullAlgorithm();
                    }
                  });
                },
                _closeSteps: () => {
                  reading = false;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                  }
                  if (!canceled1 || !canceled2) {
                    resolveCancelPromise(void 0);
                  }
                },
                _errorSteps: () => {
                  reading = false;
                }
              };
              ReadableStreamDefaultReaderRead(reader, readRequest);
              return promiseResolvedWith(void 0);
            }
            __name(pullAlgorithm, "pullAlgorithm");
            function cancel1Algorithm(reason) {
              canceled1 = true;
              reason1 = reason;
              if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
              }
              return cancelPromise;
            }
            __name(cancel1Algorithm, "cancel1Algorithm");
            function cancel2Algorithm(reason) {
              canceled2 = true;
              reason2 = reason;
              if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
              }
              return cancelPromise;
            }
            __name(cancel2Algorithm, "cancel2Algorithm");
            function startAlgorithm() {
            }
            __name(startAlgorithm, "startAlgorithm");
            branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
            branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
            uponRejection(reader._closedPromise, (r11) => {
              ReadableStreamDefaultControllerError(branch1._readableStreamController, r11);
              ReadableStreamDefaultControllerError(branch2._readableStreamController, r11);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
            return [branch1, branch2];
          }
          __name(ReadableStreamDefaultTee, "ReadableStreamDefaultTee");
          function ReadableByteStreamTee(stream) {
            let reader = AcquireReadableStreamDefaultReader(stream);
            let reading = false;
            let readAgainForBranch1 = false;
            let readAgainForBranch2 = false;
            let canceled1 = false;
            let canceled2 = false;
            let reason1;
            let reason2;
            let branch1;
            let branch2;
            let resolveCancelPromise;
            const cancelPromise = newPromise((resolve) => {
              resolveCancelPromise = resolve;
            });
            function forwardReaderError(thisReader) {
              uponRejection(thisReader._closedPromise, (r11) => {
                if (thisReader !== reader) {
                  return;
                }
                ReadableByteStreamControllerError(branch1._readableStreamController, r11);
                ReadableByteStreamControllerError(branch2._readableStreamController, r11);
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              });
            }
            __name(forwardReaderError, "forwardReaderError");
            function pullWithDefaultReader() {
              if (IsReadableStreamBYOBReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamDefaultReader(stream);
                forwardReaderError(reader);
              }
              const readRequest = {
                _chunkSteps: (chunk) => {
                  queueMicrotask2(() => {
                    readAgainForBranch1 = false;
                    readAgainForBranch2 = false;
                    const chunk1 = chunk;
                    let chunk2 = chunk;
                    if (!canceled1 && !canceled2) {
                      try {
                        chunk2 = CloneAsUint8Array(chunk);
                      } catch (cloneE) {
                        ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                        ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                        return;
                      }
                    }
                    if (!canceled1) {
                      ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                    }
                    if (!canceled2) {
                      ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                    }
                    reading = false;
                    if (readAgainForBranch1) {
                      pull1Algorithm();
                    } else if (readAgainForBranch2) {
                      pull2Algorithm();
                    }
                  });
                },
                _closeSteps: () => {
                  reading = false;
                  if (!canceled1) {
                    ReadableByteStreamControllerClose(branch1._readableStreamController);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerClose(branch2._readableStreamController);
                  }
                  if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                  }
                  if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                  }
                  if (!canceled1 || !canceled2) {
                    resolveCancelPromise(void 0);
                  }
                },
                _errorSteps: () => {
                  reading = false;
                }
              };
              ReadableStreamDefaultReaderRead(reader, readRequest);
            }
            __name(pullWithDefaultReader, "pullWithDefaultReader");
            function pullWithBYOBReader(view2, forBranch2) {
              if (IsReadableStreamDefaultReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamBYOBReader(stream);
                forwardReaderError(reader);
              }
              const byobBranch = forBranch2 ? branch2 : branch1;
              const otherBranch = forBranch2 ? branch1 : branch2;
              const readIntoRequest = {
                _chunkSteps: (chunk) => {
                  queueMicrotask2(() => {
                    readAgainForBranch1 = false;
                    readAgainForBranch2 = false;
                    const byobCanceled = forBranch2 ? canceled2 : canceled1;
                    const otherCanceled = forBranch2 ? canceled1 : canceled2;
                    if (!otherCanceled) {
                      let clonedChunk;
                      try {
                        clonedChunk = CloneAsUint8Array(chunk);
                      } catch (cloneE) {
                        ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                        ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                        resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                        return;
                      }
                      if (!byobCanceled) {
                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                      }
                      ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                    } else if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    reading = false;
                    if (readAgainForBranch1) {
                      pull1Algorithm();
                    } else if (readAgainForBranch2) {
                      pull2Algorithm();
                    }
                  });
                },
                _closeSteps: (chunk) => {
                  reading = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!byobCanceled) {
                    ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                  }
                  if (!otherCanceled) {
                    ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                  }
                  if (chunk !== void 0) {
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                      ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                    }
                  }
                  if (!byobCanceled || !otherCanceled) {
                    resolveCancelPromise(void 0);
                  }
                },
                _errorSteps: () => {
                  reading = false;
                }
              };
              ReadableStreamBYOBReaderRead(reader, view2, readIntoRequest);
            }
            __name(pullWithBYOBReader, "pullWithBYOBReader");
            function pull1Algorithm() {
              if (reading) {
                readAgainForBranch1 = true;
                return promiseResolvedWith(void 0);
              }
              reading = true;
              const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
              if (byobRequest === null) {
                pullWithDefaultReader();
              } else {
                pullWithBYOBReader(byobRequest._view, false);
              }
              return promiseResolvedWith(void 0);
            }
            __name(pull1Algorithm, "pull1Algorithm");
            function pull2Algorithm() {
              if (reading) {
                readAgainForBranch2 = true;
                return promiseResolvedWith(void 0);
              }
              reading = true;
              const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
              if (byobRequest === null) {
                pullWithDefaultReader();
              } else {
                pullWithBYOBReader(byobRequest._view, true);
              }
              return promiseResolvedWith(void 0);
            }
            __name(pull2Algorithm, "pull2Algorithm");
            function cancel1Algorithm(reason) {
              canceled1 = true;
              reason1 = reason;
              if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
              }
              return cancelPromise;
            }
            __name(cancel1Algorithm, "cancel1Algorithm");
            function cancel2Algorithm(reason) {
              canceled2 = true;
              reason2 = reason;
              if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
              }
              return cancelPromise;
            }
            __name(cancel2Algorithm, "cancel2Algorithm");
            function startAlgorithm() {
              return;
            }
            __name(startAlgorithm, "startAlgorithm");
            branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
            branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
            forwardReaderError(reader);
            return [branch1, branch2];
          }
          __name(ReadableByteStreamTee, "ReadableByteStreamTee");
          function convertUnderlyingDefaultOrByteSource(source, context8) {
            assertDictionary(source, context8);
            const original = source;
            const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
            const cancel = original === null || original === void 0 ? void 0 : original.cancel;
            const pull = original === null || original === void 0 ? void 0 : original.pull;
            const start = original === null || original === void 0 ? void 0 : original.start;
            const type = original === null || original === void 0 ? void 0 : original.type;
            return {
              autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context8} has member 'autoAllocateChunkSize' that`),
              cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context8} has member 'cancel' that`),
              pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context8} has member 'pull' that`),
              start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context8} has member 'start' that`),
              type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context8} has member 'type' that`)
            };
          }
          __name(convertUnderlyingDefaultOrByteSource, "convertUnderlyingDefaultOrByteSource");
          function convertUnderlyingSourceCancelCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (reason) => promiseCall(fn, original, [reason]);
          }
          __name(convertUnderlyingSourceCancelCallback, "convertUnderlyingSourceCancelCallback");
          function convertUnderlyingSourcePullCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (controller) => promiseCall(fn, original, [controller]);
          }
          __name(convertUnderlyingSourcePullCallback, "convertUnderlyingSourcePullCallback");
          function convertUnderlyingSourceStartCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (controller) => reflectCall(fn, original, [controller]);
          }
          __name(convertUnderlyingSourceStartCallback, "convertUnderlyingSourceStartCallback");
          function convertReadableStreamType(type, context8) {
            type = `${type}`;
            if (type !== "bytes") {
              throw new TypeError(`${context8} '${type}' is not a valid enumeration value for ReadableStreamType`);
            }
            return type;
          }
          __name(convertReadableStreamType, "convertReadableStreamType");
          function convertReaderOptions(options, context8) {
            assertDictionary(options, context8);
            const mode = options === null || options === void 0 ? void 0 : options.mode;
            return {
              mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context8} has member 'mode' that`)
            };
          }
          __name(convertReaderOptions, "convertReaderOptions");
          function convertReadableStreamReaderMode(mode, context8) {
            mode = `${mode}`;
            if (mode !== "byob") {
              throw new TypeError(`${context8} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
            }
            return mode;
          }
          __name(convertReadableStreamReaderMode, "convertReadableStreamReaderMode");
          function convertIteratorOptions(options, context8) {
            assertDictionary(options, context8);
            const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
            return { preventCancel: Boolean(preventCancel) };
          }
          __name(convertIteratorOptions, "convertIteratorOptions");
          function convertPipeOptions(options, context8) {
            assertDictionary(options, context8);
            const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
            const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
            const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
            const signal = options === null || options === void 0 ? void 0 : options.signal;
            if (signal !== void 0) {
              assertAbortSignal(signal, `${context8} has member 'signal' that`);
            }
            return {
              preventAbort: Boolean(preventAbort),
              preventCancel: Boolean(preventCancel),
              preventClose: Boolean(preventClose),
              signal
            };
          }
          __name(convertPipeOptions, "convertPipeOptions");
          function assertAbortSignal(signal, context8) {
            if (!isAbortSignal3(signal)) {
              throw new TypeError(`${context8} is not an AbortSignal.`);
            }
          }
          __name(assertAbortSignal, "assertAbortSignal");
          function convertReadableWritablePair(pair, context8) {
            assertDictionary(pair, context8);
            const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
            assertRequiredField(readable, "readable", "ReadableWritablePair");
            assertReadableStream(readable, `${context8} has member 'readable' that`);
            const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
            assertRequiredField(writable, "writable", "ReadableWritablePair");
            assertWritableStream(writable, `${context8} has member 'writable' that`);
            return { readable, writable };
          }
          __name(convertReadableWritablePair, "convertReadableWritablePair");
          class ReadableStream2 {
            static {
              __name(this, "ReadableStream");
            }
            constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
              if (rawUnderlyingSource === void 0) {
                rawUnderlyingSource = null;
              } else {
                assertObject(rawUnderlyingSource, "First parameter");
              }
              const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
              const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
              InitializeReadableStream(this);
              if (underlyingSource.type === "bytes") {
                if (strategy.size !== void 0) {
                  throw new RangeError("The strategy for a byte stream cannot have a size function");
                }
                const highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
              } else {
                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                const highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
              }
            }
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get locked() {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("locked");
              }
              return IsReadableStreamLocked(this);
            }
            /**
             * Cancels the stream, signaling a loss of interest in the stream by a consumer.
             *
             * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
             * method, which might or might not use it.
             */
            cancel(reason = void 0) {
              if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1("cancel"));
              }
              if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
              }
              return ReadableStreamCancel(this, reason);
            }
            getReader(rawOptions = void 0) {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("getReader");
              }
              const options = convertReaderOptions(rawOptions, "First parameter");
              if (options.mode === void 0) {
                return AcquireReadableStreamDefaultReader(this);
              }
              return AcquireReadableStreamBYOBReader(this);
            }
            pipeThrough(rawTransform, rawOptions = {}) {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("pipeThrough");
              }
              assertRequiredArgument(rawTransform, 1, "pipeThrough");
              const transform = convertReadableWritablePair(rawTransform, "First parameter");
              const options = convertPipeOptions(rawOptions, "Second parameter");
              if (IsReadableStreamLocked(this)) {
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
              }
              if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
              }
              const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
              setPromiseIsHandledToTrue(promise);
              return transform.readable;
            }
            pipeTo(destination, rawOptions = {}) {
              if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
              }
              if (destination === void 0) {
                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
              }
              if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
              }
              let options;
              try {
                options = convertPipeOptions(rawOptions, "Second parameter");
              } catch (e11) {
                return promiseRejectedWith(e11);
              }
              if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
              }
              if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
              }
              return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            }
            /**
             * Tees this readable stream, returning a two-element array containing the two resulting branches as
             * new {@link ReadableStream} instances.
             *
             * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
             * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
             * propagated to the stream's underlying source.
             *
             * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
             * this could allow interference between the two branches.
             */
            tee() {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("tee");
              }
              const branches = ReadableStreamTee(this);
              return CreateArrayFromList(branches);
            }
            values(rawOptions = void 0) {
              if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("values");
              }
              const options = convertIteratorOptions(rawOptions, "First parameter");
              return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
            }
          }
          Object.defineProperties(ReadableStream2.prototype, {
            cancel: { enumerable: true },
            getReader: { enumerable: true },
            pipeThrough: { enumerable: true },
            pipeTo: { enumerable: true },
            tee: { enumerable: true },
            values: { enumerable: true },
            locked: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
              value: "ReadableStream",
              configurable: true
            });
          }
          if (typeof SymbolPolyfill.asyncIterator === "symbol") {
            Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
              value: ReadableStream2.prototype.values,
              writable: true,
              configurable: true
            });
          }
          function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
            const stream = Object.create(ReadableStream2.prototype);
            InitializeReadableStream(stream);
            const controller = Object.create(ReadableStreamDefaultController.prototype);
            SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
            return stream;
          }
          __name(CreateReadableStream, "CreateReadableStream");
          function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
            const stream = Object.create(ReadableStream2.prototype);
            InitializeReadableStream(stream);
            const controller = Object.create(ReadableByteStreamController.prototype);
            SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
            return stream;
          }
          __name(CreateReadableByteStream, "CreateReadableByteStream");
          function InitializeReadableStream(stream) {
            stream._state = "readable";
            stream._reader = void 0;
            stream._storedError = void 0;
            stream._disturbed = false;
          }
          __name(InitializeReadableStream, "InitializeReadableStream");
          function IsReadableStream(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_readableStreamController")) {
              return false;
            }
            return x5 instanceof ReadableStream2;
          }
          __name(IsReadableStream, "IsReadableStream");
          function IsReadableStreamLocked(stream) {
            if (stream._reader === void 0) {
              return false;
            }
            return true;
          }
          __name(IsReadableStreamLocked, "IsReadableStreamLocked");
          function ReadableStreamCancel(stream, reason) {
            stream._disturbed = true;
            if (stream._state === "closed") {
              return promiseResolvedWith(void 0);
            }
            if (stream._state === "errored") {
              return promiseRejectedWith(stream._storedError);
            }
            ReadableStreamClose(stream);
            const reader = stream._reader;
            if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
              reader._readIntoRequests.forEach((readIntoRequest) => {
                readIntoRequest._closeSteps(void 0);
              });
              reader._readIntoRequests = new SimpleQueue();
            }
            const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
            return transformPromiseWith(sourceCancelPromise, noop);
          }
          __name(ReadableStreamCancel, "ReadableStreamCancel");
          function ReadableStreamClose(stream) {
            stream._state = "closed";
            const reader = stream._reader;
            if (reader === void 0) {
              return;
            }
            defaultReaderClosedPromiseResolve(reader);
            if (IsReadableStreamDefaultReader(reader)) {
              reader._readRequests.forEach((readRequest) => {
                readRequest._closeSteps();
              });
              reader._readRequests = new SimpleQueue();
            }
          }
          __name(ReadableStreamClose, "ReadableStreamClose");
          function ReadableStreamError(stream, e11) {
            stream._state = "errored";
            stream._storedError = e11;
            const reader = stream._reader;
            if (reader === void 0) {
              return;
            }
            defaultReaderClosedPromiseReject(reader, e11);
            if (IsReadableStreamDefaultReader(reader)) {
              reader._readRequests.forEach((readRequest) => {
                readRequest._errorSteps(e11);
              });
              reader._readRequests = new SimpleQueue();
            } else {
              reader._readIntoRequests.forEach((readIntoRequest) => {
                readIntoRequest._errorSteps(e11);
              });
              reader._readIntoRequests = new SimpleQueue();
            }
          }
          __name(ReadableStreamError, "ReadableStreamError");
          function streamBrandCheckException$1(name2) {
            return new TypeError(`ReadableStream.prototype.${name2} can only be used on a ReadableStream`);
          }
          __name(streamBrandCheckException$1, "streamBrandCheckException$1");
          function convertQueuingStrategyInit(init2, context8) {
            assertDictionary(init2, context8);
            const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
            assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
            return {
              highWaterMark: convertUnrestrictedDouble(highWaterMark)
            };
          }
          __name(convertQueuingStrategyInit, "convertQueuingStrategyInit");
          const byteLengthSizeFunction = /* @__PURE__ */ __name((chunk) => {
            return chunk.byteLength;
          }, "byteLengthSizeFunction");
          try {
            Object.defineProperty(byteLengthSizeFunction, "name", {
              value: "size",
              configurable: true
            });
          } catch (_a2) {
          }
          class ByteLengthQueuingStrategy {
            static {
              __name(this, "ByteLengthQueuingStrategy");
            }
            constructor(options) {
              assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
              options = convertQueuingStrategyInit(options, "First parameter");
              this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
            }
            /**
             * Returns the high water mark provided to the constructor.
             */
            get highWaterMark() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("highWaterMark");
              }
              return this._byteLengthQueuingStrategyHighWaterMark;
            }
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get size() {
              if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException("size");
              }
              return byteLengthSizeFunction;
            }
          }
          Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
            highWaterMark: { enumerable: true },
            size: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
              value: "ByteLengthQueuingStrategy",
              configurable: true
            });
          }
          function byteLengthBrandCheckException(name2) {
            return new TypeError(`ByteLengthQueuingStrategy.prototype.${name2} can only be used on a ByteLengthQueuingStrategy`);
          }
          __name(byteLengthBrandCheckException, "byteLengthBrandCheckException");
          function IsByteLengthQueuingStrategy(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_byteLengthQueuingStrategyHighWaterMark")) {
              return false;
            }
            return x5 instanceof ByteLengthQueuingStrategy;
          }
          __name(IsByteLengthQueuingStrategy, "IsByteLengthQueuingStrategy");
          const countSizeFunction = /* @__PURE__ */ __name(() => {
            return 1;
          }, "countSizeFunction");
          try {
            Object.defineProperty(countSizeFunction, "name", {
              value: "size",
              configurable: true
            });
          } catch (_a2) {
          }
          class CountQueuingStrategy {
            static {
              __name(this, "CountQueuingStrategy");
            }
            constructor(options) {
              assertRequiredArgument(options, 1, "CountQueuingStrategy");
              options = convertQueuingStrategyInit(options, "First parameter");
              this._countQueuingStrategyHighWaterMark = options.highWaterMark;
            }
            /**
             * Returns the high water mark provided to the constructor.
             */
            get highWaterMark() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("highWaterMark");
              }
              return this._countQueuingStrategyHighWaterMark;
            }
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get size() {
              if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException("size");
              }
              return countSizeFunction;
            }
          }
          Object.defineProperties(CountQueuingStrategy.prototype, {
            highWaterMark: { enumerable: true },
            size: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
              value: "CountQueuingStrategy",
              configurable: true
            });
          }
          function countBrandCheckException(name2) {
            return new TypeError(`CountQueuingStrategy.prototype.${name2} can only be used on a CountQueuingStrategy`);
          }
          __name(countBrandCheckException, "countBrandCheckException");
          function IsCountQueuingStrategy(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_countQueuingStrategyHighWaterMark")) {
              return false;
            }
            return x5 instanceof CountQueuingStrategy;
          }
          __name(IsCountQueuingStrategy, "IsCountQueuingStrategy");
          function convertTransformer(original, context8) {
            assertDictionary(original, context8);
            const flush = original === null || original === void 0 ? void 0 : original.flush;
            const readableType = original === null || original === void 0 ? void 0 : original.readableType;
            const start = original === null || original === void 0 ? void 0 : original.start;
            const transform = original === null || original === void 0 ? void 0 : original.transform;
            const writableType = original === null || original === void 0 ? void 0 : original.writableType;
            return {
              flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context8} has member 'flush' that`),
              readableType,
              start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context8} has member 'start' that`),
              transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context8} has member 'transform' that`),
              writableType
            };
          }
          __name(convertTransformer, "convertTransformer");
          function convertTransformerFlushCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (controller) => promiseCall(fn, original, [controller]);
          }
          __name(convertTransformerFlushCallback, "convertTransformerFlushCallback");
          function convertTransformerStartCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (controller) => reflectCall(fn, original, [controller]);
          }
          __name(convertTransformerStartCallback, "convertTransformerStartCallback");
          function convertTransformerTransformCallback(fn, original, context8) {
            assertFunction(fn, context8);
            return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
          }
          __name(convertTransformerTransformCallback, "convertTransformerTransformCallback");
          class TransformStream {
            static {
              __name(this, "TransformStream");
            }
            constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
              if (rawTransformer === void 0) {
                rawTransformer = null;
              }
              const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
              const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
              const transformer = convertTransformer(rawTransformer, "First parameter");
              if (transformer.readableType !== void 0) {
                throw new RangeError("Invalid readableType specified");
              }
              if (transformer.writableType !== void 0) {
                throw new RangeError("Invalid writableType specified");
              }
              const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
              const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
              const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
              const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
              let startPromise_resolve;
              const startPromise = newPromise((resolve) => {
                startPromise_resolve = resolve;
              });
              InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
              SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
              if (transformer.start !== void 0) {
                startPromise_resolve(transformer.start(this._transformStreamController));
              } else {
                startPromise_resolve(void 0);
              }
            }
            /**
             * The readable side of the transform stream.
             */
            get readable() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("readable");
              }
              return this._readable;
            }
            /**
             * The writable side of the transform stream.
             */
            get writable() {
              if (!IsTransformStream(this)) {
                throw streamBrandCheckException("writable");
              }
              return this._writable;
            }
          }
          Object.defineProperties(TransformStream.prototype, {
            readable: { enumerable: true },
            writable: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
              value: "TransformStream",
              configurable: true
            });
          }
          function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
            function startAlgorithm() {
              return startPromise;
            }
            __name(startAlgorithm, "startAlgorithm");
            function writeAlgorithm(chunk) {
              return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
            }
            __name(writeAlgorithm, "writeAlgorithm");
            function abortAlgorithm(reason) {
              return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
            }
            __name(abortAlgorithm, "abortAlgorithm");
            function closeAlgorithm() {
              return TransformStreamDefaultSinkCloseAlgorithm(stream);
            }
            __name(closeAlgorithm, "closeAlgorithm");
            stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
            function pullAlgorithm() {
              return TransformStreamDefaultSourcePullAlgorithm(stream);
            }
            __name(pullAlgorithm, "pullAlgorithm");
            function cancelAlgorithm(reason) {
              TransformStreamErrorWritableAndUnblockWrite(stream, reason);
              return promiseResolvedWith(void 0);
            }
            __name(cancelAlgorithm, "cancelAlgorithm");
            stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            stream._backpressure = void 0;
            stream._backpressureChangePromise = void 0;
            stream._backpressureChangePromise_resolve = void 0;
            TransformStreamSetBackpressure(stream, true);
            stream._transformStreamController = void 0;
          }
          __name(InitializeTransformStream, "InitializeTransformStream");
          function IsTransformStream(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_transformStreamController")) {
              return false;
            }
            return x5 instanceof TransformStream;
          }
          __name(IsTransformStream, "IsTransformStream");
          function TransformStreamError(stream, e11) {
            ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e11);
            TransformStreamErrorWritableAndUnblockWrite(stream, e11);
          }
          __name(TransformStreamError, "TransformStreamError");
          function TransformStreamErrorWritableAndUnblockWrite(stream, e11) {
            TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
            WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e11);
            if (stream._backpressure) {
              TransformStreamSetBackpressure(stream, false);
            }
          }
          __name(TransformStreamErrorWritableAndUnblockWrite, "TransformStreamErrorWritableAndUnblockWrite");
          function TransformStreamSetBackpressure(stream, backpressure) {
            if (stream._backpressureChangePromise !== void 0) {
              stream._backpressureChangePromise_resolve();
            }
            stream._backpressureChangePromise = newPromise((resolve) => {
              stream._backpressureChangePromise_resolve = resolve;
            });
            stream._backpressure = backpressure;
          }
          __name(TransformStreamSetBackpressure, "TransformStreamSetBackpressure");
          class TransformStreamDefaultController {
            static {
              __name(this, "TransformStreamDefaultController");
            }
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            /**
             * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
             */
            get desiredSize() {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("desiredSize");
              }
              const readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            }
            enqueue(chunk = void 0) {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("enqueue");
              }
              TransformStreamDefaultControllerEnqueue(this, chunk);
            }
            /**
             * Errors both the readable side and the writable side of the controlled transform stream, making all future
             * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
             */
            error(reason = void 0) {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("error");
              }
              TransformStreamDefaultControllerError(this, reason);
            }
            /**
             * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
             * transformer only needs to consume a portion of the chunks written to the writable side.
             */
            terminate() {
              if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("terminate");
              }
              TransformStreamDefaultControllerTerminate(this);
            }
          }
          Object.defineProperties(TransformStreamDefaultController.prototype, {
            enqueue: { enumerable: true },
            error: { enumerable: true },
            terminate: { enumerable: true },
            desiredSize: { enumerable: true }
          });
          if (typeof SymbolPolyfill.toStringTag === "symbol") {
            Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
              value: "TransformStreamDefaultController",
              configurable: true
            });
          }
          function IsTransformStreamDefaultController(x5) {
            if (!typeIsObject(x5)) {
              return false;
            }
            if (!Object.prototype.hasOwnProperty.call(x5, "_controlledTransformStream")) {
              return false;
            }
            return x5 instanceof TransformStreamDefaultController;
          }
          __name(IsTransformStreamDefaultController, "IsTransformStreamDefaultController");
          function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
            controller._controlledTransformStream = stream;
            stream._transformStreamController = controller;
            controller._transformAlgorithm = transformAlgorithm;
            controller._flushAlgorithm = flushAlgorithm;
          }
          __name(SetUpTransformStreamDefaultController, "SetUpTransformStreamDefaultController");
          function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
            const controller = Object.create(TransformStreamDefaultController.prototype);
            let transformAlgorithm = /* @__PURE__ */ __name((chunk) => {
              try {
                TransformStreamDefaultControllerEnqueue(controller, chunk);
                return promiseResolvedWith(void 0);
              } catch (transformResultE) {
                return promiseRejectedWith(transformResultE);
              }
            }, "transformAlgorithm");
            let flushAlgorithm = /* @__PURE__ */ __name(() => promiseResolvedWith(void 0), "flushAlgorithm");
            if (transformer.transform !== void 0) {
              transformAlgorithm = /* @__PURE__ */ __name((chunk) => transformer.transform(chunk, controller), "transformAlgorithm");
            }
            if (transformer.flush !== void 0) {
              flushAlgorithm = /* @__PURE__ */ __name(() => transformer.flush(controller), "flushAlgorithm");
            }
            SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
          }
          __name(SetUpTransformStreamDefaultControllerFromTransformer, "SetUpTransformStreamDefaultControllerFromTransformer");
          function TransformStreamDefaultControllerClearAlgorithms(controller) {
            controller._transformAlgorithm = void 0;
            controller._flushAlgorithm = void 0;
          }
          __name(TransformStreamDefaultControllerClearAlgorithms, "TransformStreamDefaultControllerClearAlgorithms");
          function TransformStreamDefaultControllerEnqueue(controller, chunk) {
            const stream = controller._controlledTransformStream;
            const readableController = stream._readable._readableStreamController;
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
              throw new TypeError("Readable side is not in a state that permits enqueue");
            }
            try {
              ReadableStreamDefaultControllerEnqueue(readableController, chunk);
            } catch (e11) {
              TransformStreamErrorWritableAndUnblockWrite(stream, e11);
              throw stream._readable._storedError;
            }
            const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
            if (backpressure !== stream._backpressure) {
              TransformStreamSetBackpressure(stream, true);
            }
          }
          __name(TransformStreamDefaultControllerEnqueue, "TransformStreamDefaultControllerEnqueue");
          function TransformStreamDefaultControllerError(controller, e11) {
            TransformStreamError(controller._controlledTransformStream, e11);
          }
          __name(TransformStreamDefaultControllerError, "TransformStreamDefaultControllerError");
          function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
            const transformPromise = controller._transformAlgorithm(chunk);
            return transformPromiseWith(transformPromise, void 0, (r11) => {
              TransformStreamError(controller._controlledTransformStream, r11);
              throw r11;
            });
          }
          __name(TransformStreamDefaultControllerPerformTransform, "TransformStreamDefaultControllerPerformTransform");
          function TransformStreamDefaultControllerTerminate(controller) {
            const stream = controller._controlledTransformStream;
            const readableController = stream._readable._readableStreamController;
            ReadableStreamDefaultControllerClose(readableController);
            const error = new TypeError("TransformStream terminated");
            TransformStreamErrorWritableAndUnblockWrite(stream, error);
          }
          __name(TransformStreamDefaultControllerTerminate, "TransformStreamDefaultControllerTerminate");
          function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
            const controller = stream._transformStreamController;
            if (stream._backpressure) {
              const backpressureChangePromise = stream._backpressureChangePromise;
              return transformPromiseWith(backpressureChangePromise, () => {
                const writable = stream._writable;
                const state = writable._state;
                if (state === "erroring") {
                  throw writable._storedError;
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
              });
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          }
          __name(TransformStreamDefaultSinkWriteAlgorithm, "TransformStreamDefaultSinkWriteAlgorithm");
          function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
            TransformStreamError(stream, reason);
            return promiseResolvedWith(void 0);
          }
          __name(TransformStreamDefaultSinkAbortAlgorithm, "TransformStreamDefaultSinkAbortAlgorithm");
          function TransformStreamDefaultSinkCloseAlgorithm(stream) {
            const readable = stream._readable;
            const controller = stream._transformStreamController;
            const flushPromise = controller._flushAlgorithm();
            TransformStreamDefaultControllerClearAlgorithms(controller);
            return transformPromiseWith(flushPromise, () => {
              if (readable._state === "errored") {
                throw readable._storedError;
              }
              ReadableStreamDefaultControllerClose(readable._readableStreamController);
            }, (r11) => {
              TransformStreamError(stream, r11);
              throw readable._storedError;
            });
          }
          __name(TransformStreamDefaultSinkCloseAlgorithm, "TransformStreamDefaultSinkCloseAlgorithm");
          function TransformStreamDefaultSourcePullAlgorithm(stream) {
            TransformStreamSetBackpressure(stream, false);
            return stream._backpressureChangePromise;
          }
          __name(TransformStreamDefaultSourcePullAlgorithm, "TransformStreamDefaultSourcePullAlgorithm");
          function defaultControllerBrandCheckException(name2) {
            return new TypeError(`TransformStreamDefaultController.prototype.${name2} can only be used on a TransformStreamDefaultController`);
          }
          __name(defaultControllerBrandCheckException, "defaultControllerBrandCheckException");
          function streamBrandCheckException(name2) {
            return new TypeError(`TransformStream.prototype.${name2} can only be used on a TransformStream`);
          }
          __name(streamBrandCheckException, "streamBrandCheckException");
          exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
          exports3.CountQueuingStrategy = CountQueuingStrategy;
          exports3.ReadableByteStreamController = ReadableByteStreamController;
          exports3.ReadableStream = ReadableStream2;
          exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
          exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
          exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
          exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
          exports3.TransformStream = TransformStream;
          exports3.TransformStreamDefaultController = TransformStreamDefaultController;
          exports3.WritableStream = WritableStream;
          exports3.WritableStreamDefaultController = WritableStreamDefaultController;
          exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
          Object.defineProperty(exports3, "__esModule", { value: true });
        });
      })(ponyfill_es2018, ponyfill_es2018.exports);
      return ponyfill_es2018.exports;
    }
    __name(requirePonyfill_es2018, "requirePonyfill_es2018");
    var POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process3 = __require("node:process");
        const { emitWarning } = process3;
        try {
          process3.emitWarning = () => {
          };
          Object.assign(globalThis, __require("node:stream/web"));
          process3.emitWarning = emitWarning;
        } catch (error) {
          process3.emitWarning = emitWarning;
          throw error;
        }
      } catch (error) {
        Object.assign(globalThis, requirePonyfill_es2018());
      }
    }
    try {
      const { Blob: Blob3 } = __require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = /* @__PURE__ */ __name(function name2(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        }, "name");
      }
    } catch (error) {
    }
    var POOL_SIZE = 65536;
    async function* toIterator(parts, clone3 = true) {
      for (const part of parts) {
        if ("stream" in part) {
          yield* (
            /** @type {AsyncIterableIterator<Uint8Array>} */
            part.stream()
          );
        } else if (ArrayBuffer.isView(part)) {
          if (clone3) {
            let position = part.byteOffset;
            const end = part.byteOffset + part.byteLength;
            while (position !== end) {
              const size = Math.min(end - position, POOL_SIZE);
              const chunk = part.buffer.slice(position, position + size);
              position += chunk.byteLength;
              yield new Uint8Array(chunk);
            }
          } else {
            yield part;
          }
        } else {
          let position = 0, b11 = (
            /** @type {Blob} */
            part
          );
          while (position !== b11.size) {
            const chunk = b11.slice(position, Math.min(b11.size, position + POOL_SIZE));
            const buffer = await chunk.arrayBuffer();
            position += buffer.byteLength;
            yield new Uint8Array(buffer);
          }
        }
      }
    }
    __name(toIterator, "toIterator");
    var _Blob = class Blob3 {
      static {
        __name(this, "Blob");
      }
      /** @type {Array.<(Blob|Uint8Array)>} */
      #parts = [];
      #type = "";
      #size = 0;
      #endings = "transparent";
      /**
       * The Blob() constructor returns a new Blob object. The content
       * of the blob consists of the concatenation of the values given
       * in the parameter array.
       *
       * @param {*} blobParts
       * @param {{ type?: string, endings?: string }} [options]
       */
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob3) {
            part = element;
          } else {
            part = encoder2.encode(`${element}`);
          }
          const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (size) {
            this.#size += size;
            this.#parts.push(part);
          }
        }
        this.#endings = `${options.endings === void 0 ? "transparent" : options.endings}`;
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      /**
       * The Blob interface's size property returns the
       * size of the Blob in bytes.
       */
      get size() {
        return this.#size;
      }
      /**
       * The type property of a Blob object returns the MIME type of the file.
       */
      get type() {
        return this.#type;
      }
      /**
       * The text() method in the Blob interface returns a Promise
       * that resolves with a string containing the contents of
       * the blob, interpreted as UTF-8.
       *
       * @return {Promise<string>}
       */
      async text() {
        const decoder2 = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder2.decode(part, { stream: true });
        }
        str += decoder2.decode();
        return str;
      }
      /**
       * The arrayBuffer() method in the Blob interface returns a
       * Promise that resolves with the contents of the blob as
       * binary data contained in an ArrayBuffer.
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          // @ts-ignore
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      /**
       * The Blob interface's slice() method creates and returns a
       * new Blob object which contains data from a subset of the
       * blob on which it's called.
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [type]
       */
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob3([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    var Blob2 = _Blob;
    var _Blob$1 = Blob2;
    var _File = class File extends _Blob$1 {
      static {
        __name(this, "File");
      }
      #lastModified = 0;
      #name = "";
      /**
       * @param {*[]} fileBits
       * @param {string} fileName
       * @param {{lastModified?: number, type?: string}} options
       */
      // @ts-ignore
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](object) {
        return !!object && object instanceof _Blob$1 && /^(File)$/.test(object[Symbol.toStringTag]);
      }
    };
    var File = _File;
    var File$1 = File;
    var { toStringTag: t6, iterator: i10, hasInstance: h10 } = Symbol;
    var r10 = Math.random;
    var m11 = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    var f11 = /* @__PURE__ */ __name((a10, b11, c11) => (a10 += "", /^(Blob|File)$/.test(b11 && b11[t6]) ? [(c11 = c11 !== void 0 ? c11 + "" : b11[t6] == "File" ? b11.name : "blob", a10), b11.name !== c11 || b11[t6] == "blob" ? new File$1([b11], c11, b11) : b11] : [a10, b11 + ""]), "f");
    var e10 = /* @__PURE__ */ __name((c11, f12) => (f12 ? c11 : c11.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "e");
    var x4 = /* @__PURE__ */ __name((n10, a10, e11) => {
      if (a10.length < e11) {
        throw new TypeError(`Failed to execute '${n10}' on 'FormData': ${e11} arguments required, but only ${a10.length} present.`);
      }
    }, "x");
    var FormData2 = class FormData {
      static {
        __name(this, "FormData");
      }
      #d = [];
      constructor(...a10) {
        if (a10.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t6]() {
        return "FormData";
      }
      [i10]() {
        return this.entries();
      }
      static [h10](o10) {
        return o10 && typeof o10 === "object" && o10[t6] === "FormData" && !m11.some((m12) => typeof o10[m12] != "function");
      }
      append(...a10) {
        x4("append", arguments, 2);
        this.#d.push(f11(...a10));
      }
      delete(a10) {
        x4("delete", arguments, 1);
        a10 += "";
        this.#d = this.#d.filter(([b11]) => b11 !== a10);
      }
      get(a10) {
        x4("get", arguments, 1);
        a10 += "";
        for (var b11 = this.#d, l10 = b11.length, c11 = 0; c11 < l10; c11++)
          if (b11[c11][0] === a10)
            return b11[c11][1];
        return null;
      }
      getAll(a10, b11) {
        x4("getAll", arguments, 1);
        b11 = [];
        a10 += "";
        this.#d.forEach((c11) => c11[0] === a10 && b11.push(c11[1]));
        return b11;
      }
      has(a10) {
        x4("has", arguments, 1);
        a10 += "";
        return this.#d.some((b11) => b11[0] === a10);
      }
      forEach(a10, b11) {
        x4("forEach", arguments, 1);
        for (var [c11, d10] of this)
          a10.call(b11, d10, c11, this);
      }
      set(...a10) {
        x4("set", arguments, 2);
        var b11 = [], c11 = true;
        a10 = f11(...a10);
        this.#d.forEach((d10) => {
          d10[0] === a10[0] ? c11 && (c11 = !b11.push(a10)) : b11.push(d10);
        });
        c11 && b11.push(a10);
        this.#d = b11;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a10] of this)
          yield a10;
      }
      *values() {
        for (var [, a10] of this)
          yield a10;
      }
    };
    function formDataToBlob(F4, B4 = _Blob$1) {
      var b11 = `${r10()}${r10()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c11 = [], p11 = `--${b11}\r
Content-Disposition: form-data; name="`;
      F4.forEach((v7, n10) => typeof v7 == "string" ? c11.push(p11 + e10(n10) + `"\r
\r
${v7.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c11.push(p11 + e10(n10) + `"; filename="${e10(v7.name, 1)}"\r
Content-Type: ${v7.type || "application/octet-stream"}\r
\r
`, v7, "\r\n"));
      c11.push(`--${b11}--`);
      return new B4(c11, { type: "multipart/form-data; boundary=" + b11 });
    }
    __name(formDataToBlob, "formDataToBlob");
    var FetchBaseError = class extends Error {
      static {
        __name(this, "FetchBaseError");
      }
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var FetchError2 = class extends FetchBaseError {
      static {
        __name(this, "FetchError");
      }
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} [type] -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    var NAME2 = Symbol.toStringTag;
    var isURLSearchParameters = /* @__PURE__ */ __name((object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME2] === "URLSearchParams";
    }, "isURLSearchParameters");
    var isBlob2 = /* @__PURE__ */ __name((object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME2]);
    }, "isBlob");
    var isAbortSignal2 = /* @__PURE__ */ __name((object) => {
      return typeof object === "object" && (object[NAME2] === "AbortSignal" || object[NAME2] === "EventTarget");
    }, "isAbortSignal");
    var isDomainOrSubdomain3 = /* @__PURE__ */ __name((destination, original) => {
      const orig = new URL(original).hostname;
      const dest = new URL(destination).hostname;
      return orig === dest || orig.endsWith(`.${dest}`);
    }, "isDomainOrSubdomain");
    var isSameProtocol3 = /* @__PURE__ */ __name((destination, original) => {
      const orig = new URL(original).protocol;
      const dest = new URL(destination).protocol;
      return orig === dest;
    }, "isSameProtocol");
    var pipeline = node_util.promisify(Stream3.pipeline);
    var INTERNALS$22 = Symbol("Body internals");
    var Body2 = class {
      static {
        __name(this, "Body");
      }
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = node_buffer.Buffer.from(body.toString());
        } else if (isBlob2(body))
          ;
        else if (node_buffer.Buffer.isBuffer(body))
          ;
        else if (node_util.types.isAnyArrayBuffer(body)) {
          body = node_buffer.Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof Stream3)
          ;
        else if (body instanceof FormData2) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = node_buffer.Buffer.from(String(body));
        }
        let stream = body;
        if (node_buffer.Buffer.isBuffer(body)) {
          stream = Stream3.Readable.from(body);
        } else if (isBlob2(body)) {
          stream = Stream3.Readable.from(body.stream());
        }
        this[INTERNALS$22] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof Stream3) {
          body.on("error", (error_) => {
            const error = error_ instanceof FetchBaseError ? error_ : new FetchError2(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$22].error = error;
          });
        }
      }
      get body() {
        return this[INTERNALS$22].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$22].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength: byteLength2 } = await consumeBody2(this);
        return buffer.slice(byteOffset, byteOffset + byteLength2);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData2();
          const parameters2 = new URLSearchParams(await this.text());
          for (const [name2, value] of parameters2) {
            formData.append(name2, value);
          }
          return formData;
        }
        const { toFormData } = await Promise.resolve().then(() => __toESM(require_multipart_parser()));
        return toFormData(this.body, ct);
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$22].body && this[INTERNALS$22].body.type || "";
        const buf = await this.arrayBuffer();
        return new _Blob$1([buf], {
          type: ct
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      async json() {
        const text2 = await this.text();
        return JSON.parse(text2);
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      async text() {
        const buffer = await consumeBody2(this);
        return new TextDecoder().decode(buffer);
      }
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody2(this);
      }
    };
    Body2.prototype.buffer = node_util.deprecate(Body2.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body2.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true },
      data: { get: node_util.deprecate(
        () => {
        },
        "data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
        "https://github.com/node-fetch/node-fetch/issues/1000 (response)"
      ) }
    });
    async function consumeBody2(data) {
      if (data[INTERNALS$22].disturbed) {
        throw new TypeError(`body used already for: ${data.url}`);
      }
      data[INTERNALS$22].disturbed = true;
      if (data[INTERNALS$22].error) {
        throw data[INTERNALS$22].error;
      }
      const { body } = data;
      if (body === null) {
        return node_buffer.Buffer.alloc(0);
      }
      if (!(body instanceof Stream3)) {
        return node_buffer.Buffer.alloc(0);
      }
      const accum = [];
      let accumBytes = 0;
      try {
        for await (const chunk of body) {
          if (data.size > 0 && accumBytes + chunk.length > data.size) {
            const error = new FetchError2(`content size at ${data.url} over limit: ${data.size}`, "max-size");
            body.destroy(error);
            throw error;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        }
      } catch (error) {
        const error_ = error instanceof FetchBaseError ? error : new FetchError2(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
        throw error_;
      }
      if (body.readableEnded === true || body._readableState.ended === true) {
        try {
          if (accum.every((c11) => typeof c11 === "string")) {
            return node_buffer.Buffer.from(accum.join(""));
          }
          return node_buffer.Buffer.concat(accum, accumBytes);
        } catch (error) {
          throw new FetchError2(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
        }
      } else {
        throw new FetchError2(`Premature close of server response while trying to fetch ${data.url}`);
      }
    }
    __name(consumeBody2, "consumeBody");
    var clone2 = /* @__PURE__ */ __name((instance, highWaterMark) => {
      let p1;
      let p22;
      let { body } = instance[INTERNALS$22];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream3 && typeof body.getBoundary !== "function") {
        p1 = new Stream3.PassThrough({ highWaterMark });
        p22 = new Stream3.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p22);
        instance[INTERNALS$22].stream = p1;
        body = p22;
      }
      return body;
    }, "clone");
    var getNonSpecFormDataBoundary = node_util.deprecate(
      (body) => body.getBoundary(),
      "form-data doesn't follow the spec and requires special treatment. Use alternative package",
      "https://github.com/node-fetch/node-fetch/issues/1167"
    );
    var extractContentType2 = /* @__PURE__ */ __name((body, request3) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob2(body)) {
        return body.type || null;
      }
      if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData2) {
        return `multipart/form-data; boundary=${request3[INTERNALS$22].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof Stream3) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    }, "extractContentType");
    var getTotalBytes2 = /* @__PURE__ */ __name((request3) => {
      const { body } = request3[INTERNALS$22];
      if (body === null) {
        return 0;
      }
      if (isBlob2(body)) {
        return body.size;
      }
      if (node_buffer.Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    }, "getTotalBytes");
    var writeToStream2 = /* @__PURE__ */ __name(async (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        await pipeline(body, dest);
      }
    }, "writeToStream");
    var validateHeaderName = typeof http2.validateHeaderName === "function" ? http2.validateHeaderName : (name2) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name2)) {
        const error = new TypeError(`Header name must be a valid HTTP token [${name2}]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error;
      }
    };
    var validateHeaderValue = typeof http2.validateHeaderValue === "function" ? http2.validateHeaderValue : (name2, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error = new TypeError(`Invalid character in header content ["${name2}"]`);
        Object.defineProperty(error, "code", { value: "ERR_INVALID_CHAR" });
        throw error;
      }
    };
    var Headers3 = class _Headers extends URLSearchParams {
      static {
        __name(this, "Headers");
      }
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init2) {
        let result = [];
        if (init2 instanceof _Headers) {
          const raw = init2.raw();
          for (const [name2, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name2, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !node_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || node_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name2, value]) => {
          validateHeaderName(name2);
          validateHeaderValue(name2, String(value));
          return [String(name2).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p11, receiver) {
            switch (p11) {
              case "append":
              case "set":
                return (name2, value) => {
                  validateHeaderName(name2);
                  validateHeaderValue(name2, String(value));
                  return URLSearchParams.prototype[p11].call(
                    target,
                    String(name2).toLowerCase(),
                    String(value)
                  );
                };
              case "delete":
              case "has":
              case "getAll":
                return (name2) => {
                  validateHeaderName(name2);
                  return URLSearchParams.prototype[p11].call(
                    target,
                    String(name2).toLowerCase()
                  );
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p11, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name2) {
        const values = this.getAll(name2);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name2)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name2 of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name2), name2, this]);
        }
      }
      *values() {
        for (const name2 of this.keys()) {
          yield this.get(name2);
        }
      }
      /**
       * @type {() => IterableIterator<[string, string]>}
       */
      *entries() {
        for (const name2 of this.keys()) {
          yield [name2, this.get(name2)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(
      Headers3.prototype,
      ["get", "entries", "forEach", "values"].reduce((result, property) => {
        result[property] = { enumerable: true };
        return result;
      }, {})
    );
    function fromRawHeaders(headers = []) {
      return new Headers3(
        headers.reduce((result, value, index2, array) => {
          if (index2 % 2 === 0) {
            result.push(array.slice(index2, index2 + 2));
          }
          return result;
        }, []).filter(([name2, value]) => {
          try {
            validateHeaderName(name2);
            validateHeaderValue(name2, String(value));
            return true;
          } catch {
            return false;
          }
        })
      );
    }
    __name(fromRawHeaders, "fromRawHeaders");
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    var isRedirect = /* @__PURE__ */ __name((code2) => {
      return redirectStatus.has(code2);
    }, "isRedirect");
    var INTERNALS$12 = Symbol("Response internals");
    var Response2 = class _Response extends Body2 {
      static {
        __name(this, "Response");
      }
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers3(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$12] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$12].type;
      }
      get url() {
        return this[INTERNALS$12].url || "";
      }
      get status() {
        return this[INTERNALS$12].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$12].status >= 200 && this[INTERNALS$12].status < 300;
      }
      get redirected() {
        return this[INTERNALS$12].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$12].statusText;
      }
      get headers() {
        return this[INTERNALS$12].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$12].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone2(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url12, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new _Response(null, {
          headers: {
            location: new URL(url12).toString()
          },
          status
        });
      }
      static error() {
        const response = new _Response(null, { status: 0, statusText: "" });
        response[INTERNALS$12].type = "error";
        return response;
      }
      static json(data = void 0, init2 = {}) {
        const body = JSON.stringify(data);
        if (body === void 0) {
          throw new TypeError("data is not JSON serializable");
        }
        const headers = new Headers3(init2 && init2.headers);
        if (!headers.has("content-type")) {
          headers.set("content-type", "application/json");
        }
        return new _Response(body, {
          ...init2,
          headers
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    var getSearch = /* @__PURE__ */ __name((parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    }, "getSearch");
    function stripURLForUseAsAReferrer(url12, originOnly = false) {
      if (url12 == null) {
        return "no-referrer";
      }
      url12 = new URL(url12);
      if (/^(about|blob|data):$/.test(url12.protocol)) {
        return "no-referrer";
      }
      url12.username = "";
      url12.password = "";
      url12.hash = "";
      if (originOnly) {
        url12.pathname = "";
        url12.search = "";
      }
      return url12;
    }
    __name(stripURLForUseAsAReferrer, "stripURLForUseAsAReferrer");
    var ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    function validateReferrerPolicy(referrerPolicy) {
      if (!ReferrerPolicy.has(referrerPolicy)) {
        throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
      }
      return referrerPolicy;
    }
    __name(validateReferrerPolicy, "validateReferrerPolicy");
    function isOriginPotentiallyTrustworthy(url12) {
      if (/^(http|ws)s:$/.test(url12.protocol)) {
        return true;
      }
      const hostIp = url12.host.replace(/(^\[)|(]$)/g, "");
      const hostIPVersion = node_net.isIP(hostIp);
      if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
        return true;
      }
      if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
        return true;
      }
      if (url12.host === "localhost" || url12.host.endsWith(".localhost")) {
        return false;
      }
      if (url12.protocol === "file:") {
        return true;
      }
      return false;
    }
    __name(isOriginPotentiallyTrustworthy, "isOriginPotentiallyTrustworthy");
    function isUrlPotentiallyTrustworthy(url12) {
      if (/^about:(blank|srcdoc)$/.test(url12)) {
        return true;
      }
      if (url12.protocol === "data:") {
        return true;
      }
      if (/^(blob|filesystem):$/.test(url12.protocol)) {
        return true;
      }
      return isOriginPotentiallyTrustworthy(url12);
    }
    __name(isUrlPotentiallyTrustworthy, "isUrlPotentiallyTrustworthy");
    function determineRequestsReferrer(request3, { referrerURLCallback, referrerOriginCallback } = {}) {
      if (request3.referrer === "no-referrer" || request3.referrerPolicy === "") {
        return null;
      }
      const policy = request3.referrerPolicy;
      if (request3.referrer === "about:client") {
        return "no-referrer";
      }
      const referrerSource = request3.referrer;
      let referrerURL = stripURLForUseAsAReferrer(referrerSource);
      let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      if (referrerURLCallback) {
        referrerURL = referrerURLCallback(referrerURL);
      }
      if (referrerOriginCallback) {
        referrerOrigin = referrerOriginCallback(referrerOrigin);
      }
      const currentURL = new URL(request3.url);
      switch (policy) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          return referrerOrigin;
        case "unsafe-url":
          return referrerURL;
        case "strict-origin":
          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin.toString();
        case "strict-origin-when-cross-origin":
          if (referrerURL.origin === currentURL.origin) {
            return referrerURL;
          }
          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        case "same-origin":
          if (referrerURL.origin === currentURL.origin) {
            return referrerURL;
          }
          return "no-referrer";
        case "origin-when-cross-origin":
          if (referrerURL.origin === currentURL.origin) {
            return referrerURL;
          }
          return referrerOrigin;
        case "no-referrer-when-downgrade":
          if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerURL;
        default:
          throw new TypeError(`Invalid referrerPolicy: ${policy}`);
      }
    }
    __name(determineRequestsReferrer, "determineRequestsReferrer");
    function parseReferrerPolicyFromHeader(headers) {
      const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
      let policy = "";
      for (const token of policyTokens) {
        if (token && ReferrerPolicy.has(token)) {
          policy = token;
        }
      }
      return policy;
    }
    __name(parseReferrerPolicyFromHeader, "parseReferrerPolicyFromHeader");
    var INTERNALS2 = Symbol("Request internals");
    var isRequest2 = /* @__PURE__ */ __name((object) => {
      return typeof object === "object" && typeof object[INTERNALS2] === "object";
    }, "isRequest");
    var doBadDataWarn = node_util.deprecate(
      () => {
      },
      ".data is not a valid RequestInit property, use .body instead",
      "https://github.com/node-fetch/node-fetch/issues/1000 (request)"
    );
    var Request3 = class _Request extends Body2 {
      static {
        __name(this, "Request");
      }
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest2(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
        }
        let method = init2.method || input.method || "GET";
        if (/^(delete|get|head|options|post|put)$/i.test(method)) {
          method = method.toUpperCase();
        }
        if (!isRequest2(init2) && "data" in init2) {
          doBadDataWarn();
        }
        if ((init2.body != null || isRequest2(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest2(input) && input.body !== null ? clone2(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers3(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType2(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest2(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal2(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS2] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      /** @returns {string} */
      get method() {
        return this[INTERNALS2].method;
      }
      /** @returns {string} */
      get url() {
        return node_url.format(this[INTERNALS2].parsedURL);
      }
      /** @returns {Headers} */
      get headers() {
        return this[INTERNALS2].headers;
      }
      get redirect() {
        return this[INTERNALS2].redirect;
      }
      /** @returns {AbortSignal} */
      get signal() {
        return this[INTERNALS2].signal;
      }
      // https://fetch.spec.whatwg.org/#dom-request-referrer
      get referrer() {
        if (this[INTERNALS2].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS2].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS2].referrer) {
          return this[INTERNALS2].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS2].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS2].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    var getNodeRequestOptions2 = /* @__PURE__ */ __name((request3) => {
      const { parsedURL } = request3[INTERNALS2];
      const headers = new Headers3(request3[INTERNALS2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request3.body === null && /^(post|put)$/i.test(request3.method)) {
        contentLengthValue = "0";
      }
      if (request3.body !== null) {
        const totalBytes = getTotalBytes2(request3);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request3.referrerPolicy === "") {
        request3.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request3.referrer && request3.referrer !== "no-referrer") {
        request3[INTERNALS2].referrer = determineRequestsReferrer(request3);
      } else {
        request3[INTERNALS2].referrer = "no-referrer";
      }
      if (request3[INTERNALS2].referrer instanceof URL) {
        headers.set("Referer", request3.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request3.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip, deflate, br");
      }
      let { agent } = request3;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options = {
        // Overwrite search to retain trailing ? (issue #776)
        path: parsedURL.pathname + search,
        // The following options are not expressed in the URL
        method: request3.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request3.insecureHTTPParser,
        agent
      };
      return {
        /** @type {URL} */
        parsedURL,
        options
      };
    }, "getNodeRequestOptions");
    var AbortError2 = class extends FetchBaseError {
      static {
        __name(this, "AbortError");
      }
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    if (!globalThis.DOMException) {
      try {
        const { MessageChannel } = __require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
      }
    }
    var nodeDomexception = globalThis.DOMException;
    var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
    async function fetch4(url12, options_) {
      return new Promise((resolve, reject) => {
        const request3 = new Request3(url12, options_);
        const { parsedURL, options } = getNodeRequestOptions2(request3);
        if (!supportedSchemas.has(parsedURL.protocol)) {
          throw new TypeError(`node-fetch cannot load ${url12}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
        }
        if (parsedURL.protocol === "data:") {
          const data = dataUriToBuffer(request3.url);
          const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
          resolve(response2);
          return;
        }
        const send = (parsedURL.protocol === "https:" ? https2 : http2).request;
        const { signal } = request3;
        let response = null;
        const abort = /* @__PURE__ */ __name(() => {
          const error = new AbortError2("The operation was aborted.");
          reject(error);
          if (request3.body && request3.body instanceof Stream3.Readable) {
            request3.body.destroy(error);
          }
          if (!response || !response.body) {
            return;
          }
          response.body.emit("error", error);
        }, "abort");
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = /* @__PURE__ */ __name(() => {
          abort();
          finalize();
        }, "abortAndFinalize");
        const request_ = send(parsedURL.toString(), options);
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        const finalize = /* @__PURE__ */ __name(() => {
          request_.abort();
          if (signal) {
            signal.removeEventListener("abort", abortAndFinalize);
          }
        }, "finalize");
        request_.on("error", (error) => {
          reject(new FetchError2(`request to ${request3.url} failed, reason: ${error.message}`, "system", error));
          finalize();
        });
        fixResponseChunkedTransferBadEnding2(request_, (error) => {
          if (response && response.body) {
            response.body.destroy(error);
          }
        });
        if (process.version < "v14") {
          request_.on("socket", (s10) => {
            let endedWithEventsCount;
            s10.prependListener("end", () => {
              endedWithEventsCount = s10._eventsCount;
            });
            s10.prependListener("close", (hadError) => {
              if (response && endedWithEventsCount < s10._eventsCount && !hadError) {
                const error = new Error("Premature close");
                error.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", error);
              }
            });
          });
        }
        request_.on("response", (response_) => {
          request_.setTimeout(0);
          const headers = fromRawHeaders(response_.rawHeaders);
          if (isRedirect(response_.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL(location, request3.url);
            } catch {
              if (request3.redirect !== "manual") {
                reject(new FetchError2(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request3.redirect) {
              case "error":
                reject(new FetchError2(`uri requested responds with a redirect, redirect mode is set to error: ${request3.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                break;
              case "follow": {
                if (locationURL === null) {
                  break;
                }
                if (request3.counter >= request3.follow) {
                  reject(new FetchError2(`maximum redirect reached at: ${request3.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOptions = {
                  headers: new Headers3(request3.headers),
                  follow: request3.follow,
                  counter: request3.counter + 1,
                  agent: request3.agent,
                  compress: request3.compress,
                  method: request3.method,
                  body: clone2(request3),
                  signal: request3.signal,
                  size: request3.size,
                  referrer: request3.referrer,
                  referrerPolicy: request3.referrerPolicy
                };
                if (!isDomainOrSubdomain3(request3.url, locationURL) || !isSameProtocol3(request3.url, locationURL)) {
                  for (const name2 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOptions.headers.delete(name2);
                  }
                }
                if (response_.statusCode !== 303 && request3.body && options_.body instanceof Stream3.Readable) {
                  reject(new FetchError2("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request3.method === "POST") {
                  requestOptions.method = "GET";
                  requestOptions.body = void 0;
                  requestOptions.headers.delete("content-length");
                }
                const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
                if (responseReferrerPolicy) {
                  requestOptions.referrerPolicy = responseReferrerPolicy;
                }
                resolve(fetch4(new Request3(locationURL, requestOptions)));
                finalize();
                return;
              }
              default:
                return reject(new TypeError(`Redirect option '${request3.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          if (signal) {
            response_.once("end", () => {
              signal.removeEventListener("abort", abortAndFinalize);
            });
          }
          let body = Stream3.pipeline(response_, new Stream3.PassThrough(), (error) => {
            if (error) {
              reject(error);
            }
          });
          if (process.version < "v12.10") {
            response_.on("aborted", abortAndFinalize);
          }
          const responseOptions = {
            url: request3.url,
            status: response_.statusCode,
            statusText: response_.statusMessage,
            headers,
            size: request3.size,
            counter: request3.counter,
            highWaterMark: request3.highWaterMark
          };
          const codings = headers.get("Content-Encoding");
          if (!request3.compress || request3.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
            response = new Response2(body, responseOptions);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            body = Stream3.pipeline(body, zlib2.createGunzip(zlibOptions), (error) => {
              if (error) {
                reject(error);
              }
            });
            response = new Response2(body, responseOptions);
            resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            const raw = Stream3.pipeline(response_, new Stream3.PassThrough(), (error) => {
              if (error) {
                reject(error);
              }
            });
            raw.once("data", (chunk) => {
              if ((chunk[0] & 15) === 8) {
                body = Stream3.pipeline(body, zlib2.createInflate(), (error) => {
                  if (error) {
                    reject(error);
                  }
                });
              } else {
                body = Stream3.pipeline(body, zlib2.createInflateRaw(), (error) => {
                  if (error) {
                    reject(error);
                  }
                });
              }
              response = new Response2(body, responseOptions);
              resolve(response);
            });
            raw.once("end", () => {
              if (!response) {
                response = new Response2(body, responseOptions);
                resolve(response);
              }
            });
            return;
          }
          if (codings === "br") {
            body = Stream3.pipeline(body, zlib2.createBrotliDecompress(), (error) => {
              if (error) {
                reject(error);
              }
            });
            response = new Response2(body, responseOptions);
            resolve(response);
            return;
          }
          response = new Response2(body, responseOptions);
          resolve(response);
        });
        writeToStream2(request_, request3).catch(reject);
      });
    }
    __name(fetch4, "fetch");
    function fixResponseChunkedTransferBadEnding2(request3, errorCallback) {
      const LAST_CHUNK = node_buffer.Buffer.from("0\r\n\r\n");
      let isChunkedTransfer = false;
      let properLastChunkReceived = false;
      let previousChunk;
      request3.on("response", (response) => {
        const { headers } = response;
        isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
      });
      request3.on("socket", (socket) => {
        const onSocketClose = /* @__PURE__ */ __name(() => {
          if (isChunkedTransfer && !properLastChunkReceived) {
            const error = new Error("Premature close");
            error.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(error);
          }
        }, "onSocketClose");
        const onData = /* @__PURE__ */ __name((buf) => {
          properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
          if (!properLastChunkReceived && previousChunk) {
            properLastChunkReceived = node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
          }
          previousChunk = buf;
        }, "onData");
        socket.prependListener("close", onSocketClose);
        socket.on("data", onData);
        request3.on("close", () => {
          socket.removeListener("close", onSocketClose);
          socket.removeListener("data", onData);
        });
      });
    }
    __name(fixResponseChunkedTransferBadEnding2, "fixResponseChunkedTransferBadEnding");
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    __name(pd, "pd");
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    __name(setCancelFlag, "setCancelFlag");
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i11 = 0; i11 < keys.length; ++i11) {
        const key = keys[i11];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    __name(Event, "Event");
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    __name(defineRedirectDescriptor, "defineRedirectDescriptor");
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    __name(defineCallDescriptor, "defineCallDescriptor");
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      __name(CustomEvent, "CustomEvent");
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i11 = 0; i11 < keys.length; ++i11) {
        const key = keys[i11];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    __name(defineWrapper, "defineWrapper");
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    __name(getWrapper, "getWrapper");
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    __name(wrapEvent, "wrapEvent");
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    __name(isStopped, "isStopped");
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    __name(setEventPhase, "setEventPhase");
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    __name(setCurrentTarget, "setCurrentTarget");
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    __name(setPassiveListener, "setPassiveListener");
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject2(x5) {
      return x5 !== null && typeof x5 === "object";
    }
    __name(isObject2, "isObject");
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    __name(getListeners, "getListeners");
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject2(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    __name(defineEventAttributeDescriptor, "defineEventAttributeDescriptor");
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    __name(defineEventAttribute, "defineEventAttribute");
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      __name(CustomEventTarget, "CustomEventTarget");
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i11 = 0; i11 < eventNames.length; ++i11) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i11]);
      }
      return CustomEventTarget;
    }
    __name(defineCustomEventTarget, "defineCustomEventTarget");
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i11 = 0; i11 < arguments.length; ++i11) {
          types[i11] = arguments[i11];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    __name(EventTarget, "EventTarget");
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject2(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject2(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject2(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    var AbortSignal2 = class extends EventTarget {
      static {
        __name(this, "AbortSignal");
      }
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    __name(createAbortSignal, "createAbortSignal");
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    __name(abortSignal, "abortSignal");
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController$1 = class {
      static {
        __name(this, "AbortController$1");
      }
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    __name(getSignal, "getSignal");
    Object.defineProperties(AbortController$1.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController$1;
    exports.AbortError = AbortError2;
    exports.FetchError = FetchError2;
    exports.File = File$1;
    exports.FormData = FormData2;
    exports.Headers = Headers3;
    exports.Request = Request3;
    exports.Response = Response2;
    exports._Blob = _Blob$1;
    exports.fetch = fetch4;
    exports.isRedirect = isRedirect;
    exports.nodeDomexception = nodeDomexception;
  }
});

// ../../node_modules/node-fetch-native/dist/index.cjs
var require_dist2 = __commonJS({
  "../../node_modules/node-fetch-native/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var abortController = require_node_fetch_native_8afd3fea();
    var node_fs = __require("node:fs");
    var node_path = __require("node:path");
    __require("node:http");
    __require("node:https");
    __require("node:zlib");
    __require("node:stream");
    __require("node:buffer");
    __require("node:util");
    __require("node:url");
    __require("node:net");
    var { stat } = node_fs.promises;
    var blobFromSync = /* @__PURE__ */ __name((path, type) => fromBlob(node_fs.statSync(path), path, type), "blobFromSync");
    var blobFrom = /* @__PURE__ */ __name((path, type) => stat(path).then((stat2) => fromBlob(stat2, path, type)), "blobFrom");
    var fileFrom = /* @__PURE__ */ __name((path, type) => stat(path).then((stat2) => fromFile(stat2, path, type)), "fileFrom");
    var fileFromSync = /* @__PURE__ */ __name((path, type) => fromFile(node_fs.statSync(path), path, type), "fileFromSync");
    var fromBlob = /* @__PURE__ */ __name((stat2, path, type = "") => new abortController._Blob([new BlobDataItem({
      path,
      size: stat2.size,
      lastModified: stat2.mtimeMs,
      start: 0
    })], { type }), "fromBlob");
    var fromFile = /* @__PURE__ */ __name((stat2, path, type = "") => new abortController.File([new BlobDataItem({
      path,
      size: stat2.size,
      lastModified: stat2.mtimeMs,
      start: 0
    })], node_path.basename(path), { type, lastModified: stat2.mtimeMs }), "fromFile");
    var BlobDataItem = class _BlobDataItem {
      static {
        __name(this, "BlobDataItem");
      }
      #path;
      #start;
      constructor(options) {
        this.#path = options.path;
        this.#start = options.start;
        this.size = options.size;
        this.lastModified = options.lastModified;
        this.originalSize = options.originalSize === void 0 ? options.size : options.originalSize;
      }
      /**
       * Slicing arguments is first validated and formatted
       * to not be out of range by Blob.prototype.slice
       */
      slice(start, end) {
        return new _BlobDataItem({
          path: this.#path,
          lastModified: this.lastModified,
          originalSize: this.originalSize,
          size: end - start,
          start: this.#start + start
        });
      }
      async *stream() {
        const { mtimeMs, size } = await stat(this.#path);
        if (mtimeMs > this.lastModified || this.originalSize !== size) {
          throw new abortController.nodeDomexception("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        }
        yield* node_fs.createReadStream(this.#path, {
          start: this.#start,
          end: this.#start + this.size - 1
        });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    var fetch4 = globalThis.fetch || abortController.fetch;
    var Blob2 = globalThis.Blob || abortController._Blob;
    var File = globalThis.File || abortController.File;
    var FormData2 = globalThis.FormData || abortController.FormData;
    var Headers3 = globalThis.Headers || abortController.Headers;
    var Request3 = globalThis.Request || abortController.Request;
    var Response2 = globalThis.Response || abortController.Response;
    var AbortController2 = globalThis.AbortController || abortController.AbortController;
    exports.AbortError = abortController.AbortError;
    exports.FetchError = abortController.FetchError;
    exports.isRedirect = abortController.isRedirect;
    exports.AbortController = AbortController2;
    exports.Blob = Blob2;
    exports.File = File;
    exports.FormData = FormData2;
    exports.Headers = Headers3;
    exports.Request = Request3;
    exports.Response = Response2;
    exports.blobFrom = blobFrom;
    exports.blobFromSync = blobFromSync;
    exports.default = fetch4;
    exports.fetch = fetch4;
    exports.fileFrom = fileFrom;
    exports.fileFromSync = fileFromSync;
  }
});

// ../../node_modules/node-fetch-native/lib/index.cjs
var require_lib4 = __commonJS({
  "../../node_modules/node-fetch-native/lib/index.cjs"(exports, module2) {
    var nodeFetch = require_dist2();
    function fetch4(input, options) {
      return nodeFetch.fetch(input, options);
    }
    __name(fetch4, "fetch");
    for (const key in nodeFetch) {
      fetch4[key] = nodeFetch[key];
    }
    module2.exports = fetch4;
  }
});

// ../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/dist/runtime/node/fetch.js
var require_fetch = __commonJS({
  "../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/dist/runtime/node/fetch.js"(exports, module2) {
    var { fetch: fetch4, Blob: Blob2, FormData: FormData2, Headers: Headers3, Request: Request3, Response: Response2, AbortController: AbortController2 } = require_lib4();
    module2.exports = fetch4;
    module2.exports.RuntimeBlob = Blob2;
    module2.exports.RuntimeFormData = FormData2;
    module2.exports.RuntimeHeaders = Headers3;
    module2.exports.RuntimeRequest = Request3;
    module2.exports.RuntimeResponse = Response2;
    module2.exports.RuntimeAbortController = AbortController2;
  }
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = /* @__PURE__ */ __name(function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    }, "isMergeableObject");
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    __name(isNonNullObject, "isNonNullObject");
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    __name(isSpecial, "isSpecial");
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    __name(isReactElement, "isReactElement");
    function emptyTarget(val2) {
      return Array.isArray(val2) ? [] : {};
    }
    __name(emptyTarget, "emptyTarget");
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    __name(cloneUnlessOtherwiseSpecified, "cloneUnlessOtherwiseSpecified");
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    __name(defaultArrayMerge, "defaultArrayMerge");
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    __name(getMergeFunction, "getMergeFunction");
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    __name(getEnumerableOwnPropertySymbols, "getEnumerableOwnPropertySymbols");
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    __name(getKeys, "getKeys");
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    __name(propertyIsOnObject, "propertyIsOnObject");
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    __name(propertyIsUnsafe, "propertyIsUnsafe");
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    __name(mergeObject, "mergeObject");
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    __name(deepmerge2, "deepmerge");
    deepmerge2.all = /* @__PURE__ */ __name(function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    }, "deepmergeAll");
    var deepmerge_1 = deepmerge2;
    module2.exports = deepmerge_1;
  }
});

// ../../node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "../../node_modules/map-obj/index.js"(exports, module2) {
    "use strict";
    var isObject2 = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null, "isObject");
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = /* @__PURE__ */ __name((value) => isObject2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date), "isObjectCustom");
    var mapObject = /* @__PURE__ */ __name((object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = {
        deep: false,
        target: {},
        ...options
      };
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = /* @__PURE__ */ __name((array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element), "mapArray");
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    }, "mapObject");
    module2.exports = (object, mapper, options) => {
      if (!isObject2(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module2.exports.mapObjectSkip = mapObjectSkip;
  }
});

// ../../node_modules/lower-case/dist.es2015/index.js
function lowerCase(str) {
  return str.toLowerCase();
}
var init_dist = __esm({
  "../../node_modules/lower-case/dist.es2015/index.js"() {
    __name(lowerCase, "lowerCase");
  }
});

// ../../node_modules/no-case/dist.es2015/index.js
function noCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result.length;
  while (result.charAt(start) === "\0")
    start++;
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
function replace(input, re, value) {
  if (re instanceof RegExp)
    return input.replace(re, value);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value);
  }, input);
}
var DEFAULT_SPLIT_REGEXP, DEFAULT_STRIP_REGEXP;
var init_dist2 = __esm({
  "../../node_modules/no-case/dist.es2015/index.js"() {
    init_dist();
    DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    __name(noCase, "noCase");
    __name(replace, "replace");
  }
});

// ../../node_modules/dot-case/dist.es2015/index.js
function dotCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return noCase(input, __assign2({ delimiter: "." }, options));
}
var init_dist3 = __esm({
  "../../node_modules/dot-case/dist.es2015/index.js"() {
    init_tslib_es62();
    init_dist2();
    __name(dotCase, "dotCase");
  }
});

// ../../node_modules/snake-case/dist.es2015/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  snakeCase: () => snakeCase
});
function snakeCase(input, options) {
  if (options === void 0) {
    options = {};
  }
  return dotCase(input, __assign2({ delimiter: "_" }, options));
}
var init_dist4 = __esm({
  "../../node_modules/snake-case/dist.es2015/index.js"() {
    init_tslib_es62();
    init_dist3();
    __name(snakeCase, "snakeCase");
  }
});

// ../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/node_modules/snakecase-keys/index.js
var require_snakecase_keys = __commonJS({
  "../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/node_modules/snakecase-keys/index.js"(exports, module2) {
    "use strict";
    var map2 = require_map_obj();
    var { snakeCase: snakeCase2 } = (init_dist4(), __toCommonJS(dist_exports2));
    module2.exports = function(obj, options) {
      options = Object.assign({ deep: true, exclude: [], parsingOptions: {} }, options);
      return map2(obj, function(key, val2) {
        return [
          matches(options.exclude, key) ? key : snakeCase2(key, options.parsingOptions),
          val2
        ];
      }, options);
    };
    function matches(patterns, value) {
      return patterns.some(function(pattern) {
        return typeof pattern === "string" ? pattern === value : pattern.test(value);
      });
    }
    __name(matches, "matches");
  }
});

// ../../node_modules/cookie/index.js
var require_cookie = __commonJS({
  "../../node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse5;
    exports.serialize = serialize;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse5(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode5;
      var index2 = 0;
      while (index2 < str.length) {
        var eqIdx = str.indexOf("=", index2);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index2);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index2, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val2 = str.slice(eqIdx + 1, endIdx).trim();
          if (val2.charCodeAt(0) === 34) {
            val2 = val2.slice(1, -1);
          }
          obj[key] = tryDecode(val2, dec);
        }
        index2 = endIdx + 1;
      }
      return obj;
    }
    __name(parse5, "parse");
    function serialize(name2, val2, options) {
      var opt = options || {};
      var enc = opt.encode || encode3;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name2)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val2);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name2 + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    __name(serialize, "serialize");
    function decode5(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    __name(decode5, "decode");
    function encode3(val2) {
      return encodeURIComponent(val2);
    }
    __name(encode3, "encode");
    function isDate(val2) {
      return __toString.call(val2) === "[object Date]" || val2 instanceof Date;
    }
    __name(isDate, "isDate");
    function tryDecode(str, decode6) {
      try {
        return decode6(str);
      } catch (e10) {
        return str;
      }
    }
    __name(tryDecode, "tryDecode");
  }
});

// ../../node_modules/@smithy/types/dist-es/auth.js
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

// ../../node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

// ../../node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
var getChecksumConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
  const checksumAlgorithms = [];
  if (runtimeConfig.sha256 !== void 0) {
    checksumAlgorithms.push({
      algorithmId: () => AlgorithmId.SHA256,
      checksumConstructor: () => runtimeConfig.sha256
    });
  }
  if (runtimeConfig.md5 != void 0) {
    checksumAlgorithms.push({
      algorithmId: () => AlgorithmId.MD5,
      checksumConstructor: () => runtimeConfig.md5
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, "getChecksumConfiguration");
var resolveChecksumRuntimeConfig = /* @__PURE__ */ __name((clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
}, "resolveChecksumRuntimeConfig");

// ../../node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
var getDefaultClientConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
  return {
    ...getChecksumConfiguration(runtimeConfig)
  };
}, "getDefaultClientConfiguration");
var resolveDefaultRuntimeConfig = /* @__PURE__ */ __name((config) => {
  return {
    ...resolveChecksumRuntimeConfig(config)
  };
}, "resolveDefaultRuntimeConfig");

// ../../node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function(FieldPosition2) {
  FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
  FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

// ../../node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function(RequestHandlerProtocol2) {
  RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

// ../../node_modules/@smithy/protocol-http/dist-es/httpRequest.js
var HttpRequest = class _HttpRequest {
  static {
    __name(this, "HttpRequest");
  }
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static isInstance(request3) {
    if (!request3)
      return false;
    const req = request3;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new _HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery(cloned.query);
    return cloned;
  }
};
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param2 = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param2) ? [...param2] : param2
    };
  }, {});
}
__name(cloneQuery, "cloneQuery");

// ../../node_modules/@smithy/protocol-http/dist-es/httpResponse.js
var HttpResponse = class {
  static {
    __name(this, "HttpResponse");
  }
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig(input) {
  return input;
}
__name(resolveHostHeaderConfig, "resolveHostHeaderConfig");
var hostHeaderMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request: request3 } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request3.headers[":authority"]) {
    delete request3.headers["host"];
    request3.headers[":authority"] = "";
  } else if (!request3.headers["host"]) {
    let host = request3.hostname;
    if (request3.port != null)
      host += `:${request3.port}`;
    request3.headers["host"] = host;
  }
  return next(args);
}, "hostHeaderMiddleware");
var hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
}), "getHostHeaderPlugin");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware = /* @__PURE__ */ __name(() => (next, context8) => async (args) => {
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context8;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context8.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context8.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger2?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context8;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context8.inputFilterSensitiveLog;
    logger2?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
}, "loggerMiddleware");
var loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
}), "getLoggerPlugin");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
  const { request: request3 } = args;
  if (!HttpRequest.isInstance(request3) || options.runtime !== "node" || request3.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = /* @__PURE__ */ __name((str) => typeof str === "string" && str.length > 0, "nonEmptyString");
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request3.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request: request3
  });
}, "recursionDetectionMiddleware");
var addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
}), "getRecursionDetectionPlugin");

// ../../node_modules/@smithy/property-provider/dist-es/ProviderError.js
var ProviderError = class _ProviderError extends Error {
  static {
    __name(this, "ProviderError");
  }
  constructor(message, tryNextLink = true) {
    super(message);
    this.tryNextLink = tryNextLink;
    this.name = "ProviderError";
    Object.setPrototypeOf(this, _ProviderError.prototype);
  }
  static from(error, tryNextLink = true) {
    return Object.assign(new this(error.message, tryNextLink), error);
  }
};

// ../../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
var CredentialsProviderError = class _CredentialsProviderError extends ProviderError {
  static {
    __name(this, "CredentialsProviderError");
  }
  constructor(message, tryNextLink = true) {
    super(message, tryNextLink);
    this.tryNextLink = tryNextLink;
    this.name = "CredentialsProviderError";
    Object.setPrototypeOf(this, _CredentialsProviderError.prototype);
  }
};

// ../../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
var TokenProviderError = class _TokenProviderError extends ProviderError {
  static {
    __name(this, "TokenProviderError");
  }
  constructor(message, tryNextLink = true) {
    super(message, tryNextLink);
    this.tryNextLink = tryNextLink;
    this.name = "TokenProviderError";
    Object.setPrototypeOf(this, _TokenProviderError.prototype);
  }
};

// ../../node_modules/@smithy/property-provider/dist-es/chain.js
function chain(...providers) {
  return () => {
    let promise = Promise.reject(new ProviderError("No providers in chain"));
    for (const provider of providers) {
      promise = promise.catch((err) => {
        if (err?.tryNextLink) {
          return provider();
        }
        throw err;
      });
    }
    return promise;
  };
}
__name(chain, "chain");

// ../../node_modules/@smithy/property-provider/dist-es/fromStatic.js
var fromStatic = /* @__PURE__ */ __name((staticValue) => () => Promise.resolve(staticValue), "fromStatic");

// ../../node_modules/@smithy/property-provider/dist-es/memoize.js
var memoize = /* @__PURE__ */ __name((provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = /* @__PURE__ */ __name(async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  }, "coalesceProvider");
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
}, "memoize");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js
init_dist_es9();
init_dist_es4();
var CREDENTIAL_EXPIRE_WINDOW = 3e5;
var resolveAwsAuthConfig = /* @__PURE__ */ __name((input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else if (input.regionInfoProvider) {
    signer = /* @__PURE__ */ __name(() => normalizeProvider(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    }), "signer");
  } else {
    signer = /* @__PURE__ */ __name(async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    }, "signer");
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
}, "resolveAwsAuthConfig");
var normalizeCredentialProvider = /* @__PURE__ */ __name((credentials) => {
  if (typeof credentials === "function") {
    return memoize(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials2) => credentials2.expiration !== void 0);
  }
  return normalizeProvider(credentials);
}, "normalizeCredentialProvider");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate = /* @__PURE__ */ __name((systemClockOffset) => new Date(Date.now() + systemClockOffset), "getSkewCorrectedDate");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed = /* @__PURE__ */ __name((clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5, "isClockSkewed");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset = /* @__PURE__ */ __name((clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
}, "getUpdatedSystemClockOffset");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js
var awsAuthMiddleware = /* @__PURE__ */ __name((options) => (next, context8) => async function(args) {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const authScheme = context8.endpointV2?.properties?.authSchemes?.[0];
  const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
  const signer = await options.signer(authScheme);
  const output = await next({
    ...args,
    request: await signer.sign(args.request, {
      signingDate: getSkewCorrectedDate(options.systemClockOffset),
      signingRegion: multiRegionOverride || context8["signing_region"],
      signingService: context8["signing_service"]
    })
  }).catch((error) => {
    const serverTime = error.ServerTime ?? getDateHeader(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
  }
  return output;
}, "awsAuthMiddleware");
var getDateHeader = /* @__PURE__ */ __name((response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0, "getDateHeader");
var awsAuthMiddlewareOptions = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
  }
}), "getAwsAuthPlugin");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}
__name(resolveUserAgentConfig, "resolveUserAgentConfig");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }, {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  }, {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }],
  version: "1.1"
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo = partitions_default;
var selectedUserAgentPrefix = "";
var partition = /* @__PURE__ */ __name((value) => {
  const { partitions } = selectedPartitionsInfo;
  for (const partition3 of partitions) {
    const { regions, outputs } = partition3;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition3 of partitions) {
    const { regionRegex, outputs } = partition3;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition3) => partition3.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
}, "partition");
var setPartitionInfo = /* @__PURE__ */ __name((partitionsInfo, userAgentPrefix = "") => {
  selectedPartitionsInfo = partitionsInfo;
  selectedUserAgentPrefix = userAgentPrefix;
}, "setPartitionInfo");
var useDefaultPartitionInfo = /* @__PURE__ */ __name(() => {
  setPartitionInfo(partitions_default, "");
}, "useDefaultPartitionInfo");
var getUserAgentPrefix = /* @__PURE__ */ __name(() => selectedUserAgentPrefix, "getUserAgentPrefix");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress = /* @__PURE__ */ __name((value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]"), "isIpAddress");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js
var debugId = "endpoints";

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}
__name(toDebugString, "toDebugString");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var EndpointError = class extends Error {
  static {
    __name(this, "EndpointError");
  }
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  aws: () => aws_exports,
  booleanEquals: () => booleanEquals,
  getAttr: () => getAttr,
  isSet: () => isSet,
  isValidHostLabel: () => isValidHostLabel,
  not: () => not,
  parseURL: () => parseURL,
  stringEquals: () => stringEquals,
  substring: () => substring,
  uriEncode: () => uriEncode
});

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js
var aws_exports = {};
__export(aws_exports, {
  getUserAgentPrefix: () => getUserAgentPrefix,
  isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket,
  parseArn: () => parseArn,
  partition: () => partition,
  setPartitionInfo: () => setPartitionInfo,
  useDefaultPartitionInfo: () => useDefaultPartitionInfo
});

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
}, "isValidHostLabel");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
}, "isVirtualHostableS3Bucket");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn = /* @__PURE__ */ __name((value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition3, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition3 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition3,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
}, "parseArn");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "booleanEquals");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList = /* @__PURE__ */ __name((path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
}, "getAttrPathList");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js
var getAttr = /* @__PURE__ */ __name((value, path) => getAttrPathList(path).reduce((acc, index2) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index2}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index2)];
  }
  return acc[index2];
}, value), "getAttr");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js
var isSet = /* @__PURE__ */ __name((value) => value != null, "isSet");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js
var not = /* @__PURE__ */ __name((value) => !value, "not");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/types/dist-es/dns.js
var HostAddressType;
(function(HostAddressType3) {
  HostAddressType3["AAAA"] = "AAAA";
  HostAddressType3["A"] = "A";
})(HostAddressType || (HostAddressType = {}));

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
var parseURL = /* @__PURE__ */ __name((value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url12 = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url12.search = Object.entries(query).map(([k10, v7]) => `${k10}=${v7}`).join("&");
        return url12;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
}, "parseURL");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "stringEquals");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js
var substring = /* @__PURE__ */ __name((input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
}, "substring");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode = /* @__PURE__ */ __name((value) => encodeURIComponent(value).replace(/[!*'()]/g, (c11) => `%${c11.charCodeAt(0).toString(16).toUpperCase()}`), "uriEncode");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate = /* @__PURE__ */ __name((template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
}, "evaluateTemplate");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue = /* @__PURE__ */ __name(({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
}, "getReferenceValue");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = /* @__PURE__ */ __name((obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
}, "evaluateExpression");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js
var callFunction = /* @__PURE__ */ __name(({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  return fn.split(".").reduce((acc, key) => acc[key], lib_exports)(...evaluatedArgs);
}, "callFunction");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = /* @__PURE__ */ __name(({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  options.logger?.debug?.(debugId, `evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
}, "evaluateCondition");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = /* @__PURE__ */ __name((conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(debugId, `assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
}, "evaluateConditions");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders = /* @__PURE__ */ __name((headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {}), "getEndpointHeaders");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty = /* @__PURE__ */ __name((property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
}, "getEndpointProperty");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = /* @__PURE__ */ __name((properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {}), "getEndpointProperties");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl = /* @__PURE__ */ __name((endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
}, "getEndpointUrl");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = /* @__PURE__ */ __name((endpointRule, options) => {
  const { conditions, endpoint: endpoint3 } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url: url12, properties, headers } = endpoint3;
  options.logger?.debug?.(debugId, `Resolving endpoint from template: ${toDebugString(endpoint3)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url12, endpointRuleOptions)
  };
}, "evaluateEndpointRule");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule = /* @__PURE__ */ __name((errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
}, "evaluateErrorRule");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule = /* @__PURE__ */ __name((treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
}, "evaluateTreeRule");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = /* @__PURE__ */ __name((rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
}, "evaluateRules");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint = /* @__PURE__ */ __name((ruleSetObject, options) => {
  const { endpointParams, logger: logger2 } = options;
  const { parameters: parameters2, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters2).filter(([, v7]) => v7.default != null).map(([k10, v7]) => [k10, v7.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters2).filter(([, v7]) => v7.required).map(([k10]) => k10);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint3 = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  if (options.endpointParams?.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint3.url.protocol = protocol;
      endpoint3.url.port = port;
    } catch (e10) {
    }
  }
  options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint3)}`);
  return endpoint3;
}, "resolveEndpoint");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT = "user-agent";
var X_AMZ_USER_AGENT = "x-amz-user-agent";
var SPACE = " ";
var UA_NAME_SEPARATOR = "/";
var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var UA_ESCAPE_CHAR = "-";

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = /* @__PURE__ */ __name((options) => (next, context8) => async (args) => {
  const { request: request3 } = args;
  if (!HttpRequest.isInstance(request3))
    return next(args);
  const { headers } = request3;
  const userAgent2 = context8?.userAgent?.map(escapeUserAgent) || [];
  const defaultUserAgent3 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent3, ...userAgent2, ...customUserAgent]).join(SPACE);
  const normalUAValue = [
    ...defaultUserAgent3.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request: request3
  });
}, "userAgentMiddleware");
var escapeUserAgent = /* @__PURE__ */ __name((userAgentPair) => {
  const name2 = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version3 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name2.indexOf(UA_NAME_SEPARATOR);
  const prefix = name2.substring(0, prefixSeparatorIndex);
  let uaName = name2.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version3].filter((item) => item && item.length > 0).reduce((acc, item, index2) => {
    switch (index2) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
}, "escapeUserAgent");
var getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin = /* @__PURE__ */ __name((config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
  }
}), "getUserAgentPlugin");

// ../../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
var booleanSelector = /* @__PURE__ */ __name((obj, key, type) => {
  if (!(key in obj))
    return void 0;
  if (obj[key] === "true")
    return true;
  if (obj[key] === "false")
    return false;
  throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
}, "booleanSelector");

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
var CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_DUALSTACK_ENDPOINT, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
var CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => booleanSelector(env3, ENV_USE_FIPS_ENDPOINT, SelectorType.ENV),
  configFileSelector: (profile) => booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, SelectorType.CONFIG),
  default: false
};

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
init_dist_es4();

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
init_dist_es4();

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
var REGION_ENV_NAME = "AWS_REGION";
var REGION_INI_NAME = "region";
var NODE_REGION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[REGION_ENV_NAME],
  configFileSelector: (profile) => profile[REGION_INI_NAME],
  default: () => {
    throw new Error("Region is missing");
  }
};
var NODE_REGION_CONFIG_FILE_OPTIONS = {
  preferredFile: "credentials"
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
var isFipsRegion = /* @__PURE__ */ __name((region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips")), "isFipsRegion");

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = /* @__PURE__ */ __name((region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region, "getRealRegion");

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = /* @__PURE__ */ __name((input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
}, "resolveRegionConfig");

// ../../node_modules/@smithy/middleware-content-length/dist-es/index.js
var CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request3 = args.request;
    if (HttpRequest.isInstance(request3)) {
      const { body, headers } = request3;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request3.headers = {
            ...request3.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request: request3
    });
  };
}
__name(contentLengthMiddleware, "contentLengthMiddleware");
var contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
}), "getContentLengthPlugin");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
var resolveParamsForS3 = /* @__PURE__ */ __name(async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
}, "resolveParamsForS3");
var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
var DOTS_PATTERN = /\.\./;
var isDnsCompatibleBucketName = /* @__PURE__ */ __name((bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName), "isDnsCompatibleBucketName");
var isArnBucketName = /* @__PURE__ */ __name((bucketName) => {
  const [arn, partition3, service, region, account, typeOrId] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = [arn, partition3, service, account, typeOrId].filter(Boolean).length === 5;
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return arn === "arn" && !!partition3 && !!service && !!account && !!typeOrId;
}, "isArnBucketName");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
var createConfigValueProvider = /* @__PURE__ */ __name((configKey, canonicalEndpointParamKey, config) => {
  const configProvider = /* @__PURE__ */ __name(async () => {
    const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  }, "configProvider");
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint3 = await configProvider();
      if (endpoint3 && typeof endpoint3 === "object") {
        if ("url" in endpoint3) {
          return endpoint3.url.href;
        }
        if ("hostname" in endpoint3) {
          const { protocol, hostname, port, path } = endpoint3;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint3;
    };
  }
  return configProvider;
}, "createConfigValueProvider");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = /* @__PURE__ */ __name(async (commandInput, instructionsSupplier, clientConfig, context8) => {
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint3 = clientConfig.endpointProvider(endpointParams, context8);
  return endpoint3;
}, "getEndpointFromInstructions");
var resolveParams = /* @__PURE__ */ __name(async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name2, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name2] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name2] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name2] = await createConfigValueProvider(instruction.name, name2, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
}, "resolveParams");

// ../../node_modules/@smithy/url-parser/dist-es/index.js
init_dist_es10();
var parseUrl = /* @__PURE__ */ __name((url12) => {
  if (typeof url12 === "string") {
    return parseUrl(new URL(url12));
  }
  const { hostname, pathname, port, protocol, search } = url12;
  let query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
}, "parseUrl");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = /* @__PURE__ */ __name((endpoint3) => {
  if (typeof endpoint3 === "object") {
    if ("url" in endpoint3) {
      return parseUrl(endpoint3.url);
    }
    return endpoint3;
  }
  return parseUrl(endpoint3);
}, "toEndpointV1");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
var endpointMiddleware = /* @__PURE__ */ __name(({ config, instructions }) => {
  return (next, context8) => async (args) => {
    const endpoint3 = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config }, context8);
    context8.endpointV2 = endpoint3;
    context8.authSchemes = endpoint3.properties?.authSchemes;
    const authScheme = context8.authSchemes?.[0];
    if (authScheme) {
      context8["signing_region"] = authScheme.signingRegion;
      context8["signing_service"] = authScheme.signingName;
    }
    return next({
      ...args
    });
  };
}, "endpointMiddleware");

// ../../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
var deserializerMiddleware = /* @__PURE__ */ __name((options, deserializer) => (next, context8) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += "\n  " + hint;
    }
    throw error;
  }
}, "deserializerMiddleware");

// ../../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
var serializerMiddleware = /* @__PURE__ */ __name((options, serializer) => (next, context8) => async (args) => {
  const endpoint3 = context8.endpointV2?.url && options.urlParser ? async () => options.urlParser(context8.endpointV2.url) : options.endpoint;
  if (!endpoint3) {
    throw new Error("No valid endpoint provider available.");
  }
  const request3 = await serializer(args.input, { ...options, endpoint: endpoint3 });
  return next({
    ...args,
    request: request3
  });
}, "serializerMiddleware");

// ../../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
var deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}
__name(getSerdePlugin, "getSerdePlugin");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
var getEndpointPlugin = /* @__PURE__ */ __name((config, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config,
      instructions
    }), endpointMiddlewareOptions);
  }
}), "getEndpointPlugin");

// ../../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
init_dist_es4();
var resolveEndpointConfig = /* @__PURE__ */ __name((input) => {
  const tls = input.tls ?? true;
  const { endpoint: endpoint3 } = input;
  const customEndpointProvider = endpoint3 != null ? async () => toEndpointV1(await normalizeProvider(endpoint3)()) : void 0;
  const isCustomEndpoint = !!endpoint3;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
  };
}, "resolveEndpointConfig");

// ../../node_modules/@smithy/util-retry/dist-es/config.js
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

// ../../node_modules/@smithy/service-error-classification/dist-es/constants.js
var THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@smithy/service-error-classification/dist-es/index.js
var isThrottlingError = /* @__PURE__ */ __name((error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true, "isThrottlingError");
var isTransientError = /* @__PURE__ */ __name((error) => TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0), "isTransientError");
var isServerError = /* @__PURE__ */ __name((error) => {
  if (error.$metadata?.httpStatusCode !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
}, "isServerError");

// ../../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter = class {
  static {
    __name(this, "DefaultRateLimiter");
  }
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay2 = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay2));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp2 = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp2;
      return;
    }
    const fillAmount = (timestamp2 - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp2;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp2) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp2 - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t6 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t6 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/constants.js
var DEFAULT_RETRY_DELAY_BASE = 100;
var MAXIMUM_RETRY_DELAY = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE = 500;
var INITIAL_RETRY_TOKENS = 500;
var RETRY_COST = 5;
var TIMEOUT_RETRY_COST = 10;
var NO_RETRY_INCREMENT = 1;
var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
var REQUEST_HEADER = "amz-sdk-request";

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
var getDefaultRetryBackoffStrategy = /* @__PURE__ */ __name(() => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = /* @__PURE__ */ __name((attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  }, "computeNextBackoffDelay");
  const setDelayBase = /* @__PURE__ */ __name((delay2) => {
    delayBase = delay2;
  }, "setDelayBase");
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
}, "getDefaultRetryBackoffStrategy");

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
var createDefaultRetryToken = /* @__PURE__ */ __name(({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = /* @__PURE__ */ __name(() => retryCount, "getRetryCount");
  const getRetryDelay = /* @__PURE__ */ __name(() => Math.min(MAXIMUM_RETRY_DELAY, retryDelay), "getRetryDelay");
  const getRetryCost = /* @__PURE__ */ __name(() => retryCost, "getRetryCost");
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
}, "createDefaultRetryToken");

// ../../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy = class {
  static {
    __name(this, "StandardRetryStrategy");
  }
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy = class {
  static {
    __name(this, "AdaptiveRetryStrategy");
  }
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
};

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/rng.js
import crypto from "crypto";
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
__name(rng, "rng");

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid2) {
  return typeof uuid2 === "string" && regex_default.test(uuid2);
}
__name(validate, "validate");
var validate_default = validate;

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/stringify.js
var byteToHex = [];
for (let i10 = 0; i10 < 256; ++i10) {
  byteToHex.push((i10 + 256).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
  const uuid2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
__name(stringify, "stringify");
var stringify_default = stringify;

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i10 = 0; i10 < 16; ++i10) {
      buf[offset + i10] = rnds[i10];
    }
    return buf;
  }
  return stringify_default(rnds);
}
__name(v4, "v4");
var v4_default = v4;

// ../../node_modules/@smithy/middleware-retry/dist-es/util.js
var asSdkError = /* @__PURE__ */ __name((error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
}, "asSdkError");

// ../../node_modules/@smithy/middleware-retry/dist-es/configurations.js
init_dist_es4();
var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
var CONFIG_MAX_ATTEMPTS = "max_attempts";
var NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => {
    const value = env3[ENV_MAX_ATTEMPTS];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  configFileSelector: (profile) => {
    const value = profile[CONFIG_MAX_ATTEMPTS];
    if (!value)
      return void 0;
    const maxAttempt = parseInt(value);
    if (Number.isNaN(maxAttempt)) {
      throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
    }
    return maxAttempt;
  },
  default: DEFAULT_MAX_ATTEMPTS
};
var resolveRetryConfig = /* @__PURE__ */ __name((input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
}, "resolveRetryConfig");
var ENV_RETRY_MODE = "AWS_RETRY_MODE";
var CONFIG_RETRY_MODE = "retry_mode";
var NODE_RETRY_MODE_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[ENV_RETRY_MODE],
  configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
  default: DEFAULT_RETRY_MODE
};

// ../../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = /* @__PURE__ */ __name((options) => (next, context8) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context8["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request: request3 } = args;
    if (HttpRequest.isInstance(request3)) {
      request3.headers[INVOCATION_ID_HEADER] = v4_default();
    }
    while (true) {
      try {
        if (HttpRequest.isInstance(request3)) {
          request3.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e10) {
        const retryErrorInfo = getRetryErrorInfo(e10);
        lastError = asSdkError(e10);
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay2 = retryToken.getRetryDelay();
        totalRetryDelay += delay2;
        await new Promise((resolve) => setTimeout(resolve, delay2));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context8.userAgent = [...context8.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
}, "retryMiddleware");
var isRetryStrategyV2 = /* @__PURE__ */ __name((retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined", "isRetryStrategyV2");
var getRetryErrorInfo = /* @__PURE__ */ __name((error) => {
  const errorInfo = {
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
}, "getRetryErrorInfo");
var getRetryErrorType = /* @__PURE__ */ __name((error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
}, "getRetryErrorType");
var retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
}), "getRetryPlugin");
var getRetryAfterHint = /* @__PURE__ */ __name((response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
}, "getRetryAfterHint");

// ../../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
var NoOpLogger = class {
  static {
    __name(this, "NoOpLogger");
  }
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// ../../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
var constructStack = /* @__PURE__ */ __name(() => {
  let absoluteEntries = [];
  let relativeEntries = [];
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = /* @__PURE__ */ __name((entries) => entries.sort((a10, b11) => stepWeights[b11.step] - stepWeights[a10.step] || priorityWeights[b11.priority || "normal"] - priorityWeights[a10.priority || "normal"]), "sort");
  const removeByName = /* @__PURE__ */ __name((toRemove) => {
    let isRemoved = false;
    const filterCb = /* @__PURE__ */ __name((entry) => {
      if (entry.name && entry.name === toRemove) {
        isRemoved = true;
        entriesNameSet.delete(toRemove);
        return false;
      }
      return true;
    }, "filterCb");
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  }, "removeByName");
  const removeByReference = /* @__PURE__ */ __name((toRemove) => {
    let isRemoved = false;
    const filterCb = /* @__PURE__ */ __name((entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        if (entry.name)
          entriesNameSet.delete(entry.name);
        return false;
      }
      return true;
    }, "filterCb");
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  }, "removeByReference");
  const cloneTo = /* @__PURE__ */ __name((toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    return toStack;
  }, "cloneTo");
  const expandRelativeMiddlewareList = /* @__PURE__ */ __name((from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  }, "expandRelativeMiddlewareList");
  const getMiddlewareList = /* @__PURE__ */ __name((debug = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  }, "getMiddlewareList");
  const stack = {
    add: (middleware, options = {}) => {
      const { name: name2, override } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware,
        ...options
      };
      if (name2) {
        if (entriesNameSet.has(name2)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name2}'`);
          const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === name2);
          const toOverride = absoluteEntries[toOverrideIndex];
          if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
            throw new Error(`"${name2}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
          }
          absoluteEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name2);
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware, options) => {
      const { name: name2, override } = options;
      const entry = {
        middleware,
        ...options
      };
      if (name2) {
        if (entriesNameSet.has(name2)) {
          if (!override)
            throw new Error(`Duplicate middleware name '${name2}'`);
          const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === name2);
          const toOverride = relativeEntries[toOverrideIndex];
          if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
            throw new Error(`"${name2}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
          }
          relativeEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name2);
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name((entry) => {
        const { tags, name: name2 } = entry;
        if (tags && tags.includes(toRemove)) {
          if (name2)
            entriesNameSet.delete(name2);
          isRemoved = true;
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        return mw.name + ": " + (mw.tags || []).join(",");
      });
    },
    resolve: (handler3, context8) => {
      for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler3 = middleware(handler3, context8);
      }
      return handler3;
    }
  };
  return stack;
}, "constructStack");
var stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};

// ../../node_modules/@smithy/smithy-client/dist-es/client.js
var Client = class {
  static {
    __name(this, "Client");
  }
  constructor(config) {
    this.middlewareStack = constructStack();
    this.config = config;
  }
  send(command, optionsOrCb, cb) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
    const handler3 = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler3(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
      });
    } else {
      return handler3(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// ../../node_modules/@smithy/util-base64/dist-es/fromBase64.js
init_dist_es6();
var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
var fromBase64 = /* @__PURE__ */ __name((input) => {
  if (input.length * 3 % 4 !== 0) {
    throw new TypeError(`Incorrect padding on base64 string.`);
  }
  if (!BASE64_REGEX.exec(input)) {
    throw new TypeError(`Invalid base64 string.`);
  }
  const buffer = fromString(input, "base64");
  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}, "fromBase64");

// ../../node_modules/@smithy/util-base64/dist-es/toBase64.js
init_dist_es6();
var toBase64 = /* @__PURE__ */ __name((input) => fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64"), "toBase64");

// ../../node_modules/@smithy/util-stream/dist-es/blob/transforms.js
init_dist_es7();
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase64(payload);
  }
  return toUtf84(payload);
}
__name(transformToString, "transformToString");
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf84(str));
}
__name(transformFromString, "transformFromString");

// ../../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter extends Uint8Array {
  static {
    __name(this, "Uint8ArrayBlobAdapter");
  }
  static fromString(source, encoding = "utf-8") {
    switch (typeof source) {
      case "string":
        return transformFromString(source, encoding);
      default:
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(source) {
    Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
    return source;
  }
  transformToString(encoding = "utf-8") {
    return transformToString(this, encoding);
  }
};

// ../../node_modules/@smithy/querystring-builder/dist-es/index.js
init_dist_es8();
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i10 = 0, iLen = value.length; i10 < iLen; i10++) {
        parts.push(`${key}=${escapeUri(value[i10])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}
__name(buildQueryString, "buildQueryString");

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js
import { Agent as hAgent, request as hRequest } from "http";
import { Agent as hsAgent, request as hsRequest } from "https";

// ../../node_modules/@smithy/node-http-handler/dist-es/constants.js
var NODEJS_TIMEOUT_ERROR_CODES2 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@smithy/node-http-handler/dist-es/get-transformed-headers.js
var getTransformedHeaders = /* @__PURE__ */ __name((headers) => {
  const transformedHeaders = {};
  for (const name2 of Object.keys(headers)) {
    const headerValues = headers[name2];
    transformedHeaders[name2] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
  }
  return transformedHeaders;
}, "getTransformedHeaders");

// ../../node_modules/@smithy/node-http-handler/dist-es/set-connection-timeout.js
var setConnectionTimeout = /* @__PURE__ */ __name((request3, reject, timeoutInMs = 0) => {
  if (!timeoutInMs) {
    return;
  }
  const timeoutId = setTimeout(() => {
    request3.destroy();
    reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
      name: "TimeoutError"
    }));
  }, timeoutInMs);
  request3.on("socket", (socket) => {
    if (socket.connecting) {
      socket.on("connect", () => {
        clearTimeout(timeoutId);
      });
    } else {
      clearTimeout(timeoutId);
    }
  });
}, "setConnectionTimeout");

// ../../node_modules/@smithy/node-http-handler/dist-es/set-socket-keep-alive.js
var setSocketKeepAlive = /* @__PURE__ */ __name((request3, { keepAlive, keepAliveMsecs }) => {
  if (keepAlive !== true) {
    return;
  }
  request3.on("socket", (socket) => {
    socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
  });
}, "setSocketKeepAlive");

// ../../node_modules/@smithy/node-http-handler/dist-es/set-socket-timeout.js
var setSocketTimeout = /* @__PURE__ */ __name((request3, reject, timeoutInMs = 0) => {
  request3.setTimeout(timeoutInMs, () => {
    request3.destroy();
    reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
  });
}, "setSocketTimeout");

// ../../node_modules/@smithy/node-http-handler/dist-es/write-request-body.js
import { Readable } from "stream";
var MIN_WAIT_TIME = 1e3;
async function writeRequestBody(httpRequest2, request3, maxContinueTimeoutMs = MIN_WAIT_TIME) {
  const headers = request3.headers ?? {};
  const expect = headers["Expect"] || headers["expect"];
  let timeoutId = -1;
  let hasError = false;
  if (expect === "100-continue") {
    await Promise.race([
      new Promise((resolve) => {
        timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
      }),
      new Promise((resolve) => {
        httpRequest2.on("continue", () => {
          clearTimeout(timeoutId);
          resolve();
        });
        httpRequest2.on("error", () => {
          hasError = true;
          clearTimeout(timeoutId);
          resolve();
        });
      })
    ]);
  }
  if (!hasError) {
    writeBody(httpRequest2, request3.body);
  }
}
__name(writeRequestBody, "writeRequestBody");
function writeBody(httpRequest2, body) {
  if (body instanceof Readable) {
    body.pipe(httpRequest2);
  } else if (body) {
    httpRequest2.end(Buffer.from(body));
  } else {
    httpRequest2.end();
  }
}
__name(writeBody, "writeBody");

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http-handler.js
var NodeHttpHandler = class {
  static {
    __name(this, "NodeHttpHandler");
  }
  constructor(options) {
    this.metadata = { handlerProtocol: "http/1.1" };
    this.configProvider = new Promise((resolve, reject) => {
      if (typeof options === "function") {
        options().then((_options) => {
          resolve(this.resolveDefaultConfig(_options));
        }).catch(reject);
      } else {
        resolve(this.resolveDefaultConfig(options));
      }
    });
  }
  resolveDefaultConfig(options) {
    const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
    const keepAlive = true;
    const maxSockets = 50;
    return {
      connectionTimeout,
      requestTimeout: requestTimeout ?? socketTimeout,
      httpAgent: httpAgent || new hAgent({ keepAlive, maxSockets }),
      httpsAgent: httpsAgent || new hsAgent({ keepAlive, maxSockets })
    };
  }
  destroy() {
    this.config?.httpAgent?.destroy();
    this.config?.httpsAgent?.destroy();
  }
  async handle(request3, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    return new Promise((_resolve, _reject) => {
      let writeRequestBodyPromise = void 0;
      const resolve = /* @__PURE__ */ __name(async (arg) => {
        await writeRequestBodyPromise;
        _resolve(arg);
      }, "resolve");
      const reject = /* @__PURE__ */ __name(async (arg) => {
        await writeRequestBodyPromise;
        _reject(arg);
      }, "reject");
      if (!this.config) {
        throw new Error("Node HTTP request handler config is not resolved");
      }
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        reject(abortError);
        return;
      }
      const isSSL = request3.protocol === "https:";
      const queryString = buildQueryString(request3.query || {});
      let auth2 = void 0;
      if (request3.username != null || request3.password != null) {
        const username = request3.username ?? "";
        const password = request3.password ?? "";
        auth2 = `${username}:${password}`;
      }
      let path = request3.path;
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request3.fragment) {
        path += `#${request3.fragment}`;
      }
      const nodeHttpsOptions = {
        headers: request3.headers,
        host: request3.hostname,
        method: request3.method,
        path,
        port: request3.port,
        agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
        auth: auth2
      };
      const requestFunc = isSSL ? hsRequest : hRequest;
      const req = requestFunc(nodeHttpsOptions, (res) => {
        const httpResponse = new HttpResponse({
          statusCode: res.statusCode || -1,
          reason: res.statusMessage,
          headers: getTransformedHeaders(res.headers),
          body: res
        });
        resolve({ response: httpResponse });
      });
      req.on("error", (err) => {
        if (NODEJS_TIMEOUT_ERROR_CODES2.includes(err.code)) {
          reject(Object.assign(err, { name: "TimeoutError" }));
        } else {
          reject(err);
        }
      });
      setConnectionTimeout(req, reject, this.config.connectionTimeout);
      setSocketTimeout(req, reject, this.config.requestTimeout);
      if (abortSignal) {
        abortSignal.onabort = () => {
          req.abort();
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }
      const httpAgent = nodeHttpsOptions.agent;
      if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
        setSocketKeepAlive(req, {
          keepAlive: httpAgent.keepAlive,
          keepAliveMsecs: httpAgent.keepAliveMsecs
        });
      }
      writeRequestBodyPromise = writeRequestBody(req, request3, this.config.requestTimeout).catch(_reject);
    });
  }
};

// ../../node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js
var NodeHttp2ConnectionPool = class {
  static {
    __name(this, "NodeHttp2ConnectionPool");
  }
  constructor(sessions2) {
    this.sessions = [];
    this.sessions = sessions2 ?? [];
  }
  poll() {
    if (this.sessions.length > 0) {
      return this.sessions.shift();
    }
  }
  offerLast(session) {
    this.sessions.push(session);
  }
  contains(session) {
    return this.sessions.includes(session);
  }
  remove(session) {
    this.sessions = this.sessions.filter((s10) => s10 !== session);
  }
  [Symbol.iterator]() {
    return this.sessions[Symbol.iterator]();
  }
  destroy(connection) {
    for (const session of this.sessions) {
      if (session === connection) {
        if (!session.destroyed) {
          session.destroy();
        }
      }
    }
  }
};

// ../../node_modules/@smithy/node-http-handler/dist-es/stream-collector/collector.js
import { Writable } from "stream";
var Collector = class extends Writable {
  static {
    __name(this, "Collector");
  }
  constructor() {
    super(...arguments);
    this.bufferedBytes = [];
  }
  _write(chunk, encoding, callback) {
    this.bufferedBytes.push(chunk);
    callback();
  }
};

// ../../node_modules/@smithy/node-http-handler/dist-es/stream-collector/index.js
var streamCollector = /* @__PURE__ */ __name((stream) => new Promise((resolve, reject) => {
  const collector = new Collector();
  stream.pipe(collector);
  stream.on("error", (err) => {
    collector.end();
    reject(err);
  });
  collector.on("error", reject);
  collector.on("finish", function() {
    const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
    resolve(bytes);
  });
}), "streamCollector");

// ../../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.js
init_dist_es6();

// ../../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var collectBody = /* @__PURE__ */ __name(async (streamBody = new Uint8Array(), context8) => {
  if (streamBody instanceof Uint8Array) {
    return Uint8ArrayBlobAdapter.mutate(streamBody);
  }
  if (!streamBody) {
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  }
  const fromContext = context8.streamCollector(streamBody);
  return Uint8ArrayBlobAdapter.mutate(await fromContext);
}, "collectBody");

// ../../node_modules/@smithy/smithy-client/dist-es/command.js
var Command = class {
  static {
    __name(this, "Command");
  }
  constructor() {
    this.middlewareStack = constructStack();
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/constants.js
var SENSITIVE_STRING = "***SensitiveInformation***";

// ../../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
var createAggregatedClient = /* @__PURE__ */ __name((commands2, Client4) => {
  for (const command of Object.keys(commands2)) {
    const CommandCtor = commands2[command];
    const methodImpl = /* @__PURE__ */ __name(async function(args, optionsOrCb, cb) {
      const command2 = new CommandCtor(args);
      if (typeof optionsOrCb === "function") {
        this.send(command2, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object")
          throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
        this.send(command2, optionsOrCb || {}, cb);
      } else {
        return this.send(command2, optionsOrCb);
      }
    }, "methodImpl");
    const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
    Client4.prototype[methodName] = methodImpl;
  }
}, "createAggregatedClient");

// ../../node_modules/@smithy/smithy-client/dist-es/parse-utils.js
var parseBoolean = /* @__PURE__ */ __name((value) => {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${value}"`);
  }
}, "parseBoolean");
var expectNumber = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
}, "expectNumber");
var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var expectFloat32 = /* @__PURE__ */ __name((value) => {
  const expected = expectNumber(value);
  if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
}, "expectFloat32");
var expectLong = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
}, "expectLong");
var expectInt32 = /* @__PURE__ */ __name((value) => expectSizedInt(value, 32), "expectInt32");
var expectShort = /* @__PURE__ */ __name((value) => expectSizedInt(value, 16), "expectShort");
var expectByte = /* @__PURE__ */ __name((value) => expectSizedInt(value, 8), "expectByte");
var expectSizedInt = /* @__PURE__ */ __name((value, size) => {
  const expected = expectLong(value);
  if (expected !== void 0 && castInt(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
}, "expectSizedInt");
var castInt = /* @__PURE__ */ __name((value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
}, "castInt");
var expectNonNull = /* @__PURE__ */ __name((value, location) => {
  if (value === null || value === void 0) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
}, "expectNonNull");
var expectObject = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
}, "expectObject");
var expectString = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
}, "expectString");
var strictParseDouble = /* @__PURE__ */ __name((value) => {
  if (typeof value == "string") {
    return expectNumber(parseNumber(value));
  }
  return expectNumber(value);
}, "strictParseDouble");
var strictParseFloat32 = /* @__PURE__ */ __name((value) => {
  if (typeof value == "string") {
    return expectFloat32(parseNumber(value));
  }
  return expectFloat32(value);
}, "strictParseFloat32");
var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber = /* @__PURE__ */ __name((value) => {
  const matches = value.match(NUMBER_REGEX);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
}, "parseNumber");
var strictParseInt32 = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    return expectInt32(parseNumber(value));
  }
  return expectInt32(value);
}, "strictParseInt32");
var strictParseShort = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    return expectShort(parseNumber(value));
  }
  return expectShort(value);
}, "strictParseShort");
var strictParseByte = /* @__PURE__ */ __name((value) => {
  if (typeof value === "string") {
    return expectByte(parseNumber(value));
  }
  return expectByte(value);
}, "strictParseByte");
var stackTraceWarning = /* @__PURE__ */ __name((message) => {
  return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s10) => !s10.includes("stackTraceWarning")).join("\n");
}, "stackTraceWarning");
var logger = {
  warn: console.warn
};

// ../../node_modules/@smithy/smithy-client/dist-es/date-utils.js
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var parseRfc3339DateTimeWithOffset = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  const date2 = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date2.setTime(date2.getTime() - parseOffsetToMilliseconds(offsetStr));
  }
  return date2;
}, "parseRfc3339DateTimeWithOffset");
var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var parseEpochTimestamp = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  let valueAsDouble;
  if (typeof value === "number") {
    valueAsDouble = value;
  } else if (typeof value === "string") {
    valueAsDouble = strictParseDouble(value);
  } else {
    throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
  }
  if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
    throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
  }
  return new Date(Math.round(valueAsDouble * 1e3));
}, "parseEpochTimestamp");
var buildDate = /* @__PURE__ */ __name((year, month, day, time2) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
}, "buildDate");
var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var validateDayOfMonth = /* @__PURE__ */ __name((year, month, day) => {
  let maxDays = DAYS_IN_MONTH[month];
  if (month === 1 && isLeapYear(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
  }
}, "validateDayOfMonth");
var isLeapYear = /* @__PURE__ */ __name((year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}, "isLeapYear");
var parseDateValue = /* @__PURE__ */ __name((value, type, lower, upper) => {
  const dateVal = strictParseByte(stripLeadingZeroes(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
}, "parseDateValue");
var parseMilliseconds = /* @__PURE__ */ __name((value) => {
  if (value === null || value === void 0) {
    return 0;
  }
  return strictParseFloat32("0." + value) * 1e3;
}, "parseMilliseconds");
var parseOffsetToMilliseconds = /* @__PURE__ */ __name((value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value.substring(1, 3));
  const minute = Number(value.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1e3;
}, "parseOffsetToMilliseconds");
var stripLeadingZeroes = /* @__PURE__ */ __name((value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
}, "stripLeadingZeroes");

// ../../node_modules/@smithy/smithy-client/dist-es/exceptions.js
var ServiceException = class _ServiceException extends Error {
  static {
    __name(this, "ServiceException");
  }
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, _ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException = /* @__PURE__ */ __name((exception, additions = {}) => {
  Object.entries(additions).filter(([, v7]) => v7 !== void 0).forEach(([k10, v7]) => {
    if (exception[k10] == void 0 || exception[k10] === "") {
      exception[k10] = v7;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
}, "decorateServiceException");

// ../../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = /* @__PURE__ */ __name(({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
}, "throwDefaultError");
var withBaseException = /* @__PURE__ */ __name((ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
}, "withBaseException");
var deserializeMetadata = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");

// ../../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
var loadConfigsForDefaultMode = /* @__PURE__ */ __name((mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
}, "loadConfigsForDefaultMode");

// ../../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
var warningEmitted = false;
var emitWarningIfUnsupportedVersion = /* @__PURE__ */ __name((version3) => {
  if (version3 && !warningEmitted && parseInt(version3.substring(1, version3.indexOf("."))) < 14) {
    warningEmitted = true;
  }
}, "emitWarningIfUnsupportedVersion");

// ../../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c11) {
    return "%" + c11.charCodeAt(0).toString(16).toUpperCase();
  });
}
__name(extendedEncodeURIComponent, "extendedEncodeURIComponent");

// ../../node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
var getArrayIfSingleItem = /* @__PURE__ */ __name((mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray], "getArrayIfSingleItem");

// ../../node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
var getValueFromTextNode = /* @__PURE__ */ __name((obj) => {
  const textNodeName = "#text";
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
      obj[key] = obj[key][textNodeName];
    } else if (typeof obj[key] === "object" && obj[key] !== null) {
      obj[key] = getValueFromTextNode(obj[key]);
    }
  }
  return obj;
}, "getValueFromTextNode");

// ../../node_modules/@smithy/smithy-client/dist-es/lazy-json.js
var StringWrapper = /* @__PURE__ */ __name(function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
}, "StringWrapper");
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);

// ../../node_modules/@smithy/smithy-client/dist-es/object-mapping.js
function map(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
__name(map, "map");
var take = /* @__PURE__ */ __name((source, instructions) => {
  const out = {};
  for (const key in instructions) {
    applyInstruction(out, source, instructions, key);
  }
  return out;
}, "take");
var mapWithFilter = /* @__PURE__ */ __name((target, filter, instructions) => {
  return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter, value()];
      } else {
        _instructions[key] = [filter, value];
      }
    }
    return _instructions;
  }, {}));
}, "mapWithFilter");
var applyInstruction = /* @__PURE__ */ __name((target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter, value] = instructions[targetKey];
  if (typeof value === "function") {
    let _value;
    const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
    const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value();
    }
  } else {
    const defaultFilterPassed = filter === void 0 && value != null;
    const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value;
    }
  }
}, "applyInstruction");
var nonNullish = /* @__PURE__ */ __name((_) => _ != null, "nonNullish");
var pass = /* @__PURE__ */ __name((_) => _, "pass");

// ../../node_modules/@smithy/smithy-client/dist-es/serde-json.js
var _json = /* @__PURE__ */ __name((obj) => {
  if (obj == null) {
    return {};
  }
  if (Array.isArray(obj)) {
    return obj.filter((_) => _ != null);
  }
  if (typeof obj === "object") {
    const target = {};
    for (const key of Object.keys(obj)) {
      if (obj[key] == null) {
        continue;
      }
      target[key] = _json(obj[key]);
    }
    return target;
  }
  return obj;
}, "_json");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "sqs"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-sqs/package.json
var package_default = {
  name: "@aws-sdk/client-sqs",
  description: "AWS SDK for JavaScript Sqs Client for Node.js, Browser and React Native",
  version: "3.395.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sqs"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.395.0",
    "@aws-sdk/credential-provider-node": "3.395.0",
    "@aws-sdk/middleware-host-header": "3.391.0",
    "@aws-sdk/middleware-logger": "3.391.0",
    "@aws-sdk/middleware-recursion-detection": "3.391.0",
    "@aws-sdk/middleware-sdk-sqs": "3.391.0",
    "@aws-sdk/middleware-signing": "3.391.0",
    "@aws-sdk/middleware-user-agent": "3.391.0",
    "@aws-sdk/types": "3.391.0",
    "@aws-sdk/util-endpoints": "3.391.0",
    "@aws-sdk/util-user-agent-browser": "3.391.0",
    "@aws-sdk/util-user-agent-node": "3.391.0",
    "@smithy/config-resolver": "^2.0.3",
    "@smithy/fetch-http-handler": "^2.0.3",
    "@smithy/hash-node": "^2.0.3",
    "@smithy/invalid-dependency": "^2.0.3",
    "@smithy/md5-js": "^2.0.3",
    "@smithy/middleware-content-length": "^2.0.3",
    "@smithy/middleware-endpoint": "^2.0.3",
    "@smithy/middleware-retry": "^2.0.3",
    "@smithy/middleware-serde": "^2.0.3",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.3",
    "@smithy/node-http-handler": "^2.0.3",
    "@smithy/protocol-http": "^2.0.3",
    "@smithy/smithy-client": "^2.0.3",
    "@smithy/types": "^2.2.0",
    "@smithy/url-parser": "^2.0.3",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.3",
    "@smithy/util-defaults-mode-node": "^2.0.3",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    "fast-xml-parser": "4.2.5",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sqs",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sqs"
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js
var resolveStsAuthConfig = /* @__PURE__ */ __name((input, { stsClientCtor }) => resolveAwsAuthConfig({
  ...input,
  stsClientCtor
}), "resolveStsAuthConfig");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    defaultSigningName: "sts"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/package.json
var package_default2 = {
  name: "@aws-sdk/client-sts",
  description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
  version: "3.395.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
    test: "yarn test:unit",
    "test:unit": "jest"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/credential-provider-node": "3.395.0",
    "@aws-sdk/middleware-host-header": "3.391.0",
    "@aws-sdk/middleware-logger": "3.391.0",
    "@aws-sdk/middleware-recursion-detection": "3.391.0",
    "@aws-sdk/middleware-sdk-sts": "3.391.0",
    "@aws-sdk/middleware-signing": "3.391.0",
    "@aws-sdk/middleware-user-agent": "3.391.0",
    "@aws-sdk/types": "3.391.0",
    "@aws-sdk/util-endpoints": "3.391.0",
    "@aws-sdk/util-user-agent-browser": "3.391.0",
    "@aws-sdk/util-user-agent-node": "3.391.0",
    "@smithy/config-resolver": "^2.0.3",
    "@smithy/fetch-http-handler": "^2.0.3",
    "@smithy/hash-node": "^2.0.3",
    "@smithy/invalid-dependency": "^2.0.3",
    "@smithy/middleware-content-length": "^2.0.3",
    "@smithy/middleware-endpoint": "^2.0.3",
    "@smithy/middleware-retry": "^2.0.3",
    "@smithy/middleware-serde": "^2.0.3",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.3",
    "@smithy/node-http-handler": "^2.0.3",
    "@smithy/protocol-http": "^2.0.3",
    "@smithy/smithy-client": "^2.0.3",
    "@smithy/types": "^2.2.0",
    "@smithy/url-parser": "^2.0.3",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.3",
    "@smithy/util-defaults-mode-node": "^2.0.3",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    "fast-xml-parser": "4.2.5",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sts"
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException = class _STSServiceException extends ServiceException {
  static {
    __name(this, "STSServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _STSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException = class _ExpiredTokenException2 extends STSServiceException {
  static {
    __name(this, "ExpiredTokenException");
  }
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExpiredTokenException2.prototype);
  }
};
var MalformedPolicyDocumentException = class _MalformedPolicyDocumentException extends STSServiceException {
  static {
    __name(this, "MalformedPolicyDocumentException");
  }
  constructor(opts) {
    super({
      name: "MalformedPolicyDocumentException",
      $fault: "client",
      ...opts
    });
    this.name = "MalformedPolicyDocumentException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
  }
};
var PackedPolicyTooLargeException = class _PackedPolicyTooLargeException extends STSServiceException {
  static {
    __name(this, "PackedPolicyTooLargeException");
  }
  constructor(opts) {
    super({
      name: "PackedPolicyTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "PackedPolicyTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
  }
};
var RegionDisabledException = class _RegionDisabledException extends STSServiceException {
  static {
    __name(this, "RegionDisabledException");
  }
  constructor(opts) {
    super({
      name: "RegionDisabledException",
      $fault: "client",
      ...opts
    });
    this.name = "RegionDisabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _RegionDisabledException.prototype);
  }
};
var IDPRejectedClaimException = class _IDPRejectedClaimException extends STSServiceException {
  static {
    __name(this, "IDPRejectedClaimException");
  }
  constructor(opts) {
    super({
      name: "IDPRejectedClaimException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPRejectedClaimException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
  }
};
var InvalidIdentityTokenException = class _InvalidIdentityTokenException extends STSServiceException {
  static {
    __name(this, "InvalidIdentityTokenException");
  }
  constructor(opts) {
    super({
      name: "InvalidIdentityTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdentityTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
  }
};
var IDPCommunicationErrorException = class _IDPCommunicationErrorException extends STSServiceException {
  static {
    __name(this, "IDPCommunicationErrorException");
  }
  constructor(opts) {
    super({
      name: "IDPCommunicationErrorException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPCommunicationErrorException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
  }
};
var CredentialsFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING }
}), "CredentialsFilterSensitiveLog");
var AssumeRoleResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
}), "AssumeRoleResponseFilterSensitiveLog");
var AssumeRoleWithWebIdentityRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.WebIdentityToken && { WebIdentityToken: SENSITIVE_STRING }
}), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog");
var AssumeRoleWithWebIdentityResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
}), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_fast_xml_parser = __toESM(require_fxp());
var se_AssumeRoleCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_AssumeRoleRequest(input, context8),
    Action: "AssumeRole",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest(context8, headers, "/", void 0, body);
}, "se_AssumeRoleCommand");
var se_AssumeRoleWithWebIdentityCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = SHARED_HEADERS;
  let body;
  body = buildFormUrlencodedString({
    ...se_AssumeRoleWithWebIdentityRequest(input, context8),
    Action: "AssumeRoleWithWebIdentity",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest(context8, headers, "/", void 0, body);
}, "se_AssumeRoleWithWebIdentityCommand");
var de_AssumeRoleCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_AssumeRoleCommandError(output, context8);
  }
  const data = await parseBody(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleResponse(data.AssumeRoleResult, context8);
  const response = {
    $metadata: deserializeMetadata2(output),
    ...contents
  };
  return response;
}, "de_AssumeRoleCommand");
var de_AssumeRoleCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context8)
  };
  const errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes(parsedOutput, context8);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context8);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context8);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, "de_AssumeRoleCommandError");
var de_AssumeRoleWithWebIdentityCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_AssumeRoleWithWebIdentityCommandError(output, context8);
  }
  const data = await parseBody(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context8);
  const response = {
    $metadata: deserializeMetadata2(output),
    ...contents
  };
  return response;
}, "de_AssumeRoleWithWebIdentityCommand");
var de_AssumeRoleWithWebIdentityCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody(output.body, context8)
  };
  const errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes(parsedOutput, context8);
    case "IDPCommunicationError":
    case "com.amazonaws.sts#IDPCommunicationErrorException":
      throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context8);
    case "IDPRejectedClaim":
    case "com.amazonaws.sts#IDPRejectedClaimException":
      throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context8);
    case "InvalidIdentityToken":
    case "com.amazonaws.sts#InvalidIdentityTokenException":
      throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context8);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context8);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context8);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, "de_AssumeRoleWithWebIdentityCommandError");
var de_ExpiredTokenExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_ExpiredTokenException(body.Error, context8);
  const exception = new ExpiredTokenException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_ExpiredTokenExceptionRes");
var de_IDPCommunicationErrorExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPCommunicationErrorException(body.Error, context8);
  const exception = new IDPCommunicationErrorException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_IDPCommunicationErrorExceptionRes");
var de_IDPRejectedClaimExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPRejectedClaimException(body.Error, context8);
  const exception = new IDPRejectedClaimException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_IDPRejectedClaimExceptionRes");
var de_InvalidIdentityTokenExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidIdentityTokenException(body.Error, context8);
  const exception = new InvalidIdentityTokenException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InvalidIdentityTokenExceptionRes");
var de_MalformedPolicyDocumentExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_MalformedPolicyDocumentException(body.Error, context8);
  const exception = new MalformedPolicyDocumentException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_MalformedPolicyDocumentExceptionRes");
var de_PackedPolicyTooLargeExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_PackedPolicyTooLargeException(body.Error, context8);
  const exception = new PackedPolicyTooLargeException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_PackedPolicyTooLargeExceptionRes");
var de_RegionDisabledExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_RegionDisabledException(body.Error, context8);
  const exception = new RegionDisabledException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_RegionDisabledExceptionRes");
var se_AssumeRoleRequest = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.PolicyArns != null) {
    const memberEntries = se_policyDescriptorListType(input.PolicyArns, context8);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  if (input.Tags != null) {
    const memberEntries = se_tagListType(input.Tags, context8);
    if (input.Tags?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TransitiveTagKeys != null) {
    const memberEntries = se_tagKeyListType(input.TransitiveTagKeys, context8);
    if (input.TransitiveTagKeys?.length === 0) {
      entries.TransitiveTagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitiveTagKeys.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ExternalId != null) {
    entries["ExternalId"] = input.ExternalId;
  }
  if (input.SerialNumber != null) {
    entries["SerialNumber"] = input.SerialNumber;
  }
  if (input.TokenCode != null) {
    entries["TokenCode"] = input.TokenCode;
  }
  if (input.SourceIdentity != null) {
    entries["SourceIdentity"] = input.SourceIdentity;
  }
  if (input.ProvidedContexts != null) {
    const memberEntries = se_ProvidedContextsListType(input.ProvidedContexts, context8);
    if (input.ProvidedContexts?.length === 0) {
      entries.ProvidedContexts = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ProvidedContexts.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
}, "se_AssumeRoleRequest");
var se_AssumeRoleWithWebIdentityRequest = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.WebIdentityToken != null) {
    entries["WebIdentityToken"] = input.WebIdentityToken;
  }
  if (input.ProviderId != null) {
    entries["ProviderId"] = input.ProviderId;
  }
  if (input.PolicyArns != null) {
    const memberEntries = se_policyDescriptorListType(input.PolicyArns, context8);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  return entries;
}, "se_AssumeRoleWithWebIdentityRequest");
var se_policyDescriptorListType = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_PolicyDescriptorType(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_policyDescriptorListType");
var se_PolicyDescriptorType = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.arn != null) {
    entries["arn"] = input.arn;
  }
  return entries;
}, "se_PolicyDescriptorType");
var se_ProvidedContext = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.ProviderArn != null) {
    entries["ProviderArn"] = input.ProviderArn;
  }
  if (input.ContextAssertion != null) {
    entries["ContextAssertion"] = input.ContextAssertion;
  }
  return entries;
}, "se_ProvidedContext");
var se_ProvidedContextsListType = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_ProvidedContext(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_ProvidedContextsListType");
var se_Tag = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.Key != null) {
    entries["Key"] = input.Key;
  }
  if (input.Value != null) {
    entries["Value"] = input.Value;
  }
  return entries;
}, "se_Tag");
var se_tagKeyListType = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
}, "se_tagKeyListType");
var se_tagListType = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Tag(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_tagListType");
var de_AssumedRoleUser = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["AssumedRoleId"] !== void 0) {
    contents.AssumedRoleId = expectString(output["AssumedRoleId"]);
  }
  if (output["Arn"] !== void 0) {
    contents.Arn = expectString(output["Arn"]);
  }
  return contents;
}, "de_AssumedRoleUser");
var de_AssumeRoleResponse = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["Credentials"] !== void 0) {
    contents.Credentials = de_Credentials(output["Credentials"], context8);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context8);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString(output["SourceIdentity"]);
  }
  return contents;
}, "de_AssumeRoleResponse");
var de_AssumeRoleWithWebIdentityResponse = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["Credentials"] !== void 0) {
    contents.Credentials = de_Credentials(output["Credentials"], context8);
  }
  if (output["SubjectFromWebIdentityToken"] !== void 0) {
    contents.SubjectFromWebIdentityToken = expectString(output["SubjectFromWebIdentityToken"]);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context8);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
  }
  if (output["Provider"] !== void 0) {
    contents.Provider = expectString(output["Provider"]);
  }
  if (output["Audience"] !== void 0) {
    contents.Audience = expectString(output["Audience"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString(output["SourceIdentity"]);
  }
  return contents;
}, "de_AssumeRoleWithWebIdentityResponse");
var de_Credentials = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["AccessKeyId"] !== void 0) {
    contents.AccessKeyId = expectString(output["AccessKeyId"]);
  }
  if (output["SecretAccessKey"] !== void 0) {
    contents.SecretAccessKey = expectString(output["SecretAccessKey"]);
  }
  if (output["SessionToken"] !== void 0) {
    contents.SessionToken = expectString(output["SessionToken"]);
  }
  if (output["Expiration"] !== void 0) {
    contents.Expiration = expectNonNull(parseRfc3339DateTimeWithOffset(output["Expiration"]));
  }
  return contents;
}, "de_Credentials");
var de_ExpiredTokenException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_ExpiredTokenException");
var de_IDPCommunicationErrorException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_IDPCommunicationErrorException");
var de_IDPRejectedClaimException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_IDPRejectedClaimException");
var de_InvalidIdentityTokenException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_InvalidIdentityTokenException");
var de_MalformedPolicyDocumentException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_MalformedPolicyDocumentException");
var de_PackedPolicyTooLargeException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_PackedPolicyTooLargeException");
var de_RegionDisabledException = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_RegionDisabledException");
var deserializeMetadata2 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var throwDefaultError2 = withBaseException(STSServiceException);
var buildHttpRpcRequest = /* @__PURE__ */ __name(async (context8, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath14.endsWith("/") ? basePath14.slice(0, -1) + path : basePath14 + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
}, "buildHttpRpcRequest");
var SHARED_HEADERS = {
  "content-type": "application/x-www-form-urlencoded"
};
var parseBody = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
}), "parseBody");
var parseErrorBody = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody(errorBody, context8);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
}, "parseErrorBody");
var buildFormUrlencodedString = /* @__PURE__ */ __name((formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&"), "buildFormUrlencodedString");
var loadQueryErrorCode = /* @__PURE__ */ __name((output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
}, "loadQueryErrorCode");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var AssumeRoleCommand = class _AssumeRoleCommand extends Command {
  static {
    __name(this, "AssumeRoleCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _AssumeRoleCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getAwsAuthPlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_AssumeRoleCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_AssumeRoleCommand(output, context8);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var AssumeRoleWithWebIdentityCommand = class _AssumeRoleWithWebIdentityCommand extends Command {
  static {
    __name(this, "AssumeRoleWithWebIdentityCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleWithWebIdentityCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
      outputFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_AssumeRoleWithWebIdentityCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_AssumeRoleWithWebIdentityCommand(output, context8);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
var decorateDefaultRegion = /* @__PURE__ */ __name((region) => {
  if (typeof region !== "function") {
    return region === void 0 ? ASSUME_ROLE_DEFAULT_REGION : region;
  }
  return async () => {
    try {
      return await region();
    } catch (e10) {
      return ASSUME_ROLE_DEFAULT_REGION;
    }
  };
}, "decorateDefaultRegion");
var getDefaultRoleAssumer = /* @__PURE__ */ __name((stsOptions, stsClientCtor) => {
  let stsClient;
  let closureSourceCreds;
  return async (sourceCreds, params) => {
    closureSourceCreds = sourceCreds;
    if (!stsClient) {
      const { logger: logger2, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger2,
        credentialDefaultProvider: () => async () => closureSourceCreds,
        region: decorateDefaultRegion(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
}, "getDefaultRoleAssumer");
var getDefaultRoleAssumerWithWebIdentity = /* @__PURE__ */ __name((stsOptions, stsClientCtor) => {
  let stsClient;
  return async (params) => {
    if (!stsClient) {
      const { logger: logger2, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger2,
        region: decorateDefaultRegion(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
}, "getDefaultRoleAssumerWithWebIdentity");
var decorateDefaultCredentialProvider = /* @__PURE__ */ __name((provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer(input, input.stsClientCtor),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity(input, input.stsClientCtor),
  ...input
}), "decorateDefaultCredentialProvider");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var ENV_KEY = "AWS_ACCESS_KEY_ID";
var ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
var ENV_SESSION = "AWS_SESSION_TOKEN";
var ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
var fromEnv = /* @__PURE__ */ __name(() => async () => {
  const accessKeyId = process.env[ENV_KEY];
  const secretAccessKey = process.env[ENV_SECRET];
  const sessionToken = process.env[ENV_SESSION];
  const expiry = process.env[ENV_EXPIRATION];
  if (accessKeyId && secretAccessKey) {
    return {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) }
    };
  }
  throw new CredentialsProviderError("Unable to find environment variable credentials.");
}, "fromEnv");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getHomeDir.js
import { homedir } from "os";
import { sep } from "path";
var getHomeDir = /* @__PURE__ */ __name(() => {
  const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${sep}` } = process.env;
  if (HOME)
    return HOME;
  if (USERPROFILE)
    return USERPROFILE;
  if (HOMEPATH)
    return `${HOMEDRIVE}${HOMEPATH}`;
  return homedir();
}, "getHomeDir");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileName.js
var ENV_PROFILE = "AWS_PROFILE";
var DEFAULT_PROFILE = "default";
var getProfileName = /* @__PURE__ */ __name((init2) => init2.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE, "getProfileName");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFilepath.js
import { createHash } from "crypto";
import { join } from "path";
var getSSOTokenFilepath = /* @__PURE__ */ __name((id) => {
  const hasher = createHash("sha1");
  const cacheName = hasher.update(id).digest("hex");
  return join(getHomeDir(), ".aws", "sso", "cache", `${cacheName}.json`);
}, "getSSOTokenFilepath");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js
import { promises as fsPromises } from "fs";
var { readFile } = fsPromises;
var getSSOTokenFromFile = /* @__PURE__ */ __name(async (id) => {
  const ssoTokenFilepath = getSSOTokenFilepath(id);
  const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
  return JSON.parse(ssoTokenText);
}, "getSSOTokenFromFile");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getConfigFilepath.js
import { join as join2 } from "path";
var ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
var getConfigFilepath = /* @__PURE__ */ __name(() => process.env[ENV_CONFIG_PATH] || join2(getHomeDir(), ".aws", "config"), "getConfigFilepath");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getCredentialsFilepath.js
import { join as join3 } from "path";
var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
var getCredentialsFilepath = /* @__PURE__ */ __name(() => process.env[ENV_CREDENTIALS_PATH] || join3(getHomeDir(), ".aws", "credentials"), "getCredentialsFilepath");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getProfileData.js
var profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
var getProfileData = /* @__PURE__ */ __name((data) => Object.entries(data).filter(([key]) => profileKeyRegex.test(key)).reduce((acc, [key, value]) => ({ ...acc, [profileKeyRegex.exec(key)[2]]: value }), {
  ...data.default && { default: data.default }
}), "getProfileData");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/parseIni.js
var profileNameBlockList = ["__proto__", "profile __proto__"];
var parseIni = /* @__PURE__ */ __name((iniData) => {
  const map2 = {};
  let currentSection;
  for (let line of iniData.split(/\r?\n/)) {
    line = line.split(/(^|\s)[;#]/)[0].trim();
    const isSection = line[0] === "[" && line[line.length - 1] === "]";
    if (isSection) {
      currentSection = line.substring(1, line.length - 1);
      if (profileNameBlockList.includes(currentSection)) {
        throw new Error(`Found invalid profile name "${currentSection}"`);
      }
    } else if (currentSection) {
      const indexOfEqualsSign = line.indexOf("=");
      const start = 0;
      const end = line.length - 1;
      const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
      if (isAssignment) {
        const [name2, value] = [
          line.substring(0, indexOfEqualsSign).trim(),
          line.substring(indexOfEqualsSign + 1).trim()
        ];
        map2[currentSection] = map2[currentSection] || {};
        map2[currentSection][name2] = value;
      }
    }
  }
  return map2;
}, "parseIni");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js
import { promises as fsPromises2 } from "fs";
var { readFile: readFile2 } = fsPromises2;
var filePromisesHash = {};
var slurpFile = /* @__PURE__ */ __name((path, options) => {
  if (!filePromisesHash[path] || options?.ignoreCache) {
    filePromisesHash[path] = readFile2(path, "utf8");
  }
  return filePromisesHash[path];
}, "slurpFile");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSharedConfigFiles.js
var swallowError = /* @__PURE__ */ __name(() => ({}), "swallowError");
var loadSharedConfigFiles = /* @__PURE__ */ __name(async (init2 = {}) => {
  const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init2;
  const parsedFiles = await Promise.all([
    slurpFile(configFilepath, {
      ignoreCache: init2.ignoreCache
    }).then(parseIni).then(getProfileData).catch(swallowError),
    slurpFile(filepath, {
      ignoreCache: init2.ignoreCache
    }).then(parseIni).catch(swallowError)
  ]);
  return {
    configFile: parsedFiles[0],
    credentialsFile: parsedFiles[1]
  };
}, "loadSharedConfigFiles");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/getSsoSessionData.js
var ssoSessionKeyRegex = /^sso-session\s(["'])?([^\1]+)\1$/;
var getSsoSessionData = /* @__PURE__ */ __name((data) => Object.entries(data).filter(([key]) => ssoSessionKeyRegex.test(key)).reduce((acc, [key, value]) => ({ ...acc, [ssoSessionKeyRegex.exec(key)[2]]: value }), {}), "getSsoSessionData");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/loadSsoSessionData.js
var swallowError2 = /* @__PURE__ */ __name(() => ({}), "swallowError");
var loadSsoSessionData = /* @__PURE__ */ __name(async (init2 = {}) => slurpFile(init2.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError2), "loadSsoSessionData");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/mergeConfigFiles.js
var mergeConfigFiles = /* @__PURE__ */ __name((...files) => {
  const merged = {};
  for (const file of files) {
    for (const [key, values] of Object.entries(file)) {
      if (merged[key] !== void 0) {
        Object.assign(merged[key], values);
      } else {
        merged[key] = values;
      }
    }
  }
  return merged;
}, "mergeConfigFiles");

// ../../node_modules/@smithy/shared-ini-file-loader/dist-es/parseKnownFiles.js
var parseKnownFiles = /* @__PURE__ */ __name(async (init2) => {
  const parsedFiles = await loadSharedConfigFiles(init2);
  return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
}, "parseKnownFiles");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
import { parse } from "url";

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
import { Buffer as Buffer3 } from "buffer";
import { request } from "http";
function httpRequest(options) {
  return new Promise((resolve, reject) => {
    const req = request({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err) => {
      reject(Object.assign(new ProviderError("Unable to connect to instance metadata service"), err));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new ProviderError("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new ProviderError("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk) => {
        chunks.push(chunk);
      });
      res.on("end", () => {
        resolve(Buffer3.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}
__name(httpRequest, "httpRequest");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string", "isImdsCredentials");
var fromImdsCredentials = /* @__PURE__ */ __name((creds) => ({
  accessKeyId: creds.AccessKeyId,
  secretAccessKey: creds.SecretAccessKey,
  sessionToken: creds.Token,
  expiration: new Date(creds.Expiration)
}), "fromImdsCredentials");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT = 1e3;
var DEFAULT_MAX_RETRIES = 0;
var providerConfigFromInit = /* @__PURE__ */ __name(({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout }), "providerConfigFromInit");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry = /* @__PURE__ */ __name((toRetry, maxRetries) => {
  let promise = toRetry();
  for (let i10 = 0; i10 < maxRetries; i10++) {
    promise = promise.catch(toRetry);
  }
  return promise;
}, "retry");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
var ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
var ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
var fromContainerMetadata = /* @__PURE__ */ __name((init2 = {}) => {
  const { timeout, maxRetries } = providerConfigFromInit(init2);
  return () => retry(async () => {
    const requestOptions = await getCmdsUri();
    const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
    if (!isImdsCredentials(credsResponse)) {
      throw new CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return fromImdsCredentials(credsResponse);
  }, maxRetries);
}, "fromContainerMetadata");
var requestFromEcsImds = /* @__PURE__ */ __name(async (timeout, options) => {
  if (process.env[ENV_CMDS_AUTH_TOKEN]) {
    options.headers = {
      ...options.headers,
      Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
    };
  }
  const buffer = await httpRequest({
    ...options,
    timeout
  });
  return buffer.toString();
}, "requestFromEcsImds");
var CMDS_IP = "169.254.170.2";
var GREENGRASS_HOSTS = {
  localhost: true,
  "127.0.0.1": true
};
var GREENGRASS_PROTOCOLS = {
  "http:": true,
  "https:": true
};
var getCmdsUri = /* @__PURE__ */ __name(async () => {
  if (process.env[ENV_CMDS_RELATIVE_URI]) {
    return {
      hostname: CMDS_IP,
      path: process.env[ENV_CMDS_RELATIVE_URI]
    };
  }
  if (process.env[ENV_CMDS_FULL_URI]) {
    const parsed = parse(process.env[ENV_CMDS_FULL_URI]);
    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
      throw new CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
    }
    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
      throw new CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
    }
    return {
      ...parsed,
      port: parsed.port ? parseInt(parsed.port, 10) : void 0
    };
  }
  throw new CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment variable is set`, false);
}, "getCmdsUri");

// ../../node_modules/@smithy/node-config-provider/dist-es/fromEnv.js
var fromEnv2 = /* @__PURE__ */ __name((envVarSelector) => async () => {
  try {
    const config = envVarSelector(process.env);
    if (config === void 0) {
      throw new Error();
    }
    return config;
  } catch (e10) {
    throw new CredentialsProviderError(e10.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
  }
}, "fromEnv");

// ../../node_modules/@smithy/node-config-provider/dist-es/fromSharedConfigFiles.js
var fromSharedConfigFiles = /* @__PURE__ */ __name((configSelector, { preferredFile = "config", ...init2 } = {}) => async () => {
  const profile = getProfileName(init2);
  const { configFile, credentialsFile } = await loadSharedConfigFiles(init2);
  const profileFromCredentials = credentialsFile[profile] || {};
  const profileFromConfig = configFile[profile] || {};
  const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
  try {
    const configValue = configSelector(mergedProfile);
    if (configValue === void 0) {
      throw new Error();
    }
    return configValue;
  } catch (e10) {
    throw new CredentialsProviderError(e10.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
  }
}, "fromSharedConfigFiles");

// ../../node_modules/@smithy/node-config-provider/dist-es/fromStatic.js
var isFunction = /* @__PURE__ */ __name((func) => typeof func === "function", "isFunction");
var fromStatic2 = /* @__PURE__ */ __name((defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : fromStatic(defaultValue), "fromStatic");

// ../../node_modules/@smithy/node-config-provider/dist-es/configLoader.js
var loadConfig = /* @__PURE__ */ __name(({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => memoize(chain(fromEnv2(environmentVariableSelector), fromSharedConfigFiles(configFileSelector, configuration), fromStatic2(defaultValue))), "loadConfig");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint;
(function(Endpoint2) {
  Endpoint2["IPv4"] = "http://169.254.169.254";
  Endpoint2["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint || (Endpoint = {}));

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
var ENDPOINT_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_NAME],
  configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
  default: void 0
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
(function(EndpointMode2) {
  EndpointMode2["IPv4"] = "IPv4";
  EndpointMode2["IPv6"] = "IPv6";
})(EndpointMode || (EndpointMode = {}));

// ../../node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
var ENDPOINT_MODE_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_MODE_NAME],
  configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
  default: EndpointMode.IPv4
};

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var getInstanceMetadataEndpoint = /* @__PURE__ */ __name(async () => parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig()), "getInstanceMetadataEndpoint");
var getFromEndpointConfig = /* @__PURE__ */ __name(async () => loadConfig(ENDPOINT_CONFIG_OPTIONS)(), "getFromEndpointConfig");
var getFromEndpointModeConfig = /* @__PURE__ */ __name(async () => {
  const endpointMode = await loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint.IPv4;
    case EndpointMode.IPv6:
      return Endpoint.IPv6;
    default:
      throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode)}`);
  }
}, "getFromEndpointModeConfig");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
var STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
var getExtendedInstanceMetadataCredentials = /* @__PURE__ */ __name((credentials, logger2) => {
  const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
  const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
  logger2.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " + STATIC_STABILITY_DOC_URL);
  const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
  return {
    ...credentials,
    ...originalExpiration ? { originalExpiration } : {},
    expiration: newExpiration
  };
}, "getExtendedInstanceMetadataCredentials");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider = /* @__PURE__ */ __name((provider, options = {}) => {
  const logger2 = options?.logger || console;
  let pastCredentials;
  return async () => {
    let credentials;
    try {
      credentials = await provider();
      if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
        credentials = getExtendedInstanceMetadataCredentials(credentials, logger2);
      }
    } catch (e10) {
      if (pastCredentials) {
        logger2.warn("Credential renew failed: ", e10);
        credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger2);
      } else {
        throw e10;
      }
    }
    pastCredentials = credentials;
    return credentials;
  };
}, "staticStabilityProvider");

// ../../node_modules/@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js
var IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
var IMDS_TOKEN_PATH = "/latest/api/token";
var fromInstanceMetadata = /* @__PURE__ */ __name((init2 = {}) => staticStabilityProvider(getInstanceImdsProvider(init2), { logger: init2.logger }), "fromInstanceMetadata");
var getInstanceImdsProvider = /* @__PURE__ */ __name((init2) => {
  let disableFetchToken = false;
  const { timeout, maxRetries } = providerConfigFromInit(init2);
  const getCredentials = /* @__PURE__ */ __name(async (maxRetries2, options) => {
    const profile = (await retry(async () => {
      let profile2;
      try {
        profile2 = await getProfile(options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return profile2;
    }, maxRetries2)).trim();
    return retry(async () => {
      let creds;
      try {
        creds = await getCredentialsFromProfile(profile, options);
      } catch (err) {
        if (err.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err;
      }
      return creds;
    }, maxRetries2);
  }, "getCredentials");
  return async () => {
    const endpoint3 = await getInstanceMetadataEndpoint();
    if (disableFetchToken) {
      return getCredentials(maxRetries, { ...endpoint3, timeout });
    } else {
      let token;
      try {
        token = (await getMetadataToken({ ...endpoint3, timeout })).toString();
      } catch (error) {
        if (error?.statusCode === 400) {
          throw Object.assign(error, {
            message: "EC2 Metadata token request returned error"
          });
        } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
          disableFetchToken = true;
        }
        return getCredentials(maxRetries, { ...endpoint3, timeout });
      }
      return getCredentials(maxRetries, {
        ...endpoint3,
        headers: {
          "x-aws-ec2-metadata-token": token
        },
        timeout
      });
    }
  };
}, "getInstanceImdsProvider");
var getMetadataToken = /* @__PURE__ */ __name(async (options) => httpRequest({
  ...options,
  path: IMDS_TOKEN_PATH,
  method: "PUT",
  headers: {
    "x-aws-ec2-metadata-token-ttl-seconds": "21600"
  }
}), "getMetadataToken");
var getProfile = /* @__PURE__ */ __name(async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString(), "getProfile");
var getCredentialsFromProfile = /* @__PURE__ */ __name(async (profile, options) => {
  const credsResponse = JSON.parse((await httpRequest({
    ...options,
    path: IMDS_PATH + profile
  })).toString());
  if (!isImdsCredentials(credsResponse)) {
    throw new CredentialsProviderError("Invalid response received from instance metadata service.");
  }
  return fromImdsCredentials(credsResponse);
}, "getCredentialsFromProfile");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var resolveCredentialSource = /* @__PURE__ */ __name((credentialSource, profileName) => {
  const sourceProvidersMap = {
    EcsContainer: fromContainerMetadata,
    Ec2InstanceMetadata: fromInstanceMetadata,
    Environment: fromEnv
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource]();
  } else {
    throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`);
  }
}, "resolveCredentialSource");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var isAssumeRoleProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg)), "isAssumeRoleProfile");
var isAssumeRoleWithSourceProfile = /* @__PURE__ */ __name((arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined", "isAssumeRoleWithSourceProfile");
var isAssumeRoleWithProviderProfile = /* @__PURE__ */ __name((arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined", "isAssumeRoleWithProviderProfile");
var resolveAssumeRoleCredentials = /* @__PURE__ */ __name(async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (!options.roleAssumer) {
    throw new CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
  }
  const { source_profile } = data;
  if (source_profile && source_profile in visitedProfiles) {
    throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
  }
  const sourceCredsProvider = source_profile ? resolveProfileData(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }) : resolveCredentialSource(data.credential_source, profileName)();
  const params = {
    RoleArn: data.role_arn,
    RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
    ExternalId: data.external_id
  };
  const { mfa_serial } = data;
  if (mfa_serial) {
    if (!options.mfaCodeProvider) {
      throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
    }
    params.SerialNumber = mfa_serial;
    params.TokenCode = await options.mfaCodeProvider(mfa_serial);
  }
  const sourceCreds = await sourceCredsProvider;
  return options.roleAssumer(sourceCreds, params);
}, "resolveAssumeRoleCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
import { exec } from "child_process";
import { promisify } from "util";

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var getValidatedProcessCredentials = /* @__PURE__ */ __name((profileName, data) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === void 0 || data.SecretAccessKey === void 0) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = /* @__PURE__ */ new Date();
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  return {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) }
  };
}, "getValidatedProcessCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var resolveProcessCredentials = /* @__PURE__ */ __name(async (profileName, profiles) => {
  const profile = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile["credential_process"];
    if (credentialProcess !== void 0) {
      const execPromise = promisify(exec);
      try {
        const { stdout } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials(profileName, data);
      } catch (error) {
        throw new CredentialsProviderError(error.message);
      }
    } else {
      throw new CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
    }
  } else {
    throw new CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
  }
}, "resolveProcessCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const profiles = await parseKnownFiles(init2);
  return resolveProcessCredentials(getProfileName(init2), profiles);
}, "fromProcess");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var isProcessProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string", "isProcessProfile");
var resolveProcessCredentials2 = /* @__PURE__ */ __name(async (options, profile) => fromProcess({
  ...options,
  profile
})(), "resolveProcessCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile = /* @__PURE__ */ __name((arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string"), "isSsoProfile");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters3 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/package.json
var package_default3 = {
  name: "@aws-sdk/client-sso",
  description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
  version: "3.395.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/middleware-host-header": "3.391.0",
    "@aws-sdk/middleware-logger": "3.391.0",
    "@aws-sdk/middleware-recursion-detection": "3.391.0",
    "@aws-sdk/middleware-user-agent": "3.391.0",
    "@aws-sdk/types": "3.391.0",
    "@aws-sdk/util-endpoints": "3.391.0",
    "@aws-sdk/util-user-agent-browser": "3.391.0",
    "@aws-sdk/util-user-agent-node": "3.391.0",
    "@smithy/config-resolver": "^2.0.3",
    "@smithy/fetch-http-handler": "^2.0.3",
    "@smithy/hash-node": "^2.0.3",
    "@smithy/invalid-dependency": "^2.0.3",
    "@smithy/middleware-content-length": "^2.0.3",
    "@smithy/middleware-endpoint": "^2.0.3",
    "@smithy/middleware-retry": "^2.0.3",
    "@smithy/middleware-serde": "^2.0.3",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.3",
    "@smithy/node-http-handler": "^2.0.3",
    "@smithy/protocol-http": "^2.0.3",
    "@smithy/smithy-client": "^2.0.3",
    "@smithy/types": "^2.2.0",
    "@smithy/url-parser": "^2.0.3",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.3",
    "@smithy/util-defaults-mode-node": "^2.0.3",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso"
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
import { platform, release } from "os";
import { env, versions } from "process";

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable = /* @__PURE__ */ __name(() => {
  try {
    if (typeof __require === "function" && typeof module !== "undefined" && require_dist()) {
      return ["md/crt-avail"];
    }
    return null;
  } catch (e10) {
    return null;
  }
}, "isCrtAvailable");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
var UA_APP_ID_INI_NAME = "sdk-ua-app-id";
var defaultUserAgent = /* @__PURE__ */ __name(({ serviceId, clientVersion }) => {
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${platform()}`, release()],
    ["lang/js"],
    ["md/nodejs", `${versions.node}`]
  ];
  const crtAvailable = isCrtAvailable();
  if (crtAvailable) {
    sections.push(crtAvailable);
  }
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  if (env.AWS_EXECUTION_ENV) {
    sections.push([`exec-env/${env.AWS_EXECUTION_ENV}`]);
  }
  const appIdPromise = loadConfig({
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME],
    default: void 0
  })();
  let resolvedUserAgent = void 0;
  return async () => {
    if (!resolvedUserAgent) {
      const appId = await appIdPromise;
      resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    }
    return resolvedUserAgent;
  };
}, "defaultUserAgent");

// ../../node_modules/@smithy/hash-node/dist-es/index.js
init_dist_es6();
init_dist_es7();
import { Buffer as Buffer4 } from "buffer";
import { createHash as createHash2, createHmac } from "crypto";
var Hash = class {
  static {
    __name(this, "Hash");
  }
  constructor(algorithmIdentifier, secret) {
    this.algorithmIdentifier = algorithmIdentifier;
    this.secret = secret;
    this.reset();
  }
  update(toHash, encoding) {
    this.hash.update(toUint8Array(castSourceData(toHash, encoding)));
  }
  digest() {
    return Promise.resolve(this.hash.digest());
  }
  reset() {
    this.hash = this.secret ? createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : createHash2(this.algorithmIdentifier);
  }
};
function castSourceData(toCast, encoding) {
  if (Buffer4.isBuffer(toCast)) {
    return toCast;
  }
  if (typeof toCast === "string") {
    return fromString(toCast, encoding);
  }
  if (ArrayBuffer.isView(toCast)) {
    return fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
  }
  return fromArrayBuffer(toCast);
}
__name(castSourceData, "castSourceData");

// ../../node_modules/@smithy/util-body-length-node/dist-es/calculateBodyLength.js
import { fstatSync, lstatSync } from "fs";
var calculateBodyLength = /* @__PURE__ */ __name((body) => {
  if (!body) {
    return 0;
  }
  if (typeof body === "string") {
    return Buffer.from(body).length;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
    return lstatSync(body.path).size;
  } else if (typeof body.fd === "number") {
    return fstatSync(body.fd).size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
}, "calculateBodyLength");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var p = "required";
var q = "fn";
var r = "argv";
var s = "ref";
var a = "PartitionResult";
var b = "tree";
var c = "error";
var d = "endpoint";
var e = { [p]: false, "type": "String" };
var f = { [p]: true, "default": false, "type": "Boolean" };
var g = { [s]: "Endpoint" };
var h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] };
var i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] };
var j = {};
var k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] };
var l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] };
var m = [g];
var n = [h];
var o = [i];
var _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
var ruleSet = _data;

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
  extensions: config?.extensions ?? [],
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSO",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/constants.js
var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
var AWS_REGION_ENV = "AWS_REGION";
var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
var IMDS_REGION_PATH = "/latest/meta-data/placement/region";

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/defaultsModeConfig.js
var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => {
    return env3[AWS_DEFAULTS_MODE_ENV];
  },
  configFileSelector: (profile) => {
    return profile[AWS_DEFAULTS_MODE_CONFIG];
  },
  default: "legacy"
};

// ../../node_modules/@smithy/util-defaults-mode-node/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig = /* @__PURE__ */ __name(({ region = loadConfig(NODE_REGION_CONFIG_OPTIONS), defaultsMode = loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return resolveNodeDefaultsModeAuto(region);
    case "in-region":
    case "cross-region":
    case "mobile":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
}), "resolveDefaultsModeConfig");
var resolveNodeDefaultsModeAuto = /* @__PURE__ */ __name(async (clientRegion) => {
  if (clientRegion) {
    const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
    const inferredRegion = await inferPhysicalRegion();
    if (!inferredRegion) {
      return "standard";
    }
    if (resolvedRegion === inferredRegion) {
      return "in-region";
    } else {
      return "cross-region";
    }
  }
  return "standard";
}, "resolveNodeDefaultsModeAuto");
var inferPhysicalRegion = /* @__PURE__ */ __name(async () => {
  if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
    return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
  }
  if (!process.env[ENV_IMDS_DISABLED]) {
    try {
      const endpoint3 = await getInstanceMetadataEndpoint();
      return (await httpRequest({ ...endpoint3, path: IMDS_REGION_PATH })).toString();
    } catch (e10) {
    }
  }
}, "inferPhysicalRegion");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var getRuntimeConfig2 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default3.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/runtimeExtensions.js
var asPartial = /* @__PURE__ */ __name((t6) => t6, "asPartial");
var resolveRuntimeExtensions = /* @__PURE__ */ __name((runtimeConfig, extensions) => {
  const clientConfiguration = {
    ...asPartial(getDefaultClientConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configureClient(clientConfiguration));
  return {
    ...runtimeConfig,
    ...resolveDefaultRuntimeConfig(clientConfiguration)
  };
}, "resolveRuntimeExtensions");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var SSOClient = class extends Client {
  static {
    __name(this, "SSOClient");
  }
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig2(configuration || {});
    const _config_1 = resolveClientEndpointParameters3(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveUserAgentConfig(_config_5);
    const _config_7 = resolveRuntimeExtensions(_config_6, configuration?.extensions || []);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException = class _SSOServiceException extends ServiceException {
  static {
    __name(this, "SSOServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSOServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException = class _InvalidRequestException2 extends SSOServiceException {
  static {
    __name(this, "InvalidRequestException");
  }
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidRequestException2.prototype);
  }
};
var ResourceNotFoundException = class _ResourceNotFoundException extends SSOServiceException {
  static {
    __name(this, "ResourceNotFoundException");
  }
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
  }
};
var TooManyRequestsException = class _TooManyRequestsException extends SSOServiceException {
  static {
    __name(this, "TooManyRequestsException");
  }
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
  }
};
var UnauthorizedException = class _UnauthorizedException extends SSOServiceException {
  static {
    __name(this, "UnauthorizedException");
  }
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnauthorizedException.prototype);
  }
};
var GetRoleCredentialsRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), "GetRoleCredentialsRequestFilterSensitiveLog");
var RoleCredentialsFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING }
}), "RoleCredentialsFilterSensitiveLog");
var GetRoleCredentialsResponseFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
}), "GetRoleCredentialsResponseFilterSensitiveLog");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var se_GetRoleCredentialsCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const headers = map({}, isSerializableHeaderValue, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath14?.endsWith("/") ? basePath14.slice(0, -1) : basePath14 || ""}/federation/credentials`;
  const query = map({
    role_name: [, expectNonNull(input.roleName, `roleName`)],
    account_id: [, expectNonNull(input.accountId, `accountId`)]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
}, "se_GetRoleCredentialsCommand");
var de_GetRoleCredentialsCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_GetRoleCredentialsCommandError(output, context8);
  }
  const contents = map({
    $metadata: deserializeMetadata3(output)
  });
  const data = expectNonNull(expectObject(await parseBody2(output.body, context8)), "body");
  const doc = take(data, {
    roleCredentials: _json
  });
  Object.assign(contents, doc);
  return contents;
}, "de_GetRoleCredentialsCommand");
var de_GetRoleCredentialsCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody2(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context8);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context8);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context8);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_GetRoleCredentialsCommandError");
var throwDefaultError3 = withBaseException(SSOServiceException);
var de_InvalidRequestExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidRequestExceptionRes");
var de_ResourceNotFoundExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_ResourceNotFoundExceptionRes");
var de_TooManyRequestsExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_TooManyRequestsExceptionRes");
var de_UnauthorizedExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_UnauthorizedExceptionRes");
var deserializeMetadata3 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString2 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var isSerializableHeaderValue = /* @__PURE__ */ __name((value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0), "isSerializableHeaderValue");
var parseBody2 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString2(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
}), "parseBody");
var parseErrorBody2 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody2(errorBody, context8);
  value.message = value.message ?? value.Message;
  return value;
}, "parseErrorBody");
var loadRestJsonErrorCode = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k10) => k10.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand = class _GetRoleCredentialsCommand extends Command {
  static {
    __name(this, "GetRoleCredentialsCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetRoleCredentialsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSOClient";
    const commandName = "GetRoleCredentialsCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetRoleCredentialsRequestFilterSensitiveLog,
      outputFilterSensitiveLog: GetRoleCredentialsResponseFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_GetRoleCredentialsCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_GetRoleCredentialsCommand(output, context8);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/bundle/client-sso-oidc-node.js
init_dist_es7();
var resolveClientEndpointParameters4 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssooidc"
  };
}, "resolveClientEndpointParameters");
var package_default4 = { version: "3.387.0" };
var p2 = "required";
var q2 = "fn";
var r2 = "argv";
var s2 = "ref";
var a2 = "PartitionResult";
var b2 = "tree";
var c2 = "error";
var d2 = "endpoint";
var e2 = { [p2]: false, "type": "String" };
var f2 = { [p2]: true, "default": false, "type": "Boolean" };
var g2 = { [s2]: "Endpoint" };
var h2 = { [q2]: "booleanEquals", [r2]: [{ [s2]: "UseFIPS" }, true] };
var i2 = { [q2]: "booleanEquals", [r2]: [{ [s2]: "UseDualStack" }, true] };
var j2 = {};
var k2 = { [q2]: "booleanEquals", [r2]: [true, { [q2]: "getAttr", [r2]: [{ [s2]: a2 }, "supportsFIPS"] }] };
var l2 = { [q2]: "booleanEquals", [r2]: [true, { [q2]: "getAttr", [r2]: [{ [s2]: a2 }, "supportsDualStack"] }] };
var m2 = [g2];
var n2 = [h2];
var o2 = [i2];
var _data2 = { version: "1.0", parameters: { Region: e2, UseDualStack: f2, UseFIPS: f2, Endpoint: e2 }, rules: [{ conditions: [{ [q2]: "aws.partition", [r2]: [{ [s2]: "Region" }], assign: a2 }], type: b2, rules: [{ conditions: [{ [q2]: "isSet", [r2]: m2 }, { [q2]: "parseURL", [r2]: m2, assign: "url" }], type: b2, rules: [{ conditions: n2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c2 }, { type: b2, rules: [{ conditions: o2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c2 }, { endpoint: { url: g2, properties: j2, headers: j2 }, type: d2 }] }] }, { conditions: [h2, i2], type: b2, rules: [{ conditions: [k2, l2], type: b2, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c2 }] }, { conditions: n2, type: b2, rules: [{ conditions: [k2], type: b2, rules: [{ type: b2, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c2 }] }, { conditions: o2, type: b2, rules: [{ conditions: [l2], type: b2, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c2 }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j2, headers: j2 }, type: d2 }] }] };
var ruleSet2 = _data2;
var defaultEndpointResolver2 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint(ruleSet2, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");
var getRuntimeConfig3 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver2,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSO OIDC",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");
var getRuntimeConfig22 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig3(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default4.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig2");
var SSOOIDCClient = class extends Client {
  static {
    __name(this, "SSOOIDCClient");
  }
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig22(configuration || {});
    const _config_1 = resolveClientEndpointParameters4(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveUserAgentConfig(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};
var SSOOIDCServiceException = class _SSOOIDCServiceException extends ServiceException {
  static {
    __name(this, "_SSOOIDCServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
  }
};
var AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
  static {
    __name(this, "_AccessDeniedException");
  }
  constructor(opts) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccessDeniedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _AccessDeniedException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
  static {
    __name(this, "_AuthorizationPendingException");
  }
  constructor(opts) {
    super({
      name: "AuthorizationPendingException",
      $fault: "client",
      ...opts
    });
    this.name = "AuthorizationPendingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var ExpiredTokenException2 = class _ExpiredTokenException extends SSOOIDCServiceException {
  static {
    __name(this, "_ExpiredTokenException");
  }
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
  static {
    __name(this, "_InternalServerException");
  }
  constructor(opts) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerException";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalServerException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
  static {
    __name(this, "_InvalidClientException");
  }
  constructor(opts) {
    super({
      name: "InvalidClientException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidClientException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
  static {
    __name(this, "_InvalidGrantException");
  }
  constructor(opts) {
    super({
      name: "InvalidGrantException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidGrantException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidGrantException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidRequestException2 = class _InvalidRequestException extends SSOOIDCServiceException {
  static {
    __name(this, "_InvalidRequestException");
  }
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidRequestException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
  static {
    __name(this, "_InvalidScopeException");
  }
  constructor(opts) {
    super({
      name: "InvalidScopeException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidScopeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidScopeException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
  static {
    __name(this, "_SlowDownException");
  }
  constructor(opts) {
    super({
      name: "SlowDownException",
      $fault: "client",
      ...opts
    });
    this.name = "SlowDownException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _SlowDownException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
  static {
    __name(this, "_UnauthorizedClientException");
  }
  constructor(opts) {
    super({
      name: "UnauthorizedClientException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
  static {
    __name(this, "_UnsupportedGrantTypeException");
  }
  constructor(opts) {
    super({
      name: "UnsupportedGrantTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedGrantTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidClientMetadataException = class _InvalidClientMetadataException extends SSOOIDCServiceException {
  static {
    __name(this, "_InvalidClientMetadataException");
  }
  constructor(opts) {
    super({
      name: "InvalidClientMetadataException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidClientMetadataException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidClientMetadataException.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var se_CreateTokenCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath = `${basePath14?.endsWith("/") ? basePath14.slice(0, -1) : basePath14 || ""}/token`;
  let body;
  body = JSON.stringify(take(input, {
    clientId: [],
    clientSecret: [],
    code: [],
    deviceCode: [],
    grantType: [],
    redirectUri: [],
    refreshToken: [],
    scope: (_) => _json(_)
  }));
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
}, "se_CreateTokenCommand");
var se_RegisterClientCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath = `${basePath14?.endsWith("/") ? basePath14.slice(0, -1) : basePath14 || ""}/client/register`;
  let body;
  body = JSON.stringify(take(input, {
    clientName: [],
    clientType: [],
    scopes: (_) => _json(_)
  }));
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
}, "se_RegisterClientCommand");
var se_StartDeviceAuthorizationCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath = `${basePath14?.endsWith("/") ? basePath14.slice(0, -1) : basePath14 || ""}/device_authorization`;
  let body;
  body = JSON.stringify(take(input, {
    clientId: [],
    clientSecret: [],
    startUrl: []
  }));
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
}, "se_StartDeviceAuthorizationCommand");
var de_CreateTokenCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CreateTokenCommandError(output, context8);
  }
  const contents = map({
    $metadata: deserializeMetadata4(output)
  });
  const data = expectNonNull(expectObject(await parseBody3(output.body, context8)), "body");
  const doc = take(data, {
    accessToken: expectString,
    expiresIn: expectInt32,
    idToken: expectString,
    refreshToken: expectString,
    tokenType: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, "de_CreateTokenCommand");
var de_CreateTokenCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody3(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ssooidc#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context8);
    case "AuthorizationPendingException":
    case "com.amazonaws.ssooidc#AuthorizationPendingException":
      throw await de_AuthorizationPendingExceptionRes(parsedOutput, context8);
    case "ExpiredTokenException":
    case "com.amazonaws.ssooidc#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes2(parsedOutput, context8);
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await de_InternalServerExceptionRes(parsedOutput, context8);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await de_InvalidClientExceptionRes(parsedOutput, context8);
    case "InvalidGrantException":
    case "com.amazonaws.ssooidc#InvalidGrantException":
      throw await de_InvalidGrantExceptionRes(parsedOutput, context8);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes2(parsedOutput, context8);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await de_InvalidScopeExceptionRes(parsedOutput, context8);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await de_SlowDownExceptionRes(parsedOutput, context8);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await de_UnauthorizedClientExceptionRes(parsedOutput, context8);
    case "UnsupportedGrantTypeException":
    case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
      throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_CreateTokenCommandError");
var de_RegisterClientCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_RegisterClientCommandError(output, context8);
  }
  const contents = map({
    $metadata: deserializeMetadata4(output)
  });
  const data = expectNonNull(expectObject(await parseBody3(output.body, context8)), "body");
  const doc = take(data, {
    authorizationEndpoint: expectString,
    clientId: expectString,
    clientIdIssuedAt: expectLong,
    clientSecret: expectString,
    clientSecretExpiresAt: expectLong,
    tokenEndpoint: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, "de_RegisterClientCommand");
var de_RegisterClientCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody3(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await de_InternalServerExceptionRes(parsedOutput, context8);
    case "InvalidClientMetadataException":
    case "com.amazonaws.ssooidc#InvalidClientMetadataException":
      throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context8);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes2(parsedOutput, context8);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await de_InvalidScopeExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_RegisterClientCommandError");
var de_StartDeviceAuthorizationCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_StartDeviceAuthorizationCommandError(output, context8);
  }
  const contents = map({
    $metadata: deserializeMetadata4(output)
  });
  const data = expectNonNull(expectObject(await parseBody3(output.body, context8)), "body");
  const doc = take(data, {
    deviceCode: expectString,
    expiresIn: expectInt32,
    interval: expectInt32,
    userCode: expectString,
    verificationUri: expectString,
    verificationUriComplete: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, "de_StartDeviceAuthorizationCommand");
var de_StartDeviceAuthorizationCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody3(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await de_InternalServerExceptionRes(parsedOutput, context8);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await de_InvalidClientExceptionRes(parsedOutput, context8);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes2(parsedOutput, context8);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await de_SlowDownExceptionRes(parsedOutput, context8);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await de_UnauthorizedClientExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_StartDeviceAuthorizationCommandError");
var throwDefaultError4 = withBaseException(SSOOIDCServiceException);
var de_AccessDeniedExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new AccessDeniedException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_AccessDeniedExceptionRes");
var de_AuthorizationPendingExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new AuthorizationPendingException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_AuthorizationPendingExceptionRes");
var de_ExpiredTokenExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new ExpiredTokenException2({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_ExpiredTokenExceptionRes");
var de_InternalServerExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InternalServerException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InternalServerExceptionRes");
var de_InvalidClientExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidClientException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidClientExceptionRes");
var de_InvalidClientMetadataExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidClientMetadataException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidClientMetadataExceptionRes");
var de_InvalidGrantExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidGrantException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidGrantExceptionRes");
var de_InvalidRequestExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException2({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidRequestExceptionRes");
var de_InvalidScopeExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidScopeException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidScopeExceptionRes");
var de_SlowDownExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new SlowDownException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_SlowDownExceptionRes");
var de_UnauthorizedClientExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedClientException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_UnauthorizedClientExceptionRes");
var de_UnsupportedGrantTypeExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnsupportedGrantTypeException({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_UnsupportedGrantTypeExceptionRes");
var deserializeMetadata4 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString3 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var parseBody3 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString3(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
}), "parseBody");
var parseErrorBody3 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody3(errorBody, context8);
  value.message = value.message ?? value.Message;
  return value;
}, "parseErrorBody");
var loadRestJsonErrorCode2 = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k22) => k22.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");
var CreateTokenCommand = class _CreateTokenCommand extends Command {
  static {
    __name(this, "_CreateTokenCommand");
  }
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _CreateTokenCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "CreateTokenCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_CreateTokenCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_CreateTokenCommand(output, context8);
  }
};
var RegisterClientCommand = class _RegisterClientCommand extends Command {
  static {
    __name(this, "_RegisterClientCommand");
  }
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _RegisterClientCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "RegisterClientCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_RegisterClientCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_RegisterClientCommand(output, context8);
  }
};
var StartDeviceAuthorizationCommand = class _StartDeviceAuthorizationCommand extends Command {
  static {
    __name(this, "_StartDeviceAuthorizationCommand");
  }
  constructor(input) {
    super();
    this.input = input;
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _StartDeviceAuthorizationCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "StartDeviceAuthorizationCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_StartDeviceAuthorizationCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_StartDeviceAuthorizationCommand(output, context8);
  }
};
var commands = {
  CreateTokenCommand,
  RegisterClientCommand,
  StartDeviceAuthorizationCommand
};
var SSOOIDC = class extends SSOOIDCClient {
  static {
    __name(this, "SSOOIDC");
  }
};
createAggregatedClient(commands, SSOOIDC);

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS = 5 * 60 * 1e3;
var REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash = {};
var getSsoOidcClient = /* @__PURE__ */ __name((ssoRegion) => {
  if (ssoOidcClientsHash[ssoRegion]) {
    return ssoOidcClientsHash[ssoRegion];
  }
  const ssoOidcClient = new SSOOIDCClient({ region: ssoRegion });
  ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
  return ssoOidcClient;
}, "getSsoOidcClient");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken = /* @__PURE__ */ __name((ssoToken, ssoRegion) => {
  const ssoOidcClient = getSsoOidcClient(ssoRegion);
  return ssoOidcClient.send(new CreateTokenCommand({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
}, "getNewSsoOidcToken");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry = /* @__PURE__ */ __name((token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
  }
}, "validateTokenExpiry");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey = /* @__PURE__ */ __name((key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
  }
}, "validateTokenKey");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
import { promises as fsPromises3 } from "fs";
var { writeFile } = fsPromises3;
var writeSSOTokenToFile = /* @__PURE__ */ __name((id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile(tokenFilepath, tokenString);
}, "writeSSOTokenToFile");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime = /* @__PURE__ */ new Date(0);
var fromSso = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const profiles = await parseKnownFiles(init2);
  const profileName = getProfileName(init2);
  const profile = profiles[profileName];
  if (!profile) {
    throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await loadSsoSessionData(init2);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile(ssoSessionName);
  } catch (e10) {
    throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
  }
  validateTokenKey("accessToken", ssoToken.accessToken);
  validateTokenKey("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1e3) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
  validateTokenKey("clientId", ssoToken.clientId, true);
  validateTokenKey("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion);
    validateTokenKey("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
    try {
      await writeSSOTokenToFile(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
}, "fromSso");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var EXPIRE_WINDOW_MS2 = 15 * 60 * 1e3;
var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
var resolveSSOCredentials = /* @__PURE__ */ __name(async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso({ profile })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e10) {
      throw new CredentialsProviderError(e10.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
  } else {
    try {
      token = await getSSOTokenFromFile(ssoStartUrl);
    } catch (e10) {
      throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS2) {
    throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  const { accessToken } = token;
  const sso = ssoClient || new SSOClient({ region: ssoRegion });
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e10) {
    throw CredentialsProviderError.from(e10, SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
  }
  return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
}, "resolveSSOCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile = /* @__PURE__ */ __name((profile) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
  }
  return profile;
}, "validateSsoProfile");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init2;
  const profileName = getProfileName(init2);
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles(init2);
    const profile = profiles[profileName];
    if (!profile) {
      throw new CredentialsProviderError(`Profile ${profileName} was not found.`);
    }
    if (!isSsoProfile(profile)) {
      throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
    }
    if (profile?.sso_session) {
      const ssoSessions = await loadSsoSessionData(init2);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile);
    return resolveSSOCredentials({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
  } else {
    return resolveSSOCredentials({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      profile: profileName
    });
  }
}, "fromSSO");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var resolveSsoCredentials = /* @__PURE__ */ __name((data) => {
  const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = validateSsoProfile(data);
  return fromSSO({
    ssoStartUrl: sso_start_url,
    ssoAccountId: sso_account_id,
    ssoSession: sso_session,
    ssoRegion: sso_region,
    ssoRoleName: sso_role_name
  })();
}, "resolveSsoCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var isStaticCredsProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1, "isStaticCredsProfile");
var resolveStaticCredentials = /* @__PURE__ */ __name((profile) => Promise.resolve({
  accessKeyId: profile.aws_access_key_id,
  secretAccessKey: profile.aws_secret_access_key,
  sessionToken: profile.aws_session_token
}), "resolveStaticCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
import { readFileSync } from "fs";

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken = /* @__PURE__ */ __name((init2) => () => {
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init2;
  if (!roleAssumerWithWebIdentity) {
    throw new CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity, but no role assumption callback was provided.`, false);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
}, "fromWebToken");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
var ENV_ROLE_ARN = "AWS_ROLE_ARN";
var ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
var fromTokenFile = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const webIdentityTokenFile = init2?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
  const roleArn = init2?.roleArn ?? process.env[ENV_ROLE_ARN];
  const roleSessionName = init2?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
  if (!webIdentityTokenFile || !roleArn) {
    throw new CredentialsProviderError("Web identity configuration not specified");
  }
  return fromWebToken({
    ...init2,
    webIdentityToken: readFileSync(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
}, "fromTokenFile");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var isWebIdentityProfile = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1, "isWebIdentityProfile");
var resolveWebIdentityCredentials = /* @__PURE__ */ __name(async (profile, options) => fromTokenFile({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
})(), "resolveWebIdentityCredentials");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData = /* @__PURE__ */ __name(async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data);
  }
  if (isAssumeRoleProfile(data)) {
    return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data);
  }
  if (isWebIdentityProfile(data)) {
    return resolveWebIdentityCredentials(data, options);
  }
  if (isProcessProfile(data)) {
    return resolveProcessCredentials2(options, profileName);
  }
  if (isSsoProfile(data)) {
    return resolveSsoCredentials(data);
  }
  throw new CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
}, "resolveProfileData");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const profiles = await parseKnownFiles(init2);
  return resolveProfileData(getProfileName(init2), profiles, init2);
}, "fromIni");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED";
var remoteProvider = /* @__PURE__ */ __name((init2) => {
  if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
    return fromContainerMetadata(init2);
  }
  if (process.env[ENV_IMDS_DISABLED2]) {
    return async () => {
      throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled");
    };
  }
  return fromInstanceMetadata(init2);
}, "remoteProvider");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var defaultProvider = /* @__PURE__ */ __name((init2 = {}) => memoize(chain(...init2.profile || process.env[ENV_PROFILE] ? [] : [fromEnv()], fromSSO(init2), fromIni(init2), fromProcess(init2), fromTokenFile(init2), remoteProvider(init2), async () => {
  throw new CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials) => credentials.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5, (credentials) => credentials.expiration !== void 0), "defaultProvider");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var F = "required";
var G = "type";
var H = "fn";
var I = "argv";
var J = "ref";
var a3 = false;
var b3 = true;
var c3 = "booleanEquals";
var d3 = "tree";
var e3 = "stringEquals";
var f3 = "sigv4";
var g3 = "sts";
var h3 = "us-east-1";
var i3 = "endpoint";
var j3 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
var k3 = "error";
var l3 = "getAttr";
var m3 = { [F]: false, [G]: "String" };
var n3 = { [F]: true, "default": false, [G]: "Boolean" };
var o3 = { [J]: "Endpoint" };
var p3 = { [H]: "isSet", [I]: [{ [J]: "Region" }] };
var q3 = { [J]: "Region" };
var r3 = { [H]: "aws.partition", [I]: [q3], "assign": "PartitionResult" };
var s3 = { [J]: "UseFIPS" };
var t = { [J]: "UseDualStack" };
var u = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": f3, "signingName": g3, "signingRegion": h3 }] }, "headers": {} };
var v = {};
var w = { "conditions": [{ [H]: e3, [I]: [q3, "aws-global"] }], [i3]: u, [G]: i3 };
var x = { [H]: c3, [I]: [s3, true] };
var y = { [H]: c3, [I]: [t, true] };
var z = { [H]: c3, [I]: [true, { [H]: l3, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] }] };
var A = { [J]: "PartitionResult" };
var B = { [H]: c3, [I]: [true, { [H]: l3, [I]: [A, "supportsDualStack"] }] };
var C = [{ [H]: "isSet", [I]: [o3] }];
var D = [x];
var E = [y];
var _data3 = { version: "1.0", parameters: { Region: m3, UseDualStack: n3, UseFIPS: n3, Endpoint: m3, UseGlobalEndpoint: n3 }, rules: [{ conditions: [{ [H]: c3, [I]: [{ [J]: "UseGlobalEndpoint" }, b3] }, { [H]: "not", [I]: C }, p3, r3, { [H]: c3, [I]: [s3, a3] }, { [H]: c3, [I]: [t, a3] }], [G]: d3, rules: [{ conditions: [{ [H]: e3, [I]: [q3, "ap-northeast-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "ap-south-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "ap-southeast-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "ap-southeast-2"] }], endpoint: u, [G]: i3 }, w, { conditions: [{ [H]: e3, [I]: [q3, "ca-central-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "eu-central-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "eu-north-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "eu-west-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "eu-west-2"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "eu-west-3"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "sa-east-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, h3] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "us-east-2"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "us-west-1"] }], endpoint: u, [G]: i3 }, { conditions: [{ [H]: e3, [I]: [q3, "us-west-2"] }], endpoint: u, [G]: i3 }, { endpoint: { url: j3, properties: { authSchemes: [{ name: f3, signingName: g3, signingRegion: "{Region}" }] }, headers: v }, [G]: i3 }] }, { conditions: C, [G]: d3, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k3 }, { [G]: d3, rules: [{ conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k3 }, { endpoint: { url: o3, properties: v, headers: v }, [G]: i3 }] }] }, { [G]: d3, rules: [{ conditions: [p3], [G]: d3, rules: [{ conditions: [r3], [G]: d3, rules: [{ conditions: [x, y], [G]: d3, rules: [{ conditions: [z, B], [G]: d3, rules: [{ [G]: d3, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: i3 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k3 }] }, { conditions: D, [G]: d3, rules: [{ conditions: [z], [G]: d3, rules: [{ [G]: d3, rules: [{ conditions: [{ [H]: e3, [I]: ["aws-us-gov", { [H]: l3, [I]: [A, "name"] }] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v }, [G]: i3 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v, headers: v }, [G]: i3 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k3 }] }, { conditions: E, [G]: d3, rules: [{ conditions: [B], [G]: d3, rules: [{ [G]: d3, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: i3 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k3 }] }, { [G]: d3, rules: [w, { endpoint: { url: j3, properties: v, headers: v }, [G]: i3 }] }] }] }, { error: "Invalid Configuration: Missing Region", [G]: k3 }] }] };
var ruleSet3 = _data3;

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver3 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint(ruleSet3, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var getRuntimeConfig4 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2011-06-15",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver3,
  extensions: config?.extensions ?? [],
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "STS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var getRuntimeConfig5 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig4(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default2.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/runtimeExtensions.js
var asPartial2 = /* @__PURE__ */ __name((t6) => t6, "asPartial");
var resolveRuntimeExtensions2 = /* @__PURE__ */ __name((runtimeConfig, extensions) => {
  const clientConfiguration = {
    ...asPartial2(getDefaultClientConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configureClient(clientConfiguration));
  return {
    ...runtimeConfig,
    ...resolveDefaultRuntimeConfig(clientConfiguration)
  };
}, "resolveRuntimeExtensions");

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var STSClient = class _STSClient extends Client {
  static {
    __name(this, "STSClient");
  }
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig5(configuration || {});
    const _config_1 = resolveClientEndpointParameters2(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveStsAuthConfig(_config_5, { stsClientCtor: _STSClient });
    const _config_7 = resolveUserAgentConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions2(_config_7, configuration?.extensions || []);
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sqs/node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor = /* @__PURE__ */ __name((baseCtor, customizations) => {
  if (!customizations)
    return baseCtor;
  else
    return class CustomizableSTSClient extends baseCtor {
      static {
        __name(this, "CustomizableSTSClient");
      }
      constructor(config) {
        super(config);
        for (const customization of customizations) {
          this.middlewareStack.use(customization);
        }
      }
    };
}, "getCustomizableStsClientCtor");
var getDefaultRoleAssumer2 = /* @__PURE__ */ __name((stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins)), "getDefaultRoleAssumer");
var getDefaultRoleAssumerWithWebIdentity2 = /* @__PURE__ */ __name((stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins)), "getDefaultRoleAssumerWithWebIdentity");
var decorateDefaultCredentialProvider2 = /* @__PURE__ */ __name((provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer2(input),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
  ...input
}), "decorateDefaultCredentialProvider");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/ruleset.js
var s4 = "required";
var t2 = "fn";
var u2 = "argv";
var v2 = "ref";
var a4 = "isSet";
var b4 = "tree";
var c4 = "error";
var d4 = "endpoint";
var e4 = "PartitionResult";
var f4 = "getAttr";
var g4 = { [s4]: false, "type": "String" };
var h4 = { [s4]: true, "default": false, "type": "Boolean" };
var i4 = { [v2]: "Endpoint" };
var j4 = { [t2]: "booleanEquals", [u2]: [{ [v2]: "UseFIPS" }, true] };
var k4 = { [t2]: "booleanEquals", [u2]: [{ [v2]: "UseDualStack" }, true] };
var l4 = {};
var m4 = { [t2]: "booleanEquals", [u2]: [true, { [t2]: f4, [u2]: [{ [v2]: e4 }, "supportsFIPS"] }] };
var n4 = { [v2]: e4 };
var o4 = { [t2]: "booleanEquals", [u2]: [true, { [t2]: f4, [u2]: [n4, "supportsDualStack"] }] };
var p4 = [j4];
var q4 = [k4];
var r4 = [{ [v2]: "Region" }];
var _data4 = { version: "1.0", parameters: { Region: g4, UseDualStack: h4, UseFIPS: h4, Endpoint: g4 }, rules: [{ conditions: [{ [t2]: a4, [u2]: [i4] }], type: b4, rules: [{ conditions: p4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c4 }, { type: b4, rules: [{ conditions: q4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c4 }, { endpoint: { url: i4, properties: l4, headers: l4 }, type: d4 }] }] }, { type: b4, rules: [{ conditions: [{ [t2]: a4, [u2]: r4 }], type: b4, rules: [{ conditions: [{ [t2]: "aws.partition", [u2]: r4, assign: e4 }], type: b4, rules: [{ conditions: [j4, k4], type: b4, rules: [{ conditions: [m4, o4], type: b4, rules: [{ type: b4, rules: [{ endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: l4, headers: l4 }, type: d4 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c4 }] }, { conditions: p4, type: b4, rules: [{ conditions: [m4], type: b4, rules: [{ type: b4, rules: [{ conditions: [{ [t2]: "stringEquals", [u2]: ["aws-us-gov", { [t2]: f4, [u2]: [n4, "name"] }] }], endpoint: { url: "https://sqs.{Region}.amazonaws.com", properties: l4, headers: l4 }, type: d4 }, { endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: l4, headers: l4 }, type: d4 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c4 }] }, { conditions: q4, type: b4, rules: [{ conditions: [o4], type: b4, rules: [{ type: b4, rules: [{ endpoint: { url: "https://sqs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: l4, headers: l4 }, type: d4 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c4 }] }, { type: b4, rules: [{ endpoint: { url: "https://sqs.{Region}.{PartitionResult#dnsSuffix}", properties: l4, headers: l4 }, type: d4 }] }] }] }, { error: "Invalid Configuration: Missing Region", type: c4 }] }] };
var ruleSet4 = _data4;

// ../../node_modules/@aws-sdk/client-sqs/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver4 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint(ruleSet4, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.shared.js
var getRuntimeConfig6 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2012-11-05",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver4,
  extensions: config?.extensions ?? [],
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SQS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeConfig.js
var getRuntimeConfig7 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig6(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider2(defaultProvider),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    md5: config?.md5 ?? Hash.bind(null, "md5"),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/runtimeExtensions.js
var asPartial3 = /* @__PURE__ */ __name((t6) => t6, "asPartial");
var resolveRuntimeExtensions3 = /* @__PURE__ */ __name((runtimeConfig, extensions) => {
  const clientConfiguration = {
    ...asPartial3(getDefaultClientConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configureClient(clientConfiguration));
  return {
    ...runtimeConfig,
    ...resolveDefaultRuntimeConfig(clientConfiguration)
  };
}, "resolveRuntimeExtensions");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/SQSClient.js
var SQSClient = class extends Client {
  static {
    __name(this, "SQSClient");
  }
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig7(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveUserAgentConfig(_config_6);
    const _config_8 = resolveRuntimeExtensions3(_config_7, configuration?.extensions || []);
    super(_config_8);
    this.config = _config_8;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/protocols/Aws_query.js
var import_fast_xml_parser2 = __toESM(require_fxp());

// ../../node_modules/@aws-sdk/client-sqs/dist-es/models/SQSServiceException.js
var SQSServiceException = class _SQSServiceException extends ServiceException {
  static {
    __name(this, "SQSServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SQSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/models/models_0.js
var UnsupportedOperation = class _UnsupportedOperation extends SQSServiceException {
  static {
    __name(this, "UnsupportedOperation");
  }
  constructor(opts) {
    super({
      name: "UnsupportedOperation",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedOperation";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnsupportedOperation.prototype);
  }
};
var BatchEntryIdsNotDistinct = class _BatchEntryIdsNotDistinct extends SQSServiceException {
  static {
    __name(this, "BatchEntryIdsNotDistinct");
  }
  constructor(opts) {
    super({
      name: "BatchEntryIdsNotDistinct",
      $fault: "client",
      ...opts
    });
    this.name = "BatchEntryIdsNotDistinct";
    this.$fault = "client";
    Object.setPrototypeOf(this, _BatchEntryIdsNotDistinct.prototype);
  }
};
var EmptyBatchRequest = class _EmptyBatchRequest extends SQSServiceException {
  static {
    __name(this, "EmptyBatchRequest");
  }
  constructor(opts) {
    super({
      name: "EmptyBatchRequest",
      $fault: "client",
      ...opts
    });
    this.name = "EmptyBatchRequest";
    this.$fault = "client";
    Object.setPrototypeOf(this, _EmptyBatchRequest.prototype);
  }
};
var InvalidBatchEntryId = class _InvalidBatchEntryId extends SQSServiceException {
  static {
    __name(this, "InvalidBatchEntryId");
  }
  constructor(opts) {
    super({
      name: "InvalidBatchEntryId",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidBatchEntryId";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidBatchEntryId.prototype);
  }
};
var TooManyEntriesInBatchRequest = class _TooManyEntriesInBatchRequest extends SQSServiceException {
  static {
    __name(this, "TooManyEntriesInBatchRequest");
  }
  constructor(opts) {
    super({
      name: "TooManyEntriesInBatchRequest",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyEntriesInBatchRequest";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TooManyEntriesInBatchRequest.prototype);
  }
};
var InvalidMessageContents = class _InvalidMessageContents extends SQSServiceException {
  static {
    __name(this, "InvalidMessageContents");
  }
  constructor(opts) {
    super({
      name: "InvalidMessageContents",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidMessageContents";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidMessageContents.prototype);
  }
};
var BatchRequestTooLong = class _BatchRequestTooLong extends SQSServiceException {
  static {
    __name(this, "BatchRequestTooLong");
  }
  constructor(opts) {
    super({
      name: "BatchRequestTooLong",
      $fault: "client",
      ...opts
    });
    this.name = "BatchRequestTooLong";
    this.$fault = "client";
    Object.setPrototypeOf(this, _BatchRequestTooLong.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/protocols/Aws_query.js
var se_SendMessageCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = SHARED_HEADERS2;
  let body;
  body = buildFormUrlencodedString2({
    ...se_SendMessageRequest(input, context8),
    Action: "SendMessage",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest2(context8, headers, "/", void 0, body);
}, "se_SendMessageCommand");
var se_SendMessageBatchCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = SHARED_HEADERS2;
  let body;
  body = buildFormUrlencodedString2({
    ...se_SendMessageBatchRequest(input, context8),
    Action: "SendMessageBatch",
    Version: "2012-11-05"
  });
  return buildHttpRpcRequest2(context8, headers, "/", void 0, body);
}, "se_SendMessageBatchCommand");
var de_SendMessageCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_SendMessageCommandError(output, context8);
  }
  const data = await parseBody4(output.body, context8);
  let contents = {};
  contents = de_SendMessageResult(data.SendMessageResult, context8);
  const response = {
    $metadata: deserializeMetadata5(output),
    ...contents
  };
  return response;
}, "de_SendMessageCommand");
var de_SendMessageCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody4(output.body, context8)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.UnsupportedOperation":
    case "com.amazonaws.sqs#UnsupportedOperation":
      throw await de_UnsupportedOperationRes(parsedOutput, context8);
    case "InvalidMessageContents":
    case "com.amazonaws.sqs#InvalidMessageContents":
      throw await de_InvalidMessageContentsRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError5({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, "de_SendMessageCommandError");
var de_SendMessageBatchCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_SendMessageBatchCommandError(output, context8);
  }
  const data = await parseBody4(output.body, context8);
  let contents = {};
  contents = de_SendMessageBatchResult(data.SendMessageBatchResult, context8);
  const response = {
    $metadata: deserializeMetadata5(output),
    ...contents
  };
  return response;
}, "de_SendMessageBatchCommand");
var de_SendMessageBatchCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody4(output.body, context8)
  };
  const errorCode = loadQueryErrorCode2(output, parsedOutput.body);
  switch (errorCode) {
    case "AWS.SimpleQueueService.BatchEntryIdsNotDistinct":
    case "com.amazonaws.sqs#BatchEntryIdsNotDistinct":
      throw await de_BatchEntryIdsNotDistinctRes(parsedOutput, context8);
    case "AWS.SimpleQueueService.BatchRequestTooLong":
    case "com.amazonaws.sqs#BatchRequestTooLong":
      throw await de_BatchRequestTooLongRes(parsedOutput, context8);
    case "AWS.SimpleQueueService.EmptyBatchRequest":
    case "com.amazonaws.sqs#EmptyBatchRequest":
      throw await de_EmptyBatchRequestRes(parsedOutput, context8);
    case "AWS.SimpleQueueService.InvalidBatchEntryId":
    case "com.amazonaws.sqs#InvalidBatchEntryId":
      throw await de_InvalidBatchEntryIdRes(parsedOutput, context8);
    case "AWS.SimpleQueueService.TooManyEntriesInBatchRequest":
    case "com.amazonaws.sqs#TooManyEntriesInBatchRequest":
      throw await de_TooManyEntriesInBatchRequestRes(parsedOutput, context8);
    case "AWS.SimpleQueueService.UnsupportedOperation":
    case "com.amazonaws.sqs#UnsupportedOperation":
      throw await de_UnsupportedOperationRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError5({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, "de_SendMessageBatchCommandError");
var de_BatchEntryIdsNotDistinctRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_BatchEntryIdsNotDistinct(body.Error, context8);
  const exception = new BatchEntryIdsNotDistinct({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_BatchEntryIdsNotDistinctRes");
var de_BatchRequestTooLongRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_BatchRequestTooLong(body.Error, context8);
  const exception = new BatchRequestTooLong({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_BatchRequestTooLongRes");
var de_EmptyBatchRequestRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_EmptyBatchRequest(body.Error, context8);
  const exception = new EmptyBatchRequest({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_EmptyBatchRequestRes");
var de_InvalidBatchEntryIdRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidBatchEntryId(body.Error, context8);
  const exception = new InvalidBatchEntryId({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InvalidBatchEntryIdRes");
var de_InvalidMessageContentsRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidMessageContents(body.Error, context8);
  const exception = new InvalidMessageContents({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InvalidMessageContentsRes");
var de_TooManyEntriesInBatchRequestRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_TooManyEntriesInBatchRequest(body.Error, context8);
  const exception = new TooManyEntriesInBatchRequest({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_TooManyEntriesInBatchRequestRes");
var de_UnsupportedOperationRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_UnsupportedOperation(body.Error, context8);
  const exception = new UnsupportedOperation({
    $metadata: deserializeMetadata5(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_UnsupportedOperationRes");
var se_BinaryList = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`BinaryListValue.${counter}`] = context8.base64Encoder(entry);
    counter++;
  }
  return entries;
}, "se_BinaryList");
var se_MessageAttributeValue = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.StringValue != null) {
    entries["StringValue"] = input.StringValue;
  }
  if (input.BinaryValue != null) {
    entries["BinaryValue"] = context8.base64Encoder(input.BinaryValue);
  }
  if (input.StringListValues != null) {
    const memberEntries = se_StringList(input.StringListValues, context8);
    if (input.StringListValues?.length === 0) {
      entries.StringListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StringListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BinaryListValues != null) {
    const memberEntries = se_BinaryList(input.BinaryListValues, context8);
    if (input.BinaryListValues?.length === 0) {
      entries.BinaryListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BinaryListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DataType != null) {
    entries["DataType"] = input.DataType;
  }
  return entries;
}, "se_MessageAttributeValue");
var se_MessageBodyAttributeMap = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    const memberEntries = se_MessageAttributeValue(input[key], context8);
    Object.entries(memberEntries).forEach(([key2, value]) => {
      entries[`entry.${counter}.Value.${key2}`] = value;
    });
    counter++;
  });
  return entries;
}, "se_MessageBodyAttributeMap");
var se_MessageBodySystemAttributeMap = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  Object.keys(input).filter((key) => input[key] != null).forEach((key) => {
    entries[`entry.${counter}.Name`] = key;
    const memberEntries = se_MessageSystemAttributeValue(input[key], context8);
    Object.entries(memberEntries).forEach(([key2, value]) => {
      entries[`entry.${counter}.Value.${key2}`] = value;
    });
    counter++;
  });
  return entries;
}, "se_MessageBodySystemAttributeMap");
var se_MessageSystemAttributeValue = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.StringValue != null) {
    entries["StringValue"] = input.StringValue;
  }
  if (input.BinaryValue != null) {
    entries["BinaryValue"] = context8.base64Encoder(input.BinaryValue);
  }
  if (input.StringListValues != null) {
    const memberEntries = se_StringList(input.StringListValues, context8);
    if (input.StringListValues?.length === 0) {
      entries.StringListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `StringListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BinaryListValues != null) {
    const memberEntries = se_BinaryList(input.BinaryListValues, context8);
    if (input.BinaryListValues?.length === 0) {
      entries.BinaryListValue = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BinaryListValue.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DataType != null) {
    entries["DataType"] = input.DataType;
  }
  return entries;
}, "se_MessageSystemAttributeValue");
var se_SendMessageBatchRequest = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.Entries != null) {
    const memberEntries = se_SendMessageBatchRequestEntryList(input.Entries, context8);
    if (input.Entries?.length === 0) {
      entries.SendMessageBatchRequestEntry = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SendMessageBatchRequestEntry.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
}, "se_SendMessageBatchRequest");
var se_SendMessageBatchRequestEntry = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.Id != null) {
    entries["Id"] = input.Id;
  }
  if (input.MessageBody != null) {
    entries["MessageBody"] = input.MessageBody;
  }
  if (input.DelaySeconds != null) {
    entries["DelaySeconds"] = input.DelaySeconds;
  }
  if (input.MessageAttributes != null) {
    const memberEntries = se_MessageBodyAttributeMap(input.MessageAttributes, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageSystemAttributes != null) {
    const memberEntries = se_MessageBodySystemAttributeMap(input.MessageSystemAttributes, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageSystemAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageDeduplicationId != null) {
    entries["MessageDeduplicationId"] = input.MessageDeduplicationId;
  }
  if (input.MessageGroupId != null) {
    entries["MessageGroupId"] = input.MessageGroupId;
  }
  return entries;
}, "se_SendMessageBatchRequestEntry");
var se_SendMessageBatchRequestEntryList = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_SendMessageBatchRequestEntry(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_SendMessageBatchRequestEntryList");
var se_SendMessageRequest = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.QueueUrl != null) {
    entries["QueueUrl"] = input.QueueUrl;
  }
  if (input.MessageBody != null) {
    entries["MessageBody"] = input.MessageBody;
  }
  if (input.DelaySeconds != null) {
    entries["DelaySeconds"] = input.DelaySeconds;
  }
  if (input.MessageAttributes != null) {
    const memberEntries = se_MessageBodyAttributeMap(input.MessageAttributes, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageSystemAttributes != null) {
    const memberEntries = se_MessageBodySystemAttributeMap(input.MessageSystemAttributes, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MessageSystemAttribute.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MessageDeduplicationId != null) {
    entries["MessageDeduplicationId"] = input.MessageDeduplicationId;
  }
  if (input.MessageGroupId != null) {
    entries["MessageGroupId"] = input.MessageGroupId;
  }
  return entries;
}, "se_SendMessageRequest");
var se_StringList = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`StringListValue.${counter}`] = entry;
    counter++;
  }
  return entries;
}, "se_StringList");
var de_BatchEntryIdsNotDistinct = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_BatchEntryIdsNotDistinct");
var de_BatchRequestTooLong = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_BatchRequestTooLong");
var de_BatchResultErrorEntry = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["Id"] !== void 0) {
    contents.Id = expectString(output["Id"]);
  }
  if (output["SenderFault"] !== void 0) {
    contents.SenderFault = parseBoolean(output["SenderFault"]);
  }
  if (output["Code"] !== void 0) {
    contents.Code = expectString(output["Code"]);
  }
  if (output["Message"] !== void 0) {
    contents.Message = expectString(output["Message"]);
  }
  return contents;
}, "de_BatchResultErrorEntry");
var de_BatchResultErrorEntryList = /* @__PURE__ */ __name((output, context8) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_BatchResultErrorEntry(entry, context8);
  });
}, "de_BatchResultErrorEntryList");
var de_EmptyBatchRequest = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_EmptyBatchRequest");
var de_InvalidBatchEntryId = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_InvalidBatchEntryId");
var de_InvalidMessageContents = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_InvalidMessageContents");
var de_SendMessageBatchResult = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output.SendMessageBatchResultEntry === "") {
    contents.Successful = [];
  } else if (output["SendMessageBatchResultEntry"] !== void 0) {
    contents.Successful = de_SendMessageBatchResultEntryList(getArrayIfSingleItem(output["SendMessageBatchResultEntry"]), context8);
  }
  if (output.BatchResultErrorEntry === "") {
    contents.Failed = [];
  } else if (output["BatchResultErrorEntry"] !== void 0) {
    contents.Failed = de_BatchResultErrorEntryList(getArrayIfSingleItem(output["BatchResultErrorEntry"]), context8);
  }
  return contents;
}, "de_SendMessageBatchResult");
var de_SendMessageBatchResultEntry = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["Id"] !== void 0) {
    contents.Id = expectString(output["Id"]);
  }
  if (output["MessageId"] !== void 0) {
    contents.MessageId = expectString(output["MessageId"]);
  }
  if (output["MD5OfMessageBody"] !== void 0) {
    contents.MD5OfMessageBody = expectString(output["MD5OfMessageBody"]);
  }
  if (output["MD5OfMessageAttributes"] !== void 0) {
    contents.MD5OfMessageAttributes = expectString(output["MD5OfMessageAttributes"]);
  }
  if (output["MD5OfMessageSystemAttributes"] !== void 0) {
    contents.MD5OfMessageSystemAttributes = expectString(output["MD5OfMessageSystemAttributes"]);
  }
  if (output["SequenceNumber"] !== void 0) {
    contents.SequenceNumber = expectString(output["SequenceNumber"]);
  }
  return contents;
}, "de_SendMessageBatchResultEntry");
var de_SendMessageBatchResultEntryList = /* @__PURE__ */ __name((output, context8) => {
  return (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_SendMessageBatchResultEntry(entry, context8);
  });
}, "de_SendMessageBatchResultEntryList");
var de_SendMessageResult = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["MD5OfMessageBody"] !== void 0) {
    contents.MD5OfMessageBody = expectString(output["MD5OfMessageBody"]);
  }
  if (output["MD5OfMessageAttributes"] !== void 0) {
    contents.MD5OfMessageAttributes = expectString(output["MD5OfMessageAttributes"]);
  }
  if (output["MD5OfMessageSystemAttributes"] !== void 0) {
    contents.MD5OfMessageSystemAttributes = expectString(output["MD5OfMessageSystemAttributes"]);
  }
  if (output["MessageId"] !== void 0) {
    contents.MessageId = expectString(output["MessageId"]);
  }
  if (output["SequenceNumber"] !== void 0) {
    contents.SequenceNumber = expectString(output["SequenceNumber"]);
  }
  return contents;
}, "de_SendMessageResult");
var de_TooManyEntriesInBatchRequest = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_TooManyEntriesInBatchRequest");
var de_UnsupportedOperation = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  return contents;
}, "de_UnsupportedOperation");
var deserializeMetadata5 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString4 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var throwDefaultError5 = withBaseException(SQSServiceException);
var buildHttpRpcRequest2 = /* @__PURE__ */ __name(async (context8, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath14.endsWith("/") ? basePath14.slice(0, -1) + path : basePath14 + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
}, "buildHttpRpcRequest");
var SHARED_HEADERS2 = {
  "content-type": "application/x-www-form-urlencoded"
};
var parseBody4 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString4(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser2.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
}), "parseBody");
var parseErrorBody4 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody4(errorBody, context8);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
}, "parseErrorBody");
var buildFormUrlencodedString2 = /* @__PURE__ */ __name((formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&"), "buildFormUrlencodedString");
var loadQueryErrorCode2 = /* @__PURE__ */ __name((output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
}, "loadQueryErrorCode");

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/receive-message.js
init_dist_es2();
init_dist_es7();

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/send-message.js
init_dist_es2();
init_dist_es7();
var sendMessageMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
  const resp = await next({ ...args });
  const output = resp.output;
  const hash = new options.md5();
  hash.update(toUint8Array(args.input.MessageBody || ""));
  if (output.MD5OfMessageBody !== toHex(await hash.digest())) {
    throw new Error("InvalidChecksumError");
  }
  return resp;
}, "sendMessageMiddleware");
var sendMessageMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BODY_MD5"],
  name: "sendMessageMiddleware",
  override: true
};
var getSendMessagePlugin = /* @__PURE__ */ __name((config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(sendMessageMiddleware(config), sendMessageMiddlewareOptions);
  }
}), "getSendMessagePlugin");

// ../../node_modules/@aws-sdk/middleware-sdk-sqs/dist-es/send-message-batch.js
init_dist_es2();
init_dist_es7();
var sendMessageBatchMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
  const resp = await next({ ...args });
  const output = resp.output;
  const messageIds = [];
  const entries = {};
  if (output.Successful !== void 0) {
    for (const entry of output.Successful) {
      if (entry.Id !== void 0) {
        entries[entry.Id] = entry;
      }
    }
  }
  for (const entry of args.input.Entries) {
    if (entries[entry.Id]) {
      const md5 = entries[entry.Id].MD5OfMessageBody;
      const hash = new options.md5();
      hash.update(toUint8Array(entry.MessageBody || ""));
      if (md5 !== toHex(await hash.digest())) {
        messageIds.push(entries[entry.Id].MessageId);
      }
    }
  }
  if (messageIds.length > 0) {
    throw new Error("Invalid MD5 checksum on messages: " + messageIds.join(", "));
  }
  return resp;
}, "sendMessageBatchMiddleware");
var sendMessageBatchMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BODY_MD5"],
  name: "sendMessageBatchMiddleware",
  override: true
};
var getSendMessageBatchPlugin = /* @__PURE__ */ __name((config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(sendMessageBatchMiddleware(config), sendMessageBatchMiddlewareOptions);
  }
}), "getSendMessageBatchPlugin");

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/SendMessageBatchCommand.js
var SendMessageBatchCommand = class _SendMessageBatchCommand extends Command {
  static {
    __name(this, "SendMessageBatchCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _SendMessageBatchCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSendMessageBatchPlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SQSClient";
    const commandName = "SendMessageBatchCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_SendMessageBatchCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_SendMessageBatchCommand(output, context8);
  }
};

// ../../node_modules/@aws-sdk/client-sqs/dist-es/commands/SendMessageCommand.js
var SendMessageCommand = class _SendMessageCommand extends Command {
  static {
    __name(this, "SendMessageCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _SendMessageCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getSendMessagePlugin(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SQSClient";
    const commandName = "SendMessageCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_SendMessageCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_SendMessageCommand(output, context8);
  }
};

// ../../node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val2) => val2;
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k10) => typeof obj[obj[k10]] !== "number");
    const filtered = {};
    for (const k10 of validKeys) {
      filtered[k10] = obj[k10];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e10) {
      return obj[e10];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val2) => Number.isInteger(val2) : (val2) => typeof val2 === "number" && isFinite(val2) && Math.floor(val2) === val2;
  function joinValues(array, separator = " | ") {
    return array.map((val2) => typeof val2 === "string" ? `'${val2}'` : val2).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t6 = typeof data;
  switch (t6) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class extends Error {
  static {
    __name(this, "ZodError");
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i10 = 0;
          while (i10 < issue.path.length) {
            const el = issue.path[i10];
            const terminal = i10 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i10++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m11) => !!m11).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x4) => !!x4)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s10 of results) {
      if (s10.status === "aborted")
        return INVALID;
      if (s10.status === "dirty")
        status.dirty();
      arrayValue.push(s10.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x4) => x4.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x4) => x4.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x4) => x4.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x4) => typeof Promise !== "undefined" && x4 instanceof Promise, "isAsync");
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val2) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val2);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val2, ctx) => {
      const result = check2(val2);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val2)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val2, ctx) => {
      if (!check2(val2)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val2, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = /* @__PURE__ */ __name((args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
}, "datetimeRegex");
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var ZodString = class _ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check2) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val2, step) {
  const valDecCount = (val2.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val2.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i10) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i10));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i10) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i10));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a10, b11) {
  const aType = getParsedType(a10);
  const bType = getParsedType(b11);
  if (a10 === b11) {
    return { valid: true, data: a10 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b11);
    const sharedKeys = util.objectKeys(a10).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a10, ...b11 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a10[key], b11[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a10.length !== b11.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a10.length; index2++) {
      const itemA = a10[index2];
      const itemB = b11[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a10 === +b11) {
    return { valid: true, data: a10 };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x4) => !!x4);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i10) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i10)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x4) => !!x4),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x4) => !!x4),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e10) => {
          error.addIssue(makeArgsIssue(args, e10));
          throw error;
        });
        const result = await fn(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e10) => {
          error.addIssue(makeReturnsIssue(result, e10));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a10, b11) {
    return new _ZodPipeline({
      in: a10,
      out: b11,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var custom = /* @__PURE__ */ __name((check2, params = {}, fatal) => {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      if (!check2(data)) {
        const p11 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a2 = p11.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p11 === "string" ? { message: p11 } : p11;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/nanoid/index.js
import { randomFillSync } from "crypto";

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
var fillPool = /* @__PURE__ */ __name((bytes) => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    randomFillSync(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    randomFillSync(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}, "fillPool");
var nanoid = /* @__PURE__ */ __name((size = 21) => {
  fillPool(size -= 0);
  let id = "";
  for (let i10 = poolOffset - size; i10 < poolOffset; i10++) {
    id += urlAlphabet[pool[i10] & 63];
  }
  return id;
}, "nanoid");

// ../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
function resolveHostHeaderConfig2(input) {
  return input;
}
__name(resolveHostHeaderConfig2, "resolveHostHeaderConfig");
var hostHeaderMiddleware2 = /* @__PURE__ */ __name((options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request: request3 } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request3.headers[":authority"]) {
    delete request3.headers["host"];
    request3.headers[":authority"] = "";
  } else if (!request3.headers["host"]) {
    let host = request3.hostname;
    if (request3.port != null)
      host += `:${request3.port}`;
    request3.headers["host"] = host;
  }
  return next(args);
}, "hostHeaderMiddleware");
var hostHeaderMiddlewareOptions2 = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin2 = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware2(options), hostHeaderMiddlewareOptions2);
  }
}), "getHostHeaderPlugin");

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
var loggerMiddleware2 = /* @__PURE__ */ __name(() => (next, context8) => async (args) => {
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context8;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context8.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context8.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger2?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context8;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context8.inputFilterSensitiveLog;
    logger2?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
}, "loggerMiddleware");
var loggerMiddlewareOptions2 = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin2 = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware2(), loggerMiddlewareOptions2);
  }
}), "getLoggerPlugin");

// ../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var TRACE_ID_HEADER_NAME2 = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME2 = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID2 = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware2 = /* @__PURE__ */ __name((options) => (next) => async (args) => {
  const { request: request3 } = args;
  if (!HttpRequest.isInstance(request3) || options.runtime !== "node" || request3.headers.hasOwnProperty(TRACE_ID_HEADER_NAME2)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME2];
  const traceId = process.env[ENV_TRACE_ID2];
  const nonEmptyString = /* @__PURE__ */ __name((str) => typeof str === "string" && str.length > 0, "nonEmptyString");
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request3.headers[TRACE_ID_HEADER_NAME2] = traceId;
  }
  return next({
    ...args,
    request: request3
  });
}, "recursionDetectionMiddleware");
var addRecursionDetectionMiddlewareOptions2 = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin2 = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware2(options), addRecursionDetectionMiddlewareOptions2);
  }
}), "getRecursionDetectionPlugin");

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js
init_dist_es9();
init_dist_es4();
var CREDENTIAL_EXPIRE_WINDOW2 = 3e5;
var resolveAwsAuthConfig2 = /* @__PURE__ */ __name((input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider2(input.credentials) : input.credentialDefaultProvider(input);
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else if (input.regionInfoProvider) {
    signer = /* @__PURE__ */ __name(() => normalizeProvider(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    }), "signer");
  } else {
    signer = /* @__PURE__ */ __name(async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider(input.region)(),
        properties: {}
      }, authScheme);
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      input.signingRegion = input.signingRegion || signingRegion;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    }, "signer");
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
}, "resolveAwsAuthConfig");
var normalizeCredentialProvider2 = /* @__PURE__ */ __name((credentials) => {
  if (typeof credentials === "function") {
    return memoize(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW2, (credentials2) => credentials2.expiration !== void 0);
  }
  return normalizeProvider(credentials);
}, "normalizeCredentialProvider");

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate2 = /* @__PURE__ */ __name((systemClockOffset) => new Date(Date.now() + systemClockOffset), "getSkewCorrectedDate");

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
var isClockSkewed2 = /* @__PURE__ */ __name((clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate2(systemClockOffset).getTime() - clockTime) >= 3e5, "isClockSkewed");

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset2 = /* @__PURE__ */ __name((clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed2(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
}, "getUpdatedSystemClockOffset");

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js
var awsAuthMiddleware2 = /* @__PURE__ */ __name((options) => (next, context8) => async function(args) {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const authScheme = context8.endpointV2?.properties?.authSchemes?.[0];
  const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
  const signer = await options.signer(authScheme);
  const output = await next({
    ...args,
    request: await signer.sign(args.request, {
      signingDate: getSkewCorrectedDate2(options.systemClockOffset),
      signingRegion: multiRegionOverride || context8["signing_region"],
      signingService: context8["signing_service"]
    })
  }).catch((error) => {
    const serverTime = error.ServerTime ?? getDateHeader2(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset2(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader2(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset2(dateHeader, options.systemClockOffset);
  }
  return output;
}, "awsAuthMiddleware");
var getDateHeader2 = /* @__PURE__ */ __name((response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0, "getDateHeader");
var awsAuthMiddlewareOptions2 = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin2 = /* @__PURE__ */ __name((options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware2(options), awsAuthMiddlewareOptions2);
  }
}), "getAwsAuthPlugin");

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
function resolveUserAgentConfig2(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}
__name(resolveUserAgentConfig2, "resolveUserAgentConfig");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default2 = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }, {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  }, {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }],
  version: "1.1"
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo2 = partitions_default2;
var selectedUserAgentPrefix2 = "";
var partition2 = /* @__PURE__ */ __name((value) => {
  const { partitions } = selectedPartitionsInfo2;
  for (const partition3 of partitions) {
    const { regions, outputs } = partition3;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition3 of partitions) {
    const { regionRegex, outputs } = partition3;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition3) => partition3.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
}, "partition");
var setPartitionInfo2 = /* @__PURE__ */ __name((partitionsInfo, userAgentPrefix = "") => {
  selectedPartitionsInfo2 = partitionsInfo;
  selectedUserAgentPrefix2 = userAgentPrefix;
}, "setPartitionInfo");
var useDefaultPartitionInfo2 = /* @__PURE__ */ __name(() => {
  setPartitionInfo2(partitions_default2, "");
}, "useDefaultPartitionInfo");
var getUserAgentPrefix2 = /* @__PURE__ */ __name(() => selectedUserAgentPrefix2, "getUserAgentPrefix");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
var IP_V4_REGEX2 = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress2 = /* @__PURE__ */ __name((value) => IP_V4_REGEX2.test(value) || value.startsWith("[") && value.endsWith("]"), "isIpAddress");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/debugId.js
var debugId2 = "endpoints";

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/debug/toDebugString.js
function toDebugString2(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString2(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString2).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}
__name(toDebugString2, "toDebugString");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
var EndpointError2 = class extends Error {
  static {
    __name(this, "EndpointError");
  }
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  aws: () => aws_exports2,
  booleanEquals: () => booleanEquals2,
  getAttr: () => getAttr2,
  isSet: () => isSet2,
  isValidHostLabel: () => isValidHostLabel2,
  not: () => not2,
  parseURL: () => parseURL2,
  stringEquals: () => stringEquals2,
  substring: () => substring2,
  uriEncode: () => uriEncode2
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/index.js
var aws_exports2 = {};
__export(aws_exports2, {
  getUserAgentPrefix: () => getUserAgentPrefix2,
  isVirtualHostableS3Bucket: () => isVirtualHostableS3Bucket2,
  parseArn: () => parseArn2,
  partition: () => partition2,
  setPartitionInfo: () => setPartitionInfo2,
  useDefaultPartitionInfo: () => useDefaultPartitionInfo2
});

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isValidHostLabel.js
var VALID_HOST_LABEL_REGEX2 = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel2 = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX2.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel2(label)) {
      return false;
    }
  }
  return true;
}, "isValidHostLabel");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket2 = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket2(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel2(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress2(value)) {
    return false;
  }
  return true;
}, "isVirtualHostableS3Bucket");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
var parseArn2 = /* @__PURE__ */ __name((value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition3, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition3 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition3,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
}, "parseArn");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/booleanEquals.js
var booleanEquals2 = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "booleanEquals");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttrPathList.js
var getAttrPathList2 = /* @__PURE__ */ __name((path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError2(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError2(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
}, "getAttrPathList");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/getAttr.js
var getAttr2 = /* @__PURE__ */ __name((value, path) => getAttrPathList2(path).reduce((acc, index2) => {
  if (typeof acc !== "object") {
    throw new EndpointError2(`Index '${index2}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index2)];
  }
  return acc[index2];
}, value), "getAttr");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isSet.js
var isSet2 = /* @__PURE__ */ __name((value) => value != null, "isSet");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/not.js
var not2 = /* @__PURE__ */ __name((value) => !value, "not");

// ../../node_modules/@aws-sdk/types/dist-es/dns.js
var HostAddressType2;
(function(HostAddressType3) {
  HostAddressType3["AAAA"] = "AAAA";
  HostAddressType3["A"] = "A";
})(HostAddressType2 || (HostAddressType2 = {}));

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/parseURL.js
var DEFAULT_PORTS2 = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
var parseURL2 = /* @__PURE__ */ __name((value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url12 = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url12.search = Object.entries(query).map(([k10, v7]) => `${k10}=${v7}`).join("&");
        return url12;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress2(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS2[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS2[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS2[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
}, "parseURL");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/stringEquals.js
var stringEquals2 = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "stringEquals");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/substring.js
var substring2 = /* @__PURE__ */ __name((input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
}, "substring");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/uriEncode.js
var uriEncode2 = /* @__PURE__ */ __name((value) => encodeURIComponent(value).replace(/[!*'()]/g, (c11) => `%${c11.charCodeAt(0).toString(16).toUpperCase()}`), "uriEncode");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTemplate.js
var evaluateTemplate2 = /* @__PURE__ */ __name((template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr2(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
}, "evaluateTemplate");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getReferenceValue.js
var getReferenceValue2 = /* @__PURE__ */ __name(({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
}, "getReferenceValue");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression2 = /* @__PURE__ */ __name((obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate2(obj, options);
  } else if (obj["fn"]) {
    return callFunction2(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue2(obj, options);
  }
  throw new EndpointError2(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
}, "evaluateExpression");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/callFunction.js
var callFunction2 = /* @__PURE__ */ __name(({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression2(arg, "arg", options));
  return fn.split(".").reduce((acc, key) => acc[key], lib_exports2)(...evaluatedArgs);
}, "callFunction");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition2 = /* @__PURE__ */ __name(({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError2(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction2(fnArgs, options);
  options.logger?.debug?.(debugId2, `evaluateCondition: ${toDebugString2(fnArgs)} = ${toDebugString2(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
}, "evaluateCondition");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions2 = /* @__PURE__ */ __name((conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition2(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(debugId2, `assign: ${toAssign.name} := ${toDebugString2(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
}, "evaluateConditions");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointHeaders.js
var getEndpointHeaders2 = /* @__PURE__ */ __name((headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression2(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError2(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {}), "getEndpointHeaders");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperty.js
var getEndpointProperty2 = /* @__PURE__ */ __name((property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty2(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate2(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError2(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties2(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError2(`Unexpected endpoint property type: ${typeof property}`);
  }
}, "getEndpointProperty");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties2 = /* @__PURE__ */ __name((properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty2(propertyVal, options)
}), {}), "getEndpointProperties");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/getEndpointUrl.js
var getEndpointUrl2 = /* @__PURE__ */ __name((endpointUrl, options) => {
  const expression = evaluateExpression2(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError2(`Endpoint URL must be a string, got ${typeof expression}`);
}, "getEndpointUrl");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule2 = /* @__PURE__ */ __name((endpointRule, options) => {
  const { conditions, endpoint: endpoint3 } = endpointRule;
  const { result, referenceRecord } = evaluateConditions2(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url: url12, properties, headers } = endpoint3;
  options.logger?.debug?.(debugId2, `Resolving endpoint from template: ${toDebugString2(endpoint3)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders2(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties2(properties, endpointRuleOptions)
    },
    url: getEndpointUrl2(url12, endpointRuleOptions)
  };
}, "evaluateEndpointRule");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateErrorRule.js
var evaluateErrorRule2 = /* @__PURE__ */ __name((errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions2(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError2(evaluateExpression2(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
}, "evaluateErrorRule");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateTreeRule.js
var evaluateTreeRule2 = /* @__PURE__ */ __name((treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions2(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules2(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
}, "evaluateTreeRule");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules2 = /* @__PURE__ */ __name((rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule2(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule2(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule2(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError2(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError2(`Rules evaluation failed`);
}, "evaluateRules");

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint2 = /* @__PURE__ */ __name((ruleSetObject, options) => {
  const { endpointParams, logger: logger2 } = options;
  const { parameters: parameters2, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId2} Initial EndpointParams: ${toDebugString2(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters2).filter(([, v7]) => v7.default != null).map(([k10, v7]) => [k10, v7.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters2).filter(([, v7]) => v7.required).map(([k10]) => k10);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError2(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint3 = evaluateRules2(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  if (options.endpointParams?.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint3.url.protocol = protocol;
      endpoint3.url.port = port;
    } catch (e10) {
    }
  }
  options.logger?.debug?.(`${debugId2} Resolved endpoint: ${toDebugString2(endpoint3)}`);
  return endpoint3;
}, "resolveEndpoint");

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
var USER_AGENT2 = "user-agent";
var X_AMZ_USER_AGENT2 = "x-amz-user-agent";
var SPACE2 = " ";
var UA_NAME_SEPARATOR2 = "/";
var UA_NAME_ESCAPE_REGEX2 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var UA_VALUE_ESCAPE_REGEX2 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var UA_ESCAPE_CHAR2 = "-";

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware2 = /* @__PURE__ */ __name((options) => (next, context8) => async (args) => {
  const { request: request3 } = args;
  if (!HttpRequest.isInstance(request3))
    return next(args);
  const { headers } = request3;
  const userAgent2 = context8?.userAgent?.map(escapeUserAgent2) || [];
  const defaultUserAgent3 = (await options.defaultUserAgentProvider()).map(escapeUserAgent2);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent2) || [];
  const prefix = getUserAgentPrefix2();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent3, ...userAgent2, ...customUserAgent]).join(SPACE2);
  const normalUAValue = [
    ...defaultUserAgent3.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE2);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT2] = headers[X_AMZ_USER_AGENT2] ? `${headers[USER_AGENT2]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT2] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT2] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request: request3
  });
}, "userAgentMiddleware");
var escapeUserAgent2 = /* @__PURE__ */ __name((userAgentPair) => {
  const name2 = userAgentPair[0].split(UA_NAME_SEPARATOR2).map((part) => part.replace(UA_NAME_ESCAPE_REGEX2, UA_ESCAPE_CHAR2)).join(UA_NAME_SEPARATOR2);
  const version3 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX2, UA_ESCAPE_CHAR2);
  const prefixSeparatorIndex = name2.indexOf(UA_NAME_SEPARATOR2);
  const prefix = name2.substring(0, prefixSeparatorIndex);
  let uaName = name2.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version3].filter((item) => item && item.length > 0).reduce((acc, item, index2) => {
    switch (index2) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
}, "escapeUserAgent");
var getUserAgentMiddlewareOptions2 = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin2 = /* @__PURE__ */ __name((config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware2(config), getUserAgentMiddlewareOptions2);
  }
}), "getUserAgentPlugin");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters5 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "ssm"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-ssm/package.json
var package_default5 = {
  name: "@aws-sdk/client-ssm",
  description: "AWS SDK for JavaScript Ssm Client for Node.js, Browser and React Native",
  version: "3.379.1",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo ssm"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.379.1",
    "@aws-sdk/credential-provider-node": "3.379.1",
    "@aws-sdk/middleware-host-header": "3.379.1",
    "@aws-sdk/middleware-logger": "3.378.0",
    "@aws-sdk/middleware-recursion-detection": "3.378.0",
    "@aws-sdk/middleware-signing": "3.379.1",
    "@aws-sdk/middleware-user-agent": "3.379.1",
    "@aws-sdk/types": "3.378.0",
    "@aws-sdk/util-endpoints": "3.378.0",
    "@aws-sdk/util-user-agent-browser": "3.378.0",
    "@aws-sdk/util-user-agent-node": "3.378.0",
    "@smithy/config-resolver": "^2.0.1",
    "@smithy/fetch-http-handler": "^2.0.1",
    "@smithy/hash-node": "^2.0.1",
    "@smithy/invalid-dependency": "^2.0.1",
    "@smithy/middleware-content-length": "^2.0.1",
    "@smithy/middleware-endpoint": "^2.0.1",
    "@smithy/middleware-retry": "^2.0.1",
    "@smithy/middleware-serde": "^2.0.1",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.1",
    "@smithy/node-http-handler": "^2.0.1",
    "@smithy/protocol-http": "^2.0.1",
    "@smithy/smithy-client": "^2.0.1",
    "@smithy/types": "^2.0.2",
    "@smithy/url-parser": "^2.0.1",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.1",
    "@smithy/util-defaults-mode-node": "^2.0.1",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    "@smithy/util-waiter": "^2.0.1",
    tslib: "^2.5.0",
    uuid: "^8.3.2"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    "@types/uuid": "^8.3.0",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ssm",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-ssm"
  }
};

// ../../node_modules/@aws-sdk/middleware-sdk-sts/dist-es/index.js
var resolveStsAuthConfig2 = /* @__PURE__ */ __name((input, { stsClientCtor }) => resolveAwsAuthConfig2({
  ...input,
  stsClientCtor
}), "resolveStsAuthConfig");

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters6 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    defaultSigningName: "sts"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-sts/package.json
var package_default6 = {
  name: "@aws-sdk/client-sts",
  description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
  version: "3.379.1",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
    test: "yarn test:unit",
    "test:unit": "jest"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/credential-provider-node": "3.379.1",
    "@aws-sdk/middleware-host-header": "3.379.1",
    "@aws-sdk/middleware-logger": "3.378.0",
    "@aws-sdk/middleware-recursion-detection": "3.378.0",
    "@aws-sdk/middleware-sdk-sts": "3.379.1",
    "@aws-sdk/middleware-signing": "3.379.1",
    "@aws-sdk/middleware-user-agent": "3.379.1",
    "@aws-sdk/types": "3.378.0",
    "@aws-sdk/util-endpoints": "3.378.0",
    "@aws-sdk/util-user-agent-browser": "3.378.0",
    "@aws-sdk/util-user-agent-node": "3.378.0",
    "@smithy/config-resolver": "^2.0.1",
    "@smithy/fetch-http-handler": "^2.0.1",
    "@smithy/hash-node": "^2.0.1",
    "@smithy/invalid-dependency": "^2.0.1",
    "@smithy/middleware-content-length": "^2.0.1",
    "@smithy/middleware-endpoint": "^2.0.1",
    "@smithy/middleware-retry": "^2.0.1",
    "@smithy/middleware-serde": "^2.0.1",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.1",
    "@smithy/node-http-handler": "^2.0.1",
    "@smithy/protocol-http": "^2.0.1",
    "@smithy/smithy-client": "^2.0.1",
    "@smithy/types": "^2.0.2",
    "@smithy/url-parser": "^2.0.1",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.1",
    "@smithy/util-defaults-mode-node": "^2.0.1",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    "fast-xml-parser": "4.2.5",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sts"
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/STSServiceException.js
var STSServiceException2 = class _STSServiceException extends ServiceException {
  static {
    __name(this, "STSServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _STSServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/models/models_0.js
var ExpiredTokenException3 = class _ExpiredTokenException2 extends STSServiceException2 {
  static {
    __name(this, "ExpiredTokenException");
  }
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExpiredTokenException2.prototype);
  }
};
var MalformedPolicyDocumentException2 = class _MalformedPolicyDocumentException extends STSServiceException2 {
  static {
    __name(this, "MalformedPolicyDocumentException");
  }
  constructor(opts) {
    super({
      name: "MalformedPolicyDocumentException",
      $fault: "client",
      ...opts
    });
    this.name = "MalformedPolicyDocumentException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
  }
};
var PackedPolicyTooLargeException2 = class _PackedPolicyTooLargeException extends STSServiceException2 {
  static {
    __name(this, "PackedPolicyTooLargeException");
  }
  constructor(opts) {
    super({
      name: "PackedPolicyTooLargeException",
      $fault: "client",
      ...opts
    });
    this.name = "PackedPolicyTooLargeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
  }
};
var RegionDisabledException2 = class _RegionDisabledException extends STSServiceException2 {
  static {
    __name(this, "RegionDisabledException");
  }
  constructor(opts) {
    super({
      name: "RegionDisabledException",
      $fault: "client",
      ...opts
    });
    this.name = "RegionDisabledException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _RegionDisabledException.prototype);
  }
};
var IDPRejectedClaimException2 = class _IDPRejectedClaimException extends STSServiceException2 {
  static {
    __name(this, "IDPRejectedClaimException");
  }
  constructor(opts) {
    super({
      name: "IDPRejectedClaimException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPRejectedClaimException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
  }
};
var InvalidIdentityTokenException2 = class _InvalidIdentityTokenException extends STSServiceException2 {
  static {
    __name(this, "InvalidIdentityTokenException");
  }
  constructor(opts) {
    super({
      name: "InvalidIdentityTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidIdentityTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
  }
};
var IDPCommunicationErrorException2 = class _IDPCommunicationErrorException extends STSServiceException2 {
  static {
    __name(this, "IDPCommunicationErrorException");
  }
  constructor(opts) {
    super({
      name: "IDPCommunicationErrorException",
      $fault: "client",
      ...opts
    });
    this.name = "IDPCommunicationErrorException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
  }
};
var CredentialsFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING }
}), "CredentialsFilterSensitiveLog");
var AssumeRoleResponseFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog2(obj.Credentials) }
}), "AssumeRoleResponseFilterSensitiveLog");
var AssumeRoleWithWebIdentityRequestFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.WebIdentityToken && { WebIdentityToken: SENSITIVE_STRING }
}), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog");
var AssumeRoleWithWebIdentityResponseFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog2(obj.Credentials) }
}), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog");

// ../../node_modules/@aws-sdk/client-sts/dist-es/protocols/Aws_query.js
var import_fast_xml_parser3 = __toESM(require_fxp());
var se_AssumeRoleCommand2 = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = SHARED_HEADERS3;
  let body;
  body = buildFormUrlencodedString3({
    ...se_AssumeRoleRequest2(input, context8),
    Action: "AssumeRole",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest3(context8, headers, "/", void 0, body);
}, "se_AssumeRoleCommand");
var se_AssumeRoleWithWebIdentityCommand2 = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = SHARED_HEADERS3;
  let body;
  body = buildFormUrlencodedString3({
    ...se_AssumeRoleWithWebIdentityRequest2(input, context8),
    Action: "AssumeRoleWithWebIdentity",
    Version: "2011-06-15"
  });
  return buildHttpRpcRequest3(context8, headers, "/", void 0, body);
}, "se_AssumeRoleWithWebIdentityCommand");
var de_AssumeRoleCommand2 = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_AssumeRoleCommandError2(output, context8);
  }
  const data = await parseBody5(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleResponse2(data.AssumeRoleResult, context8);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return response;
}, "de_AssumeRoleCommand");
var de_AssumeRoleCommandError2 = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context8)
  };
  const errorCode = loadQueryErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes3(parsedOutput, context8);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes2(parsedOutput, context8);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes2(parsedOutput, context8);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes2(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError6({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, "de_AssumeRoleCommandError");
var de_AssumeRoleWithWebIdentityCommand2 = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_AssumeRoleWithWebIdentityCommandError2(output, context8);
  }
  const data = await parseBody5(output.body, context8);
  let contents = {};
  contents = de_AssumeRoleWithWebIdentityResponse2(data.AssumeRoleWithWebIdentityResult, context8);
  const response = {
    $metadata: deserializeMetadata6(output),
    ...contents
  };
  return response;
}, "de_AssumeRoleWithWebIdentityCommand");
var de_AssumeRoleWithWebIdentityCommandError2 = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody5(output.body, context8)
  };
  const errorCode = loadQueryErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "ExpiredTokenException":
    case "com.amazonaws.sts#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes3(parsedOutput, context8);
    case "IDPCommunicationError":
    case "com.amazonaws.sts#IDPCommunicationErrorException":
      throw await de_IDPCommunicationErrorExceptionRes2(parsedOutput, context8);
    case "IDPRejectedClaim":
    case "com.amazonaws.sts#IDPRejectedClaimException":
      throw await de_IDPRejectedClaimExceptionRes2(parsedOutput, context8);
    case "InvalidIdentityToken":
    case "com.amazonaws.sts#InvalidIdentityTokenException":
      throw await de_InvalidIdentityTokenExceptionRes2(parsedOutput, context8);
    case "MalformedPolicyDocument":
    case "com.amazonaws.sts#MalformedPolicyDocumentException":
      throw await de_MalformedPolicyDocumentExceptionRes2(parsedOutput, context8);
    case "PackedPolicyTooLarge":
    case "com.amazonaws.sts#PackedPolicyTooLargeException":
      throw await de_PackedPolicyTooLargeExceptionRes2(parsedOutput, context8);
    case "RegionDisabledException":
    case "com.amazonaws.sts#RegionDisabledException":
      throw await de_RegionDisabledExceptionRes2(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError6({
        output,
        parsedBody: parsedBody.Error,
        errorCode
      });
  }
}, "de_AssumeRoleWithWebIdentityCommandError");
var de_ExpiredTokenExceptionRes3 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_ExpiredTokenException2(body.Error, context8);
  const exception = new ExpiredTokenException3({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_ExpiredTokenExceptionRes");
var de_IDPCommunicationErrorExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPCommunicationErrorException2(body.Error, context8);
  const exception = new IDPCommunicationErrorException2({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_IDPCommunicationErrorExceptionRes");
var de_IDPRejectedClaimExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_IDPRejectedClaimException2(body.Error, context8);
  const exception = new IDPRejectedClaimException2({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_IDPRejectedClaimExceptionRes");
var de_InvalidIdentityTokenExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_InvalidIdentityTokenException2(body.Error, context8);
  const exception = new InvalidIdentityTokenException2({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InvalidIdentityTokenExceptionRes");
var de_MalformedPolicyDocumentExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_MalformedPolicyDocumentException2(body.Error, context8);
  const exception = new MalformedPolicyDocumentException2({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_MalformedPolicyDocumentExceptionRes");
var de_PackedPolicyTooLargeExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_PackedPolicyTooLargeException2(body.Error, context8);
  const exception = new PackedPolicyTooLargeException2({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_PackedPolicyTooLargeExceptionRes");
var de_RegionDisabledExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = de_RegionDisabledException2(body.Error, context8);
  const exception = new RegionDisabledException2({
    $metadata: deserializeMetadata6(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_RegionDisabledExceptionRes");
var se_AssumeRoleRequest2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.PolicyArns != null) {
    const memberEntries = se_policyDescriptorListType2(input.PolicyArns, context8);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  if (input.Tags != null) {
    const memberEntries = se_tagListType2(input.Tags, context8);
    if (input.Tags?.length === 0) {
      entries.Tags = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tags.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TransitiveTagKeys != null) {
    const memberEntries = se_tagKeyListType2(input.TransitiveTagKeys, context8);
    if (input.TransitiveTagKeys?.length === 0) {
      entries.TransitiveTagKeys = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitiveTagKeys.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ExternalId != null) {
    entries["ExternalId"] = input.ExternalId;
  }
  if (input.SerialNumber != null) {
    entries["SerialNumber"] = input.SerialNumber;
  }
  if (input.TokenCode != null) {
    entries["TokenCode"] = input.TokenCode;
  }
  if (input.SourceIdentity != null) {
    entries["SourceIdentity"] = input.SourceIdentity;
  }
  if (input.ProvidedContexts != null) {
    const memberEntries = se_ProvidedContextsListType2(input.ProvidedContexts, context8);
    if (input.ProvidedContexts?.length === 0) {
      entries.ProvidedContexts = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ProvidedContexts.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
}, "se_AssumeRoleRequest");
var se_AssumeRoleWithWebIdentityRequest2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.RoleArn != null) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.RoleSessionName != null) {
    entries["RoleSessionName"] = input.RoleSessionName;
  }
  if (input.WebIdentityToken != null) {
    entries["WebIdentityToken"] = input.WebIdentityToken;
  }
  if (input.ProviderId != null) {
    entries["ProviderId"] = input.ProviderId;
  }
  if (input.PolicyArns != null) {
    const memberEntries = se_policyDescriptorListType2(input.PolicyArns, context8);
    if (input.PolicyArns?.length === 0) {
      entries.PolicyArns = [];
    }
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PolicyArns.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Policy != null) {
    entries["Policy"] = input.Policy;
  }
  if (input.DurationSeconds != null) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  return entries;
}, "se_AssumeRoleWithWebIdentityRequest");
var se_policyDescriptorListType2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_PolicyDescriptorType2(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_policyDescriptorListType");
var se_PolicyDescriptorType2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.arn != null) {
    entries["arn"] = input.arn;
  }
  return entries;
}, "se_PolicyDescriptorType");
var se_ProvidedContext2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.ProviderArn != null) {
    entries["ProviderArn"] = input.ProviderArn;
  }
  if (input.ContextAssertion != null) {
    entries["ContextAssertion"] = input.ContextAssertion;
  }
  return entries;
}, "se_ProvidedContext");
var se_ProvidedContextsListType2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_ProvidedContext2(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_ProvidedContextsListType");
var se_Tag2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  if (input.Key != null) {
    entries["Key"] = input.Key;
  }
  if (input.Value != null) {
    entries["Value"] = input.Value;
  }
  return entries;
}, "se_Tag");
var se_tagKeyListType2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
}, "se_tagKeyListType");
var se_tagListType2 = /* @__PURE__ */ __name((input, context8) => {
  const entries = {};
  let counter = 1;
  for (const entry of input) {
    if (entry === null) {
      continue;
    }
    const memberEntries = se_Tag2(entry, context8);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
}, "se_tagListType");
var de_AssumedRoleUser2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["AssumedRoleId"] !== void 0) {
    contents.AssumedRoleId = expectString(output["AssumedRoleId"]);
  }
  if (output["Arn"] !== void 0) {
    contents.Arn = expectString(output["Arn"]);
  }
  return contents;
}, "de_AssumedRoleUser");
var de_AssumeRoleResponse2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["Credentials"] !== void 0) {
    contents.Credentials = de_Credentials2(output["Credentials"], context8);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = de_AssumedRoleUser2(output["AssumedRoleUser"], context8);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString(output["SourceIdentity"]);
  }
  return contents;
}, "de_AssumeRoleResponse");
var de_AssumeRoleWithWebIdentityResponse2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["Credentials"] !== void 0) {
    contents.Credentials = de_Credentials2(output["Credentials"], context8);
  }
  if (output["SubjectFromWebIdentityToken"] !== void 0) {
    contents.SubjectFromWebIdentityToken = expectString(output["SubjectFromWebIdentityToken"]);
  }
  if (output["AssumedRoleUser"] !== void 0) {
    contents.AssumedRoleUser = de_AssumedRoleUser2(output["AssumedRoleUser"], context8);
  }
  if (output["PackedPolicySize"] !== void 0) {
    contents.PackedPolicySize = strictParseInt32(output["PackedPolicySize"]);
  }
  if (output["Provider"] !== void 0) {
    contents.Provider = expectString(output["Provider"]);
  }
  if (output["Audience"] !== void 0) {
    contents.Audience = expectString(output["Audience"]);
  }
  if (output["SourceIdentity"] !== void 0) {
    contents.SourceIdentity = expectString(output["SourceIdentity"]);
  }
  return contents;
}, "de_AssumeRoleWithWebIdentityResponse");
var de_Credentials2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["AccessKeyId"] !== void 0) {
    contents.AccessKeyId = expectString(output["AccessKeyId"]);
  }
  if (output["SecretAccessKey"] !== void 0) {
    contents.SecretAccessKey = expectString(output["SecretAccessKey"]);
  }
  if (output["SessionToken"] !== void 0) {
    contents.SessionToken = expectString(output["SessionToken"]);
  }
  if (output["Expiration"] !== void 0) {
    contents.Expiration = expectNonNull(parseRfc3339DateTimeWithOffset(output["Expiration"]));
  }
  return contents;
}, "de_Credentials");
var de_ExpiredTokenException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_ExpiredTokenException");
var de_IDPCommunicationErrorException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_IDPCommunicationErrorException");
var de_IDPRejectedClaimException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_IDPRejectedClaimException");
var de_InvalidIdentityTokenException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_InvalidIdentityTokenException");
var de_MalformedPolicyDocumentException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_MalformedPolicyDocumentException");
var de_PackedPolicyTooLargeException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_PackedPolicyTooLargeException");
var de_RegionDisabledException2 = /* @__PURE__ */ __name((output, context8) => {
  const contents = {};
  if (output["message"] !== void 0) {
    contents.message = expectString(output["message"]);
  }
  return contents;
}, "de_RegionDisabledException");
var deserializeMetadata6 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString5 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var throwDefaultError6 = withBaseException(STSServiceException2);
var buildHttpRpcRequest3 = /* @__PURE__ */ __name(async (context8, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath14.endsWith("/") ? basePath14.slice(0, -1) + path : basePath14 + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
}, "buildHttpRpcRequest");
var SHARED_HEADERS3 = {
  "content-type": "application/x-www-form-urlencoded"
};
var parseBody5 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString5(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser3.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    const parsedObj = parser.parse(encoded);
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
}), "parseBody");
var parseErrorBody5 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody5(errorBody, context8);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
}, "parseErrorBody");
var buildFormUrlencodedString3 = /* @__PURE__ */ __name((formEntries) => Object.entries(formEntries).map(([key, value]) => extendedEncodeURIComponent(key) + "=" + extendedEncodeURIComponent(value)).join("&"), "buildFormUrlencodedString");
var loadQueryErrorCode3 = /* @__PURE__ */ __name((output, data) => {
  if (data.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
}, "loadQueryErrorCode");

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleCommand.js
var AssumeRoleCommand2 = class _AssumeRoleCommand extends Command {
  static {
    __name(this, "AssumeRoleCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _AssumeRoleCommand.getEndpointParameterInstructions()));
    this.middlewareStack.use(getAwsAuthPlugin2(configuration));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_AssumeRoleCommand2(input, context8);
  }
  deserialize(output, context8) {
    return de_AssumeRoleCommand2(output, context8);
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/commands/AssumeRoleWithWebIdentityCommand.js
var AssumeRoleWithWebIdentityCommand2 = class _AssumeRoleWithWebIdentityCommand extends Command {
  static {
    __name(this, "AssumeRoleWithWebIdentityCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "STSClient";
    const commandName = "AssumeRoleWithWebIdentityCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_AssumeRoleWithWebIdentityCommand2(input, context8);
  }
  deserialize(output, context8) {
    return de_AssumeRoleWithWebIdentityCommand2(output, context8);
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/defaultStsRoleAssumers.js
var ASSUME_ROLE_DEFAULT_REGION2 = "us-east-1";
var decorateDefaultRegion2 = /* @__PURE__ */ __name((region) => {
  if (typeof region !== "function") {
    return region === void 0 ? ASSUME_ROLE_DEFAULT_REGION2 : region;
  }
  return async () => {
    try {
      return await region();
    } catch (e10) {
      return ASSUME_ROLE_DEFAULT_REGION2;
    }
  };
}, "decorateDefaultRegion");
var getDefaultRoleAssumer3 = /* @__PURE__ */ __name((stsOptions, stsClientCtor) => {
  let stsClient;
  let closureSourceCreds;
  return async (sourceCreds, params) => {
    closureSourceCreds = sourceCreds;
    if (!stsClient) {
      const { logger: logger2, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger2,
        credentialDefaultProvider: () => async () => closureSourceCreds,
        region: decorateDefaultRegion2(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand2(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
}, "getDefaultRoleAssumer");
var getDefaultRoleAssumerWithWebIdentity3 = /* @__PURE__ */ __name((stsOptions, stsClientCtor) => {
  let stsClient;
  return async (params) => {
    if (!stsClient) {
      const { logger: logger2, region, requestHandler } = stsOptions;
      stsClient = new stsClientCtor({
        logger: logger2,
        region: decorateDefaultRegion2(region || stsOptions.region),
        ...requestHandler ? { requestHandler } : {}
      });
    }
    const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand2(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration
    };
  };
}, "getDefaultRoleAssumerWithWebIdentity");
var decorateDefaultCredentialProvider3 = /* @__PURE__ */ __name((provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer3(input, input.stsClientCtor),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity3(input, input.stsClientCtor),
  ...input
}), "decorateDefaultCredentialProvider");

// ../../node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var ENV_KEY2 = "AWS_ACCESS_KEY_ID";
var ENV_SECRET2 = "AWS_SECRET_ACCESS_KEY";
var ENV_SESSION2 = "AWS_SESSION_TOKEN";
var ENV_EXPIRATION2 = "AWS_CREDENTIAL_EXPIRATION";
var fromEnv3 = /* @__PURE__ */ __name(() => async () => {
  const accessKeyId = process.env[ENV_KEY2];
  const secretAccessKey = process.env[ENV_SECRET2];
  const sessionToken = process.env[ENV_SESSION2];
  const expiry = process.env[ENV_EXPIRATION2];
  if (accessKeyId && secretAccessKey) {
    return {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) }
    };
  }
  throw new CredentialsProviderError("Unable to find environment variable credentials.");
}, "fromEnv");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var resolveCredentialSource2 = /* @__PURE__ */ __name((credentialSource, profileName) => {
  const sourceProvidersMap = {
    EcsContainer: fromContainerMetadata,
    Ec2InstanceMetadata: fromInstanceMetadata,
    Environment: fromEnv3
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource]();
  } else {
    throw new CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`);
  }
}, "resolveCredentialSource");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var isAssumeRoleProfile2 = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile2(arg) || isAssumeRoleWithProviderProfile2(arg)), "isAssumeRoleProfile");
var isAssumeRoleWithSourceProfile2 = /* @__PURE__ */ __name((arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined", "isAssumeRoleWithSourceProfile");
var isAssumeRoleWithProviderProfile2 = /* @__PURE__ */ __name((arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined", "isAssumeRoleWithProviderProfile");
var resolveAssumeRoleCredentials2 = /* @__PURE__ */ __name(async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (!options.roleAssumer) {
    throw new CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
  }
  const { source_profile } = data;
  if (source_profile && source_profile in visitedProfiles) {
    throw new CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
  }
  const sourceCredsProvider = source_profile ? resolveProfileData2(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }) : resolveCredentialSource2(data.credential_source, profileName)();
  const params = {
    RoleArn: data.role_arn,
    RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
    ExternalId: data.external_id
  };
  const { mfa_serial } = data;
  if (mfa_serial) {
    if (!options.mfaCodeProvider) {
      throw new CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
    }
    params.SerialNumber = mfa_serial;
    params.TokenCode = await options.mfaCodeProvider(mfa_serial);
  }
  const sourceCreds = await sourceCredsProvider;
  return options.roleAssumer(sourceCreds, params);
}, "resolveAssumeRoleCredentials");

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
import { exec as exec2 } from "child_process";
import { promisify as promisify2 } from "util";

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var getValidatedProcessCredentials2 = /* @__PURE__ */ __name((profileName, data) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === void 0 || data.SecretAccessKey === void 0) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = /* @__PURE__ */ new Date();
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  return {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) }
  };
}, "getValidatedProcessCredentials");

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
var resolveProcessCredentials3 = /* @__PURE__ */ __name(async (profileName, profiles) => {
  const profile = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile["credential_process"];
    if (credentialProcess !== void 0) {
      const execPromise = promisify2(exec2);
      try {
        const { stdout } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials2(profileName, data);
      } catch (error) {
        throw new CredentialsProviderError(error.message);
      }
    } else {
      throw new CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
    }
  } else {
    throw new CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
  }
}, "resolveProcessCredentials");

// ../../node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var fromProcess2 = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const profiles = await parseKnownFiles(init2);
  return resolveProcessCredentials3(getProfileName(init2), profiles);
}, "fromProcess");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var isProcessProfile2 = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string", "isProcessProfile");
var resolveProcessCredentials4 = /* @__PURE__ */ __name(async (options, profile) => fromProcess2({
  ...options,
  profile
})(), "resolveProcessCredentials");

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile2 = /* @__PURE__ */ __name((arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string"), "isSsoProfile");

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters7 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-sso/package.json
var package_default7 = {
  name: "@aws-sdk/client-sso",
  description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
  version: "3.379.1",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/middleware-host-header": "3.379.1",
    "@aws-sdk/middleware-logger": "3.378.0",
    "@aws-sdk/middleware-recursion-detection": "3.378.0",
    "@aws-sdk/middleware-user-agent": "3.379.1",
    "@aws-sdk/types": "3.378.0",
    "@aws-sdk/util-endpoints": "3.378.0",
    "@aws-sdk/util-user-agent-browser": "3.378.0",
    "@aws-sdk/util-user-agent-node": "3.378.0",
    "@smithy/config-resolver": "^2.0.1",
    "@smithy/fetch-http-handler": "^2.0.1",
    "@smithy/hash-node": "^2.0.1",
    "@smithy/invalid-dependency": "^2.0.1",
    "@smithy/middleware-content-length": "^2.0.1",
    "@smithy/middleware-endpoint": "^2.0.1",
    "@smithy/middleware-retry": "^2.0.1",
    "@smithy/middleware-serde": "^2.0.1",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.1",
    "@smithy/node-http-handler": "^2.0.1",
    "@smithy/protocol-http": "^2.0.1",
    "@smithy/smithy-client": "^2.0.1",
    "@smithy/types": "^2.0.2",
    "@smithy/url-parser": "^2.0.1",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.1",
    "@smithy/util-defaults-mode-node": "^2.0.1",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso"
  }
};

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
import { platform as platform2, release as release2 } from "os";
import { env as env2, versions as versions2 } from "process";

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/is-crt-available.js
var isCrtAvailable2 = /* @__PURE__ */ __name(() => {
  try {
    if (typeof __require === "function" && typeof module !== "undefined" && require_dist()) {
      return ["md/crt-avail"];
    }
    return null;
  } catch (e10) {
    return null;
  }
}, "isCrtAvailable");

// ../../node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js
var UA_APP_ID_ENV_NAME2 = "AWS_SDK_UA_APP_ID";
var UA_APP_ID_INI_NAME2 = "sdk-ua-app-id";
var defaultUserAgent2 = /* @__PURE__ */ __name(({ serviceId, clientVersion }) => {
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${platform2()}`, release2()],
    ["lang/js"],
    ["md/nodejs", `${versions2.node}`]
  ];
  const crtAvailable = isCrtAvailable2();
  if (crtAvailable) {
    sections.push(crtAvailable);
  }
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  if (env2.AWS_EXECUTION_ENV) {
    sections.push([`exec-env/${env2.AWS_EXECUTION_ENV}`]);
  }
  const appIdPromise = loadConfig({
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME2],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME2],
    default: void 0
  })();
  let resolvedUserAgent = void 0;
  return async () => {
    if (!resolvedUserAgent) {
      const appId = await appIdPromise;
      resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
    }
    return resolvedUserAgent;
  };
}, "defaultUserAgent");

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var p5 = "required";
var q5 = "fn";
var r5 = "argv";
var s5 = "ref";
var a5 = "PartitionResult";
var b5 = "tree";
var c5 = "error";
var d5 = "endpoint";
var e5 = { [p5]: false, "type": "String" };
var f5 = { [p5]: true, "default": false, "type": "Boolean" };
var g5 = { [s5]: "Endpoint" };
var h5 = { [q5]: "booleanEquals", [r5]: [{ [s5]: "UseFIPS" }, true] };
var i5 = { [q5]: "booleanEquals", [r5]: [{ [s5]: "UseDualStack" }, true] };
var j5 = {};
var k5 = { [q5]: "booleanEquals", [r5]: [true, { [q5]: "getAttr", [r5]: [{ [s5]: a5 }, "supportsFIPS"] }] };
var l5 = { [q5]: "booleanEquals", [r5]: [true, { [q5]: "getAttr", [r5]: [{ [s5]: a5 }, "supportsDualStack"] }] };
var m5 = [g5];
var n5 = [h5];
var o5 = [i5];
var _data5 = { version: "1.0", parameters: { Region: e5, UseDualStack: f5, UseFIPS: f5, Endpoint: e5 }, rules: [{ conditions: [{ [q5]: "aws.partition", [r5]: [{ [s5]: "Region" }], assign: a5 }], type: b5, rules: [{ conditions: [{ [q5]: "isSet", [r5]: m5 }, { [q5]: "parseURL", [r5]: m5, assign: "url" }], type: b5, rules: [{ conditions: n5, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c5 }, { type: b5, rules: [{ conditions: o5, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c5 }, { endpoint: { url: g5, properties: j5, headers: j5 }, type: d5 }] }] }, { conditions: [h5, i5], type: b5, rules: [{ conditions: [k5, l5], type: b5, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j5, headers: j5 }, type: d5 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c5 }] }, { conditions: n5, type: b5, rules: [{ conditions: [k5], type: b5, rules: [{ type: b5, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j5, headers: j5 }, type: d5 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c5 }] }, { conditions: o5, type: b5, rules: [{ conditions: [l5], type: b5, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j5, headers: j5 }, type: d5 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c5 }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j5, headers: j5 }, type: d5 }] }] };
var ruleSet5 = _data5;

// ../../node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver5 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint2(ruleSet5, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var getRuntimeConfig8 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver5,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSO",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var getRuntimeConfig9 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig8(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default7.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var SSOClient2 = class extends Client {
  static {
    __name(this, "SSOClient");
  }
  constructor(configuration) {
    const _config_0 = getRuntimeConfig9(configuration);
    const _config_1 = resolveClientEndpointParameters7(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveUserAgentConfig2(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var SSOServiceException2 = class _SSOServiceException extends ServiceException {
  static {
    __name(this, "SSOServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSOServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var InvalidRequestException3 = class _InvalidRequestException2 extends SSOServiceException2 {
  static {
    __name(this, "InvalidRequestException");
  }
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidRequestException2.prototype);
  }
};
var ResourceNotFoundException3 = class _ResourceNotFoundException extends SSOServiceException2 {
  static {
    __name(this, "ResourceNotFoundException");
  }
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    this.name = "ResourceNotFoundException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
  }
};
var TooManyRequestsException2 = class _TooManyRequestsException extends SSOServiceException2 {
  static {
    __name(this, "TooManyRequestsException");
  }
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    this.name = "TooManyRequestsException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
  }
};
var UnauthorizedException2 = class _UnauthorizedException extends SSOServiceException2 {
  static {
    __name(this, "UnauthorizedException");
  }
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnauthorizedException.prototype);
  }
};
var GetRoleCredentialsRequestFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: SENSITIVE_STRING }
}), "GetRoleCredentialsRequestFilterSensitiveLog");
var RoleCredentialsFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: SENSITIVE_STRING },
  ...obj.sessionToken && { sessionToken: SENSITIVE_STRING }
}), "RoleCredentialsFilterSensitiveLog");
var GetRoleCredentialsResponseFilterSensitiveLog2 = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog2(obj.roleCredentials) }
}), "GetRoleCredentialsResponseFilterSensitiveLog");

// ../../node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var se_GetRoleCredentialsCommand2 = /* @__PURE__ */ __name(async (input, context8) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const headers = map({}, isSerializableHeaderValue2, {
    "x-amz-sso_bearer_token": input.accessToken
  });
  const resolvedPath = `${basePath14?.endsWith("/") ? basePath14.slice(0, -1) : basePath14 || ""}/federation/credentials`;
  const query = map({
    role_name: [, expectNonNull(input.roleName, `roleName`)],
    account_id: [, expectNonNull(input.accountId, `accountId`)]
  });
  let body;
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
}, "se_GetRoleCredentialsCommand");
var de_GetRoleCredentialsCommand2 = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_GetRoleCredentialsCommandError2(output, context8);
  }
  const contents = map({
    $metadata: deserializeMetadata7(output)
  });
  const data = expectNonNull(expectObject(await parseBody6(output.body, context8)), "body");
  const doc = take(data, {
    roleCredentials: _json
  });
  Object.assign(contents, doc);
  return contents;
}, "de_GetRoleCredentialsCommand");
var de_GetRoleCredentialsCommandError2 = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody6(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode3(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes3(parsedOutput, context8);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes2(parsedOutput, context8);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes2(parsedOutput, context8);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes2(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError7({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_GetRoleCredentialsCommandError");
var throwDefaultError7 = withBaseException(SSOServiceException2);
var de_InvalidRequestExceptionRes3 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException3({
    $metadata: deserializeMetadata7(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidRequestExceptionRes");
var de_ResourceNotFoundExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new ResourceNotFoundException3({
    $metadata: deserializeMetadata7(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_ResourceNotFoundExceptionRes");
var de_TooManyRequestsExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException2({
    $metadata: deserializeMetadata7(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_TooManyRequestsExceptionRes");
var de_UnauthorizedExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    message: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedException2({
    $metadata: deserializeMetadata7(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_UnauthorizedExceptionRes");
var deserializeMetadata7 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString6 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var isSerializableHeaderValue2 = /* @__PURE__ */ __name((value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0), "isSerializableHeaderValue");
var parseBody6 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString6(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
}), "parseBody");
var parseErrorBody6 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody6(errorBody, context8);
  value.message = value.message ?? value.Message;
  return value;
}, "parseErrorBody");
var loadRestJsonErrorCode3 = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k10) => k10.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");

// ../../node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var GetRoleCredentialsCommand2 = class _GetRoleCredentialsCommand extends Command {
  static {
    __name(this, "GetRoleCredentialsCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetRoleCredentialsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSOClient";
    const commandName = "GetRoleCredentialsCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetRoleCredentialsRequestFilterSensitiveLog2,
      outputFilterSensitiveLog: GetRoleCredentialsResponseFilterSensitiveLog2
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_GetRoleCredentialsCommand2(input, context8);
  }
  deserialize(output, context8) {
    return de_GetRoleCredentialsCommand2(output, context8);
  }
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS3 = 5 * 60 * 1e3;
var REFRESH_MESSAGE2 = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters8 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssooidc"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-sso-oidc/package.json
var package_default8 = {
  name: "@aws-sdk/client-sso-oidc",
  description: "AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native",
  version: "3.379.1",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso-oidc"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/middleware-host-header": "3.379.1",
    "@aws-sdk/middleware-logger": "3.378.0",
    "@aws-sdk/middleware-recursion-detection": "3.378.0",
    "@aws-sdk/middleware-user-agent": "3.379.1",
    "@aws-sdk/types": "3.378.0",
    "@aws-sdk/util-endpoints": "3.378.0",
    "@aws-sdk/util-user-agent-browser": "3.378.0",
    "@aws-sdk/util-user-agent-node": "3.378.0",
    "@smithy/config-resolver": "^2.0.1",
    "@smithy/fetch-http-handler": "^2.0.1",
    "@smithy/hash-node": "^2.0.1",
    "@smithy/invalid-dependency": "^2.0.1",
    "@smithy/middleware-content-length": "^2.0.1",
    "@smithy/middleware-endpoint": "^2.0.1",
    "@smithy/middleware-retry": "^2.0.1",
    "@smithy/middleware-serde": "^2.0.1",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.1",
    "@smithy/node-http-handler": "^2.0.1",
    "@smithy/protocol-http": "^2.0.1",
    "@smithy/smithy-client": "^2.0.1",
    "@smithy/types": "^2.0.2",
    "@smithy/url-parser": "^2.0.1",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.1",
    "@smithy/util-defaults-mode-node": "^2.0.1",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-sso-oidc"
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/ruleset.js
var p6 = "required";
var q6 = "fn";
var r6 = "argv";
var s6 = "ref";
var a6 = "PartitionResult";
var b6 = "tree";
var c6 = "error";
var d6 = "endpoint";
var e6 = { [p6]: false, "type": "String" };
var f6 = { [p6]: true, "default": false, "type": "Boolean" };
var g6 = { [s6]: "Endpoint" };
var h6 = { [q6]: "booleanEquals", [r6]: [{ [s6]: "UseFIPS" }, true] };
var i6 = { [q6]: "booleanEquals", [r6]: [{ [s6]: "UseDualStack" }, true] };
var j6 = {};
var k6 = { [q6]: "booleanEquals", [r6]: [true, { [q6]: "getAttr", [r6]: [{ [s6]: a6 }, "supportsFIPS"] }] };
var l6 = { [q6]: "booleanEquals", [r6]: [true, { [q6]: "getAttr", [r6]: [{ [s6]: a6 }, "supportsDualStack"] }] };
var m6 = [g6];
var n6 = [h6];
var o6 = [i6];
var _data6 = { version: "1.0", parameters: { Region: e6, UseDualStack: f6, UseFIPS: f6, Endpoint: e6 }, rules: [{ conditions: [{ [q6]: "aws.partition", [r6]: [{ [s6]: "Region" }], assign: a6 }], type: b6, rules: [{ conditions: [{ [q6]: "isSet", [r6]: m6 }, { [q6]: "parseURL", [r6]: m6, assign: "url" }], type: b6, rules: [{ conditions: n6, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c6 }, { type: b6, rules: [{ conditions: o6, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c6 }, { endpoint: { url: g6, properties: j6, headers: j6 }, type: d6 }] }] }, { conditions: [h6, i6], type: b6, rules: [{ conditions: [k6, l6], type: b6, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c6 }] }, { conditions: n6, type: b6, rules: [{ conditions: [k6], type: b6, rules: [{ type: b6, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c6 }] }, { conditions: o6, type: b6, rules: [{ conditions: [l6], type: b6, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c6 }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j6, headers: j6 }, type: d6 }] }] };
var ruleSet6 = _data6;

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver6 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint2(ruleSet6, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.shared.js
var getRuntimeConfig10 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2019-06-10",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver6,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSO OIDC",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/runtimeConfig.js
var getRuntimeConfig11 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig10(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default8.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/SSOOIDCClient.js
var SSOOIDCClient2 = class extends Client {
  static {
    __name(this, "SSOOIDCClient");
  }
  constructor(configuration) {
    const _config_0 = getRuntimeConfig11(configuration);
    const _config_1 = resolveClientEndpointParameters8(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveUserAgentConfig2(_config_5);
    super(_config_6);
    this.config = _config_6;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/SSOOIDCServiceException.js
var SSOOIDCServiceException2 = class _SSOOIDCServiceException2 extends ServiceException {
  static {
    __name(this, "SSOOIDCServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSOOIDCServiceException2.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/models/models_0.js
var AccessDeniedException2 = class _AccessDeniedException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "AccessDeniedException");
  }
  constructor(opts) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts
    });
    this.name = "AccessDeniedException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _AccessDeniedException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var AuthorizationPendingException2 = class _AuthorizationPendingException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "AuthorizationPendingException");
  }
  constructor(opts) {
    super({
      name: "AuthorizationPendingException",
      $fault: "client",
      ...opts
    });
    this.name = "AuthorizationPendingException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _AuthorizationPendingException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var ExpiredTokenException4 = class _ExpiredTokenException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "ExpiredTokenException");
  }
  constructor(opts) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts
    });
    this.name = "ExpiredTokenException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _ExpiredTokenException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InternalServerException2 = class _InternalServerException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "InternalServerException");
  }
  constructor(opts) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerException";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalServerException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidClientException2 = class _InvalidClientException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "InvalidClientException");
  }
  constructor(opts) {
    super({
      name: "InvalidClientException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidClientException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidGrantException2 = class _InvalidGrantException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "InvalidGrantException");
  }
  constructor(opts) {
    super({
      name: "InvalidGrantException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidGrantException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidGrantException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidRequestException4 = class _InvalidRequestException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "InvalidRequestException");
  }
  constructor(opts) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidRequestException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidRequestException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var InvalidScopeException2 = class _InvalidScopeException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "InvalidScopeException");
  }
  constructor(opts) {
    super({
      name: "InvalidScopeException",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidScopeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidScopeException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var SlowDownException2 = class _SlowDownException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "SlowDownException");
  }
  constructor(opts) {
    super({
      name: "SlowDownException",
      $fault: "client",
      ...opts
    });
    this.name = "SlowDownException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _SlowDownException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnauthorizedClientException2 = class _UnauthorizedClientException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "UnauthorizedClientException");
  }
  constructor(opts) {
    super({
      name: "UnauthorizedClientException",
      $fault: "client",
      ...opts
    });
    this.name = "UnauthorizedClientException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnauthorizedClientException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};
var UnsupportedGrantTypeException2 = class _UnsupportedGrantTypeException2 extends SSOOIDCServiceException2 {
  static {
    __name(this, "UnsupportedGrantTypeException");
  }
  constructor(opts) {
    super({
      name: "UnsupportedGrantTypeException",
      $fault: "client",
      ...opts
    });
    this.name = "UnsupportedGrantTypeException";
    this.$fault = "client";
    Object.setPrototypeOf(this, _UnsupportedGrantTypeException2.prototype);
    this.error = opts.error;
    this.error_description = opts.error_description;
  }
};

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/protocols/Aws_restJson1.js
var se_CreateTokenCommand2 = /* @__PURE__ */ __name(async (input, context8) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const headers = {
    "content-type": "application/json"
  };
  const resolvedPath = `${basePath14?.endsWith("/") ? basePath14.slice(0, -1) : basePath14 || ""}/token`;
  let body;
  body = JSON.stringify(take(input, {
    clientId: [],
    clientSecret: [],
    code: [],
    deviceCode: [],
    grantType: [],
    redirectUri: [],
    refreshToken: [],
    scope: (_) => _json(_)
  }));
  return new HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
}, "se_CreateTokenCommand");
var de_CreateTokenCommand2 = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CreateTokenCommandError2(output, context8);
  }
  const contents = map({
    $metadata: deserializeMetadata8(output)
  });
  const data = expectNonNull(expectObject(await parseBody7(output.body, context8)), "body");
  const doc = take(data, {
    accessToken: expectString,
    expiresIn: expectInt32,
    idToken: expectString,
    refreshToken: expectString,
    tokenType: expectString
  });
  Object.assign(contents, doc);
  return contents;
}, "de_CreateTokenCommand");
var de_CreateTokenCommandError2 = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody7(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode4(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ssooidc#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes2(parsedOutput, context8);
    case "AuthorizationPendingException":
    case "com.amazonaws.ssooidc#AuthorizationPendingException":
      throw await de_AuthorizationPendingExceptionRes2(parsedOutput, context8);
    case "ExpiredTokenException":
    case "com.amazonaws.ssooidc#ExpiredTokenException":
      throw await de_ExpiredTokenExceptionRes4(parsedOutput, context8);
    case "InternalServerException":
    case "com.amazonaws.ssooidc#InternalServerException":
      throw await de_InternalServerExceptionRes2(parsedOutput, context8);
    case "InvalidClientException":
    case "com.amazonaws.ssooidc#InvalidClientException":
      throw await de_InvalidClientExceptionRes2(parsedOutput, context8);
    case "InvalidGrantException":
    case "com.amazonaws.ssooidc#InvalidGrantException":
      throw await de_InvalidGrantExceptionRes2(parsedOutput, context8);
    case "InvalidRequestException":
    case "com.amazonaws.ssooidc#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes4(parsedOutput, context8);
    case "InvalidScopeException":
    case "com.amazonaws.ssooidc#InvalidScopeException":
      throw await de_InvalidScopeExceptionRes2(parsedOutput, context8);
    case "SlowDownException":
    case "com.amazonaws.ssooidc#SlowDownException":
      throw await de_SlowDownExceptionRes2(parsedOutput, context8);
    case "UnauthorizedClientException":
    case "com.amazonaws.ssooidc#UnauthorizedClientException":
      throw await de_UnauthorizedClientExceptionRes2(parsedOutput, context8);
    case "UnsupportedGrantTypeException":
    case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
      throw await de_UnsupportedGrantTypeExceptionRes2(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError8({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_CreateTokenCommandError");
var throwDefaultError8 = withBaseException(SSOOIDCServiceException2);
var de_AccessDeniedExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new AccessDeniedException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_AccessDeniedExceptionRes");
var de_AuthorizationPendingExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new AuthorizationPendingException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_AuthorizationPendingExceptionRes");
var de_ExpiredTokenExceptionRes4 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new ExpiredTokenException4({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_ExpiredTokenExceptionRes");
var de_InternalServerExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InternalServerException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InternalServerExceptionRes");
var de_InvalidClientExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidClientException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidClientExceptionRes");
var de_InvalidGrantExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidGrantException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidGrantExceptionRes");
var de_InvalidRequestExceptionRes4 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException4({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidRequestExceptionRes");
var de_InvalidScopeExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidScopeException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_InvalidScopeExceptionRes");
var de_SlowDownExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new SlowDownException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_SlowDownExceptionRes");
var de_UnauthorizedClientExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedClientException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_UnauthorizedClientExceptionRes");
var de_UnsupportedGrantTypeExceptionRes2 = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const contents = map({});
  const data = parsedOutput.body;
  const doc = take(data, {
    error: expectString,
    error_description: expectString
  });
  Object.assign(contents, doc);
  const exception = new UnsupportedGrantTypeException2({
    $metadata: deserializeMetadata8(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
}, "de_UnsupportedGrantTypeExceptionRes");
var deserializeMetadata8 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString7 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var parseBody7 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString7(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
}), "parseBody");
var parseErrorBody7 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody7(errorBody, context8);
  value.message = value.message ?? value.Message;
  return value;
}, "parseErrorBody");
var loadRestJsonErrorCode4 = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k10) => k10.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");

// ../../node_modules/@aws-sdk/client-sso-oidc/dist-es/commands/CreateTokenCommand.js
var CreateTokenCommand2 = class _CreateTokenCommand2 extends Command {
  static {
    __name(this, "CreateTokenCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _CreateTokenCommand2.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSOOIDCClient";
    const commandName = "CreateTokenCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_CreateTokenCommand2(input, context8);
  }
  deserialize(output, context8) {
    return de_CreateTokenCommand2(output, context8);
  }
};

// ../../node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var ssoOidcClientsHash2 = {};
var getSsoOidcClient2 = /* @__PURE__ */ __name((ssoRegion) => {
  if (ssoOidcClientsHash2[ssoRegion]) {
    return ssoOidcClientsHash2[ssoRegion];
  }
  const ssoOidcClient = new SSOOIDCClient2({ region: ssoRegion });
  ssoOidcClientsHash2[ssoRegion] = ssoOidcClient;
  return ssoOidcClient;
}, "getSsoOidcClient");

// ../../node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken2 = /* @__PURE__ */ __name((ssoToken, ssoRegion) => {
  const ssoOidcClient = getSsoOidcClient2(ssoRegion);
  return ssoOidcClient.send(new CreateTokenCommand2({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
}, "getNewSsoOidcToken");

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var validateTokenExpiry2 = /* @__PURE__ */ __name((token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new TokenProviderError(`Token is expired. ${REFRESH_MESSAGE2}`, false);
  }
}, "validateTokenExpiry");

// ../../node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var validateTokenKey2 = /* @__PURE__ */ __name((key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE2}`, false);
  }
}, "validateTokenKey");

// ../../node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
import { promises as fsPromises4 } from "fs";
var { writeFile: writeFile2 } = fsPromises4;
var writeSSOTokenToFile2 = /* @__PURE__ */ __name((id, ssoToken) => {
  const tokenFilepath = getSSOTokenFilepath(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile2(tokenFilepath, tokenString);
}, "writeSSOTokenToFile");

// ../../node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var lastRefreshAttemptTime2 = /* @__PURE__ */ new Date(0);
var fromSso2 = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const profiles = await parseKnownFiles(init2);
  const profileName = getProfileName(init2);
  const profile = profiles[profileName];
  if (!profile) {
    throw new TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await loadSsoSessionData(init2);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await getSSOTokenFromFile(ssoSessionName);
  } catch (e10) {
    throw new TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE2}`, false);
  }
  validateTokenKey2("accessToken", ssoToken.accessToken);
  validateTokenKey2("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS3) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime2.getTime() < 30 * 1e3) {
    validateTokenExpiry2(existingToken);
    return existingToken;
  }
  validateTokenKey2("clientId", ssoToken.clientId, true);
  validateTokenKey2("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey2("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime2.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken2(ssoToken, ssoRegion);
    validateTokenKey2("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey2("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
    try {
      await writeSSOTokenToFile2(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {
    }
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry2(existingToken);
    return existingToken;
  }
}, "fromSso");

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var EXPIRE_WINDOW_MS4 = 15 * 60 * 1e3;
var SHOULD_FAIL_CREDENTIAL_CHAIN2 = false;
var resolveSSOCredentials2 = /* @__PURE__ */ __name(async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso2({ profile })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e10) {
      throw new CredentialsProviderError(e10.message, SHOULD_FAIL_CREDENTIAL_CHAIN2);
    }
  } else {
    try {
      token = await getSSOTokenFromFile(ssoStartUrl);
    } catch (e10) {
      throw new CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN2);
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS4) {
    throw new CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  const { accessToken } = token;
  const sso = ssoClient || new SSOClient2({ region: ssoRegion });
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand2({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e10) {
    throw CredentialsProviderError.from(e10, SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN2);
  }
  return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
}, "resolveSSOCredentials");

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var validateSsoProfile2 = /* @__PURE__ */ __name((profile) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
  }
  return profile;
}, "validateSsoProfile");

// ../../node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var fromSSO2 = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init2;
  const profileName = getProfileName(init2);
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await parseKnownFiles(init2);
    const profile = profiles[profileName];
    if (!profile) {
      throw new CredentialsProviderError(`Profile ${profileName} was not found.`);
    }
    if (!isSsoProfile2(profile)) {
      throw new CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
    }
    if (profile?.sso_session) {
      const ssoSessions = await loadSsoSessionData(init2);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile2(profile);
    return resolveSSOCredentials2({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      profile: profileName
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
  } else {
    return resolveSSOCredentials2({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      profile: profileName
    });
  }
}, "fromSSO");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var resolveSsoCredentials2 = /* @__PURE__ */ __name((data) => {
  const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = validateSsoProfile2(data);
  return fromSSO2({
    ssoStartUrl: sso_start_url,
    ssoAccountId: sso_account_id,
    ssoSession: sso_session,
    ssoRegion: sso_region,
    ssoRoleName: sso_role_name
  })();
}, "resolveSsoCredentials");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var isStaticCredsProfile2 = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1, "isStaticCredsProfile");
var resolveStaticCredentials2 = /* @__PURE__ */ __name((profile) => Promise.resolve({
  accessKeyId: profile.aws_access_key_id,
  secretAccessKey: profile.aws_secret_access_key,
  sessionToken: profile.aws_session_token
}), "resolveStaticCredentials");

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
import { readFileSync as readFileSync2 } from "fs";

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken2 = /* @__PURE__ */ __name((init2) => () => {
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init2;
  if (!roleAssumerWithWebIdentity) {
    throw new CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity, but no role assumption callback was provided.`, false);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
}, "fromWebToken");

// ../../node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
var ENV_TOKEN_FILE2 = "AWS_WEB_IDENTITY_TOKEN_FILE";
var ENV_ROLE_ARN2 = "AWS_ROLE_ARN";
var ENV_ROLE_SESSION_NAME2 = "AWS_ROLE_SESSION_NAME";
var fromTokenFile2 = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const webIdentityTokenFile = init2?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE2];
  const roleArn = init2?.roleArn ?? process.env[ENV_ROLE_ARN2];
  const roleSessionName = init2?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME2];
  if (!webIdentityTokenFile || !roleArn) {
    throw new CredentialsProviderError("Web identity configuration not specified");
  }
  return fromWebToken2({
    ...init2,
    webIdentityToken: readFileSync2(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
}, "fromTokenFile");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var isWebIdentityProfile2 = /* @__PURE__ */ __name((arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1, "isWebIdentityProfile");
var resolveWebIdentityCredentials2 = /* @__PURE__ */ __name(async (profile, options) => fromTokenFile2({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
})(), "resolveWebIdentityCredentials");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var resolveProfileData2 = /* @__PURE__ */ __name(async (profileName, profiles, options, visitedProfiles = {}) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile2(data)) {
    return resolveStaticCredentials2(data);
  }
  if (isAssumeRoleProfile2(data)) {
    return resolveAssumeRoleCredentials2(profileName, profiles, options, visitedProfiles);
  }
  if (isStaticCredsProfile2(data)) {
    return resolveStaticCredentials2(data);
  }
  if (isWebIdentityProfile2(data)) {
    return resolveWebIdentityCredentials2(data, options);
  }
  if (isProcessProfile2(data)) {
    return resolveProcessCredentials4(options, profileName);
  }
  if (isSsoProfile2(data)) {
    return resolveSsoCredentials2(data);
  }
  throw new CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
}, "resolveProfileData");

// ../../node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var fromIni2 = /* @__PURE__ */ __name((init2 = {}) => async () => {
  const profiles = await parseKnownFiles(init2);
  return resolveProfileData2(getProfileName(init2), profiles, init2);
}, "fromIni");

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var ENV_IMDS_DISABLED3 = "AWS_EC2_METADATA_DISABLED";
var remoteProvider2 = /* @__PURE__ */ __name((init2) => {
  if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
    return fromContainerMetadata(init2);
  }
  if (process.env[ENV_IMDS_DISABLED3]) {
    return async () => {
      throw new CredentialsProviderError("EC2 Instance Metadata Service access disabled");
    };
  }
  return fromInstanceMetadata(init2);
}, "remoteProvider");

// ../../node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var defaultProvider2 = /* @__PURE__ */ __name((init2 = {}) => memoize(chain(...init2.profile || process.env[ENV_PROFILE] ? [] : [fromEnv3()], fromSSO2(init2), fromIni2(init2), fromProcess2(init2), fromTokenFile2(init2), remoteProvider2(init2), async () => {
  throw new CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials) => credentials.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5, (credentials) => credentials.expiration !== void 0), "defaultProvider");

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/ruleset.js
var F2 = "required";
var G2 = "type";
var H2 = "fn";
var I2 = "argv";
var J2 = "ref";
var a7 = false;
var b7 = true;
var c7 = "booleanEquals";
var d7 = "tree";
var e7 = "stringEquals";
var f7 = "sigv4";
var g7 = "sts";
var h7 = "us-east-1";
var i7 = "endpoint";
var j7 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
var k7 = "error";
var l7 = "getAttr";
var m7 = { [F2]: false, [G2]: "String" };
var n7 = { [F2]: true, "default": false, [G2]: "Boolean" };
var o7 = { [J2]: "Endpoint" };
var p7 = { [H2]: "isSet", [I2]: [{ [J2]: "Region" }] };
var q7 = { [J2]: "Region" };
var r7 = { [H2]: "aws.partition", [I2]: [q7], "assign": "PartitionResult" };
var s7 = { [J2]: "UseFIPS" };
var t3 = { [J2]: "UseDualStack" };
var u3 = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": f7, "signingName": g7, "signingRegion": h7 }] }, "headers": {} };
var v3 = {};
var w2 = { "conditions": [{ [H2]: e7, [I2]: [q7, "aws-global"] }], [i7]: u3, [G2]: i7 };
var x2 = { [H2]: c7, [I2]: [s7, true] };
var y2 = { [H2]: c7, [I2]: [t3, true] };
var z3 = { [H2]: c7, [I2]: [true, { [H2]: l7, [I2]: [{ [J2]: "PartitionResult" }, "supportsFIPS"] }] };
var A2 = { [J2]: "PartitionResult" };
var B2 = { [H2]: c7, [I2]: [true, { [H2]: l7, [I2]: [A2, "supportsDualStack"] }] };
var C2 = [{ [H2]: "isSet", [I2]: [o7] }];
var D2 = [x2];
var E2 = [y2];
var _data7 = { version: "1.0", parameters: { Region: m7, UseDualStack: n7, UseFIPS: n7, Endpoint: m7, UseGlobalEndpoint: n7 }, rules: [{ conditions: [{ [H2]: c7, [I2]: [{ [J2]: "UseGlobalEndpoint" }, b7] }, { [H2]: "not", [I2]: C2 }, p7, r7, { [H2]: c7, [I2]: [s7, a7] }, { [H2]: c7, [I2]: [t3, a7] }], [G2]: d7, rules: [{ conditions: [{ [H2]: e7, [I2]: [q7, "ap-northeast-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "ap-south-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "ap-southeast-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "ap-southeast-2"] }], endpoint: u3, [G2]: i7 }, w2, { conditions: [{ [H2]: e7, [I2]: [q7, "ca-central-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "eu-central-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "eu-north-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "eu-west-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "eu-west-2"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "eu-west-3"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "sa-east-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, h7] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "us-east-2"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "us-west-1"] }], endpoint: u3, [G2]: i7 }, { conditions: [{ [H2]: e7, [I2]: [q7, "us-west-2"] }], endpoint: u3, [G2]: i7 }, { endpoint: { url: j7, properties: { authSchemes: [{ name: f7, signingName: g7, signingRegion: "{Region}" }] }, headers: v3 }, [G2]: i7 }] }, { conditions: C2, [G2]: d7, rules: [{ conditions: D2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G2]: k7 }, { [G2]: d7, rules: [{ conditions: E2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G2]: k7 }, { endpoint: { url: o7, properties: v3, headers: v3 }, [G2]: i7 }] }] }, { [G2]: d7, rules: [{ conditions: [p7], [G2]: d7, rules: [{ conditions: [r7], [G2]: d7, rules: [{ conditions: [x2, y2], [G2]: d7, rules: [{ conditions: [z3, B2], [G2]: d7, rules: [{ [G2]: d7, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v3, headers: v3 }, [G2]: i7 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G2]: k7 }] }, { conditions: D2, [G2]: d7, rules: [{ conditions: [z3], [G2]: d7, rules: [{ [G2]: d7, rules: [{ conditions: [{ [H2]: e7, [I2]: ["aws-us-gov", { [H2]: l7, [I2]: [A2, "name"] }] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v3, headers: v3 }, [G2]: i7 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v3, headers: v3 }, [G2]: i7 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [G2]: k7 }] }, { conditions: E2, [G2]: d7, rules: [{ conditions: [B2], [G2]: d7, rules: [{ [G2]: d7, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v3, headers: v3 }, [G2]: i7 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", [G2]: k7 }] }, { [G2]: d7, rules: [w2, { endpoint: { url: j7, properties: v3, headers: v3 }, [G2]: i7 }] }] }] }, { error: "Invalid Configuration: Missing Region", [G2]: k7 }] }] };
var ruleSet7 = _data7;

// ../../node_modules/@aws-sdk/client-sts/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver7 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint2(ruleSet7, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.shared.js
var getRuntimeConfig12 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2011-06-15",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver7,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "STS",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sts/dist-es/runtimeConfig.js
var getRuntimeConfig13 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig12(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider3(defaultProvider2),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default6.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-sts/dist-es/STSClient.js
var STSClient2 = class _STSClient extends Client {
  static {
    __name(this, "STSClient");
  }
  constructor(configuration) {
    const _config_0 = getRuntimeConfig13(configuration);
    const _config_1 = resolveClientEndpointParameters6(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveStsAuthConfig2(_config_5, { stsClientCtor: _STSClient });
    const _config_7 = resolveUserAgentConfig2(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js
var getCustomizableStsClientCtor2 = /* @__PURE__ */ __name((baseCtor, customizations) => {
  if (!customizations)
    return baseCtor;
  else
    return class CustomizableSTSClient extends baseCtor {
      static {
        __name(this, "CustomizableSTSClient");
      }
      constructor(config) {
        super(config);
        for (const customization of customizations) {
          this.middlewareStack.use(customization);
        }
      }
    };
}, "getCustomizableStsClientCtor");
var getDefaultRoleAssumer4 = /* @__PURE__ */ __name((stsOptions = {}, stsPlugins) => getDefaultRoleAssumer3(stsOptions, getCustomizableStsClientCtor2(STSClient2, stsPlugins)), "getDefaultRoleAssumer");
var getDefaultRoleAssumerWithWebIdentity4 = /* @__PURE__ */ __name((stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity3(stsOptions, getCustomizableStsClientCtor2(STSClient2, stsPlugins)), "getDefaultRoleAssumerWithWebIdentity");
var decorateDefaultCredentialProvider4 = /* @__PURE__ */ __name((provider) => (input) => provider({
  roleAssumer: getDefaultRoleAssumer4(input),
  roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity4(input),
  ...input
}), "decorateDefaultCredentialProvider");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-ssm/dist-es/endpoint/ruleset.js
var s8 = "required";
var t4 = "fn";
var u4 = "argv";
var v5 = "ref";
var a8 = "isSet";
var b8 = "tree";
var c8 = "error";
var d8 = "endpoint";
var e8 = "PartitionResult";
var f8 = "getAttr";
var g8 = { [s8]: false, "type": "String" };
var h8 = { [s8]: true, "default": false, "type": "Boolean" };
var i8 = { [v5]: "Endpoint" };
var j8 = { [t4]: "booleanEquals", [u4]: [{ [v5]: "UseFIPS" }, true] };
var k8 = { [t4]: "booleanEquals", [u4]: [{ [v5]: "UseDualStack" }, true] };
var l8 = {};
var m8 = { [t4]: "booleanEquals", [u4]: [true, { [t4]: f8, [u4]: [{ [v5]: e8 }, "supportsFIPS"] }] };
var n8 = { [v5]: e8 };
var o8 = { [t4]: "booleanEquals", [u4]: [true, { [t4]: f8, [u4]: [n8, "supportsDualStack"] }] };
var p8 = [j8];
var q8 = [k8];
var r8 = [{ [v5]: "Region" }];
var _data8 = { version: "1.0", parameters: { Region: g8, UseDualStack: h8, UseFIPS: h8, Endpoint: g8 }, rules: [{ conditions: [{ [t4]: a8, [u4]: [i8] }], type: b8, rules: [{ conditions: p8, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c8 }, { type: b8, rules: [{ conditions: q8, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c8 }, { endpoint: { url: i8, properties: l8, headers: l8 }, type: d8 }] }] }, { type: b8, rules: [{ conditions: [{ [t4]: a8, [u4]: r8 }], type: b8, rules: [{ conditions: [{ [t4]: "aws.partition", [u4]: r8, assign: e8 }], type: b8, rules: [{ conditions: [j8, k8], type: b8, rules: [{ conditions: [m8, o8], type: b8, rules: [{ type: b8, rules: [{ endpoint: { url: "https://ssm-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: l8, headers: l8 }, type: d8 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c8 }] }, { conditions: p8, type: b8, rules: [{ conditions: [m8], type: b8, rules: [{ type: b8, rules: [{ conditions: [{ [t4]: "stringEquals", [u4]: ["aws-us-gov", { [t4]: f8, [u4]: [n8, "name"] }] }], endpoint: { url: "https://ssm.{Region}.amazonaws.com", properties: l8, headers: l8 }, type: d8 }, { endpoint: { url: "https://ssm-fips.{Region}.{PartitionResult#dnsSuffix}", properties: l8, headers: l8 }, type: d8 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c8 }] }, { conditions: q8, type: b8, rules: [{ conditions: [o8], type: b8, rules: [{ type: b8, rules: [{ endpoint: { url: "https://ssm.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: l8, headers: l8 }, type: d8 }] }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c8 }] }, { type: b8, rules: [{ endpoint: { url: "https://ssm.{Region}.{PartitionResult#dnsSuffix}", properties: l8, headers: l8 }, type: d8 }] }] }] }, { error: "Invalid Configuration: Missing Region", type: c8 }] }] };
var ruleSet8 = _data8;

// ../../node_modules/@aws-sdk/client-ssm/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver8 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint2(ruleSet8, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/runtimeConfig.shared.js
var getRuntimeConfig14 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2014-11-06",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver8,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "SSM",
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/runtimeConfig.js
var getRuntimeConfig15 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig14(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider4(defaultProvider2),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default5.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/SSMClient.js
var SSMClient = class extends Client {
  static {
    __name(this, "SSMClient");
  }
  constructor(configuration) {
    const _config_0 = getRuntimeConfig15(configuration);
    const _config_1 = resolveClientEndpointParameters5(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveAwsAuthConfig2(_config_5);
    const _config_7 = resolveUserAgentConfig2(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getAwsAuthPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-ssm/dist-es/models/SSMServiceException.js
var SSMServiceException = class _SSMServiceException extends ServiceException {
  static {
    __name(this, "SSMServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _SSMServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-ssm/dist-es/models/models_0.js
var InternalServerError = class _InternalServerError extends SSMServiceException {
  static {
    __name(this, "InternalServerError");
  }
  constructor(opts) {
    super({
      name: "InternalServerError",
      $fault: "server",
      ...opts
    });
    this.name = "InternalServerError";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalServerError.prototype);
    this.Message = opts.Message;
  }
};

// ../../node_modules/@aws-sdk/client-ssm/dist-es/models/models_1.js
var InvalidKeyId = class _InvalidKeyId extends SSMServiceException {
  static {
    __name(this, "InvalidKeyId");
  }
  constructor(opts) {
    super({
      name: "InvalidKeyId",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidKeyId";
    this.$fault = "client";
    Object.setPrototypeOf(this, _InvalidKeyId.prototype);
  }
};
var ParameterFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.Value && { Value: SENSITIVE_STRING }
}), "ParameterFilterSensitiveLog");
var GetParametersResultFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
  ...obj,
  ...obj.Parameters && { Parameters: obj.Parameters.map((item) => ParameterFilterSensitiveLog(item)) }
}), "GetParametersResultFilterSensitiveLog");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/protocols/Aws_json1_1.js
var se_GetParametersCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = sharedHeaders("GetParameters");
  let body;
  body = JSON.stringify(_json(input));
  return buildHttpRpcRequest4(context8, headers, "/", void 0, body);
}, "se_GetParametersCommand");
var de_GetParametersCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_GetParametersCommandError(output, context8);
  }
  const data = await parseBody8(output.body, context8);
  let contents = {};
  contents = de_GetParametersResult(data, context8);
  const response = {
    $metadata: deserializeMetadata9(output),
    ...contents
  };
  return response;
}, "de_GetParametersCommand");
var de_GetParametersCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody8(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode5(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.ssm#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context8);
    case "InvalidKeyId":
    case "com.amazonaws.ssm#InvalidKeyId":
      throw await de_InvalidKeyIdRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError9({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_GetParametersCommandError");
var de_InternalServerErrorRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InternalServerError({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InternalServerErrorRes");
var de_InvalidKeyIdRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InvalidKeyId({
    $metadata: deserializeMetadata9(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InvalidKeyIdRes");
var de_GetParametersResult = /* @__PURE__ */ __name((output, context8) => {
  return take(output, {
    InvalidParameters: _json,
    Parameters: (_) => de_ParameterList(_, context8)
  });
}, "de_GetParametersResult");
var de_Parameter = /* @__PURE__ */ __name((output, context8) => {
  return take(output, {
    ARN: expectString,
    DataType: expectString,
    LastModifiedDate: (_) => expectNonNull(parseEpochTimestamp(expectNumber(_))),
    Name: expectString,
    Selector: expectString,
    SourceResult: expectString,
    Type: expectString,
    Value: expectString,
    Version: expectLong
  });
}, "de_Parameter");
var de_ParameterList = /* @__PURE__ */ __name((output, context8) => {
  const retVal = (output || []).filter((e10) => e10 != null).map((entry) => {
    return de_Parameter(entry, context8);
  });
  return retVal;
}, "de_ParameterList");
var deserializeMetadata9 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString8 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var throwDefaultError9 = withBaseException(SSMServiceException);
var buildHttpRpcRequest4 = /* @__PURE__ */ __name(async (context8, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath14.endsWith("/") ? basePath14.slice(0, -1) + path : basePath14 + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
}, "buildHttpRpcRequest");
function sharedHeaders(operation) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AmazonSSM.${operation}`
  };
}
__name(sharedHeaders, "sharedHeaders");
var parseBody8 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString8(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
}), "parseBody");
var parseErrorBody8 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody8(errorBody, context8);
  value.message = value.message ?? value.Message;
  return value;
}, "parseErrorBody");
var loadRestJsonErrorCode5 = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k10) => k10.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");

// ../../node_modules/@aws-sdk/client-ssm/dist-es/commands/GetParametersCommand.js
var GetParametersCommand = class _GetParametersCommand extends Command {
  static {
    __name(this, "GetParametersCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _GetParametersCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "SSMClient";
    const commandName = "GetParametersCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: GetParametersResultFilterSensitiveLog
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_GetParametersCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_GetParametersCommand(output, context8);
  }
};

// ../../node_modules/sst/node/util/index.js
var ssm = new SSMClient({ region: process.env.SST_REGION });
var allVariables = {};
var _placeholder = await parseEnvironment();
function createProxy(constructName) {
  const result = new Proxy({}, {
    get(target, prop) {
      if (typeof prop === "string") {
        if (!process.env.SST_APP) {
          throw new Error(buildMissingBuiltInEnvError());
        }
        const normProp = normalizeId(prop);
        if (!(normProp in target)) {
          throw new Error(`Cannot use ${constructName}.${String(prop)}. Please make sure it is bound to this function.`);
        }
        return Reflect.get(target, normProp);
      }
      return Reflect.get(target, prop);
    }
  });
  Object.assign(result, getVariables2(constructName));
  return result;
}
__name(createProxy, "createProxy");
function getVariables2(constructName) {
  return allVariables[constructName] || {};
}
__name(getVariables2, "getVariables2");
async function parseEnvironment() {
  const variablesFromSsm = [];
  const variablesFromSecret = [];
  Object.keys(process.env).filter((name2) => name2.startsWith("SST_")).forEach((name2) => {
    const variable = parseEnvName(name2);
    if (!variable.constructName || !variable.constructId || !variable.propName) {
      return;
    }
    const value = process.env[name2];
    if (value === "__FETCH_FROM_SSM__") {
      variablesFromSsm.push(variable);
    } else if (value.startsWith("__FETCH_FROM_SECRET__:")) {
      variablesFromSecret.push([variable, value.split(":")[1]]);
    } else {
      storeVariable(variable, value);
    }
  });
  await fetchValuesFromSSM(variablesFromSsm);
  variablesFromSecret.forEach(([variable, secretName]) => {
    const value = allVariables["Secret"]?.[secretName]?.value;
    if (value) {
      storeVariable(variable, value);
    }
  });
  return allVariables;
}
__name(parseEnvironment, "parseEnvironment");
async function fetchValuesFromSSM(variablesFromSsm) {
  const ssmPaths = variablesFromSsm.map((variable) => buildSsmPath(variable));
  if (ssmPaths.length === 0)
    return;
  const results = await loadSecrets(ssmPaths);
  results.validParams.forEach((item) => {
    const variable = parseSsmPath(item.Name);
    storeVariable(variable, item.Value);
  });
  const ssmFallbackPaths = results.invalidParams.map((name2) => parseSsmPath(name2)).filter((variable) => variable.constructName === "Secret").map((variable) => buildSsmFallbackPath(variable));
  if (ssmFallbackPaths.length === 0)
    return;
  const fallbackResults = await loadSecrets(ssmFallbackPaths);
  fallbackResults.validParams.forEach((item) => {
    const variable = parseSsmFallbackPath(item.Name);
    storeVariable(variable, item.Value);
  });
  const missingSecrets = fallbackResults.invalidParams.map((name2) => parseSsmFallbackPath(name2)).filter((variable) => variable.constructName === "Secret").map((variable) => variable.constructId);
  if (missingSecrets.length > 0) {
    throw new Error(`The following secret values are not set in the "${process.env.SST_STAGE} stage": ${missingSecrets.join(", ")}`);
  }
}
__name(fetchValuesFromSSM, "fetchValuesFromSSM");
async function loadSecrets(paths) {
  const chunks = [];
  for (let i10 = 0; i10 < paths.length; i10 += 10) {
    chunks.push(paths.slice(i10, i10 + 10));
  }
  const validParams = [];
  const invalidParams = [];
  await Promise.all(chunks.map(async (chunk) => {
    const command = new GetParametersCommand({
      Names: chunk,
      WithDecryption: true
    });
    const result = await ssm.send(command);
    validParams.push(...result.Parameters || []);
    invalidParams.push(...result.InvalidParameters || []);
  }));
  return { validParams, invalidParams };
}
__name(loadSecrets, "loadSecrets");
function parseEnvName(env3) {
  const [_SST, constructName, propName, ...idParts] = env3.split("_");
  return {
    constructName,
    constructId: idParts.join("_"),
    propName
  };
}
__name(parseEnvName, "parseEnvName");
function parseSsmPath(path) {
  const prefix = ssmPrefix();
  const parts = path.substring(prefix.length).split("/");
  return {
    constructName: parts[0],
    constructId: parts[1],
    propName: parts[2]
  };
}
__name(parseSsmPath, "parseSsmPath");
function parseSsmFallbackPath(path) {
  const parts = path.split("/");
  return {
    constructName: parts[4],
    constructId: parts[5],
    propName: parts[6]
  };
}
__name(parseSsmFallbackPath, "parseSsmFallbackPath");
function buildSsmPath(data) {
  return `${ssmPrefix()}${data.constructName}/${data.constructId}/${data.propName}`;
}
__name(buildSsmPath, "buildSsmPath");
function buildSsmFallbackPath(data) {
  return `/sst/${process.env.SST_APP}/.fallback/${data.constructName}/${data.constructId}/${data.propName}`;
}
__name(buildSsmFallbackPath, "buildSsmFallbackPath");
function normalizeId(name2) {
  return name2.replace(/-/g, "_");
}
__name(normalizeId, "normalizeId");
function ssmPrefix() {
  return process.env.SST_SSM_PREFIX || "";
}
__name(ssmPrefix, "ssmPrefix");
function storeVariable(variable, value) {
  const { constructId: id, constructName: c11, propName: prop } = variable;
  allVariables[c11] = allVariables[c11] || {};
  allVariables[c11][id] = allVariables[c11][id] || {};
  allVariables[c11][id][prop] = value;
}
__name(storeVariable, "storeVariable");
function buildMissingBuiltInEnvError() {
  if (process.env.SST) {
    return [
      "",
      `Cannot access bound resources. This usually happens if the "sst/node" package is used at build time. For example:`,
      "",
      `  - The "sst/node" package is used inside the "getStaticProps()" function of a Next.js app.`,
      `  - The "sst/node" package is used at the top level outside of the "load()" function of a SvelteKit app.`,
      "",
      `Please wrap your build script with "sst bind". For example, "sst bind next build".`,
      ""
    ].join("\n");
  }
  if (process.env.AWS_LAMBDA_FUNCTION_NAME || process.env.CODEBUILD_BUILD_ARN) {
    return `Cannot access bound resources. This usually happens if you are using an older version of SST. Please update SST to the latest version.`;
  }
  return `Cannot access bound resources. This usually happens if the "sst/node" package is used on the client-side. Ensure that it's only called in your server functions.`;
}
__name(buildMissingBuiltInEnvError, "buildMissingBuiltInEnvError");

// ../../node_modules/sst/node/queue/index.js
var Queue = /* @__PURE__ */ createProxy("Queue");

// src/create-message.ts
var sqs = new SQSClient();
function createMessage({
  kind,
  contentShape,
  metadataShape
}) {
  const queueUrl = Queue.ExtractQueue.queueUrl;
  const messageSchema = z2.object({
    kind: z2.literal(kind),
    content: z2.object(contentShape),
    metadata: z2.object(metadataShape)
  });
  const send = /* @__PURE__ */ __name(async (content, metadata2) => {
    await sqs.send(new SendMessageCommand({
      QueueUrl: queueUrl,
      MessageBody: JSON.stringify(messageSchema.parse({ content, metadata: metadata2, kind }))
    }));
  }, "send");
  const sendAll = /* @__PURE__ */ __name(async (contentArray, metadata2) => {
    const batches = [];
    for (let i10 = 0; i10 < contentArray.length; i10 += 10) {
      const contentBatch = contentArray.slice(i10, i10 + 10);
      const Entries = contentBatch.map((content) => JSON.stringify(messageSchema.parse({ content, metadata: metadata2, kind }))).map((MessageBody) => ({
        Id: nanoid(),
        MessageBody
      }));
      batches.push(Entries);
    }
    const result = await Promise.allSettled(batches.map((batch) => sqs.send(new SendMessageBatchCommand({
      QueueUrl: queueUrl,
      Entries: batch
    }))));
    result.forEach((r10, i10) => {
      if (r10.status === "rejected") {
        console.error("batch failed", r10.reason, batches[i10]);
      }
    });
  }, "sendAll");
  return {
    kind,
    send,
    sendAll,
    shapes: {
      contentShape,
      metadataShape
    }
  };
}
__name(createMessage, "createMessage");
function createLog(kind, event, logMap2) {
  const propertiesToLog = logMap2.get(kind);
  if (!propertiesToLog)
    return;
  const properties = propertiesToLog.map((property) => property.split("."));
  const log = properties.map((property) => property.reduce((acc, curr) => ({ key: property.join("."), value: acc.value[curr] || acc.value }), { key: "", value: event })).filter((value) => !!value);
  const logMessage = log.map(({ key, value }) => `- ${key}: ${JSON.stringify(value)}`).join("\n");
  return `${kind}
${logMessage}`;
}
__name(createLog, "createLog");
function QueueHandler(map2, logMap2) {
  return async (event) => {
    if (event.Records.length > 1)
      console.warn("WARNING: QueueHandler should process 1 message but got", event.Records.length);
    for (const record of event.Records) {
      const parsedEvent = JSON.parse(record.body);
      const { sender: sender7, handler: handler3 } = map2.get(parsedEvent.kind) ?? { sender: null, handler: null };
      if (!sender7 || !handler3) {
        console.error("No handler for message kind", parsedEvent.kind);
        break;
      }
      const schema = z2.object({
        content: z2.object(sender7.shapes.contentShape),
        metadata: z2.object(sender7.shapes.metadataShape),
        kind: z2.string()
      });
      const validatedEvent = schema.parse(parsedEvent);
      try {
        await handler3(validatedEvent);
        console.log("Handled message", createLog(validatedEvent.kind, validatedEvent, logMap2));
      } catch (e10) {
        console.error("Failed to handle message", e10, createLog(validatedEvent.kind, validatedEvent, logMap2));
        throw e10;
      }
    }
  };
}
__name(QueueHandler, "QueueHandler");
function createMessageHandler({
  kind,
  contentShape,
  metadataShape,
  handler: handler3
}) {
  const sender7 = createMessage({ kind, contentShape, metadataShape });
  return {
    sender: sender7,
    handler: handler3
  };
}
__name(createMessageHandler, "createMessageHandler");

// src/messages.ts
var paginationSchema = z2.object({
  page: z2.number(),
  perPage: z2.number(),
  totalPages: z2.number()
});
var metadataSchema = z2.object({
  version: z2.number(),
  timestamp: z2.number(),
  caller: z2.string(),
  sourceControl: z2.literal("github").or(z2.literal("gitlab")),
  userId: z2.string()
});

// ../../node_modules/@libsql/client/lib-esm/api.js
var LibsqlError = class extends Error {
  static {
    __name(this, "LibsqlError");
  }
  /** Machine-readable error code. */
  code;
  constructor(message, code2, cause) {
    if (code2 !== void 0) {
      message = `${code2}: ${message}`;
    }
    super(message, { cause });
    this.code = code2;
    this.name = "LibsqlError";
  }
};

// ../../node_modules/@libsql/client/lib-esm/uri.js
function parseUri(text2) {
  const match = URI_RE.exec(text2);
  if (match === null) {
    throw new LibsqlError("The URL is not in a valid format", "URL_INVALID");
  }
  const groups = match.groups;
  const scheme = groups["scheme"];
  const authority = groups["authority"] !== void 0 ? parseAuthority(groups["authority"]) : void 0;
  const path = percentDecode(groups["path"]);
  const query = groups["query"] !== void 0 ? parseQuery(groups["query"]) : void 0;
  const fragment = groups["fragment"] !== void 0 ? percentDecode(groups["fragment"]) : void 0;
  return { scheme, authority, path, query, fragment };
}
__name(parseUri, "parseUri");
var URI_RE = (() => {
  const SCHEME = "(?<scheme>[A-Za-z][A-Za-z.+-]*)";
  const AUTHORITY = "(?<authority>[^/?#]*)";
  const PATH = "(?<path>[^?#]*)";
  const QUERY = "(?<query>[^#]*)";
  const FRAGMENT = "(?<fragment>.*)";
  return new RegExp(`^${SCHEME}:(//${AUTHORITY})?${PATH}(\\?${QUERY})?(#${FRAGMENT})?$`, "su");
})();
function parseAuthority(text2) {
  const match = AUTHORITY_RE.exec(text2);
  if (match === null) {
    throw new LibsqlError("The authority part of the URL is not in a valid format", "URL_INVALID");
  }
  const groups = match.groups;
  const host = percentDecode(groups["host_br"] ?? groups["host"]);
  const port = groups["port"] ? parseInt(groups["port"], 10) : void 0;
  const userinfo = groups["username"] !== void 0 ? {
    username: percentDecode(groups["username"]),
    password: groups["password"] !== void 0 ? percentDecode(groups["password"]) : void 0
  } : void 0;
  return { host, port, userinfo };
}
__name(parseAuthority, "parseAuthority");
var AUTHORITY_RE = (() => {
  const USERINFO = "(?<username>[^:]*)(:(?<password>.*))?";
  const HOST = "((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))";
  const PORT = "(?<port>[0-9]*)";
  return new RegExp(`^(${USERINFO}@)?${HOST}(:${PORT})?$`, "su");
})();
function parseQuery(text2) {
  const sequences = text2.split("&");
  const pairs = [];
  for (const sequence of sequences) {
    if (sequence === "") {
      continue;
    }
    let key;
    let value;
    const splitIdx = sequence.indexOf("=");
    if (splitIdx < 0) {
      key = sequence;
      value = "";
    } else {
      key = sequence.substring(0, splitIdx);
      value = sequence.substring(splitIdx + 1);
    }
    pairs.push({
      key: percentDecode(key.replaceAll("+", " ")),
      value: percentDecode(value.replaceAll("+", " "))
    });
  }
  return { pairs };
}
__name(parseQuery, "parseQuery");
function percentDecode(text2) {
  try {
    return decodeURIComponent(text2);
  } catch (e10) {
    if (e10 instanceof URIError) {
      throw new LibsqlError(`URL component has invalid percent encoding: ${e10}`, "URL_INVALID", e10);
    }
    throw e10;
  }
}
__name(percentDecode, "percentDecode");
function encodeBaseUrl(scheme, authority, path) {
  if (authority === void 0) {
    throw new LibsqlError(`URL with scheme ${JSON.stringify(scheme + ":")} requires authority (the "//" part)`, "URL_INVALID");
  }
  const schemeText = `${scheme}:`;
  const hostText = encodeHost(authority.host);
  const portText = encodePort(authority.port);
  const userinfoText = encodeUserinfo(authority.userinfo);
  const authorityText = `//${userinfoText}${hostText}${portText}`;
  let pathText = path.split("/").map(encodeURIComponent).join("/");
  if (pathText !== "" && !pathText.startsWith("/")) {
    pathText = "/" + pathText;
  }
  return new URL(`${schemeText}${authorityText}${pathText}`);
}
__name(encodeBaseUrl, "encodeBaseUrl");
function encodeHost(host) {
  return host.includes(":") ? `[${encodeURI(host)}]` : encodeURI(host);
}
__name(encodeHost, "encodeHost");
function encodePort(port) {
  return port !== void 0 ? `:${port}` : "";
}
__name(encodePort, "encodePort");
function encodeUserinfo(userinfo) {
  if (userinfo === void 0) {
    return "";
  }
  const usernameText = encodeURIComponent(userinfo.username);
  const passwordText = userinfo.password !== void 0 ? `:${encodeURIComponent(userinfo.password)}` : "";
  return `${usernameText}${passwordText}@`;
}
__name(encodeUserinfo, "encodeUserinfo");

// ../../node_modules/js-base64/base64.mjs
var version = "3.7.5";
var VERSION = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a10) => {
  let tab = {};
  a10.forEach((c11, i10) => tab[c11] = i10);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = /* @__PURE__ */ __name((src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_"), "_mkUriSafe");
var _tidyB64 = /* @__PURE__ */ __name((s10) => s10.replace(/[^A-Za-z0-9\+\/]/g, ""), "_tidyB64");
var btoaPolyfill = /* @__PURE__ */ __name((bin) => {
  let u32, c0, c1, c22, asc2 = "";
  const pad = bin.length % 3;
  for (let i10 = 0; i10 < bin.length; ) {
    if ((c0 = bin.charCodeAt(i10++)) > 255 || (c1 = bin.charCodeAt(i10++)) > 255 || (c22 = bin.charCodeAt(i10++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c22;
    asc2 += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc2.slice(0, pad - 3) + "===".substring(pad) : asc2;
}, "btoaPolyfill");
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i10 = 0, l10 = u8a.length; i10 < l10; i10 += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i10, i10 + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = /* @__PURE__ */ __name((u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a), "fromUint8Array");
var cb_utob = /* @__PURE__ */ __name((c11) => {
  if (c11.length < 2) {
    var cc = c11.charCodeAt(0);
    return cc < 128 ? c11 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c11.charCodeAt(0) - 55296) * 1024 + (c11.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
}, "cb_utob");
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = /* @__PURE__ */ __name((u6) => u6.replace(re_utob, cb_utob), "utob");
var _encode = _hasBuffer ? (s10) => Buffer.from(s10, "utf8").toString("base64") : _TE ? (s10) => _fromUint8Array(_TE.encode(s10)) : (s10) => _btoa(utob(s10));
var encode = /* @__PURE__ */ __name((src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src), "encode");
var encodeURI2 = /* @__PURE__ */ __name((src) => encode(src, true), "encodeURI");
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = /* @__PURE__ */ __name((cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
}, "cb_btou");
var btou = /* @__PURE__ */ __name((b11) => b11.replace(re_btou, cb_btou), "btou");
var atobPolyfill = /* @__PURE__ */ __name((asc2) => {
  asc2 = asc2.replace(/\s+/g, "");
  if (!b64re.test(asc2))
    throw new TypeError("malformed base64.");
  asc2 += "==".slice(2 - (asc2.length & 3));
  let u24, bin = "", r1, r22;
  for (let i10 = 0; i10 < asc2.length; ) {
    u24 = b64tab[asc2.charAt(i10++)] << 18 | b64tab[asc2.charAt(i10++)] << 12 | (r1 = b64tab[asc2.charAt(i10++)]) << 6 | (r22 = b64tab[asc2.charAt(i10++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r22 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
}, "atobPolyfill");
var _atob = _hasatob ? (asc2) => atob(_tidyB64(asc2)) : _hasBuffer ? (asc2) => Buffer.from(asc2, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a10) => _U8Afrom(Buffer.from(a10, "base64")) : (a10) => _U8Afrom(_atob(a10).split("").map((c11) => c11.charCodeAt(0)));
var toUint8Array2 = /* @__PURE__ */ __name((a10) => _toUint8Array(_unURI(a10)), "toUint8Array");
var _decode = _hasBuffer ? (a10) => Buffer.from(a10, "base64").toString("utf8") : _TD ? (a10) => _TD.decode(_toUint8Array(a10)) : (a10) => btou(_atob(a10));
var _unURI = /* @__PURE__ */ __name((a10) => _tidyB64(a10.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/")), "_unURI");
var decode = /* @__PURE__ */ __name((src) => _decode(_unURI(src)), "decode");
var isValid2 = /* @__PURE__ */ __name((src) => {
  if (typeof src !== "string")
    return false;
  const s10 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s10) || !/[^\s0-9a-zA-Z\-_]/.test(s10);
}, "isValid");
var _noEnum = /* @__PURE__ */ __name((v7) => {
  return {
    value: v7,
    enumerable: false,
    writable: true,
    configurable: true
  };
}, "_noEnum");
var extendString = /* @__PURE__ */ __name(function() {
  const _add = /* @__PURE__ */ __name((name2, body) => Object.defineProperty(String.prototype, name2, _noEnum(body)), "_add");
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array2(this);
  });
}, "extendString");
var extendUint8Array = /* @__PURE__ */ __name(function() {
  const _add = /* @__PURE__ */ __name((name2, body) => Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body)), "_add");
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
}, "extendUint8Array");
var extendBuiltins = /* @__PURE__ */ __name(() => {
  extendString();
  extendUint8Array();
}, "extendBuiltins");
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid: isValid2,
  fromUint8Array,
  toUint8Array: toUint8Array2,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// ../../node_modules/@libsql/client/lib-esm/util.js
var supportedUrlLink = "https://github.com/libsql/libsql-client-ts#supported-urls";
function transactionModeToBegin(mode) {
  if (mode === "write") {
    return "BEGIN IMMEDIATE";
  } else if (mode === "read") {
    return "BEGIN TRANSACTION READONLY";
  } else if (mode === "deferred") {
    return "BEGIN DEFERRED";
  } else {
    throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"');
  }
}
__name(transactionModeToBegin, "transactionModeToBegin");
var ResultSetImpl = class {
  static {
    __name(this, "ResultSetImpl");
  }
  columns;
  rows;
  rowsAffected;
  lastInsertRowid;
  constructor(columns, rows, rowsAffected, lastInsertRowid) {
    this.columns = columns;
    this.rows = rows;
    this.rowsAffected = rowsAffected;
    this.lastInsertRowid = lastInsertRowid;
  }
  toJSON() {
    return {
      "columns": this.columns,
      "rows": this.rows.map(rowToJson),
      "rowsAffected": this.rowsAffected,
      "lastInsertRowid": this.lastInsertRowid !== void 0 ? "" + this.lastInsertRowid : null
    };
  }
};
function rowToJson(row) {
  return Array.prototype.map.call(row, valueToJson);
}
__name(rowToJson, "rowToJson");
function valueToJson(value) {
  if (typeof value === "bigint") {
    return "" + value;
  } else if (value instanceof ArrayBuffer) {
    return gBase64.fromUint8Array(new Uint8Array(value));
  } else {
    return value;
  }
}
__name(valueToJson, "valueToJson");

// ../../node_modules/@libsql/client/lib-esm/config.js
function expandConfig(config, preferHttp) {
  if (typeof config !== "object") {
    throw new TypeError(`Expected client configuration as object, got ${typeof config}`);
  }
  const uri = parseUri(config.url);
  let tls = config.tls;
  let authToken = config.authToken;
  for (const { key, value } of uri.query?.pairs ?? []) {
    if (key === "authToken") {
      authToken = value ? value : void 0;
    } else if (key === "tls") {
      if (value === "0") {
        tls = false;
      } else if (value === "1") {
        tls = true;
      } else {
        throw new LibsqlError(`Unknown value for the "tls" query argument: ${JSON.stringify(value)}. Supported values are "0" and "1"`, "URL_INVALID");
      }
    } else {
      throw new LibsqlError(`Unknown URL query parameter ${JSON.stringify(key)}`, "URL_PARAM_NOT_SUPPORTED");
    }
  }
  const uriScheme = uri.scheme.toLowerCase();
  let scheme;
  if (uriScheme === "libsql") {
    if (tls === false) {
      if (uri.authority?.port === void 0) {
        throw new LibsqlError('A "libsql:" URL with ?tls=0 must specify an explicit port', "URL_INVALID");
      }
      scheme = preferHttp ? "http" : "ws";
    } else {
      scheme = preferHttp ? "https" : "wss";
    }
  } else if (uriScheme === "http" || uriScheme === "ws") {
    scheme = uriScheme;
    tls ??= false;
  } else if (uriScheme === "https" || uriScheme === "wss" || uriScheme === "file") {
    scheme = uriScheme;
  } else {
    throw new LibsqlError(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(uri.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (uri.fragment !== void 0) {
    throw new LibsqlError(`URL fragments are not supported: ${JSON.stringify("#" + uri.fragment)}`, "URL_INVALID");
  }
  const intMode = "" + (config.intMode ?? "number");
  if (intMode !== "number" && intMode !== "bigint" && intMode !== "string") {
    throw new TypeError(`Invalid value for intMode, expected "number", "bigint" or "string",             got ${JSON.stringify(intMode)}`);
  }
  return {
    scheme,
    tls: tls ?? true,
    authority: uri.authority,
    path: uri.path,
    authToken,
    intMode,
    fetch: config.fetch
  };
}
__name(expandConfig, "expandConfig");

// ../../node_modules/@libsql/client/lib-esm/sqlite3.js
var import_better_sqlite3 = __toESM(require_lib(), 1);
import { Buffer as Buffer5 } from "node:buffer";
function _createClient(config) {
  if (config.scheme !== "file") {
    throw new LibsqlError(`URL scheme ${JSON.stringify(config.scheme + ":")} is not supported by the local sqlite3 client. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  const authority = config.authority;
  if (authority !== void 0) {
    const host = authority.host.toLowerCase();
    if (host !== "" && host !== "localhost") {
      throw new LibsqlError(`Invalid host in file URL: ${JSON.stringify(authority.host)}. A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). For more information, please read ${supportedUrlLink}`, "URL_INVALID");
    }
    if (authority.port !== void 0) {
      throw new LibsqlError("File URL cannot have a port", "URL_INVALID");
    }
    if (authority.userinfo !== void 0) {
      throw new LibsqlError("File URL cannot have username and password", "URL_INVALID");
    }
  }
  const path = config.path;
  const options = {};
  const db8 = new import_better_sqlite3.default(path, options);
  try {
    executeStmt(db8, "SELECT 1 AS checkThatTheDatabaseCanBeOpened", config.intMode);
  } finally {
    db8.close();
  }
  return new Sqlite3Client(path, options, config.intMode);
}
__name(_createClient, "_createClient");
var Sqlite3Client = class {
  static {
    __name(this, "Sqlite3Client");
  }
  #path;
  #options;
  #intMode;
  closed;
  protocol;
  /** @private */
  constructor(path, options, intMode) {
    this.#path = path;
    this.#options = options;
    this.#intMode = intMode;
    this.closed = false;
    this.protocol = "file";
  }
  async execute(stmt) {
    this.#checkNotClosed();
    const db8 = new import_better_sqlite3.default(this.#path, this.#options);
    try {
      return executeStmt(db8, stmt, this.#intMode);
    } finally {
      db8.close();
    }
  }
  async batch(stmts, mode = "deferred") {
    this.#checkNotClosed();
    const db8 = new import_better_sqlite3.default(this.#path, this.#options);
    try {
      executeStmt(db8, transactionModeToBegin(mode), this.#intMode);
      const resultSets = stmts.map((stmt) => executeStmt(db8, stmt, this.#intMode));
      executeStmt(db8, "COMMIT", this.#intMode);
      return resultSets;
    } finally {
      db8.close();
    }
  }
  async transaction(mode = "write") {
    this.#checkNotClosed();
    const db8 = new import_better_sqlite3.default(this.#path, this.#options);
    try {
      executeStmt(db8, transactionModeToBegin(mode), this.#intMode);
      return new Sqlite3Transaction(db8, this.#intMode);
    } catch (e10) {
      db8.close();
      throw e10;
    }
  }
  async executeMultiple(sql2) {
    this.#checkNotClosed();
    const db8 = new import_better_sqlite3.default(this.#path, this.#options);
    try {
      return executeMultiple(db8, sql2);
    } finally {
      db8.close();
    }
  }
  close() {
    this.closed = true;
  }
  #checkNotClosed() {
    if (this.closed) {
      throw new LibsqlError("The client is closed", "CLIENT_CLOSED");
    }
  }
};
var Sqlite3Transaction = class {
  static {
    __name(this, "Sqlite3Transaction");
  }
  #database;
  #intMode;
  /** @private */
  constructor(database, intMode) {
    this.#database = database;
    this.#intMode = intMode;
  }
  async execute(stmt) {
    this.#checkNotClosed();
    return executeStmt(this.#database, stmt, this.#intMode);
  }
  async batch(stmts) {
    this.#checkNotClosed();
    return stmts.map((stmt) => executeStmt(this.#database, stmt, this.#intMode));
  }
  async executeMultiple(sql2) {
    this.#checkNotClosed();
    return executeMultiple(this.#database, sql2);
  }
  async rollback() {
    if (!this.#database.open) {
      return;
    }
    executeStmt(this.#database, "ROLLBACK", this.#intMode);
    this.#database.close();
  }
  async commit() {
    this.#checkNotClosed();
    executeStmt(this.#database, "COMMIT", this.#intMode);
    this.#database.close();
  }
  close() {
    this.#database.close();
  }
  get closed() {
    return !this.#database.open;
  }
  #checkNotClosed() {
    if (!this.#database.open) {
      throw new LibsqlError("The transaction is closed", "TRANSACTION_CLOSED");
    }
  }
};
function executeStmt(db8, stmt, intMode) {
  let sql2;
  let args;
  if (typeof stmt === "string") {
    sql2 = stmt;
    args = [];
  } else {
    sql2 = stmt.sql;
    if (Array.isArray(stmt.args)) {
      args = stmt.args.map(valueToSql);
    } else {
      args = {};
      for (const name2 in stmt.args) {
        const argName = name2[0] === "@" || name2[0] === "$" || name2[0] === ":" ? name2.substring(1) : name2;
        args[argName] = valueToSql(stmt.args[name2]);
      }
    }
  }
  try {
    const sqlStmt = db8.prepare(sql2);
    sqlStmt.safeIntegers(true);
    let returnsData = true;
    try {
      sqlStmt.raw(true);
    } catch {
      returnsData = false;
    }
    if (returnsData) {
      const columns = Array.from(sqlStmt.columns().map((col) => col.name));
      const rows = sqlStmt.all(args).map((sqlRow) => {
        return rowFromSql(sqlRow, columns, intMode);
      });
      const rowsAffected = 0;
      const lastInsertRowid = void 0;
      return new ResultSetImpl(columns, rows, rowsAffected, lastInsertRowid);
    } else {
      const info = sqlStmt.run(args);
      const rowsAffected = info.changes;
      const lastInsertRowid = BigInt(info.lastInsertRowid);
      return new ResultSetImpl([], [], rowsAffected, lastInsertRowid);
    }
  } catch (e10) {
    throw mapSqliteError(e10);
  }
}
__name(executeStmt, "executeStmt");
function rowFromSql(sqlRow, columns, intMode) {
  const row = {};
  Object.defineProperty(row, "length", { value: sqlRow.length });
  for (let i10 = 0; i10 < sqlRow.length; ++i10) {
    const value = valueFromSql(sqlRow[i10], intMode);
    Object.defineProperty(row, i10, { value });
    const column = columns[i10];
    if (!Object.hasOwn(row, column)) {
      Object.defineProperty(row, column, { value, enumerable: true });
    }
  }
  return row;
}
__name(rowFromSql, "rowFromSql");
function valueFromSql(sqlValue, intMode) {
  if (typeof sqlValue === "bigint") {
    if (intMode === "number") {
      if (sqlValue < minSafeBigint || sqlValue > maxSafeBigint) {
        throw new RangeError("Received integer which cannot be safely represented as a JavaScript number");
      }
      return Number(sqlValue);
    } else if (intMode === "bigint") {
      return sqlValue;
    } else if (intMode === "string") {
      return "" + sqlValue;
    } else {
      throw new Error("Invalid value for IntMode");
    }
  } else if (sqlValue instanceof Buffer5) {
    return sqlValue.buffer;
  }
  return sqlValue;
}
__name(valueFromSql, "valueFromSql");
var minSafeBigint = -9007199254740991n;
var maxSafeBigint = 9007199254740991n;
function valueToSql(value) {
  if (typeof value === "number") {
    if (!Number.isFinite(value)) {
      throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");
    }
    return value;
  } else if (typeof value === "bigint") {
    if (value < minInteger || value > maxInteger) {
      throw new RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");
    }
    return value;
  } else if (typeof value === "boolean") {
    return value ? 1 : 0;
  } else if (value instanceof ArrayBuffer) {
    return Buffer5.from(value);
  } else if (value instanceof Date) {
    return value.valueOf();
  } else if (value === void 0) {
    throw new TypeError("undefined cannot be passed as argument to the database");
  } else {
    return value;
  }
}
__name(valueToSql, "valueToSql");
var minInteger = -9223372036854775808n;
var maxInteger = 9223372036854775807n;
function executeMultiple(db8, sql2) {
  try {
    db8.exec(sql2);
  } catch (e10) {
    throw mapSqliteError(e10);
  }
}
__name(executeMultiple, "executeMultiple");
function mapSqliteError(e10) {
  if (e10 instanceof import_better_sqlite3.default.SqliteError) {
    return new LibsqlError(e10.message, e10.code, e10);
  }
  return e10;
}
__name(mapSqliteError, "mapSqliteError");

// ../../node_modules/ws/wrapper.mjs
var import_stream3 = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// ../../node_modules/@libsql/hrana-client/lib-esm/client.js
var protocolVersions = /* @__PURE__ */ new Map([
  ["hrana2", 2],
  ["hrana1", 1]
]);
var Client2 = class {
  static {
    __name(this, "Client");
  }
  /** @private */
  constructor() {
    this.intMode = "number";
  }
  /** Representation of integers returned from the database. See {@link IntMode}.
   *
   * This value is inherited by {@link Stream} objects created with {@link openStream}, but you can
   * override the integer mode for every stream by setting {@link Stream.intMode} on the stream.
   */
  intMode;
};

// ../../node_modules/@libsql/hrana-client/lib-esm/errors.js
var ClientError = class extends Error {
  static {
    __name(this, "ClientError");
  }
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ClientError";
  }
};
var ProtoError = class extends ClientError {
  static {
    __name(this, "ProtoError");
  }
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ProtoError";
  }
};
var ResponseError = class extends ClientError {
  static {
    __name(this, "ResponseError");
  }
  code;
  /** @internal */
  proto;
  /** @private */
  constructor(message, protoError) {
    super(message);
    this.name = "ResponseError";
    this.code = protoError["code"] ?? void 0;
    this.proto = protoError;
    this.stack = void 0;
  }
};
var ClosedError = class extends ClientError {
  static {
    __name(this, "ClosedError");
  }
  /** @private */
  constructor(message, cause) {
    if (cause !== void 0) {
      super(`${message}: ${cause}`);
      this.cause = cause;
    } else {
      super(message);
    }
    this.name = "ClosedError";
  }
};
var WebSocketUnsupportedError = class extends ClientError {
  static {
    __name(this, "WebSocketUnsupportedError");
  }
  /** @private */
  constructor(message) {
    super(message);
    this.name = "WebSocketUnsupportedError";
  }
};
var WebSocketError = class extends ClientError {
  static {
    __name(this, "WebSocketError");
  }
  /** @private */
  constructor(message) {
    super(message);
    this.name = "WebSocketError";
  }
};
var HttpServerError = class extends ClientError {
  static {
    __name(this, "HttpServerError");
  }
  status;
  /** @private */
  constructor(message, status) {
    super(message);
    this.status = status;
    this.name = "HttpServerError";
  }
};
var ProtocolVersionError = class extends ClientError {
  static {
    __name(this, "ProtocolVersionError");
  }
  /** @private */
  constructor(message) {
    super(message);
    this.name = "ProtocolVersionError";
  }
};

// ../../node_modules/node-fetch/lib/index.mjs
var import_whatwg_url = __toESM(require_public_api(), 1);
import Stream from "stream";
import http from "http";
import Url from "url";
import https from "https";
import zlib from "zlib";
var Readable2 = Stream.Readable;
var BUFFER = Symbol("buffer");
var TYPE = Symbol("type");
var Blob = class _Blob {
  static {
    __name(this, "Blob");
  }
  constructor() {
    this[TYPE] = "";
    const blobParts = arguments[0];
    const options = arguments[1];
    const buffers = [];
    let size = 0;
    if (blobParts) {
      const a10 = blobParts;
      const length = Number(a10.length);
      for (let i10 = 0; i10 < length; i10++) {
        const element = a10[i10];
        let buffer;
        if (element instanceof Buffer) {
          buffer = element;
        } else if (ArrayBuffer.isView(element)) {
          buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
        } else if (element instanceof ArrayBuffer) {
          buffer = Buffer.from(element);
        } else if (element instanceof _Blob) {
          buffer = element[BUFFER];
        } else {
          buffer = Buffer.from(typeof element === "string" ? element : String(element));
        }
        size += buffer.length;
        buffers.push(buffer);
      }
    }
    this[BUFFER] = Buffer.concat(buffers);
    let type = options && options.type !== void 0 && String(options.type).toLowerCase();
    if (type && !/[^\u0020-\u007E]/.test(type)) {
      this[TYPE] = type;
    }
  }
  get size() {
    return this[BUFFER].length;
  }
  get type() {
    return this[TYPE];
  }
  text() {
    return Promise.resolve(this[BUFFER].toString());
  }
  arrayBuffer() {
    const buf = this[BUFFER];
    const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    return Promise.resolve(ab);
  }
  stream() {
    const readable = new Readable2();
    readable._read = function() {
    };
    readable.push(this[BUFFER]);
    readable.push(null);
    return readable;
  }
  toString() {
    return "[object Blob]";
  }
  slice() {
    const size = this.size;
    const start = arguments[0];
    const end = arguments[1];
    let relativeStart, relativeEnd;
    if (start === void 0) {
      relativeStart = 0;
    } else if (start < 0) {
      relativeStart = Math.max(size + start, 0);
    } else {
      relativeStart = Math.min(start, size);
    }
    if (end === void 0) {
      relativeEnd = size;
    } else if (end < 0) {
      relativeEnd = Math.max(size + end, 0);
    } else {
      relativeEnd = Math.min(end, size);
    }
    const span = Math.max(relativeEnd - relativeStart, 0);
    const buffer = this[BUFFER];
    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
    const blob = new _Blob([], { type: arguments[2] });
    blob[BUFFER] = slicedBuffer;
    return blob;
  }
};
Object.defineProperties(Blob.prototype, {
  size: { enumerable: true },
  type: { enumerable: true },
  slice: { enumerable: true }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
  value: "Blob",
  writable: false,
  enumerable: false,
  configurable: true
});
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
__name(FetchError, "FetchError");
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = "FetchError";
var convert;
try {
  convert = __require("encoding").convert;
} catch (e10) {
}
var INTERNALS = Symbol("Body internals");
var PassThrough = Stream.PassThrough;
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body))
    ;
  else if (Buffer.isBuffer(body))
    ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof Stream)
    ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof Stream) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
__name(Body, "Body");
Body.prototype = {
  get body() {
    return this[INTERNALS].body;
  },
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  },
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  arrayBuffer() {
    return consumeBody.call(this).then(function(buf) {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    });
  },
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  blob() {
    let ct = this.headers && this.headers.get("content-type") || "";
    return consumeBody.call(this).then(function(buf) {
      return Object.assign(
        // Prevent copying
        new Blob([], {
          type: ct.toLowerCase()
        }),
        {
          [BUFFER]: buf
        }
      );
    });
  },
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  json() {
    var _this2 = this;
    return consumeBody.call(this).then(function(buffer) {
      try {
        return JSON.parse(buffer.toString());
      } catch (err) {
        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
      }
    });
  },
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  text() {
    return consumeBody.call(this).then(function(buffer) {
      return buffer.toString();
    });
  },
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody.call(this);
  },
  /**
   * Decode response as text, while automatically detecting the encoding and
   * trying to decode to UTF-8 (non-spec api)
   *
   * @return  Promise
   */
  textConverted() {
    var _this3 = this;
    return consumeBody.call(this).then(function(buffer) {
      return convertBody(buffer, _this3.headers);
    });
  }
};
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true }
});
Body.mixIn = function(proto) {
  for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {
    if (!(name2 in proto)) {
      const desc2 = Object.getOwnPropertyDescriptor(Body.prototype, name2);
      Object.defineProperty(proto, name2, desc2);
    }
  }
};
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof Stream)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
__name(consumeBody, "consumeBody");
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
__name(convertBody, "convertBody");
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
__name(isURLSearchParams, "isURLSearchParams");
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
__name(isBlob, "isBlob");
function clone(instance) {
  let p1, p22;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p22 = new PassThrough();
    body.pipe(p1);
    body.pipe(p22);
    instance[INTERNALS].body = p1;
    body = p22;
  }
  return body;
}
__name(clone, "clone");
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof Stream) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
__name(extractContentType, "extractContentType");
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
__name(getTotalBytes, "getTotalBytes");
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
__name(writeToStream, "writeToStream");
Body.Promise = global.Promise;
var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name2) {
  name2 = `${name2}`;
  if (invalidTokenRegex.test(name2) || name2 === "") {
    throw new TypeError(`${name2} is not a legal HTTP header name`);
  }
}
__name(validateName, "validateName");
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
__name(validateValue, "validateValue");
function find(map2, name2) {
  name2 = name2.toLowerCase();
  for (const key in map2) {
    if (key.toLowerCase() === name2) {
      return key;
    }
  }
  return void 0;
}
__name(find, "find");
var MAP = Symbol("map");
var Headers = class _Headers {
  static {
    __name(this, "Headers");
  }
  /**
   * Headers class
   *
   * @param   Object  headers  Response headers
   * @return  Void
   */
  constructor() {
    let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    this[MAP] = /* @__PURE__ */ Object.create(null);
    if (init2 instanceof _Headers) {
      const rawHeaders = init2.raw();
      const headerNames = Object.keys(rawHeaders);
      for (const headerName of headerNames) {
        for (const value of rawHeaders[headerName]) {
          this.append(headerName, value);
        }
      }
      return;
    }
    if (init2 == null)
      ;
    else if (typeof init2 === "object") {
      const method = init2[Symbol.iterator];
      if (method != null) {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        const pairs = [];
        for (const pair of init2) {
          if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
            throw new TypeError("Each header pair must be iterable");
          }
          pairs.push(Array.from(pair));
        }
        for (const pair of pairs) {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          this.append(pair[0], pair[1]);
        }
      } else {
        for (const key of Object.keys(init2)) {
          const value = init2[key];
          this.append(key, value);
        }
      }
    } else {
      throw new TypeError("Provided initializer must be an object");
    }
  }
  /**
   * Return combined header value given name
   *
   * @param   String  name  Header name
   * @return  Mixed
   */
  get(name2) {
    name2 = `${name2}`;
    validateName(name2);
    const key = find(this[MAP], name2);
    if (key === void 0) {
      return null;
    }
    return this[MAP][key].join(", ");
  }
  /**
   * Iterate over all headers
   *
   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
   * @param   Boolean   thisArg   `this` context for callback function
   * @return  Void
   */
  forEach(callback) {
    let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    let pairs = getHeaders(this);
    let i10 = 0;
    while (i10 < pairs.length) {
      var _pairs$i = pairs[i10];
      const name2 = _pairs$i[0], value = _pairs$i[1];
      callback.call(thisArg, value, name2, this);
      pairs = getHeaders(this);
      i10++;
    }
  }
  /**
   * Overwrite header values given name
   *
   * @param   String  name   Header name
   * @param   String  value  Header value
   * @return  Void
   */
  set(name2, value) {
    name2 = `${name2}`;
    value = `${value}`;
    validateName(name2);
    validateValue(value);
    const key = find(this[MAP], name2);
    this[MAP][key !== void 0 ? key : name2] = [value];
  }
  /**
   * Append a value onto existing header
   *
   * @param   String  name   Header name
   * @param   String  value  Header value
   * @return  Void
   */
  append(name2, value) {
    name2 = `${name2}`;
    value = `${value}`;
    validateName(name2);
    validateValue(value);
    const key = find(this[MAP], name2);
    if (key !== void 0) {
      this[MAP][key].push(value);
    } else {
      this[MAP][name2] = [value];
    }
  }
  /**
   * Check for header name existence
   *
   * @param   String   name  Header name
   * @return  Boolean
   */
  has(name2) {
    name2 = `${name2}`;
    validateName(name2);
    return find(this[MAP], name2) !== void 0;
  }
  /**
   * Delete all header values given name
   *
   * @param   String  name  Header name
   * @return  Void
   */
  delete(name2) {
    name2 = `${name2}`;
    validateName(name2);
    const key = find(this[MAP], name2);
    if (key !== void 0) {
      delete this[MAP][key];
    }
  }
  /**
   * Return raw headers (non-spec api)
   *
   * @return  Object
   */
  raw() {
    return this[MAP];
  }
  /**
   * Get an iterator on keys.
   *
   * @return  Iterator
   */
  keys() {
    return createHeadersIterator(this, "key");
  }
  /**
   * Get an iterator on values.
   *
   * @return  Iterator
   */
  values() {
    return createHeadersIterator(this, "value");
  }
  /**
   * Get an iterator on entries.
   *
   * This is the default iterator of the Headers object.
   *
   * @return  Iterator
   */
  [Symbol.iterator]() {
    return createHeadersIterator(this, "key+value");
  }
};
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  value: "Headers",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(Headers.prototype, {
  get: { enumerable: true },
  forEach: { enumerable: true },
  set: { enumerable: true },
  append: { enumerable: true },
  has: { enumerable: true },
  delete: { enumerable: true },
  keys: { enumerable: true },
  values: { enumerable: true },
  entries: { enumerable: true }
});
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k10) {
    return k10.toLowerCase();
  } : kind === "value" ? function(k10) {
    return headers[MAP][k10].join(", ");
  } : function(k10) {
    return [k10.toLowerCase(), headers[MAP][k10].join(", ")];
  });
}
__name(getHeaders, "getHeaders");
var INTERNAL = Symbol("internal");
function createHeadersIterator(target, kind) {
  const iterator2 = Object.create(HeadersIteratorPrototype);
  iterator2[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator2;
}
__name(createHeadersIterator, "createHeadersIterator");
var HeadersIteratorPrototype = Object.setPrototypeOf({
  next() {
    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
      throw new TypeError("Value of `this` is not a HeadersIterator");
    }
    var _INTERNAL = this[INTERNAL];
    const target = _INTERNAL.target, kind = _INTERNAL.kind, index2 = _INTERNAL.index;
    const values = getHeaders(target, kind);
    const len = values.length;
    if (index2 >= len) {
      return {
        value: void 0,
        done: true
      };
    }
    this[INTERNAL].index = index2 + 1;
    return {
      value: values[index2],
      done: false
    };
  }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  value: "HeadersIterator",
  writable: false,
  enumerable: false,
  configurable: true
});
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
__name(exportNodeCompatibleHeaders, "exportNodeCompatibleHeaders");
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name2 of Object.keys(obj)) {
    if (invalidTokenRegex.test(name2)) {
      continue;
    }
    if (Array.isArray(obj[name2])) {
      for (const val2 of obj[name2]) {
        if (invalidHeaderCharRegex.test(val2)) {
          continue;
        }
        if (headers[MAP][name2] === void 0) {
          headers[MAP][name2] = [val2];
        } else {
          headers[MAP][name2].push(val2);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name2])) {
      headers[MAP][name2] = [obj[name2]];
    }
  }
  return headers;
}
__name(createHeadersLenient, "createHeadersLenient");
var INTERNALS$1 = Symbol("Response internals");
var STATUS_CODES = http.STATUS_CODES;
var Response = class _Response {
  static {
    __name(this, "Response");
  }
  constructor() {
    let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Body.call(this, body, opts);
    const status = opts.status || 200;
    const headers = new Headers(opts.headers);
    if (body != null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: opts.url,
      status,
      statusText: opts.statusText || STATUS_CODES[status],
      headers,
      counter: opts.counter
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new _Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected
    });
  }
};
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
  value: "Response",
  writable: false,
  enumerable: false,
  configurable: true
});
var INTERNALS$2 = Symbol("Request internals");
var URL2 = Url.URL || import_whatwg_url.default.URL;
var parse_url = Url.parse;
var format_url = Url.format;
function parseURL3(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL2(urlStr).toString();
  }
  return parse_url(urlStr);
}
__name(parseURL3, "parseURL");
var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
__name(isRequest, "isRequest");
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
__name(isAbortSignal, "isAbortSignal");
var Request2 = class _Request {
  static {
    __name(this, "Request");
  }
  constructor(input) {
    let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let parsedURL;
    if (!isRequest(input)) {
      if (input && input.href) {
        parsedURL = parseURL3(input.href);
      } else {
        parsedURL = parseURL3(`${input}`);
      }
      input = {};
    } else {
      parsedURL = parseURL3(input.url);
    }
    let method = init2.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    let inputBody = init2.body != null ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
    Body.call(this, inputBody, {
      timeout: init2.timeout || input.timeout || 0,
      size: init2.size || input.size || 0
    });
    const headers = new Headers(init2.headers || input.headers || {});
    if (inputBody != null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init2)
      signal = init2.signal;
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS$2] = {
      method,
      redirect: init2.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
    this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
    this.counter = init2.counter || input.counter || 0;
    this.agent = init2.agent || input.agent;
  }
  get method() {
    return this[INTERNALS$2].method;
  }
  get url() {
    return format_url(this[INTERNALS$2].parsedURL);
  }
  get headers() {
    return this[INTERNALS$2].headers;
  }
  get redirect() {
    return this[INTERNALS$2].redirect;
  }
  get signal() {
    return this[INTERNALS$2].signal;
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new _Request(this);
  }
};
Body.mixIn(Request2.prototype);
Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
  value: "Request",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(Request2.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true }
});
function getNodeRequestOptions(request3) {
  const parsedURL = request3[INTERNALS$2].parsedURL;
  const headers = new Headers(request3[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request3.signal && request3.body instanceof Stream.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request3.body == null && /^(POST|PUT)$/i.test(request3.method)) {
    contentLengthValue = "0";
  }
  if (request3.body != null) {
    const totalBytes = getTotalBytes(request3);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request3.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent = request3.agent;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  return Object.assign({}, parsedURL, {
    method: request3.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
__name(getNodeRequestOptions, "getNodeRequestOptions");
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
__name(AbortError, "AbortError");
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = "AbortError";
var URL$1 = Url.URL || import_whatwg_url.default.URL;
var PassThrough$1 = Stream.PassThrough;
var isDomainOrSubdomain = /* @__PURE__ */ __name(function isDomainOrSubdomain2(destination, original) {
  const orig = new URL$1(original).hostname;
  const dest = new URL$1(destination).hostname;
  return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
}, "isDomainOrSubdomain");
var isSameProtocol = /* @__PURE__ */ __name(function isSameProtocol2(destination, original) {
  const orig = new URL$1(original).protocol;
  const dest = new URL$1(destination).protocol;
  return orig === dest;
}, "isSameProtocol");
function fetch2(url12, opts) {
  if (!fetch2.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch2.Promise;
  return new fetch2.Promise(function(resolve, reject) {
    const request3 = new Request2(url12, opts);
    const options = getNodeRequestOptions(request3);
    const send = (options.protocol === "https:" ? https : http).request;
    const signal = request3.signal;
    let response = null;
    const abort = /* @__PURE__ */ __name(function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request3.body && request3.body instanceof Stream.Readable) {
        destroyStream(request3.body, error);
      }
      if (!response || !response.body)
        return;
      response.body.emit("error", error);
    }, "abort");
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = /* @__PURE__ */ __name(function abortAndFinalize2() {
      abort();
      finalize();
    }, "abortAndFinalize");
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal)
        signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    __name(finalize, "finalize");
    if (request3.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request3.url}`, "request-timeout"));
          finalize();
        }, request3.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request3.url} failed, reason: ${err.message}`, "system", err));
      if (response && response.body) {
        destroyStream(response.body, err);
      }
      finalize();
    });
    fixResponseChunkedTransferBadEnding(req, function(err) {
      if (signal && signal.aborted) {
        return;
      }
      if (response && response.body) {
        destroyStream(response.body, err);
      }
    });
    if (parseInt(process.version.substring(1)) < 14) {
      req.on("socket", function(s10) {
        s10.addListener("close", function(hadError) {
          const hasDataListener = s10.listenerCount("data") > 0;
          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", err);
          }
        });
      });
    }
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch2.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL$1(location, request3.url).toString();
        } catch (err) {
          if (request3.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request3.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request3.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request3.counter >= request3.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request3.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request3.headers),
              follow: request3.follow,
              counter: request3.counter + 1,
              agent: request3.agent,
              compress: request3.compress,
              method: request3.method,
              body: request3.body,
              signal: request3.signal,
              timeout: request3.timeout,
              size: request3.size
            };
            if (!isDomainOrSubdomain(request3.url, locationURL) || !isSameProtocol(request3.url, locationURL)) {
              for (const name2 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOpts.headers.delete(name2);
              }
            }
            if (res.statusCode !== 303 && request3.body && getTotalBytes(request3) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request3.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch2(new Request2(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request3.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request3.size,
        timeout: request3.timeout,
        counter: request3.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request3.compress || request3.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(zlib.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(zlib.createInflate());
          } else {
            body = body.pipe(zlib.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        raw.on("end", function() {
          if (!response) {
            response = new Response(body, response_options);
            resolve(response);
          }
        });
        return;
      }
      if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
        body = body.pipe(zlib.createBrotliDecompress());
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      response = new Response(body, response_options);
      resolve(response);
    });
    writeToStream(req, request3);
  });
}
__name(fetch2, "fetch");
function fixResponseChunkedTransferBadEnding(request3, errorCallback) {
  let socket;
  request3.on("socket", function(s10) {
    socket = s10;
  });
  request3.on("response", function(response) {
    const headers = response.headers;
    if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
      response.once("close", function(hadError) {
        const hasDataListener = socket && socket.listenerCount("data") > 0;
        if (hasDataListener && !hadError) {
          const err = new Error("Premature close");
          err.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(err);
        }
      });
    }
  });
}
__name(fixResponseChunkedTransferBadEnding, "fixResponseChunkedTransferBadEnding");
function destroyStream(stream, err) {
  if (stream.destroy) {
    stream.destroy(err);
  } else {
    stream.emit("error", err);
    stream.end();
  }
}
__name(destroyStream, "destroyStream");
fetch2.isRedirect = function(code2) {
  return code2 === 301 || code2 === 302 || code2 === 303 || code2 === 307 || code2 === 308;
};
fetch2.Promise = global.Promise;
var lib_default = fetch2;

// ../../node_modules/@libsql/hrana-client/lib-esm/id_alloc.js
var IdAlloc = class {
  static {
    __name(this, "IdAlloc");
  }
  // Set of all allocated ids
  #usedIds;
  // Set of all free ids lower than `#usedIds.size`
  #freeIds;
  constructor() {
    this.#usedIds = /* @__PURE__ */ new Set();
    this.#freeIds = /* @__PURE__ */ new Set();
  }
  // Returns an id that was free, and marks it as used.
  alloc() {
    for (const freeId2 of this.#freeIds) {
      this.#freeIds.delete(freeId2);
      this.#usedIds.add(freeId2);
      if (!this.#usedIds.has(this.#usedIds.size - 1)) {
        this.#freeIds.add(this.#usedIds.size - 1);
      }
      return freeId2;
    }
    const freeId = this.#usedIds.size;
    this.#usedIds.add(freeId);
    return freeId;
  }
  free(id) {
    if (!this.#usedIds.delete(id)) {
      throw new Error("Freeing an id that is not allocated");
    }
    this.#freeIds.delete(this.#usedIds.size);
    if (id < this.#usedIds.size) {
      this.#freeIds.add(id);
    }
  }
};

// ../../node_modules/@libsql/hrana-client/lib-esm/ponyfill.js
var _queueMicrotask;
if (typeof queueMicrotask !== "undefined") {
  _queueMicrotask = queueMicrotask;
} else {
  const resolved = Promise.resolve();
  _queueMicrotask = /* @__PURE__ */ __name((callback) => {
    resolved.then(callback);
  }, "_queueMicrotask");
}

// ../../node_modules/@libsql/hrana-client/lib-esm/value.js
function valueToProto(value) {
  if (value === null) {
    return protoNull;
  } else if (typeof value === "string") {
    return { "type": "text", "value": value };
  } else if (typeof value === "number") {
    if (!Number.isFinite(value)) {
      throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");
    }
    return { "type": "float", "value": +value };
  } else if (typeof value === "bigint") {
    if (value < minInteger2 || value > maxInteger2) {
      throw new RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");
    }
    return { "type": "integer", "value": "" + value };
  } else if (typeof value === "boolean") {
    return { "type": "integer", "value": value ? "1" : "0" };
  } else if (value instanceof ArrayBuffer) {
    return { "type": "blob", "base64": gBase64.fromUint8Array(new Uint8Array(value)) };
  } else if (value instanceof Uint8Array) {
    return { "type": "blob", "base64": gBase64.fromUint8Array(value) };
  } else if (value instanceof Date) {
    return { "type": "float", "value": value.valueOf() };
  } else if (typeof value === "object") {
    return { "type": "text", "value": value.toString() };
  } else {
    throw new TypeError("Unsupported type of value");
  }
}
__name(valueToProto, "valueToProto");
var minInteger2 = -9223372036854775808n;
var maxInteger2 = 9223372036854775807n;
var protoNull = { "type": "null" };
function valueFromProto(value, intMode) {
  if (value["type"] === "null") {
    return null;
  } else if (value["type"] === "integer") {
    if (intMode === "number") {
      const int = parseInt(value["value"], 10);
      if (!Number.isSafeInteger(int)) {
        throw new RangeError("Received integer which cannot be safely represented as a JavaScript number");
      }
      return int;
    } else if (intMode === "bigint") {
      return BigInt(value["value"]);
    } else if (intMode === "string") {
      return "" + value["value"];
    } else {
      throw new Error("Invalid value for IntMode");
    }
  } else if (value["type"] === "float") {
    return +value["value"];
  } else if (value["type"] === "text") {
    return "" + value["value"];
  } else if (value["type"] === "blob") {
    return gBase64.toUint8Array(value["base64"]).buffer;
  } else {
    throw new ProtoError("Unexpected value type");
  }
}
__name(valueFromProto, "valueFromProto");

// ../../node_modules/@libsql/hrana-client/lib-esm/result.js
function stmtResultFromProto(result) {
  return {
    affectedRowCount: result["affected_row_count"],
    lastInsertRowid: result["last_insert_rowid"] ?? void 0,
    columnNames: result["cols"].map((col) => col["name"] ?? void 0),
    columnDecltypes: result["cols"].map((col) => col["decltype"] ?? void 0)
  };
}
__name(stmtResultFromProto, "stmtResultFromProto");
function rowsResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  const rows = result["rows"].map((row) => rowFromProto(stmtResult.columnNames, row, intMode));
  return { ...stmtResult, rows };
}
__name(rowsResultFromProto, "rowsResultFromProto");
function rowResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let row;
  if (result.rows.length > 0) {
    row = rowFromProto(stmtResult.columnNames, result.rows[0], intMode);
  }
  return { ...stmtResult, row };
}
__name(rowResultFromProto, "rowResultFromProto");
function valueResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let value;
  if (result.rows.length > 0 && stmtResult.columnNames.length > 0) {
    value = valueFromProto(result.rows[0][0], intMode);
  }
  return { ...stmtResult, value };
}
__name(valueResultFromProto, "valueResultFromProto");
function rowFromProto(colNames, values, intMode) {
  const row = {};
  Object.defineProperty(row, "length", { value: values.length });
  for (let i10 = 0; i10 < values.length; ++i10) {
    const value = valueFromProto(values[i10], intMode);
    Object.defineProperty(row, i10, { value });
    const colName = colNames[i10];
    if (colName !== void 0 && !Object.hasOwn(row, colName)) {
      Object.defineProperty(row, colName, { value, enumerable: true });
    }
  }
  return row;
}
__name(rowFromProto, "rowFromProto");
function errorFromProto(error) {
  return new ResponseError(error["message"], error);
}
__name(errorFromProto, "errorFromProto");

// ../../node_modules/@libsql/hrana-client/lib-esm/sql.js
var Sql = class {
  static {
    __name(this, "Sql");
  }
  #owner;
  #state;
  /** @private */
  constructor(owner, state) {
    this.#owner = owner;
    this.#state = state;
  }
  /** @private */
  _getSqlId(owner) {
    if (this.#owner !== owner) {
      throw new Error("Attempted to use SQL text opened with other object");
    } else if (this.#state.closed !== void 0) {
      throw new ClosedError("SQL text is closed", this.#state.closed);
    }
    return this.#state.sqlId;
  }
  /** Remove the SQL text from the server, releasing resouces. */
  close() {
    this.#owner._closeSql(this.#state, new ClientError("SQL was manually closed"));
  }
  /** True if the SQL text is closed (removed from the server). */
  get closed() {
    return this.#state.closed !== void 0;
  }
};
function sqlToProto(owner, sql2) {
  if (sql2 instanceof Sql) {
    return { sqlId: sql2._getSqlId(owner) };
  } else {
    return { sql: "" + sql2 };
  }
}
__name(sqlToProto, "sqlToProto");

// ../../node_modules/@libsql/hrana-client/lib-esm/stmt.js
var Stmt = class {
  static {
    __name(this, "Stmt");
  }
  /** The SQL statement text. */
  sql;
  /** @private */
  _args;
  /** @private */
  _namedArgs;
  /** Initialize the statement with given SQL text. */
  constructor(sql2) {
    this.sql = sql2;
    this._args = [];
    this._namedArgs = /* @__PURE__ */ new Map();
  }
  /** Binds positional parameters from the given `values`. All previous positional bindings are cleared. */
  bindIndexes(values) {
    this._args.length = 0;
    for (const value of values) {
      this._args.push(valueToProto(value));
    }
    return this;
  }
  /** Binds a parameter by a 1-based index. */
  bindIndex(index2, value) {
    if (index2 !== (index2 | 0) || index2 <= 0) {
      throw new RangeError("Index of a positional argument must be positive integer");
    }
    while (this._args.length < index2) {
      this._args.push(protoNull);
    }
    this._args[index2 - 1] = valueToProto(value);
    return this;
  }
  /** Binds a parameter by name. */
  bindName(name2, value) {
    this._namedArgs.set(name2, valueToProto(value));
    return this;
  }
  /** Clears all bindings. */
  unbindAll() {
    this._args.length = 0;
    this._namedArgs.clear();
    return this;
  }
};
function stmtToProto(sqlOwner, stmt, wantRows) {
  let inSql;
  let args = [];
  let namedArgs = [];
  if (stmt instanceof Stmt) {
    inSql = stmt.sql;
    args = stmt._args;
    for (const [name2, value] of stmt._namedArgs.entries()) {
      namedArgs.push({ "name": name2, "value": value });
    }
  } else if (Array.isArray(stmt)) {
    inSql = stmt[0];
    if (Array.isArray(stmt[1])) {
      args = stmt[1].map(valueToProto);
    } else {
      namedArgs = Object.entries(stmt[1]).map((entry) => {
        const [key, value] = entry;
        return { "name": key, "value": valueToProto(value) };
      });
    }
  } else {
    inSql = stmt;
  }
  const { sql: sql2, sqlId } = sqlToProto(sqlOwner, inSql);
  return {
    "sql": sql2,
    "sql_id": sqlId,
    "args": args,
    "named_args": namedArgs,
    "want_rows": wantRows
  };
}
__name(stmtToProto, "stmtToProto");

// ../../node_modules/@libsql/hrana-client/lib-esm/batch.js
var Batch = class {
  static {
    __name(this, "Batch");
  }
  /** @private */
  _stream;
  #executed;
  /** @private */
  _steps;
  /** @private */
  _resultCallbacks;
  /** @private */
  constructor(stream) {
    this._stream = stream;
    this.#executed = false;
    this._steps = [];
    this._resultCallbacks = [];
  }
  /** Return a builder for adding a step to the batch. */
  step() {
    return new BatchStep(this);
  }
  /** Execute the batch. */
  execute() {
    if (this.#executed) {
      throw new Error("This batch has already been executed");
    }
    this.#executed = true;
    const batch = {
      "steps": this._steps
    };
    return this._stream._batch(batch).then((result) => {
      for (const callback of this._resultCallbacks) {
        callback(result);
      }
    });
  }
};
var BatchStep = class {
  static {
    __name(this, "BatchStep");
  }
  #batch;
  #conditions;
  /** @private */
  _index;
  /** @private */
  constructor(batch) {
    this.#batch = batch;
    this.#conditions = [];
    this._index = void 0;
  }
  /** Add the condition that needs to be satisfied to execute the statement. If you use this method multiple
  * times, we join them with a logical AND. */
  condition(cond) {
    this.#conditions.push(cond._proto);
    return this;
  }
  /** Add a statement that returns rows. */
  query(stmt) {
    return this.#add(stmt, true, rowsResultFromProto);
  }
  /** Add a statement that returns at most a single row. */
  queryRow(stmt) {
    return this.#add(stmt, true, rowResultFromProto);
  }
  /** Add a statement returns at most a single value. */
  queryValue(stmt) {
    return this.#add(stmt, true, valueResultFromProto);
  }
  /** Add a statement without returning rows. */
  run(stmt) {
    return this.#add(stmt, false, stmtResultFromProto);
  }
  #add(inStmt, wantRows, fromProto) {
    const stmt = stmtToProto(this.#batch._stream._sqlOwner(), inStmt, wantRows);
    if (this._index !== void 0) {
      throw new Error("This step has already been added to the batch");
    }
    const index2 = this.#batch._steps.length;
    this._index = index2;
    let condition;
    if (this.#conditions.length === 0) {
      condition = null;
    } else if (this.#conditions.length === 1) {
      condition = this.#conditions[0];
    } else {
      condition = { "type": "and", "conds": this.#conditions };
    }
    this.#batch._steps.push({
      "stmt": stmt,
      "condition": condition
    });
    return new Promise((outputCallback, errorCallback) => {
      this.#batch._resultCallbacks.push((result) => {
        const stepResult = result["step_results"][index2];
        const stepError = result["step_errors"][index2];
        if (stepResult === void 0 || stepError === void 0) {
          errorCallback(new ProtoError("Server returned fewer step results than expected"));
        } else if (stepResult !== null && stepError !== null) {
          errorCallback(new ProtoError("Server returned both result and error"));
        } else if (stepError !== null) {
          errorCallback(errorFromProto(stepError));
        } else if (stepResult !== null) {
          outputCallback(fromProto(stepResult, this.#batch._stream.intMode));
        } else {
          outputCallback(void 0);
        }
      });
    });
  }
};
var BatchCond = class _BatchCond {
  static {
    __name(this, "BatchCond");
  }
  /** @private */
  _proto;
  /** @private */
  constructor(proto) {
    this._proto = proto;
  }
  static ok(step) {
    return new _BatchCond({ "type": "ok", "step": stepIndex(step) });
  }
  static error(step) {
    return new _BatchCond({ "type": "error", "step": stepIndex(step) });
  }
  static not(cond) {
    return new _BatchCond({ "type": "not", "cond": cond._proto });
  }
  static and(conds) {
    return new _BatchCond({ "type": "and", "conds": conds.map((e10) => e10._proto) });
  }
  static or(conds) {
    return new _BatchCond({ "type": "or", "conds": conds.map((e10) => e10._proto) });
  }
};
function stepIndex(step) {
  if (step._index === void 0) {
    throw new Error("Cannot add a condition referencing a step that has not been added to the batch");
  }
  return step._index;
}
__name(stepIndex, "stepIndex");

// ../../node_modules/@libsql/hrana-client/lib-esm/describe.js
function describeResultFromProto(result) {
  return {
    paramNames: result["params"].map((p11) => p11.name ?? void 0),
    columns: result["cols"].map((c11) => {
      return {
        name: c11["name"],
        decltype: c11["decltype"] ?? void 0
      };
    }),
    isExplain: result["is_explain"],
    isReadonly: result["is_readonly"]
  };
}
__name(describeResultFromProto, "describeResultFromProto");

// ../../node_modules/@libsql/hrana-client/lib-esm/stream.js
var Stream2 = class {
  static {
    __name(this, "Stream");
  }
  /** @private */
  constructor(intMode) {
    this.intMode = intMode;
  }
  /** Execute a statement and return rows. */
  query(stmt) {
    return this.#execute(stmt, true, rowsResultFromProto);
  }
  /** Execute a statement and return at most a single row. */
  queryRow(stmt) {
    return this.#execute(stmt, true, rowResultFromProto);
  }
  /** Execute a statement and return at most a single value. */
  queryValue(stmt) {
    return this.#execute(stmt, true, valueResultFromProto);
  }
  /** Execute a statement without returning rows. */
  run(stmt) {
    return this.#execute(stmt, false, stmtResultFromProto);
  }
  #execute(inStmt, wantRows, fromProto) {
    const stmt = stmtToProto(this._sqlOwner(), inStmt, wantRows);
    return this._execute(stmt).then((r10) => fromProto(r10, this.intMode));
  }
  /** Return a builder for creating and executing a batch. */
  batch() {
    return new Batch(this);
  }
  /** Parse and analyze a statement. This requires protocol version 2 or higher. */
  describe(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._describe(protoSql).then(describeResultFromProto);
  }
  /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.
   * */
  sequence(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._sequence(protoSql);
  }
  /** Representation of integers returned from the database. See {@link IntMode}.
   *
   * This value affects the results of all operations on this stream.
   */
  intMode;
};

// ../../node_modules/@libsql/hrana-client/lib-esm/http/stream.js
var HttpStream = class extends Stream2 {
  static {
    __name(this, "HttpStream");
  }
  #client;
  #baseUrl;
  #jwt;
  #fetch;
  #closed;
  #baton;
  #pipeline;
  #pipelineInProgress;
  #sqlIdAlloc;
  /** @private */
  constructor(client10, baseUrl, jwt, customFetch) {
    super(client10.intMode);
    this.#client = client10;
    this.#baseUrl = baseUrl.toString();
    this.#jwt = jwt;
    this.#fetch = customFetch;
    this.#closed = void 0;
    this.#baton = null;
    this.#pipeline = [];
    this.#pipelineInProgress = false;
    this.#sqlIdAlloc = new IdAlloc();
  }
  /** @private*/
  _sqlOwner() {
    return this;
  }
  /** Cache a SQL text on the server. */
  storeSql(sql2) {
    const sqlId = this.#sqlIdAlloc.alloc();
    const sqlState = {
      sqlId,
      closed: void 0
    };
    this.#sendStreamRequest({
      "type": "store_sql",
      "sql_id": sqlId,
      "sql": sql2
    }).then(() => void 0, (error) => this.#setClosed(error));
    return new Sql(this, sqlState);
  }
  /** @private */
  _closeSql(sqlState, error) {
    if (sqlState.closed !== void 0 || this.#closed !== void 0) {
      return;
    }
    sqlState.closed = error;
    this.#sendStreamRequest({
      "type": "close_sql",
      "sql_id": sqlState.sqlId
    }).then(() => this.#sqlIdAlloc.free(sqlState.sqlId), (error2) => this.#setClosed(error2));
  }
  /** @private */
  _execute(stmt) {
    return this.#sendStreamRequest({
      "type": "execute",
      "stmt": stmt
    }).then((response) => {
      return response["result"];
    });
  }
  /** @private */
  _batch(batch) {
    return this.#sendStreamRequest({
      "type": "batch",
      "batch": batch
    }).then((response) => {
      return response["result"];
    });
  }
  /** @private */
  _describe(protoSql) {
    return this.#sendStreamRequest({
      "type": "describe",
      "sql": protoSql.sql,
      "sql_id": protoSql.sqlId
    }).then((response) => {
      return response["result"];
    });
  }
  /** @private */
  _sequence(protoSql) {
    return this.#sendStreamRequest({
      "type": "sequence",
      "sql": protoSql.sql,
      "sql_id": protoSql.sqlId
    }).then((_response) => {
      return void 0;
    });
  }
  /** Close the stream. */
  close() {
    this.#setClosed(new ClientError("Stream was manually closed"));
  }
  /** @private */
  _closeFromClient() {
    this.#setClosed(new ClosedError("Client was closed", void 0));
  }
  /** True if the stream is closed. */
  get closed() {
    return this.#closed !== void 0;
  }
  #setClosed(error) {
    if (this.#closed !== void 0) {
      return;
    }
    this.#closed = error;
    this.#client._streamClosed(this);
    if (this.#baton !== null || this.#pipeline.length !== 0 || this.#pipelineInProgress) {
      this.#pipeline.push({
        request: { "type": "close" },
        responseCallback() {
        },
        errorCallback() {
        }
      });
      this.#flushPipeline();
    }
  }
  #sendStreamRequest(request3) {
    if (this.#closed !== void 0) {
      return Promise.reject(new ClosedError("Stream is closed", this.#closed));
    }
    return new Promise((responseCallback, errorCallback) => {
      this.#pipeline.push({ request: request3, responseCallback, errorCallback });
      _queueMicrotask(() => this.#flushPipeline());
    });
  }
  #flushPipeline() {
    if (this.#pipeline.length === 0 || this.#pipelineInProgress) {
      return;
    }
    const pipeline = Array.from(this.#pipeline);
    let promise;
    try {
      const request3 = this.#createPipelineRequest(pipeline);
      const fetch4 = this.#fetch;
      promise = fetch4(request3);
    } catch (error) {
      promise = Promise.reject(error);
    }
    this.#pipelineInProgress = true;
    this.#pipeline.length = 0;
    promise.then((resp) => {
      if (!resp.ok) {
        return errorFromResponse(resp).then((error) => {
          throw error;
        });
      }
      return resp.json();
    }).then((respJson) => {
      const respBody = respJson;
      this.#baton = respBody["baton"] ?? null;
      this.#baseUrl = respBody["base_url"] ?? this.#baseUrl;
      handlePipelineResponse(pipeline, respBody);
    }).catch((error) => {
      this.#setClosed(error);
      for (const entry of pipeline) {
        entry.errorCallback(error);
      }
    }).finally(() => {
      this.#pipelineInProgress = false;
      this.#flushPipeline();
    });
  }
  #createPipelineRequest(pipeline) {
    const url12 = new URL("v2/pipeline", this.#baseUrl);
    const requestBody = {
      "baton": this.#baton,
      "requests": pipeline.map((entry) => entry.request)
    };
    const headers = new Headers();
    if (this.#jwt !== null) {
      headers.set("authorization", `Bearer ${this.#jwt}`);
    }
    return new Request2(url12, {
      method: "POST",
      headers,
      body: JSON.stringify(requestBody)
    });
  }
};
function handlePipelineResponse(pipeline, respBody) {
  if (respBody["results"].length !== pipeline.length) {
    throw new ProtoError("Server returned unexpected number of pipeline results");
  }
  for (let i10 = 0; i10 < pipeline.length; ++i10) {
    const result = respBody["results"][i10];
    const entry = pipeline[i10];
    if (result["type"] === "ok") {
      if (result["response"]["type"] !== entry.request["type"]) {
        throw new ProtoError("Received unexpected type of response");
      }
      entry.responseCallback(result["response"]);
    } else if (result["type"] === "error") {
      entry.errorCallback(errorFromProto(result["error"]));
    } else {
      throw new ProtoError("Received unexpected type of result");
    }
  }
}
__name(handlePipelineResponse, "handlePipelineResponse");
async function errorFromResponse(resp) {
  const respType = resp.headers.get("content-type") ?? "text/plain";
  if (respType === "application/json") {
    const respBody = await resp.json();
    if ("message" in respBody) {
      return errorFromProto(respBody);
    }
  }
  let message = `Server returned HTTP status ${resp.status}`;
  if (respType === "text/plain") {
    const respBody = (await resp.text()).trim();
    if (respBody !== "") {
      message += `: ${respBody}`;
    }
  }
  if (resp.status === 404) {
    message += ". It seems that the libsql server is outdated, please try updating the database.";
  }
  return new HttpServerError(message, resp.status);
}
__name(errorFromResponse, "errorFromResponse");

// ../../node_modules/@libsql/hrana-client/lib-esm/http/client.js
var HttpClient = class extends Client2 {
  static {
    __name(this, "HttpClient");
  }
  #url;
  #jwt;
  #fetch;
  #closed;
  #streams;
  /** @private */
  constructor(url12, jwt, customFetch) {
    super();
    this.#url = url12;
    this.#jwt = jwt;
    this.#fetch = customFetch ?? lib_default;
    this.#closed = false;
    this.#streams = /* @__PURE__ */ new Set();
  }
  /** Get the protocol version supported by the server. */
  getVersion() {
    return Promise.resolve(2);
  }
  /** Open a {@link HttpStream}, a stream for executing SQL statements. */
  openStream() {
    if (this.#closed) {
      throw new ClosedError("Client is closed", void 0);
    }
    const stream = new HttpStream(this, this.#url, this.#jwt, this.#fetch);
    this.#streams.add(stream);
    return stream;
  }
  /** @private */
  _streamClosed(stream) {
    this.#streams.delete(stream);
  }
  /** Close the client and all its streams. */
  close() {
    this.#closed = true;
    for (const stream of Array.from(this.#streams)) {
      stream._closeFromClient();
    }
  }
  /** True if the client is closed. */
  get closed() {
    return this.#closed;
  }
};

// ../../node_modules/@libsql/hrana-client/lib-esm/ws/stream.js
var WsStream = class extends Stream2 {
  static {
    __name(this, "WsStream");
  }
  #client;
  #state;
  /** @private */
  constructor(client10, state) {
    super(client10.intMode);
    this.#client = client10;
    this.#state = state;
  }
  /** @private */
  _sqlOwner() {
    return this.#client;
  }
  /** @private */
  _execute(stmt) {
    return this.#sendStreamRequest({
      "type": "execute",
      "stream_id": this.#state.streamId,
      "stmt": stmt
    }).then((response) => {
      return response["result"];
    });
  }
  /** @private */
  _batch(batch) {
    return this.#sendStreamRequest({
      "type": "batch",
      "stream_id": this.#state.streamId,
      "batch": batch
    }).then((response) => {
      return response["result"];
    });
  }
  /** @private */
  _describe(protoSql) {
    this.#client._ensureVersion(2, "describe()");
    return this.#sendStreamRequest({
      "type": "describe",
      "stream_id": this.#state.streamId,
      "sql": protoSql.sql,
      "sql_id": protoSql.sqlId
    }).then((response) => {
      return response["result"];
    });
  }
  /** @private */
  _sequence(protoSql) {
    this.#client._ensureVersion(2, "sequence()");
    return this.#sendStreamRequest({
      "type": "sequence",
      "stream_id": this.#state.streamId,
      "sql": protoSql.sql,
      "sql_id": protoSql.sqlId
    }).then((_response) => {
      return void 0;
    });
  }
  #sendStreamRequest(request3) {
    return new Promise((responseCallback, errorCallback) => {
      this.#client._sendStreamRequest(this.#state, request3, { responseCallback, errorCallback });
    });
  }
  /** Close the stream. */
  close() {
    this.#client._closeStream(this.#state, new ClientError("Stream was manually closed"));
  }
  /** True if the stream is closed. */
  get closed() {
    return this.#state.closed !== void 0;
  }
};

// ../../node_modules/@libsql/hrana-client/lib-esm/ws/client.js
var WsClient = class extends Client2 {
  static {
    __name(this, "WsClient");
  }
  #socket;
  // List of callbacks that we queue until the socket transitions from the CONNECTING to the OPEN state.
  #openCallbacks;
  // Have we already transitioned from CONNECTING to OPEN and fired the callbacks in #openCallbacks?
  #opened;
  // Stores the error that caused us to close the client (and the socket). If we are not closed, this is
  // `undefined`.
  #closed;
  // Have we received a response to our "hello" from the server?
  #recvdHello;
  // Protocol version negotiated with the server. It is only available after the socket transitions to the
  // OPEN state.
  #version;
  // Has the `getVersion()` function been called? This is only used to validate that the API is used
  // correctly.
  #getVersionCalled;
  // A map from request id to the responses that we expect to receive from the server.
  #responseMap;
  // An allocator of request ids.
  #requestIdAlloc;
  // An allocator of stream ids.
  #streamIdAlloc;
  // An allocator of SQL text ids.
  #sqlIdAlloc;
  /** @private */
  constructor(socket, jwt) {
    super();
    this.#socket = socket;
    this.#socket.binaryType = "arraybuffer";
    this.#openCallbacks = [];
    this.#opened = false;
    this.#closed = void 0;
    this.#recvdHello = false;
    this.#version = void 0;
    this.#getVersionCalled = false;
    this.#responseMap = /* @__PURE__ */ new Map();
    this.#requestIdAlloc = new IdAlloc();
    this.#streamIdAlloc = new IdAlloc();
    this.#sqlIdAlloc = new IdAlloc();
    this.#socket.addEventListener("open", () => this.#onSocketOpen());
    this.#socket.addEventListener("close", (event) => this.#onSocketClose(event));
    this.#socket.addEventListener("error", (event) => this.#onSocketError(event));
    this.#socket.addEventListener("message", (event) => this.#onSocketMessage(event));
    this.#send({ "type": "hello", "jwt": jwt });
  }
  // Send (or enqueue to send) a message to the server.
  #send(msg) {
    if (this.#closed !== void 0) {
      throw new ClientError("Internal error: trying to send a message on a closed client");
    }
    if (this.#opened) {
      this.#sendToSocket(msg);
    } else {
      const openCallback = /* @__PURE__ */ __name(() => this.#sendToSocket(msg), "openCallback");
      const errorCallback = /* @__PURE__ */ __name((_) => void 0, "errorCallback");
      this.#openCallbacks.push({ openCallback, errorCallback });
    }
  }
  // The socket transitioned from CONNECTING to OPEN
  #onSocketOpen() {
    const protocol = this.#socket.protocol;
    if (protocol === "") {
      this.#version = 1;
    } else if (protocol === void 0) {
      this.#version = 1;
    } else {
      this.#version = protocolVersions.get(protocol);
      if (this.#version === void 0) {
        this.#setClosed(new ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));
      }
    }
    for (const callbacks of this.#openCallbacks) {
      callbacks.openCallback();
    }
    this.#openCallbacks.length = 0;
    this.#opened = true;
  }
  #sendToSocket(msg) {
    this.#socket.send(JSON.stringify(msg));
  }
  /** Get the protocol version negotiated with the server, possibly waiting until the socket is open. */
  getVersion() {
    return new Promise((versionCallback, errorCallback) => {
      this.#getVersionCalled = true;
      if (this.#closed !== void 0) {
        errorCallback(this.#closed);
      } else if (!this.#opened) {
        const openCallback = /* @__PURE__ */ __name(() => versionCallback(this.#version), "openCallback");
        this.#openCallbacks.push({ openCallback, errorCallback });
      } else {
        versionCallback(this.#version);
      }
    });
  }
  // Make sure that the negotiated version is at least `minVersion`.
  /** @private */
  _ensureVersion(minVersion, feature) {
    if (this.#version === void 0 || !this.#getVersionCalled) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, but the version supported by the server is not yet known. Use WsClient.getVersion() to wait until the version is available.`);
    } else if (this.#version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, but the server only supports version ${this.#version}`);
    }
  }
  // Send a request to the server and invoke a callback when we get the response.
  /** @private */
  _sendRequest(request3, callbacks) {
    if (this.#closed !== void 0) {
      callbacks.errorCallback(new ClosedError("Client is closed", this.#closed));
      return;
    }
    const requestId = this.#requestIdAlloc.alloc();
    this.#responseMap.set(requestId, { ...callbacks, type: request3.type });
    this.#send({ "type": "request", "request_id": requestId, request: request3 });
  }
  // The socket encountered an error.
  #onSocketError(event) {
    const eventMessage = event.message;
    const message = eventMessage ?? "Connection was closed due to an error";
    this.#setClosed(new WebSocketError(message));
  }
  // The socket was closed.
  #onSocketClose(event) {
    let message = `WebSocket was closed with code ${event.code}`;
    if (event.reason) {
      message += `: ${event.reason}`;
    }
    this.#setClosed(new WebSocketError(message));
  }
  // Close the client with the given error.
  #setClosed(error) {
    if (this.#closed !== void 0) {
      return;
    }
    this.#closed = error;
    for (const callbacks of this.#openCallbacks) {
      callbacks.errorCallback(error);
    }
    this.#openCallbacks.length = 0;
    for (const [requestId, responseState] of this.#responseMap.entries()) {
      responseState.errorCallback(error);
      this.#requestIdAlloc.free(requestId);
    }
    this.#responseMap.clear();
    this.#socket.close();
  }
  // We received a message from the socket.
  #onSocketMessage(event) {
    if (this.#closed !== void 0) {
      return;
    }
    if (typeof event.data !== "string") {
      this.#socket.close(3003, "Only string messages are accepted");
      this.#setClosed(new ProtoError("Received non-string message from server"));
      return;
    }
    try {
      this.#handleMsg(event.data);
    } catch (e10) {
      this.#socket.close(3007, "Could not handle message");
      this.#setClosed(e10);
    }
  }
  // Handle a message from the server.
  #handleMsg(msgText) {
    const msg = JSON.parse(msgText);
    if (msg["type"] === "hello_ok" || msg["type"] === "hello_error") {
      if (this.#recvdHello) {
        throw new ProtoError("Received a duplicated hello response");
      }
      this.#recvdHello = true;
      if (msg["type"] === "hello_error") {
        throw errorFromProto(msg["error"]);
      }
      return;
    } else if (!this.#recvdHello) {
      throw new ProtoError("Received a non-hello message before a hello response");
    }
    if (msg["type"] === "response_ok") {
      const requestId = msg["request_id"];
      const responseState = this.#responseMap.get(requestId);
      this.#responseMap.delete(requestId);
      if (responseState === void 0) {
        throw new ProtoError("Received unexpected OK response");
      }
      this.#requestIdAlloc.free(requestId);
      try {
        if (responseState.type !== msg["response"]["type"]) {
          throw new ProtoError("Received unexpected type of response");
        }
        responseState.responseCallback(msg["response"]);
      } catch (e10) {
        responseState.errorCallback(e10);
        throw e10;
      }
    } else if (msg["type"] === "response_error") {
      const requestId = msg["request_id"];
      const responseState = this.#responseMap.get(requestId);
      this.#responseMap.delete(requestId);
      if (responseState === void 0) {
        throw new ProtoError("Received unexpected error response");
      }
      this.#requestIdAlloc.free(requestId);
      responseState.errorCallback(errorFromProto(msg["error"]));
    } else {
      throw new ProtoError("Received unexpected message type");
    }
  }
  /** Open a {@link WsStream}, a stream for executing SQL statements. */
  openStream() {
    const streamId = this.#streamIdAlloc.alloc();
    const streamState = {
      streamId,
      closed: void 0
    };
    const responseCallback = /* @__PURE__ */ __name(() => void 0, "responseCallback");
    const errorCallback = /* @__PURE__ */ __name((e10) => this._closeStream(streamState, e10), "errorCallback");
    const request3 = {
      "type": "open_stream",
      "stream_id": streamId
    };
    this._sendRequest(request3, { responseCallback, errorCallback });
    return new WsStream(this, streamState);
  }
  // Make sure that the stream is closed.
  /** @private */
  _closeStream(streamState, error) {
    if (streamState.closed !== void 0 || this.#closed !== void 0) {
      return;
    }
    streamState.closed = error;
    const callback = /* @__PURE__ */ __name(() => {
      this.#streamIdAlloc.free(streamState.streamId);
    }, "callback");
    const request3 = {
      "type": "close_stream",
      "stream_id": streamState.streamId
    };
    this._sendRequest(request3, { responseCallback: callback, errorCallback: callback });
  }
  // Send a stream-specific request to the server and invoke a callback when we get the response.
  /** @private */
  _sendStreamRequest(streamState, request3, callbacks) {
    if (streamState.closed !== void 0) {
      callbacks.errorCallback(new ClosedError("Stream is closed", streamState.closed));
      return;
    }
    this._sendRequest(request3, callbacks);
  }
  /** Cache a SQL text on the server. This requires protocol version 2 or higher. */
  storeSql(sql2) {
    this._ensureVersion(2, "storeSql()");
    const sqlId = this.#sqlIdAlloc.alloc();
    const sqlState = {
      sqlId,
      closed: void 0
    };
    const responseCallback = /* @__PURE__ */ __name(() => void 0, "responseCallback");
    const errorCallback = /* @__PURE__ */ __name((e10) => this._closeSql(sqlState, e10), "errorCallback");
    const request3 = {
      "type": "store_sql",
      "sql_id": sqlId,
      "sql": sql2
    };
    this._sendRequest(request3, { responseCallback, errorCallback });
    return new Sql(this, sqlState);
  }
  // Make sure that the SQL text is closed.
  /** @private */
  _closeSql(sqlState, error) {
    if (sqlState.closed !== void 0 || this.#closed !== void 0) {
      return;
    }
    sqlState.closed = error;
    const callback = /* @__PURE__ */ __name(() => {
      this.#sqlIdAlloc.free(sqlState.sqlId);
    }, "callback");
    const request3 = {
      "type": "close_sql",
      "sql_id": sqlState.sqlId
    };
    this._sendRequest(request3, { responseCallback: callback, errorCallback: callback });
  }
  /** Close the client and the WebSocket. */
  close() {
    this.#setClosed(new ClientError("Client was manually closed"));
  }
  /** True if the client is closed. */
  get closed() {
    return this.#closed !== void 0;
  }
};

// ../../node_modules/@libsql/hrana-client/lib-esm/index.js
function openWs(url12, jwt) {
  if (typeof import_websocket.default === "undefined") {
    throw new WebSocketUnsupportedError("WebSockets are not supported in this environment");
  }
  const socket = new import_websocket.default(url12, Array.from(protocolVersions.keys()));
  return new WsClient(socket, jwt ?? null);
}
__name(openWs, "openWs");
function openHttp(url12, jwt, customFetch) {
  return new HttpClient(url12 instanceof URL ? url12 : new URL(url12), jwt ?? null, customFetch);
}
__name(openHttp, "openHttp");

// ../../node_modules/@libsql/client/lib-esm/hrana.js
var HranaTransaction = class {
  static {
    __name(this, "HranaTransaction");
  }
  #mode;
  // Promise that is resolved when the BEGIN statement completes, or `undefined` if we haven't executed the
  // BEGIN statement yet.
  #started;
  /** @private */
  constructor(mode) {
    this.#mode = mode;
    this.#started = void 0;
  }
  async execute(stmt) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute a statement because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      const hranaStmt = stmtToHrana(stmt);
      let rowsPromise;
      if (this.#started === void 0) {
        this._getSqlCache().apply([hranaStmt]);
        const batch = stream.batch();
        const beginStep = batch.step();
        const beginPromise = beginStep.run(transactionModeToBegin(this.#mode));
        rowsPromise = batch.step().condition(BatchCond.ok(beginStep)).query(hranaStmt).then((result) => result);
        this.#started = batch.execute().then(() => beginPromise).then(() => void 0);
        try {
          await this.#started;
        } catch (e10) {
          this.close();
          throw e10;
        }
      } else {
        await this.#started;
        this._getSqlCache().apply([hranaStmt]);
        rowsPromise = stream.query(hranaStmt);
      }
      return resultSetFromHrana(await rowsPromise);
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  async batch(stmts) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute a batch because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      let rowsPromises;
      if (this.#started === void 0) {
        this._getSqlCache().apply(hranaStmts);
        const batch = stream.batch();
        const beginStep = batch.step();
        const beginPromise = beginStep.run(transactionModeToBegin(this.#mode));
        let lastStep = beginStep;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch.step().condition(BatchCond.ok(lastStep));
          const rowsPromise = stmtStep.query(hranaStmt);
          lastStep = stmtStep;
          return rowsPromise;
        });
        this.#started = batch.execute().then(() => beginPromise).then(() => void 0);
        try {
          await this.#started;
        } catch (e10) {
          this.close();
          throw e10;
        }
      } else {
        await this.#started;
        this._getSqlCache().apply(hranaStmts);
        const batch = stream.batch();
        let lastStep = void 0;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch.step();
          if (lastStep !== void 0) {
            stmtStep.condition(BatchCond.ok(lastStep));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          lastStep = stmtStep;
          return rowsPromise;
        });
        await batch.execute();
      }
      const resultSets = [];
      for (const rowsPromise of rowsPromises) {
        const rows = await rowsPromise;
        if (rows === void 0) {
          throw new LibsqlError("Server did not return a result for statement in a batch", "SERVER_ERROR");
        }
        resultSets.push(resultSetFromHrana(rows));
      }
      return resultSets;
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  async executeMultiple(sql2) {
    const stream = this._getStream();
    if (stream.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      if (this.#started === void 0) {
        this.#started = stream.run(transactionModeToBegin(this.#mode)).then(() => void 0);
        try {
          await this.#started;
        } catch (e10) {
          this.close();
          throw e10;
        }
      } else {
        await this.#started;
      }
      await stream.sequence(sql2);
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  async rollback() {
    try {
      const stream = this._getStream();
      if (stream.closed) {
        return;
      }
      if (this.#started !== void 0) {
      } else {
        return;
      }
      const promise = stream.run("ROLLBACK").catch((e10) => {
        throw mapHranaError(e10);
      });
      stream.close();
      await promise;
    } catch (e10) {
      throw mapHranaError(e10);
    } finally {
      this.close();
    }
  }
  async commit() {
    try {
      const stream = this._getStream();
      if (stream.closed) {
        throw new LibsqlError("Cannot commit the transaction because it is already closed", "TRANSACTION_CLOSED");
      }
      if (this.#started !== void 0) {
        await this.#started;
      } else {
        return;
      }
      const promise = stream.run("COMMIT").catch((e10) => {
        throw mapHranaError(e10);
      });
      stream.close();
      await promise;
    } catch (e10) {
      throw mapHranaError(e10);
    } finally {
      this.close();
    }
  }
};
async function executeHranaBatch(mode, batch, hranaStmts) {
  const beginStep = batch.step();
  const beginPromise = beginStep.run(transactionModeToBegin(mode));
  let lastStep = beginStep;
  const stmtPromises = hranaStmts.map((hranaStmt) => {
    const stmtStep = batch.step().condition(BatchCond.ok(lastStep));
    const stmtPromise = stmtStep.query(hranaStmt);
    lastStep = stmtStep;
    return stmtPromise;
  });
  const commitStep = batch.step().condition(BatchCond.ok(lastStep));
  const commitPromise = commitStep.run("COMMIT");
  const rollbackStep = batch.step().condition(BatchCond.not(BatchCond.ok(commitStep)));
  rollbackStep.run("ROLLBACK").catch((_) => void 0);
  await batch.execute();
  const resultSets = [];
  await beginPromise;
  for (const stmtPromise of stmtPromises) {
    const hranaRows = await stmtPromise;
    if (hranaRows === void 0) {
      throw new LibsqlError("Server did not return a result for statement in a batch", "SERVER_ERROR");
    }
    resultSets.push(resultSetFromHrana(hranaRows));
  }
  await commitPromise;
  return resultSets;
}
__name(executeHranaBatch, "executeHranaBatch");
function stmtToHrana(stmt) {
  if (typeof stmt === "string") {
    return new Stmt(stmt);
  }
  const hranaStmt = new Stmt(stmt.sql);
  if (Array.isArray(stmt.args)) {
    hranaStmt.bindIndexes(stmt.args);
  } else {
    for (const [key, value] of Object.entries(stmt.args)) {
      hranaStmt.bindName(key, value);
    }
  }
  return hranaStmt;
}
__name(stmtToHrana, "stmtToHrana");
function resultSetFromHrana(hranaRows) {
  const columns = hranaRows.columnNames.map((c11) => c11 ?? "");
  const rows = hranaRows.rows;
  const rowsAffected = hranaRows.affectedRowCount;
  const lastInsertRowid = hranaRows.lastInsertRowid !== void 0 ? BigInt(hranaRows.lastInsertRowid) : void 0;
  return new ResultSetImpl(columns, rows, rowsAffected, lastInsertRowid);
}
__name(resultSetFromHrana, "resultSetFromHrana");
function mapHranaError(e10) {
  if (e10 instanceof ClientError) {
    let code2 = "UNKNOWN";
    if (e10 instanceof ResponseError && e10.code !== void 0) {
      code2 = e10.code;
    } else if (e10 instanceof ProtoError) {
      code2 = "HRANA_PROTO_ERROR";
    } else if (e10 instanceof ClosedError) {
      code2 = "HRANA_CLOSED_ERROR";
    } else if (e10 instanceof WebSocketError) {
      code2 = "HRANA_WEBSOCKET_ERROR";
    } else if (e10 instanceof HttpServerError) {
      code2 = "SERVER_ERROR";
    } else if (e10 instanceof ProtocolVersionError) {
      code2 = "PROTOCOL_VERSION_ERROR";
    }
    return new LibsqlError(e10.message, code2, e10);
  }
  return e10;
}
__name(mapHranaError, "mapHranaError");

// ../../node_modules/@libsql/client/lib-esm/sql_cache.js
var SqlCache = class {
  static {
    __name(this, "SqlCache");
  }
  #owner;
  #sqls;
  capacity;
  constructor(owner, capacity) {
    this.#owner = owner;
    this.#sqls = new Lru();
    this.capacity = capacity;
  }
  // Replaces SQL strings with cached `hrana.Sql` objects in the statements in `hranaStmts`. After this
  // function returns, we guarantee that all `hranaStmts` refer to valid (not closed) `hrana.Sql` objects,
  // but _we may invalidate any other `hrana.Sql` objects_ (by closing them, thus removing them from the
  // server).
  //
  // In practice, this means that after calling this function, you can use the statements only up to the
  // first `await`, because concurrent code may also use the cache and invalidate those statements.
  apply(hranaStmts) {
    if (this.capacity <= 0) {
      return;
    }
    const usedSqlObjs = /* @__PURE__ */ new Set();
    for (const hranaStmt of hranaStmts) {
      if (typeof hranaStmt.sql !== "string") {
        continue;
      }
      const sqlText = hranaStmt.sql;
      let sqlObj = this.#sqls.get(sqlText);
      if (sqlObj === void 0) {
        while (this.#sqls.size + 1 > this.capacity) {
          const [evictSqlText, evictSqlObj] = this.#sqls.peekLru();
          if (usedSqlObjs.has(evictSqlObj)) {
            break;
          }
          evictSqlObj.close();
          this.#sqls.delete(evictSqlText);
        }
        if (this.#sqls.size + 1 <= this.capacity) {
          sqlObj = this.#owner.storeSql(sqlText);
          this.#sqls.set(sqlText, sqlObj);
        }
      }
      if (sqlObj !== void 0) {
        hranaStmt.sql = sqlObj;
        usedSqlObjs.add(sqlObj);
      }
    }
  }
};
var Lru = class {
  static {
    __name(this, "Lru");
  }
  // This maps keys to the cache values. The entries are ordered by their last use (entires that were used
  // most recently are at the end).
  #cache;
  constructor() {
    this.#cache = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.#cache.get(key);
    if (value !== void 0) {
      this.#cache.delete(key);
      this.#cache.set(key, value);
    }
    return value;
  }
  set(key, value) {
    this.#cache.set(key, value);
  }
  peekLru() {
    for (const entry of this.#cache.entries()) {
      return entry;
    }
    return void 0;
  }
  delete(key) {
    this.#cache.delete(key);
  }
  get size() {
    return this.#cache.size;
  }
};

// ../../node_modules/@libsql/client/lib-esm/ws.js
function _createClient2(config) {
  if (config.scheme !== "wss" && config.scheme !== "ws") {
    throw new LibsqlError(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config.scheme === "ws" && config.tls) {
    throw new LibsqlError(`A "ws:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config.scheme === "wss" && !config.tls) {
    throw new LibsqlError(`A "wss:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url12 = encodeBaseUrl(config.scheme, config.authority, config.path);
  let client10;
  try {
    client10 = openWs(url12, config.authToken);
  } catch (e10) {
    if (e10 instanceof WebSocketUnsupportedError) {
      const suggestedScheme = config.scheme === "wss" ? "https" : "http";
      const suggestedUrl = encodeBaseUrl(suggestedScheme, config.authority, config.path);
      throw new LibsqlError(`This environment does not support WebSockets, please switch to the HTTP client by using a "${suggestedScheme}:" URL (${JSON.stringify(suggestedUrl)}). For more information, please read ${supportedUrlLink}`, "WEBSOCKETS_NOT_SUPPORTED");
    }
    throw mapHranaError(e10);
  }
  return new WsClient2(client10, url12, config.authToken, config.intMode);
}
__name(_createClient2, "_createClient");
var maxConnAgeMillis = 60 * 1e3;
var sqlCacheCapacity = 100;
var WsClient2 = class {
  static {
    __name(this, "WsClient");
  }
  #url;
  #authToken;
  #intMode;
  // State of the current connection. The `hrana.WsClient` inside may be closed at any moment due to an
  // asynchronous error.
  #connState;
  // If defined, this is a connection that will be used in the future, once it is ready.
  #futureConnState;
  closed;
  protocol;
  /** @private */
  constructor(client10, url12, authToken, intMode) {
    this.#url = url12;
    this.#authToken = authToken;
    this.#intMode = intMode;
    this.#connState = this.#openConn(client10);
    this.#futureConnState = void 0;
    this.closed = false;
    this.protocol = "ws";
  }
  async execute(stmt) {
    const streamState = await this.#openStream();
    try {
      const hranaStmt = stmtToHrana(stmt);
      streamState.conn.sqlCache.apply([hranaStmt]);
      const hranaRowsPromise = streamState.stream.query(hranaStmt);
      streamState.stream.close();
      return resultSetFromHrana(await hranaRowsPromise);
    } catch (e10) {
      throw mapHranaError(e10);
    } finally {
      this._closeStream(streamState);
    }
  }
  async batch(stmts, mode = "deferred") {
    const streamState = await this.#openStream();
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      streamState.conn.sqlCache.apply(hranaStmts);
      const batch = streamState.stream.batch();
      const resultsPromise = executeHranaBatch(mode, batch, hranaStmts);
      streamState.stream.close();
      return await resultsPromise;
    } catch (e10) {
      throw mapHranaError(e10);
    } finally {
      this._closeStream(streamState);
    }
  }
  async transaction(mode = "write") {
    const streamState = await this.#openStream();
    try {
      return new WsTransaction(this, streamState, mode);
    } catch (e10) {
      this._closeStream(streamState);
      throw mapHranaError(e10);
    }
  }
  async executeMultiple(sql2) {
    const streamState = await this.#openStream();
    try {
      const promise = streamState.stream.sequence(sql2);
      streamState.stream.close();
      await promise;
    } catch (e10) {
      throw mapHranaError(e10);
    } finally {
      this._closeStream(streamState);
    }
  }
  async #openStream() {
    if (this.closed) {
      throw new LibsqlError("The client is closed", "CLIENT_CLOSED");
    }
    const now = /* @__PURE__ */ new Date();
    const ageMillis = now.valueOf() - this.#connState.openTime.valueOf();
    if (ageMillis > maxConnAgeMillis && this.#futureConnState === void 0) {
      const futureConnState = this.#openConn();
      this.#futureConnState = futureConnState;
      futureConnState.client.getVersion().then((_version) => {
        if (this.#connState !== futureConnState) {
          if (this.#connState.streamStates.size === 0) {
            this.#connState.client.close();
          } else {
          }
        }
        this.#connState = futureConnState;
        this.#futureConnState = void 0;
      }, (_e) => {
        this.#futureConnState = void 0;
      });
    }
    if (this.#connState.client.closed) {
      try {
        if (this.#futureConnState !== void 0) {
          this.#connState = this.#futureConnState;
        } else {
          this.#connState = this.#openConn();
        }
      } catch (e10) {
        throw mapHranaError(e10);
      }
    }
    const connState = this.#connState;
    try {
      if (connState.useSqlCache === void 0) {
        connState.useSqlCache = await connState.client.getVersion() >= 2;
        if (connState.useSqlCache) {
          connState.sqlCache.capacity = sqlCacheCapacity;
        }
      }
      const stream = connState.client.openStream();
      stream.intMode = this.#intMode;
      const streamState = { conn: connState, stream };
      connState.streamStates.add(streamState);
      return streamState;
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  #openConn(client10) {
    try {
      client10 ??= openWs(this.#url, this.#authToken);
      return {
        client: client10,
        useSqlCache: void 0,
        sqlCache: new SqlCache(client10, 0),
        openTime: /* @__PURE__ */ new Date(),
        streamStates: /* @__PURE__ */ new Set()
      };
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  _closeStream(streamState) {
    streamState.stream.close();
    const connState = streamState.conn;
    connState.streamStates.delete(streamState);
    if (connState.streamStates.size === 0 && connState !== this.#connState) {
      connState.client.close();
    }
  }
  close() {
    this.#connState.client.close();
    this.closed = true;
  }
};
var WsTransaction = class extends HranaTransaction {
  static {
    __name(this, "WsTransaction");
  }
  #client;
  #streamState;
  /** @private */
  constructor(client10, state, mode) {
    super(mode);
    this.#client = client10;
    this.#streamState = state;
  }
  /** @private */
  _getStream() {
    return this.#streamState.stream;
  }
  /** @private */
  _getSqlCache() {
    return this.#streamState.conn.sqlCache;
  }
  close() {
    this.#client._closeStream(this.#streamState);
  }
  get closed() {
    return this.#streamState.stream.closed;
  }
};

// ../../node_modules/@libsql/client/lib-esm/http.js
function _createClient3(config) {
  if (config.scheme !== "https" && config.scheme !== "http") {
    throw new LibsqlError(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(config.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config.scheme === "http" && config.tls) {
    throw new LibsqlError(`A "http:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config.scheme === "https" && !config.tls) {
    throw new LibsqlError(`A "https:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url12 = encodeBaseUrl(config.scheme, config.authority, config.path);
  return new HttpClient2(url12, config.authToken, config.intMode, config.fetch);
}
__name(_createClient3, "_createClient");
var sqlCacheCapacity2 = 30;
var HttpClient2 = class {
  static {
    __name(this, "HttpClient");
  }
  #client;
  protocol;
  /** @private */
  constructor(url12, authToken, intMode, customFetch) {
    this.#client = openHttp(url12, authToken, customFetch);
    this.#client.intMode = intMode;
    this.protocol = "http";
  }
  async execute(stmt) {
    try {
      const hranaStmt = stmtToHrana(stmt);
      let rowsPromise;
      const stream = this.#client.openStream();
      try {
        rowsPromise = stream.query(hranaStmt);
      } finally {
        stream.close();
      }
      return resultSetFromHrana(await rowsPromise);
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  async batch(stmts, mode = "deferred") {
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      let resultsPromise;
      const stream = this.#client.openStream();
      try {
        const sqlCache = new SqlCache(stream, sqlCacheCapacity2);
        sqlCache.apply(hranaStmts);
        const batch = stream.batch();
        resultsPromise = executeHranaBatch(mode, batch, hranaStmts);
      } finally {
        stream.close();
      }
      return await resultsPromise;
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  async transaction(mode = "write") {
    try {
      return new HttpTransaction(this.#client.openStream(), mode);
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  async executeMultiple(sql2) {
    try {
      let promise;
      const stream = this.#client.openStream();
      try {
        promise = stream.sequence(sql2);
      } finally {
        stream.close();
      }
      await promise;
    } catch (e10) {
      throw mapHranaError(e10);
    }
  }
  close() {
    this.#client.close();
  }
  get closed() {
    return this.#client.closed;
  }
};
var HttpTransaction = class extends HranaTransaction {
  static {
    __name(this, "HttpTransaction");
  }
  #stream;
  #sqlCache;
  /** @private */
  constructor(stream, mode) {
    super(mode);
    this.#stream = stream;
    this.#sqlCache = new SqlCache(stream, sqlCacheCapacity2);
  }
  /** @private */
  _getStream() {
    return this.#stream;
  }
  /** @private */
  _getSqlCache() {
    return this.#sqlCache;
  }
  close() {
    this.#stream.close();
  }
  get closed() {
    return this.#stream.closed;
  }
};

// ../../node_modules/@libsql/client/lib-esm/index.js
function createClient(config) {
  return _createClient4(expandConfig(config, true));
}
__name(createClient, "createClient");
function _createClient4(config) {
  if (config.scheme === "wss" || config.scheme === "ws") {
    return _createClient2(config);
  } else if (config.scheme === "https" || config.scheme === "http") {
    return _createClient3(config);
  } else {
    return _createClient(config);
  }
}
__name(_createClient4, "_createClient");

// ../../node_modules/drizzle-orm/alias-cf8e03cd.mjs
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
__name(is, "is");
var Column = class {
  static {
    __name(this, "Column");
  }
  table;
  static [entityKind] = "Column";
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  config;
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
  }
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
};
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
var View = class {
  static {
    __name(this, "View");
  }
  static [entityKind] = "View";
  /** @internal */
  [ViewBaseConfig];
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");
var Subquery = class {
  static {
    __name(this, "Subquery");
  }
  static [entityKind] = "Subquery";
  /** @internal */
  [SubqueryConfig];
  constructor(sql2, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql: sql2,
      selection,
      alias,
      isWith
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
var WithSubquery = class extends Subquery {
  static {
    __name(this, "WithSubquery");
  }
  static [entityKind] = "WithSubquery";
};
var SelectionProxyHandler = class _SelectionProxyHandler {
  static {
    __name(this, "SelectionProxyHandler");
  }
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery[SubqueryConfig],
        selection: new Proxy(subquery[SubqueryConfig].selection, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery[SubqueryConfig].selection : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new _SelectionProxyHandler(this.config));
  }
};
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder2;
    if (is(field, Column)) {
      decoder2 = field;
    } else if (is(field, SQL)) {
      decoder2 = field.decoder;
    } else {
      decoder2 = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
__name(mapResultRow, "mapResultRow");
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name2, field]) => {
    if (typeof name2 !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name2] : [name2];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
__name(orderSelectedFields, "orderSelectedFields");
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
__name(mapUpdateSet, "mapUpdateSet");
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name2 of Object.getOwnPropertyNames(extendedClass.prototype)) {
      Object.defineProperty(baseClass.prototype, name2, Object.getOwnPropertyDescriptor(extendedClass.prototype, name2) || /* @__PURE__ */ Object.create(null));
    }
  }
}
__name(applyMixins, "applyMixins");
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
__name(getTableColumns, "getTableColumns");
function getTableLikeName(table) {
  return is(table, Subquery) ? table[SubqueryConfig].alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
__name(getTableLikeName, "getTableLikeName");
function iife(fn, ...args) {
  return fn(...args);
}
__name(iife, "iife");
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
var Table = class {
  static {
    __name(this, "Table");
  }
  static [entityKind] = "Table";
  /** @internal */
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [TableName];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema];
  /** @internal */
  [Columns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  [IsDrizzleTable] = true;
  constructor(name2, schema, baseName) {
    this[TableName] = this[OriginalName] = name2;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
  getSQL() {
    return new SQL([this]);
  }
};
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
__name(isTable, "isTable");
function getTableName(table) {
  return table[TableName];
}
__name(getTableName, "getTableName");
var QueryPromise = class {
  static {
    __name(this, "QueryPromise");
  }
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};
var tracer = {
  startActiveSpan(name2, fn) {
    {
      return fn();
    }
  }
};
var DrizzleError = class _DrizzleError extends Error {
  static {
    __name(this, "DrizzleError");
  }
  static [entityKind] = "DrizzleError";
  constructor(message) {
    super(message);
    this.name = "DrizzleError";
  }
  static wrap(error, message) {
    return error instanceof Error ? new _DrizzleError(message ? `${message}: ${error.message}` : error.message) : new _DrizzleError(message ?? String(error));
  }
};
var TransactionRollbackError = class extends DrizzleError {
  static {
    __name(this, "TransactionRollbackError");
  }
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super("Rollback");
  }
};
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var PgTable = class extends Table {
  static {
    __name(this, "PgTable");
  }
  static [entityKind] = "PgTable";
  /** @internal */
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys
  });
  /**@internal */
  [InlineForeignKeys] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
function pgTableWithSchema(name2, columns, extraConfig, schema, baseName = name2) {
  const rawTable = new PgTable(name2, schema, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name3, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name3, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
__name(pgTableWithSchema, "pgTableWithSchema");
var pgTable = /* @__PURE__ */ __name((name2, columns, extraConfig) => {
  return pgTableWithSchema(name2, columns, extraConfig, void 0);
}, "pgTable");
var CheckBuilder = class {
  static {
    __name(this, "CheckBuilder");
  }
  name;
  value;
  static [entityKind] = "PgCheckBuilder";
  brand;
  constructor(name2, value) {
    this.name = name2;
    this.value = value;
  }
  /** @internal */
  build(table) {
    return new Check(table, this);
  }
};
var Check = class {
  static {
    __name(this, "Check");
  }
  table;
  static [entityKind] = "PgCheck";
  name;
  value;
  constructor(table, builder) {
    this.table = table;
    this.name = builder.name;
    this.value = builder.value;
  }
};
var ForeignKeyBuilder = class {
  static {
    __name(this, "ForeignKeyBuilder");
  }
  static [entityKind] = "PgForeignKeyBuilder";
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { columns, foreignColumns } = config();
      return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table) {
    return new ForeignKey(table, this);
  }
};
var ForeignKey = class {
  static {
    __name(this, "ForeignKey");
  }
  table;
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  getName() {
    const { columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return `${chunks.join("_")}_fk`;
  }
};
var IndexBuilderOn = class {
  static {
    __name(this, "IndexBuilderOn");
  }
  unique;
  name;
  static [entityKind] = "PgIndexBuilderOn";
  constructor(unique3, name2) {
    this.unique = unique3;
    this.name = name2;
  }
  on(...columns) {
    return new IndexBuilder(columns, this.unique, false, this.name);
  }
  onOnly(...columns) {
    return new IndexBuilder(columns, this.unique, true, this.name);
  }
};
var IndexBuilder = class {
  static {
    __name(this, "IndexBuilder");
  }
  static [entityKind] = "PgIndexBuilder";
  /** @internal */
  config;
  constructor(columns, unique3, only, name2) {
    this.config = {
      name: name2,
      columns,
      unique: unique3,
      only
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  using(method) {
    this.config.using = method;
    return this;
  }
  asc() {
    this.config.order = "asc";
    return this;
  }
  desc() {
    this.config.order = "desc";
    return this;
  }
  nullsFirst() {
    this.config.nulls = "first";
    return this;
  }
  nullsLast() {
    this.config.nulls = "last";
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  /** @internal */
  build(table) {
    return new Index(this.config, table);
  }
};
var Index = class {
  static {
    __name(this, "Index");
  }
  static [entityKind] = "PgIndex";
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
};
var PrimaryKeyBuilder = class {
  static {
    __name(this, "PrimaryKeyBuilder");
  }
  static [entityKind] = "PgPrimaryKeyBuilder";
  /** @internal */
  columns;
  constructor(columns) {
    this.columns = columns;
  }
  /** @internal */
  build(table) {
    return new PrimaryKey(table, this.columns);
  }
};
var PrimaryKey = class {
  static {
    __name(this, "PrimaryKey");
  }
  table;
  static [entityKind] = "PgPrimaryKey";
  columns;
  constructor(table, columns) {
    this.table = table;
    this.columns = columns;
  }
  getName() {
    return `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};
function uniqueKeyName(table, columns) {
  return `${table[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName, "uniqueKeyName");
var UniqueConstraintBuilder = class {
  static {
    __name(this, "UniqueConstraintBuilder");
  }
  name;
  static [entityKind] = "PgUniqueConstraintBuilder";
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  constructor(columns, name2) {
    this.name = name2;
    this.columns = columns;
  }
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table) {
    return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
var UniqueOnConstraintBuilder = class {
  static {
    __name(this, "UniqueOnConstraintBuilder");
  }
  static [entityKind] = "PgUniqueOnConstraintBuilder";
  /** @internal */
  name;
  constructor(name2) {
    this.name = name2;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
var UniqueConstraint = class {
  static {
    __name(this, "UniqueConstraint");
  }
  table;
  static [entityKind] = "PgUniqueConstraint";
  columns;
  name;
  nullsNotDistinct = false;
  constructor(table, columns, nullsNotDistinct, name2) {
    this.table = table;
    this.columns = columns;
    this.name = name2 ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  getName() {
    return this.name;
  }
};
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i10 = startFrom; i10 < arrayString.length; i10++) {
    const char = arrayString[i10];
    if (char === "\\") {
      i10++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i10).replace(/\\/g, ""), i10 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i10).replace(/\\/g, ""), i10];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
__name(parsePgArrayValue, "parsePgArrayValue");
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i10 = startFrom;
  let lastCharIsComma = false;
  while (i10 < arrayString.length) {
    const char = arrayString[i10];
    if (char === ",") {
      if (lastCharIsComma || i10 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i10++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i10 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i10 + 1, true);
      result.push(value2);
      i10 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i10 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i10 + 1);
      result.push(value2);
      i10 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i10, false);
    result.push(value);
    i10 = newStartFrom;
  }
  return [result, i10];
}
__name(parsePgNestedArray, "parsePgNestedArray");
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
__name(parsePgArray, "parsePgArray");
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string" && item.includes(",")) {
      return `"${item.replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
__name(makePgArray, "makePgArray");
var ColumnBuilder = class {
  static {
    __name(this, "ColumnBuilder");
  }
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name2, dataType, columnType) {
    this.config = {
      name: name2,
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
};
var PgColumnBuilder = class extends ColumnBuilder {
  static {
    __name(this, "PgColumnBuilder");
  }
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name2, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name2;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref, actions);
    });
  }
};
var PgColumn = class extends Column {
  static {
    __name(this, "PgColumn");
  }
  table;
  static [entityKind] = "PgColumn";
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
};
var PgArrayBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgArrayBuilder");
  }
  static [entityKind] = "PgArrayBuilder";
  constructor(name2, baseBuilder, size) {
    super(name2, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  /** @internal */
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
};
var PgArray = class _PgArray extends PgColumn {
  static {
    __name(this, "PgArray");
  }
  baseColumn;
  range;
  size;
  static [entityKind] = "PgArray";
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v7) => this.baseColumn.mapFromDriverValue(v7));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a10 = value.map((v7) => v7 === null ? null : is(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v7, true) : this.baseColumn.mapToDriverValue(v7));
    if (isNestedArray)
      return a10;
    return makePgArray(a10);
  }
};
var PgDateColumnBaseBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgDateColumnBaseBuilder");
  }
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
};
var PgDateBuilder = class extends PgDateColumnBaseBuilder {
  static {
    __name(this, "PgDateBuilder");
  }
  static [entityKind] = "PgDateBuilder";
  constructor(name2) {
    super(name2, "date", "PgDate");
  }
  /** @internal */
  build(table) {
    return new PgDate(table, this.config);
  }
};
var PgDate = class extends PgColumn {
  static {
    __name(this, "PgDate");
  }
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
};
var PgDateStringBuilder = class extends PgDateColumnBaseBuilder {
  static {
    __name(this, "PgDateStringBuilder");
  }
  static [entityKind] = "PgDateStringBuilder";
  constructor(name2) {
    super(name2, "string", "PgDateString");
  }
  /** @internal */
  build(table) {
    return new PgDateString(table, this.config);
  }
};
var PgDateString = class extends PgColumn {
  static {
    __name(this, "PgDateString");
  }
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
};
var PgJsonBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgJsonBuilder");
  }
  static [entityKind] = "PgJsonBuilder";
  constructor(name2) {
    super(name2, "json", "PgJson");
  }
  /** @internal */
  build(table) {
    return new PgJson(table, this.config);
  }
};
var PgJson = class extends PgColumn {
  static {
    __name(this, "PgJson");
  }
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
var PgJsonbBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgJsonbBuilder");
  }
  static [entityKind] = "PgJsonbBuilder";
  constructor(name2) {
    super(name2, "json", "PgJsonb");
  }
  /** @internal */
  build(table) {
    return new PgJsonb(table, this.config);
  }
};
var PgJsonb = class extends PgColumn {
  static {
    __name(this, "PgJsonb");
  }
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
};
var PgNumericBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgNumericBuilder");
  }
  static [entityKind] = "PgNumericBuilder";
  constructor(name2, precision, scale) {
    super(name2, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new PgNumeric(table, this.config);
  }
};
var PgNumeric = class extends PgColumn {
  static {
    __name(this, "PgNumeric");
  }
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
};
var PgTimeBuilder = class extends PgDateColumnBaseBuilder {
  static {
    __name(this, "PgTimeBuilder");
  }
  withTimezone;
  precision;
  static [entityKind] = "PgTimeBuilder";
  constructor(name2, withTimezone, precision) {
    super(name2, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTime(table, this.config);
  }
};
var PgTime = class extends PgColumn {
  static {
    __name(this, "PgTime");
  }
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
var PgTimestampBuilder = class extends PgDateColumnBaseBuilder {
  static {
    __name(this, "PgTimestampBuilder");
  }
  static [entityKind] = "PgTimestampBuilder";
  constructor(name2, withTimezone, precision) {
    super(name2, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestamp(table, this.config);
  }
};
var PgTimestamp = class extends PgColumn {
  static {
    __name(this, "PgTimestamp");
  }
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return this.withTimezone ? value.toUTCString() : value.toISOString();
  };
};
var PgTimestampStringBuilder = class extends PgDateColumnBaseBuilder {
  static {
    __name(this, "PgTimestampStringBuilder");
  }
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name2, withTimezone, precision) {
    super(name2, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  /** @internal */
  build(table) {
    return new PgTimestampString(table, this.config);
  }
};
var PgTimestampString = class extends PgColumn {
  static {
    __name(this, "PgTimestampString");
  }
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === void 0 ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
};
var PgUUIDBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgUUIDBuilder");
  }
  static [entityKind] = "PgUUIDBuilder";
  constructor(name2) {
    super(name2, "string", "PgUUID");
  }
  /**
   * Adds `default gen_random_uuid()` to the column definition.
   */
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  /** @internal */
  build(table) {
    return new PgUUID(table, this.config);
  }
};
var PgUUID = class extends PgColumn {
  static {
    __name(this, "PgUUID");
  }
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
};
var PgDialect = class {
  static {
    __name(this, "PgDialect");
  }
  static [entityKind] = "PgDialect";
  async migrate(migrations, session) {
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS "drizzle"`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name2) {
    return `"${name2}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table, where, returning }) {
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const setEntries = Object.entries(set);
    const setSize = setEntries.length;
    return sql.join(setEntries.flatMap(([colName, value], i10) => {
      const col = table[Table.Symbol.Columns][colName];
      const res = sql`${sql.identifier(col.name)} = ${value}`;
      if (i10 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning }) {
    const setSql = this.buildUpdateSet(table, set);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i10) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c11) => {
            if (is(c11, PgColumn)) {
              return sql.identifier(c11.name);
            }
            return c11;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i10 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClauses, distinct }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f11 of fieldsList) {
      if (is(f11.field, Column) && getTableName(f11.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f11.field.table)) {
        const tableName = getTableName(f11.field.table);
        throw new Error(`Your "${f11.path.join("->")}" field references a column "${tableName}"."${f11.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql`with `];
      for (const [i10, w4] of withList.entries()) {
        withSqlChunks.push(sql`${sql.identifier(w4[SubqueryConfig].alias)} as (${w4[SubqueryConfig].sql})`);
        if (i10 < withList.length - 1) {
          withSqlChunks.push(sql`, `);
        }
      }
      withSqlChunks.push(sql` `);
      withSql = sql.join(withSqlChunks);
    }
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, ", ")})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
        if (table[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
        if (is(table2, PgTable)) {
          const tableName = table2[PgTable.Symbol.Name];
          const tableSchema = table2[PgTable.Symbol.Schema];
          const origTableName = table2[PgTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else if (is(table2, View)) {
          const viewName = table2[ViewBaseConfig].name;
          const viewSchema = table2[ViewBaseConfig].schema;
          const origViewName = table2[ViewBaseConfig].originalName;
          const alias = viewName === origViewName ? void 0 : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`);
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const lockingClausesSql = sql.empty();
    if (lockingClauses) {
      for (const { strength, config } of lockingClauses) {
        const clauseSql = sql` for ${sql.raw(strength)}`;
        if (config.of) {
          clauseSql.append(sql` of ${config.of}`);
        }
        if (config.noWait) {
          clauseSql.append(sql` no wait`);
        } else if (config.skipLocked) {
          clauseSql.append(sql` skip locked`);
        }
        lockingClausesSql.append(clauseSql);
      }
    }
    return sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
  }
  buildInsertQuery({ table, values, onConflict, returning }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    return sql`insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view: view2, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : void 0;
    const withNoDataSql = withNoData ? sql` with no data` : void 0;
    return sql`refresh materialized view${concurrentlySql} ${view2}${withNoDataSql}`;
  }
  prepareTyping(encoder2) {
    if (is(encoder2, PgJsonb) || is(encoder2, PgJson)) {
      return "json";
    } else if (is(encoder2, PgNumeric)) {
      return "decimal";
    } else if (is(encoder2, PgTime)) {
      return "time";
    } else if (is(encoder2, PgTimestamp)) {
      return "timestamp";
    } else if (is(encoder2, PgDate)) {
      return "date";
    } else if (is(encoder2, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2) {
    return sql2.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping
    });
  }
  // buildRelationalQueryWithPK({
  // 	fullSchema,
  // 	schema,
  // 	tableNamesMap,
  // 	table,
  // 	tableConfig,
  // 	queryConfig: config,
  // 	tableAlias,
  // 	isRoot = false,
  // 	joinOn,
  // }: {
  // 	fullSchema: Record<string, unknown>;
  // 	schema: TablesRelationalConfig;
  // 	tableNamesMap: Record<string, string>;
  // 	table: PgTable;
  // 	tableConfig: TableRelationalConfig;
  // 	queryConfig: true | DBQueryConfig<'many', true>;
  // 	tableAlias: string;
  // 	isRoot?: boolean;
  // 	joinOn?: SQL;
  // }): BuildRelationalQueryResult<PgTable, PgColumn> {
  // 	// For { "<relation>": true }, return a table with selection of all columns
  // 	if (config === true) {
  // 		const selectionEntries = Object.entries(tableConfig.columns);
  // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
  // 			[key, value],
  // 		) => ({
  // 			dbKey: value.name,
  // 			tsKey: key,
  // 			field: value as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection,
  // 		};
  // 	}
  // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// let selectionForBuild = selection;
  // 	const aliasedColumns = Object.fromEntries(
  // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
  // 	);
  // 	const aliasedRelations = Object.fromEntries(
  // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
  // 	);
  // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
  // 	let where, hasUserDefinedWhere;
  // 	if (config.where) {
  // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
  // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
  // 		hasUserDefinedWhere = !!where;
  // 	}
  // 	where = and(joinOn, where);
  // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
  // 	let joins: Join[] = [];
  // 	let selectedColumns: string[] = [];
  // 	// Figure out which columns to select
  // 	if (config.columns) {
  // 		let isIncludeMode = false;
  // 		for (const [field, value] of Object.entries(config.columns)) {
  // 			if (value === undefined) {
  // 				continue;
  // 			}
  // 			if (field in tableConfig.columns) {
  // 				if (!isIncludeMode && value === true) {
  // 					isIncludeMode = true;
  // 				}
  // 				selectedColumns.push(field);
  // 			}
  // 		}
  // 		if (selectedColumns.length > 0) {
  // 			selectedColumns = isIncludeMode
  // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
  // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
  // 		}
  // 	} else {
  // 		// Select all columns if selection is not specified
  // 		selectedColumns = Object.keys(tableConfig.columns);
  // 	}
  // 	// for (const field of selectedColumns) {
  // 	// 	const column = tableConfig.columns[field]! as PgColumn;
  // 	// 	fieldsSelection.push({ tsKey: field, value: column });
  // 	// }
  // 	let initiallySelectedRelations: {
  // 		tsKey: string;
  // 		queryConfig: true | DBQueryConfig<'many', false>;
  // 		relation: Relation;
  // 	}[] = [];
  // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
  // 	// Figure out which relations to select
  // 	if (config.with) {
  // 		initiallySelectedRelations = Object.entries(config.with)
  // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
  // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
  // 	}
  // 	const manyRelations = initiallySelectedRelations.filter((r) =>
  // 		is(r.relation, Many)
  // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
  // 	);
  // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
  // 	const isInnermostQuery = manyRelations.length < 2;
  // 	const selectedExtras: {
  // 		tsKey: string;
  // 		value: SQL.Aliased;
  // 	}[] = [];
  // 	// Figure out which extras to select
  // 	if (isInnermostQuery && config.extras) {
  // 		const extras = typeof config.extras === 'function'
  // 			? config.extras(aliasedFields, { sql })
  // 			: config.extras;
  // 		for (const [tsKey, value] of Object.entries(extras)) {
  // 			selectedExtras.push({
  // 				tsKey,
  // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
  // 			});
  // 		}
  // 	}
  // 	// Transform `fieldsSelection` into `selection`
  // 	// `fieldsSelection` shouldn't be used after this point
  // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
  // 	// 	selection.push({
  // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
  // 	// 		tsKey,
  // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
  // 	// 		relationTableTsKey: undefined,
  // 	// 		isJson: false,
  // 	// 		isExtra,
  // 	// 		selection: [],
  // 	// 	});
  // 	// }
  // 	let orderByOrig = typeof config.orderBy === 'function'
  // 		? config.orderBy(aliasedFields, orderByOperators)
  // 		: config.orderBy ?? [];
  // 	if (!Array.isArray(orderByOrig)) {
  // 		orderByOrig = [orderByOrig];
  // 	}
  // 	const orderBy = orderByOrig.map((orderByValue) => {
  // 		if (is(orderByValue, Column)) {
  // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
  // 		}
  // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
  // 	});
  // 	const limit = isInnermostQuery ? config.limit : undefined;
  // 	const offset = isInnermostQuery ? config.offset : undefined;
  // 	// For non-root queries without additional config except columns, return a table with selection
  // 	if (
  // 		!isRoot
  // 		&& initiallySelectedRelations.length === 0
  // 		&& selectedExtras.length === 0
  // 		&& !where
  // 		&& orderBy.length === 0
  // 		&& limit === undefined
  // 		&& offset === undefined
  // 	) {
  // 		return {
  // 			tableTsKey: tableConfig.tsName,
  // 			sql: table,
  // 			selection: selectedColumns.map((key) => ({
  // 				dbKey: tableConfig.columns[key]!.name,
  // 				tsKey: key,
  // 				field: tableConfig.columns[key] as PgColumn,
  // 				relationTableTsKey: undefined,
  // 				isJson: false,
  // 				selection: [],
  // 			})),
  // 		};
  // 	}
  // 	const selectedRelationsWithoutPK:
  // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of initiallySelectedRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length > 0) {
  // 			continue;
  // 		}
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithoutPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 			nestedQueryRelation: relation,
  // 		});
  // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
  // 		joins.push({
  // 			on: sql`true`,
  // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: true,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
  // 		is(r.relation, One)
  // 	);
  // 	// Process all One relations with PKs, because they can all be joined on the same level
  // 	for (
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationConfigValue,
  // 			relation,
  // 		} of oneRelations
  // 	) {
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const relationTable = schema[relationTableTsName]!;
  // 		if (relationTable.primaryKey.length === 0) {
  // 			continue;
  // 		}
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelation = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationConfigValue,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
  // 			sql.join(
  // 				builtRelation.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelation.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: is(builtRelation.sql, SQL)
  // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
  // 				: aliasedTable(builtRelation.sql, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: is(builtRelation.sql, SQL),
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelation.selection,
  // 		});
  // 	}
  // 	let distinct: PgSelectConfig['distinct'];
  // 	let tableFrom: PgTable | Subquery = table;
  // 	// Process first Many relation - each one requires a nested subquery
  // 	const manyRelation = manyRelations[0];
  // 	if (manyRelation) {
  // 		const {
  // 			tsKey: selectedRelationTsKey,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			relation,
  // 		} = manyRelation;
  // 		distinct = {
  // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
  // 		};
  // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
  // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
  // 		const relationTableTsName = tableNamesMap[relationTableName]!;
  // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
  // 		const joinOn = and(
  // 			...normalizedRelation.fields.map((field, i) =>
  // 				eq(
  // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
  // 					aliasedTableColumn(field, tableAlias),
  // 				)
  // 			),
  // 		);
  // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table: fullSchema[relationTableTsName] as PgTable,
  // 			tableConfig: schema[relationTableTsName]!,
  // 			queryConfig: selectedRelationQueryConfig,
  // 			tableAlias: relationTableAlias,
  // 			joinOn,
  // 		});
  // 		const builtRelationSelectionField = sql`case when ${
  // 			sql.identifier(relationTableAlias)
  // 		} is null then '[]' else json_agg(json_build_array(${
  // 			sql.join(
  // 				builtRelationJoin.selection.map(({ field }) =>
  // 					is(field, SQL.Aliased)
  // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
  // 						: is(field, Column)
  // 						? aliasedTableColumn(field, relationTableAlias)
  // 						: field
  // 				),
  // 				sql`, `,
  // 			)
  // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
  // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
  // 		joins.push({
  // 			on: isLateralJoin ? sql`true` : joinOn,
  // 			table: isLateralJoin
  // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
  // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
  // 			alias: relationTableAlias,
  // 			joinType: 'left',
  // 			lateral: isLateralJoin,
  // 		});
  // 		// Build the "from" subquery with the remaining Many relations
  // 		const builtTableFrom = this.buildRelationalQueryWithPK({
  // 			fullSchema,
  // 			schema,
  // 			tableNamesMap,
  // 			table,
  // 			tableConfig,
  // 			queryConfig: {
  // 				...config,
  // 				where: undefined,
  // 				orderBy: undefined,
  // 				limit: undefined,
  // 				offset: undefined,
  // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
  // 					(result, { tsKey, queryConfig: configValue }) => {
  // 						result[tsKey] = configValue;
  // 						return result;
  // 					},
  // 					{},
  // 				),
  // 			},
  // 			tableAlias,
  // 		});
  // 		selectedRelations.push({
  // 			dbKey: selectedRelationTsKey,
  // 			tsKey: selectedRelationTsKey,
  // 			field: builtRelationSelectionField,
  // 			relationTableTsKey: relationTableTsName,
  // 			isJson: true,
  // 			selection: builtRelationJoin.selection,
  // 		});
  // 		// selection = builtTableFrom.selection.map((item) =>
  // 		// 	is(item.field, SQL.Aliased)
  // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 		// 		: item
  // 		// );
  // 		// selectionForBuild = [{
  // 		// 	dbKey: '*',
  // 		// 	tsKey: '*',
  // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
  // 		// 	selection: [],
  // 		// 	isJson: false,
  // 		// 	relationTableTsKey: undefined,
  // 		// }];
  // 		// const newSelectionItem: (typeof selection)[number] = {
  // 		// 	dbKey: selectedRelationTsKey,
  // 		// 	tsKey: selectedRelationTsKey,
  // 		// 	field,
  // 		// 	relationTableTsKey: relationTableTsName,
  // 		// 	isJson: true,
  // 		// 	selection: builtRelationJoin.selection,
  // 		// };
  // 		// selection.push(newSelectionItem);
  // 		// selectionForBuild.push(newSelectionItem);
  // 		tableFrom = is(builtTableFrom.sql, PgTable)
  // 			? builtTableFrom.sql
  // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
  // 	}
  // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
  // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
  // 	}
  // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
  // 	function prepareSelectedColumns() {
  // 		return selectedColumns.map((key) => ({
  // 			dbKey: tableConfig.columns[key]!.name,
  // 			tsKey: key,
  // 			field: tableConfig.columns[key] as PgColumn,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	function prepareSelectedExtras() {
  // 		return selectedExtras.map((item) => ({
  // 			dbKey: item.value.fieldAlias,
  // 			tsKey: item.tsKey,
  // 			field: item.value,
  // 			relationTableTsKey: undefined,
  // 			isJson: false,
  // 			selection: [],
  // 		}));
  // 	}
  // 	if (isRoot) {
  // 		selection = [
  // 			...prepareSelectedColumns(),
  // 			...prepareSelectedExtras(),
  // 		];
  // 	}
  // 	if (hasUserDefinedWhere || orderBy.length > 0) {
  // 		tableFrom = new Subquery(
  // 			this.buildSelectQuery({
  // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 				fields: {},
  // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 					path: [],
  // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 				})),
  // 				joins,
  // 				distinct,
  // 			}),
  // 			{},
  // 			tableAlias,
  // 		);
  // 		selectionForBuild = selection.map((item) =>
  // 			is(item.field, SQL.Aliased)
  // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
  // 				: item
  // 		);
  // 		joins = [];
  // 		distinct = undefined;
  // 	}
  // 	const result = this.buildSelectQuery({
  // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
  // 		fields: {},
  // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
  // 			path: [],
  // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
  // 		})),
  // 		where,
  // 		limit,
  // 		offset,
  // 		joins,
  // 		orderBy,
  // 		distinct,
  // 	});
  // 	return {
  // 		tableTsKey: tableConfig.tsName,
  // 		sql: result,
  // 		selection,
  // 	};
  // }
  buildRelationalQueryWithoutPK({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c11) => config.columns?.[c11] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i10) => eq(aliasedTableColumn(normalizedRelation.references[i10], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : void 0}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
var TypedQueryBuilder = class {
  static {
    __name(this, "TypedQueryBuilder");
  }
  static [entityKind] = "TypedQueryBuilder";
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};
var PgSelectBuilder = class {
  static {
    __name(this, "PgSelectBuilder");
  }
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  /**
   * Specify the table, subquery, or other target that you're
   * building a select query against.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM|Postgres from documentation}
   */
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelect({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
var PgSelectQueryBuilder = class extends TypedQueryBuilder {
  static {
    __name(this, "PgSelectQueryBuilder");
  }
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join4) => join4.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * For each row of the table, include
   * values from a matching row of the joined
   * table, if there is a matching row. If not,
   * all of the columns of the joined table
   * will be set to null.
   */
  leftJoin = this.createJoin("left");
  /**
   * Includes all of the rows of the joined table.
   * If there is no matching row in the main table,
   * all the columns of the main table will be
   * set to null.
   */
  rightJoin = this.createJoin("right");
  /**
   * This is the default type of join.
   *
   * For each row of the table, the joined table
   * needs to have a matching row, or it will
   * be excluded from results.
   */
  innerJoin = this.createJoin("inner");
  /**
   * Rows from both the main & joined are included,
   * regardless of whether or not they have matching
   * rows in the other table.
   */
  fullJoin = this.createJoin("full");
  /**
   * Specify a condition to narrow the result set. Multiple
   * conditions can be combined with the `and` and `or`
   * functions.
   *
   * ## Examples
   *
   * ```ts
   * // Find cars made in the year 2000
   * db.select().from(cars).where(eq(cars.year, 2000));
   * ```
   */
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  /**
   * Sets the HAVING clause of this query, which often
   * used with GROUP BY and filters rows after they've been
   * grouped together and combined.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING|Postgres having clause documentation}
   */
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
    } else {
      this.config.orderBy = columns;
    }
    return this;
  }
  /**
   * Set the maximum number of rows that will be
   * returned by this query.
   *
   * ## Examples
   *
   * ```ts
   * // Get the first 10 people from this query.
   * db.select().from(people).limit(10);
   * ```
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-LIMIT|Postgres LIMIT documentation}
   */
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  /**
   * Skip a number of rows when returning results
   * from this query.
   *
   * ## Examples
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    this.config.offset = offset;
    return this;
  }
  /**
   * The FOR clause specifies a lock strength for this query
   * that controls how strictly it acquires exclusive access to
   * the rows being queried.
   *
   * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE|Postgres locking clause documentation}
   */
  for(strength, config = {}) {
    if (!this.config.lockingClauses) {
      this.config.lockingClauses = [];
    }
    this.config.lockingClauses.push({ strength, config });
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
};
var PgSelect = class extends PgSelectQueryBuilder {
  static {
    __name(this, "PgSelect");
  }
  static [entityKind] = "PgSelect";
  _prepare(name2) {
    const { session, config, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config.fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name2);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  /**
   * Create a prepared statement for this query. This allows
   * the database to remember this query for the given session
   * and call it by name, rather than specifying the full query.
   *
   * {@link https://www.postgresql.org/docs/current/sql-prepare.html|Postgres prepare documentation}
   */
  prepare(name2) {
    return this._prepare(name2);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
};
applyMixins(PgSelect, [QueryPromise]);
var QueryBuilder = class {
  static {
    __name(this, "QueryBuilder");
  }
  static [entityKind] = "PgQueryBuilder";
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    __name(selectDistinctOn, "selectDistinctOn");
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect();
    }
    return this.dialect;
  }
};
var DefaultViewBuilderCore = class {
  static {
    __name(this, "DefaultViewBuilderCore");
  }
  name;
  schema;
  static [entityKind] = "PgDefaultViewBuilderCore";
  constructor(name2, schema) {
    this.name = name2;
    this.schema = schema;
  }
  config = {};
  with(config) {
    this.config.with = config;
    return this;
  }
};
var ViewBuilder = class extends DefaultViewBuilderCore {
  static {
    __name(this, "ViewBuilder");
  }
  static [entityKind] = "PgViewBuilder";
  as(qb) {
    if (typeof qb === "function") {
      qb = qb(new QueryBuilder());
    }
    const selectionProxy = new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    });
    const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
    return new Proxy(new PgView({
      pgConfig: this.config,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: aliasedSelection,
        query: qb.getSQL().inlineParams()
      }
    }), selectionProxy);
  }
};
var ManualViewBuilder = class extends DefaultViewBuilderCore {
  static {
    __name(this, "ManualViewBuilder");
  }
  static [entityKind] = "PgManualViewBuilder";
  columns;
  constructor(name2, columns, schema) {
    super(name2, schema);
    this.columns = getTableColumns(pgTable(name2, columns));
  }
  existing() {
    return new Proxy(new PgView({
      pgConfig: void 0,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: this.columns,
        query: void 0
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
  as(query) {
    return new Proxy(new PgView({
      pgConfig: this.config,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: this.columns,
        query: query.inlineParams()
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
};
var MaterializedViewBuilderCore = class {
  static {
    __name(this, "MaterializedViewBuilderCore");
  }
  name;
  schema;
  static [entityKind] = "PgMaterializedViewBuilderCore";
  constructor(name2, schema) {
    this.name = name2;
    this.schema = schema;
  }
  config = {};
  using(using) {
    this.config.using = using;
    return this;
  }
  with(config) {
    this.config.with = config;
    return this;
  }
  tablespace(tablespace) {
    this.config.tablespace = tablespace;
    return this;
  }
  withNoData() {
    this.config.withNoData = true;
    return this;
  }
};
var MaterializedViewBuilder = class extends MaterializedViewBuilderCore {
  static {
    __name(this, "MaterializedViewBuilder");
  }
  static [entityKind] = "PgMaterializedViewBuilder";
  as(qb) {
    if (typeof qb === "function") {
      qb = qb(new QueryBuilder());
    }
    const selectionProxy = new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    });
    const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
    return new Proxy(new PgMaterializedView({
      pgConfig: {
        with: this.config.with,
        using: this.config.using,
        tablespace: this.config.tablespace,
        withNoData: this.config.withNoData
      },
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: aliasedSelection,
        query: qb.getSQL().inlineParams()
      }
    }), selectionProxy);
  }
};
var ManualMaterializedViewBuilder = class extends MaterializedViewBuilderCore {
  static {
    __name(this, "ManualMaterializedViewBuilder");
  }
  static [entityKind] = "PgManualMaterializedViewBuilder";
  columns;
  constructor(name2, columns, schema) {
    super(name2, schema);
    this.columns = getTableColumns(pgTable(name2, columns));
  }
  existing() {
    return new Proxy(new PgMaterializedView({
      pgConfig: void 0,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: this.columns,
        query: void 0
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
  as(query) {
    return new Proxy(new PgMaterializedView({
      pgConfig: void 0,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: this.columns,
        query: query.inlineParams()
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
};
var PgViewBase = class extends View {
  static {
    __name(this, "PgViewBase");
  }
  static [entityKind] = "PgViewBase";
};
var PgViewConfig = Symbol.for("drizzle:PgViewConfig");
var PgView = class extends PgViewBase {
  static {
    __name(this, "PgView");
  }
  static [entityKind] = "PgView";
  [PgViewConfig];
  constructor({ pgConfig, config }) {
    super(config);
    if (pgConfig) {
      this[PgViewConfig] = {
        with: pgConfig.with
      };
    }
  }
};
var PgMaterializedViewConfig = Symbol.for("drizzle:PgMaterializedViewConfig");
var PgMaterializedView = class extends PgViewBase {
  static {
    __name(this, "PgMaterializedView");
  }
  static [entityKind] = "PgMaterializedView";
  [PgMaterializedViewConfig];
  constructor({ pgConfig, config }) {
    super(config);
    this[PgMaterializedViewConfig] = {
      with: pgConfig?.with,
      using: pgConfig?.using,
      tablespace: pgConfig?.tablespace,
      withNoData: pgConfig?.withNoData
    };
  }
};
function pgViewWithSchema(name2, selection, schema) {
  if (selection) {
    return new ManualViewBuilder(name2, selection, schema);
  }
  return new ViewBuilder(name2, schema);
}
__name(pgViewWithSchema, "pgViewWithSchema");
function pgMaterializedViewWithSchema(name2, selection, schema) {
  if (selection) {
    return new ManualMaterializedViewBuilder(name2, selection, schema);
  }
  return new MaterializedViewBuilder(name2, schema);
}
__name(pgMaterializedViewWithSchema, "pgMaterializedViewWithSchema");
var Relation = class {
  static {
    __name(this, "Relation");
  }
  sourceTable;
  referencedTable;
  relationName;
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
};
var Relations = class {
  static {
    __name(this, "Relations");
  }
  table;
  config;
  static [entityKind] = "Relations";
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
};
var One = class _One extends Relation {
  static {
    __name(this, "One");
  }
  config;
  isNullable;
  static [entityKind] = "One";
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  withFieldName(fieldName) {
    const relation = new _One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = class _Many extends Relation {
  static {
    __name(this, "Many");
  }
  config;
  static [entityKind] = "Many";
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  withFieldName(fieldName) {
    const relation = new _Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
};
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not: not3,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
__name(getOperators, "getOperators");
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
__name(getOrderByOperators, "getOrderByOperators");
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey3;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey: primaryKey3
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
__name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f11) => res && f11.notNull, true) ?? false);
  }, "one");
}
__name(createOne, "createOne");
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  }, "many");
}
__name(createMany, "createMany");
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
__name(normalizeRelation, "normalizeRelation");
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
__name(createTableRelationsHelpers, "createTableRelationsHelpers");
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [selectionItemIndex, selectionItem] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder2.mapFromDriverValue(value);
    }
  }
  return result;
}
__name(mapRelationalRow, "mapRelationalRow");
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
__name(bindIfParam, "bindIfParam");
var eq = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
}, "eq");
var ne = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
}, "ne");
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c11) => c11 !== void 0);
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
__name(and, "and");
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c11) => c11 !== void 0);
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
__name(or, "or");
function not3(condition) {
  return sql`not ${condition}`;
}
__name(not3, "not");
var gt = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
}, "gt");
var gte = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
}, "gte");
var lt = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
}, "lt");
var lte = /* @__PURE__ */ __name((left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
}, "lte");
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column} in ${values.map((v7) => bindIfParam(v7, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
__name(inArray, "inArray");
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column} not in ${values.map((v7) => bindIfParam(v7, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
__name(notInArray, "notInArray");
function isNull(value) {
  return sql`${value} is null`;
}
__name(isNull, "isNull");
function isNotNull(value) {
  return sql`${value} is not null`;
}
__name(isNotNull, "isNotNull");
function exists(subquery) {
  return sql`exists (${subquery})`;
}
__name(exists, "exists");
function notExists(subquery) {
  return sql`not exists (${subquery})`;
}
__name(notExists, "notExists");
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
__name(between, "between");
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
__name(notBetween, "notBetween");
function like(column, value) {
  return sql`${column} like ${value}`;
}
__name(like, "like");
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
__name(notLike, "notLike");
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
__name(ilike, "ilike");
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
__name(notIlike, "notIlike");
function asc(column) {
  return sql`${column} asc`;
}
__name(asc, "asc");
function desc(column) {
  return sql`${column} desc`;
}
__name(desc, "desc");
var FakePrimitiveParam = class {
  static {
    __name(this, "FakePrimitiveParam");
  }
  static [entityKind] = "FakePrimitiveParam";
};
function isSQLWrapper(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
}
__name(isSQLWrapper, "isSQLWrapper");
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
__name(mergeQueries, "mergeQueries");
var StringChunk = class {
  static {
    __name(this, "StringChunk");
  }
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
};
var SQL = class _SQL {
  static {
    __name(this, "SQL");
  }
  queryChunks;
  static [entityKind] = "SQL";
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const { escapeName, escapeParam, prepareTyping, inlineParams, paramStartIndex } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i10, p11] of chunk.entries()) {
          result.push(p11);
          if (i10 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, _SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings;
        if (prepareTyping !== void 0) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (is(chunk, Relation)) {
        return this.buildQueryFromSourceParams([
          chunk.sourceTable,
          new StringChunk("."),
          sql.identifier(chunk.fieldName)
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias);
  }
  mapWith(decoder2) {
    this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
};
var Name = class {
  static {
    __name(this, "Name");
  }
  value;
  static [entityKind] = "Name";
  brand;
  constructor(value) {
    this.value = value;
  }
  getSQL() {
    return new SQL([this]);
  }
};
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
__name(isDriverValueEncoder, "isDriverValueEncoder");
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var Param = class {
  static {
    __name(this, "Param");
  }
  value;
  encoder;
  static [entityKind] = "Param";
  brand;
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value, encoder2 = noopEncoder) {
    this.value = value;
    this.encoder = encoder2;
  }
  getSQL() {
    return new SQL([this]);
  }
};
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
__name(sql, "sql");
(function(sql2) {
  function empty() {
    return new SQL([]);
  }
  __name(empty, "empty");
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  __name(fromList, "fromList");
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  __name(raw, "raw");
  sql2.raw = raw;
  function join4(chunks, separator) {
    const result = [];
    for (const [i10, chunk] of chunks.entries()) {
      if (i10 > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  __name(join4, "join");
  sql2.join = join4;
  function identifier(value) {
    return new Name(value);
  }
  __name(identifier, "identifier");
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  __name(placeholder2, "placeholder");
  sql2.placeholder = placeholder2;
  function param2(value, encoder2) {
    return new Param(value, encoder2);
  }
  __name(param2, "param");
  sql2.param = param2;
})(sql || (sql = {}));
(function(SQL2) {
  class Aliased {
    static {
      __name(this, "Aliased");
    }
    sql;
    fieldAlias;
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var Placeholder = class {
  static {
    __name(this, "Placeholder");
  }
  name;
  static [entityKind] = "Placeholder";
  constructor(name2) {
    this.name = name2;
  }
  getSQL() {
    return new SQL([this]);
  }
};
function fillPlaceholders(params, values) {
  return params.map((p11) => {
    if (is(p11, Placeholder)) {
      if (!(p11.name in values)) {
        throw new Error(`No value for placeholder "${p11.name}" was provided`);
      }
      return values[p11.name];
    }
    return p11;
  });
}
__name(fillPlaceholders, "fillPlaceholders");
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
var ColumnAliasProxyHandler = class {
  static {
    __name(this, "ColumnAliasProxyHandler");
  }
  table;
  static [entityKind] = "ColumnAliasProxyHandler";
  constructor(table) {
    this.table = table;
  }
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
var TableAliasProxyHandler = class {
  static {
    __name(this, "TableAliasProxyHandler");
  }
  alias;
  replaceOriginalName;
  static [entityKind] = "TableAliasProxyHandler";
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
};
var RelationTableAliasProxyHandler = class {
  static {
    __name(this, "RelationTableAliasProxyHandler");
  }
  alias;
  static [entityKind] = "RelationTableAliasProxyHandler";
  constructor(alias) {
    this.alias = alias;
  }
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
__name(aliasedTable, "aliasedTable");
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
__name(aliasedTableColumn, "aliasedTableColumn");
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
__name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c11) => {
    if (is(c11, Column)) {
      return aliasedTableColumn(c11, alias);
    }
    if (is(c11, SQL)) {
      return mapColumnsInSQLToAlias(c11, alias);
    }
    if (is(c11, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c11, alias);
    }
    return c11;
  }));
}
__name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");

// ../../node_modules/drizzle-orm/index.mjs
var ConsoleLogWriter = class {
  static {
    __name(this, "ConsoleLogWriter");
  }
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
};
var DefaultLogger = class {
  static {
    __name(this, "DefaultLogger");
  }
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p11) => {
      try {
        return JSON.stringify(p11);
      } catch {
        return String(p11);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
var NoopLogger = class {
  static {
    __name(this, "NoopLogger");
  }
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
};

// ../../node_modules/drizzle-orm/session-afae3551.mjs
var InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");
var SQLiteTable = class extends Table {
  static {
    __name(this, "SQLiteTable");
  }
  static [entityKind] = "SQLiteTable";
  /** @internal */
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  /** @internal */
  [Table.Symbol.Columns];
  /** @internal */
  [InlineForeignKeys2] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
function sqliteTableBase(name2, columns, extraConfig, schema, baseName = name2) {
  const rawTable = new SQLiteTable(name2, schema, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name3, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name3, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
__name(sqliteTableBase, "sqliteTableBase");
var sqliteTable = /* @__PURE__ */ __name((name2, columns, extraConfig) => {
  return sqliteTableBase(name2, columns, extraConfig);
}, "sqliteTable");
var SQLiteDelete = class extends QueryPromise {
  static {
    __name(this, "SQLiteDelete");
  }
  table;
  session;
  dialect;
  static [entityKind] = "SQLiteDelete";
  /** @internal */
  config;
  constructor(table, session, dialect) {
    super();
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.config = { table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare(isOneTimeQuery) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run");
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute(placeholderValues) {
    return this.prepare(true).execute(placeholderValues);
  }
};
var SQLiteInsertBuilder = class {
  static {
    __name(this, "SQLiteInsertBuilder");
  }
  table;
  session;
  dialect;
  static [entityKind] = "SQLiteInsertBuilder";
  constructor(table, session, dialect) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new SQLiteInsert(this.table, mappedValues, this.session, this.dialect);
  }
};
var SQLiteInsert = class extends QueryPromise {
  static {
    __name(this, "SQLiteInsert");
  }
  session;
  dialect;
  static [entityKind] = "SQLiteInsert";
  /** @internal */
  config;
  constructor(table, values, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values };
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === void 0) {
      this.config.onConflict = sql`do nothing`;
    } else {
      const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
      const whereSql = config.where ? sql` where ${config.where}` : sql``;
      this.config.onConflict = sql`${targetSql} do nothing${whereSql}`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    const targetSql = Array.isArray(config.target) ? sql`${config.target}` : sql`${[config.target]}`;
    const whereSql = config.where ? sql` where ${config.where}` : sql``;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    this.config.onConflict = sql`${targetSql} do update set ${setSql}${whereSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare(isOneTimeQuery) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run");
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
};
var ForeignKeyBuilder2 = class {
  static {
    __name(this, "ForeignKeyBuilder");
  }
  static [entityKind] = "SQLiteForeignKeyBuilder";
  /** @internal */
  reference;
  /** @internal */
  _onUpdate;
  /** @internal */
  _onDelete;
  constructor(config, actions) {
    this.reference = () => {
      const { columns, foreignColumns } = config();
      return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  /** @internal */
  build(table) {
    return new ForeignKey2(table, this);
  }
};
var ForeignKey2 = class {
  static {
    __name(this, "ForeignKey");
  }
  table;
  static [entityKind] = "SQLiteForeignKey";
  reference;
  onUpdate;
  onDelete;
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  getName() {
    const { columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[SQLiteTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[SQLiteTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return `${chunks.join("_")}_fk`;
  }
};
function uniqueKeyName2(table, columns) {
  return `${table[SQLiteTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName2, "uniqueKeyName");
var UniqueConstraintBuilder2 = class {
  static {
    __name(this, "UniqueConstraintBuilder");
  }
  name;
  static [entityKind] = "SQLiteUniqueConstraintBuilder";
  /** @internal */
  columns;
  constructor(columns, name2) {
    this.name = name2;
    this.columns = columns;
  }
  /** @internal */
  build(table) {
    return new UniqueConstraint2(table, this.columns, this.name);
  }
};
var UniqueOnConstraintBuilder2 = class {
  static {
    __name(this, "UniqueOnConstraintBuilder");
  }
  static [entityKind] = "SQLiteUniqueOnConstraintBuilder";
  /** @internal */
  name;
  constructor(name2) {
    this.name = name2;
  }
  on(...columns) {
    return new UniqueConstraintBuilder2(columns, this.name);
  }
};
var UniqueConstraint2 = class {
  static {
    __name(this, "UniqueConstraint");
  }
  table;
  static [entityKind] = "SQLiteUniqueConstraint";
  columns;
  name;
  constructor(table, columns, name2) {
    this.table = table;
    this.columns = columns;
    this.name = name2 ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
  }
  getName() {
    return this.name;
  }
};
var SQLiteColumnBuilder = class extends ColumnBuilder {
  static {
    __name(this, "SQLiteColumnBuilder");
  }
  static [entityKind] = "SQLiteColumnBuilder";
  foreignKeyConfigs = [];
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name2) {
    this.config.isUnique = true;
    this.config.uniqueName = name2;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return ((ref2, actions2) => {
        const builder = new ForeignKeyBuilder2(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      })(ref, actions);
    });
  }
};
var SQLiteColumn = class extends Column {
  static {
    __name(this, "SQLiteColumn");
  }
  table;
  static [entityKind] = "SQLiteColumn";
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName2(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
};
var ViewBuilderCore = class {
  static {
    __name(this, "ViewBuilderCore");
  }
  name;
  static [entityKind] = "SQLiteViewBuilderCore";
  constructor(name2) {
    this.name = name2;
  }
  config = {};
};
var ViewBuilder2 = class extends ViewBuilderCore {
  static {
    __name(this, "ViewBuilder");
  }
  static [entityKind] = "SQLiteViewBuilder";
  as(qb) {
    if (typeof qb === "function") {
      qb = qb(new QueryBuilder2());
    }
    const selectionProxy = new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    });
    const aliasedSelectedFields = qb.getSelectedFields();
    return new Proxy(new SQLiteView({
      sqliteConfig: this.config,
      config: {
        name: this.name,
        schema: void 0,
        selectedFields: aliasedSelectedFields,
        query: qb.getSQL().inlineParams()
      }
    }), selectionProxy);
  }
};
var ManualViewBuilder2 = class extends ViewBuilderCore {
  static {
    __name(this, "ManualViewBuilder");
  }
  static [entityKind] = "SQLiteManualViewBuilder";
  columns;
  constructor(name2, columns) {
    super(name2);
    this.columns = getTableColumns(sqliteTable(name2, columns));
  }
  existing() {
    return new Proxy(new SQLiteView({
      sqliteConfig: void 0,
      config: {
        name: this.name,
        schema: void 0,
        selectedFields: this.columns,
        query: void 0
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
  as(query) {
    return new Proxy(new SQLiteView({
      sqliteConfig: this.config,
      config: {
        name: this.name,
        schema: void 0,
        selectedFields: this.columns,
        query: query.inlineParams()
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
};
var SQLiteViewBase = class extends View {
  static {
    __name(this, "SQLiteViewBase");
  }
  static [entityKind] = "SQLiteViewBase";
};
var SQLiteViewConfig = Symbol.for("drizzle:SQLiteViewConfig");
var SQLiteView = class extends SQLiteViewBase {
  static {
    __name(this, "SQLiteView");
  }
  static [entityKind] = "SQLiteView";
  /** @internal */
  [SQLiteViewConfig];
  constructor({ sqliteConfig, config }) {
    super(config);
    this[SQLiteViewConfig] = sqliteConfig;
  }
};
var SQLiteDialect = class {
  static {
    __name(this, "SQLiteDialect");
  }
  static [entityKind] = "SQLiteDialect";
  escapeName(name2) {
    return `"${name2}"`;
  }
  escapeParam(_num) {
    return "?";
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table, where, returning }) {
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const setEntries = Object.entries(set);
    const setSize = setEntries.length;
    return sql.join(setEntries.flatMap(([colName, value], i10) => {
      const col = table[Table.Symbol.Columns][colName];
      const res = sql`${sql.identifier(col.name)} = ${value}`;
      if (i10 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning }) {
    const setSql = this.buildUpdateSet(table, set);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i10) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c11) => {
            if (is(c11, Column)) {
              return sql.identifier(c11.name);
            }
            return c11;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        const tableName = field.table[Table.Symbol.Name];
        const columnName = field.name;
        if (isSingleTable) {
          chunk.push(sql.identifier(columnName));
        } else {
          chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(columnName)}`);
        }
      }
      if (i10 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, distinct }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f11 of fieldsList) {
      if (is(f11.field, Column) && getTableName(f11.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f11.field.table)) {
        const tableName = getTableName(f11.field.table);
        throw new Error(`Your "${f11.path.join("->")}" field references a column "${tableName}"."${f11.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql`with `];
      for (const [i10, w4] of withList.entries()) {
        withSqlChunks.push(sql`${sql.identifier(w4[SubqueryConfig].alias)} as (${w4[SubqueryConfig].sql})`);
        if (i10 < withList.length - 1) {
          withSqlChunks.push(sql`, `);
        }
      }
      withSqlChunks.push(sql` `);
      withSql = sql.join(withSqlChunks);
    }
    const distinctSql = distinct ? sql` distinct` : void 0;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        if (is(table2, SQLiteTable)) {
          const tableName = table2[SQLiteTable.Symbol.Name];
          const tableSchema = table2[SQLiteTable.Symbol.Schema];
          const origTableName = table2[SQLiteTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join ${table2} on ${joinMeta.on}`);
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    const orderByList = [];
    if (orderBy) {
      for (const [index2, orderByValue] of orderBy.entries()) {
        orderByList.push(orderByValue);
        if (index2 < orderBy.length - 1) {
          orderByList.push(sql`, `);
        }
      }
    }
    const groupByList = [];
    if (groupBy) {
      for (const [index2, groupByValue] of groupBy.entries()) {
        groupByList.push(groupByValue);
        if (index2 < groupBy.length - 1) {
          groupByList.push(sql`, `);
        }
      }
    }
    const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
    const orderBySql = orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values, onConflict, returning }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          let defaultValue;
          if (col.default !== null && col.default !== void 0) {
            defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
          } else if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
          } else {
            defaultValue = sql`null`;
          }
          valueList.push(defaultValue);
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : void 0;
    return sql`insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  sqlToQuery(sql2) {
    return sql2.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString
    });
  }
  buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c11) => config.columns?.[c11] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i10) => eq(aliasedTableColumn(normalizedRelation.references[i10], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(selection.map(({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_group_array(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            }
          ],
          where,
          limit,
          offset,
          orderBy
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = void 0;
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
var SQLiteSyncDialect = class extends SQLiteDialect {
  static {
    __name(this, "SQLiteSyncDialect");
  }
  static [entityKind] = "SQLiteSyncDialect";
  migrate(migrations, session) {
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    session.run(migrationTableCreate);
    const dbMigrations = session.values(sql`SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
    const lastDbMigration = dbMigrations[0] ?? void 0;
    session.run(sql`BEGIN`);
    try {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            session.run(sql.raw(stmt));
          }
          session.run(sql`INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
        }
      }
      session.run(sql`COMMIT`);
    } catch (e10) {
      session.run(sql`ROLLBACK`);
      throw e10;
    }
  }
};
var SQLiteAsyncDialect = class extends SQLiteDialect {
  static {
    __name(this, "SQLiteAsyncDialect");
  }
  static [entityKind] = "SQLiteAsyncDialect";
  async migrate(migrations, session) {
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    await session.run(migrationTableCreate);
    const dbMigrations = await session.values(sql`SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
    const lastDbMigration = dbMigrations[0] ?? void 0;
    await session.transaction(async (tx) => {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.run(sql.raw(stmt));
          }
          await tx.run(sql`INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
};
var SQLiteSelectBuilder = class {
  static {
    __name(this, "SQLiteSelectBuilder");
  }
  static [entityKind] = "SQLiteSelectBuilder";
  fields;
  session;
  dialect;
  withList;
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    this.withList = config.withList;
    this.distinct = config.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, SQLiteViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new SQLiteSelect({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
var SQLiteSelectQueryBuilder = class extends TypedQueryBuilder {
  static {
    __name(this, "SQLiteSelectQueryBuilder");
  }
  static [entityKind] = "SQLiteSelectQueryBuilder";
  _;
  /** @internal */
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join4) => join4.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
    } else {
      this.config.orderBy = columns;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  offset(offset) {
    this.config.offset = offset;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
};
var SQLiteSelect = class extends SQLiteSelectQueryBuilder {
  static {
    __name(this, "SQLiteSelect");
  }
  static [entityKind] = "SQLiteSelect";
  prepare(isOneTimeQuery) {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), fieldsList, "all");
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute() {
    return this.all();
  }
};
applyMixins(SQLiteSelect, [QueryPromise]);
var QueryBuilder2 = class {
  static {
    __name(this, "QueryBuilder");
  }
  static [entityKind] = "SQLiteQueryBuilder";
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new SQLiteSyncDialect();
    }
    return this.dialect;
  }
};
var SQLiteUpdateBuilder = class {
  static {
    __name(this, "SQLiteUpdateBuilder");
  }
  table;
  session;
  dialect;
  static [entityKind] = "SQLiteUpdateBuilder";
  constructor(table, session, dialect) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
  }
  set(values) {
    return new SQLiteUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
  }
};
var SQLiteUpdate = class extends QueryPromise {
  static {
    __name(this, "SQLiteUpdate");
  }
  session;
  dialect;
  static [entityKind] = "SQLiteUpdate";
  /** @internal */
  config;
  constructor(table, set, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare(isOneTimeQuery) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run");
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
};
var RelationalQueryBuilder = class {
  static {
    __name(this, "RelationalQueryBuilder");
  }
  mode;
  fullSchema;
  schema;
  tableNamesMap;
  table;
  tableConfig;
  dialect;
  session;
  static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
  constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.mode = mode;
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  findMany(config) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
};
var SQLiteRelationalQuery = class extends QueryPromise {
  static {
    __name(this, "SQLiteRelationalQuery");
  }
  fullSchema;
  schema;
  tableNamesMap;
  table;
  tableConfig;
  dialect;
  session;
  config;
  static [entityKind] = "SQLiteAsyncRelationalQuery";
  /** @internal */
  mode;
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }).sql;
  }
  prepare() {
    const { query, builtQuery } = this._toSQL();
    return this.session.prepareQuery(builtQuery, void 0, this.mode === "first" ? "get" : "all", (rawRows, mapColumnValue) => {
      const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
      if (this.mode === "first") {
        return rows[0];
      }
      return rows;
    });
  }
  _toSQL() {
    const query = this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  /** @internal */
  executeRaw() {
    if (this.mode === "first") {
      return this.prepare().get();
    }
    return this.prepare().all();
  }
  async execute() {
    return this.executeRaw();
  }
};
var SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
  static {
    __name(this, "SQLiteSyncRelationalQuery");
  }
  static [entityKind] = "SQLiteSyncRelationalQuery";
  sync() {
    return this.executeRaw();
  }
};
var SQLiteRaw = class extends QueryPromise {
  static {
    __name(this, "SQLiteRaw");
  }
  cb;
  getSQLCb;
  static [entityKind] = "SQLiteRaw";
  /** @internal */
  config;
  constructor(cb, getSQLCb, action) {
    super();
    this.cb = cb;
    this.getSQLCb = getSQLCb;
    this.config = { action };
  }
  /** @internal */
  getSQL() {
    return this.getSQLCb();
  }
  async execute() {
    return this.cb();
  }
};
var BaseSQLiteDatabase = class {
  static {
    __name(this, "BaseSQLiteDatabase");
  }
  resultKind;
  dialect;
  session;
  static [entityKind] = "BaseSQLiteDatabase";
  query;
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(resultKind, schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
  }
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder2());
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new SQLiteUpdateBuilder(table, this.session, this.dialect);
  }
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  delete(from) {
    return new SQLiteDelete(from, this.session, this.dialect);
  }
  run(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.run(sql2), () => sql2, "run");
    }
    return this.session.run(sql2);
  }
  all(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.all(sql2), () => sql2, "all");
    }
    return this.session.all(sql2);
  }
  get(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.get(sql2), () => sql2, "get");
    }
    return this.session.get(sql2);
  }
  values(query) {
    const sql2 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.values(sql2), () => sql2, "values");
    }
    return this.session.values(sql2);
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
};
var ExecuteResultSync = class extends QueryPromise {
  static {
    __name(this, "ExecuteResultSync");
  }
  resultCb;
  static [entityKind] = "ExecuteResultSync";
  constructor(resultCb) {
    super();
    this.resultCb = resultCb;
  }
  async execute() {
    return this.resultCb();
  }
  sync() {
    return this.resultCb();
  }
};
var PreparedQuery$1 = class PreparedQuery {
  static {
    __name(this, "PreparedQuery");
  }
  mode;
  executeMethod;
  static [entityKind] = "PreparedQuery";
  /** @internal */
  joinsNotNullableMap;
  constructor(mode, executeMethod) {
    this.mode = mode;
    this.executeMethod = executeMethod;
  }
  execute(placeholderValues) {
    if (this.mode === "async") {
      return this[this.executeMethod](placeholderValues);
    }
    return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
  }
};
var SQLiteSession = class {
  static {
    __name(this, "SQLiteSession");
  }
  dialect;
  static [entityKind] = "SQLiteSession";
  constructor(dialect) {
    this.dialect = dialect;
  }
  prepareOneTimeQuery(query, fields, executeMethod) {
    return this.prepareQuery(query, fields, executeMethod);
  }
  run(query) {
    const staticQuery = this.dialect.sqlToQuery(query);
    try {
      return this.prepareOneTimeQuery(staticQuery, void 0, "run").run();
    } catch (err) {
      throw DrizzleError.wrap(err, `Failed to run the query '${staticQuery.sql}'`);
    }
  }
  all(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run").all();
  }
  get(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run").get();
  }
  values(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run").values();
  }
};
var SQLiteTransaction = class extends BaseSQLiteDatabase {
  static {
    __name(this, "SQLiteTransaction");
  }
  schema;
  nestedIndex;
  static [entityKind] = "SQLiteTransaction";
  constructor(resultType, dialect, session, schema, nestedIndex = 0) {
    super(resultType, dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError();
  }
};

// ../../node_modules/drizzle-orm/libsql/index.mjs
var LibSQLSession = class _LibSQLSession extends SQLiteSession {
  static {
    __name(this, "LibSQLSession");
  }
  client;
  schema;
  options;
  tx;
  static [entityKind] = "LibSQLSession";
  logger;
  constructor(client10, dialect, schema, options, tx) {
    super(dialect);
    this.client = client10;
    this.schema = schema;
    this.options = options;
    this.tx = tx;
    this.logger = options.logger ?? new NoopLogger();
  }
  prepareQuery(query, fields, executeMethod, customResultMapper) {
    return new PreparedQuery2(this.client, query.sql, query.params, this.logger, fields, this.tx, executeMethod, customResultMapper);
  }
  /*override */
  batch(queries) {
    const queryToType = [];
    const builtQueries = queries.map((query) => {
      const builtQuery = this.dialect.sqlToQuery(query.getSQL());
      if (is(query, SQLiteSelect)) {
        const prepared = query.prepare();
        prepared.fields === void 0 ? queryToType.push({ mode: "all" }) : queryToType.push({
          mode: "all_mapped",
          config: { fields: prepared.fields, joinsNotNullableMap: prepared.joinsNotNullableMap }
        });
      } else if (is(query, SQLiteInsert) || is(query, SQLiteUpdate) || is(query, SQLiteDelete)) {
        queryToType.push(
          // @ts-expect-error
          query.config.returning ? {
            mode: "all_mapped",
            config: { fields: query.config.returning }
          } : { mode: "raw" }
        );
      } else if (is(query, SQLiteRaw)) {
        queryToType.push(query.config.action === "run" ? { mode: "raw" } : { mode: query.config.action });
      } else if (is(query, SQLiteRelationalQuery)) {
        const preparedRqb = query.prepare();
        queryToType.push({ mode: "rqb", mapper: preparedRqb.customResultMapper });
      }
      return { sql: builtQuery.sql, args: builtQuery.params };
    });
    const res = this.client.batch(builtQueries).then((stmt) => stmt.map(({ rows }, index2) => {
      const action = queryToType[index2];
      if (action.mode === "all") {
        return rows.map((row) => normalizeRow(row));
      }
      if (action.mode === "all_mapped") {
        return rows.map((row) => {
          return mapResultRow(action.config.fields, Array.prototype.slice.call(row).map((v7) => normalizeFieldValue(v7)), action.config.joinsNotNullableMap);
        });
      }
      if (action.mode === "get") {
        return normalizeRow(rows[0]);
      }
      if (action.mode === "values") {
        return rows.map((row) => Object.values(row));
      }
      if (action.mode === "raw") {
        return stmt[index2];
      }
      return action.mapper(rows, normalizeFieldValue);
    }));
    return res;
  }
  async transaction(transaction, _config) {
    const libsqlTx = await this.client.transaction();
    const session = new _LibSQLSession(this.client, this.dialect, this.schema, this.options, libsqlTx);
    const tx = new LibSQLTransaction("async", this.dialect, session, this.schema);
    try {
      const result = await transaction(tx);
      await libsqlTx.commit();
      return result;
    } catch (err) {
      await libsqlTx.rollback();
      throw err;
    }
  }
};
var LibSQLTransaction = class _LibSQLTransaction extends SQLiteTransaction {
  static {
    __name(this, "LibSQLTransaction");
  }
  static [entityKind] = "LibSQLTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex}`;
    const tx = new _LibSQLTransaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await this.session.run(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await this.session.run(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
};
var PreparedQuery2 = class extends PreparedQuery$1 {
  static {
    __name(this, "PreparedQuery");
  }
  client;
  queryString;
  params;
  logger;
  tx;
  static [entityKind] = "LibSQLPreparedQuery";
  /** @internal */
  customResultMapper;
  /** @internal */
  fields;
  constructor(client10, queryString, params, logger2, fields, tx, executeMethod, customResultMapper) {
    super("async", executeMethod);
    this.client = client10;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger2;
    this.tx = tx;
    this.customResultMapper = customResultMapper;
    this.fields = fields;
  }
  run(placeholderValues) {
    const params = fillPlaceholders(this.params, placeholderValues ?? {});
    this.logger.logQuery(this.queryString, params);
    const stmt = { sql: this.queryString, args: params };
    return this.tx ? this.tx.execute(stmt) : this.client.execute(stmt);
  }
  async all(placeholderValues) {
    const { fields, joinsNotNullableMap, logger: logger2, queryString, tx, client: client10, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(this.params, placeholderValues ?? {});
      logger2.logQuery(queryString, params);
      const stmt = { sql: queryString, args: params };
      return (tx ? tx.execute(stmt) : client10.execute(stmt)).then(({ rows: rows2 }) => rows2.map((row) => normalizeRow(row)));
    }
    const rows = await this.values(placeholderValues);
    if (customResultMapper) {
      return customResultMapper(rows, normalizeFieldValue);
    }
    return rows.map((row) => {
      return mapResultRow(fields, Array.prototype.slice.call(row).map((v7) => normalizeFieldValue(v7)), joinsNotNullableMap);
    });
  }
  async get(placeholderValues) {
    const { fields, joinsNotNullableMap, logger: logger2, queryString, tx, client: client10, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(this.params, placeholderValues ?? {});
      logger2.logQuery(queryString, params);
      const stmt = { sql: queryString, args: params };
      return (tx ? tx.execute(stmt) : client10.execute(stmt)).then(({ rows: rows2 }) => normalizeRow(rows2[0]));
    }
    const rows = await this.values(placeholderValues);
    if (!rows[0]) {
      return void 0;
    }
    if (customResultMapper) {
      return customResultMapper(rows, normalizeFieldValue);
    }
    return mapResultRow(fields, Array.prototype.slice.call(rows[0]).map((v7) => normalizeFieldValue(v7)), joinsNotNullableMap);
  }
  values(placeholderValues) {
    const params = fillPlaceholders(this.params, placeholderValues ?? {});
    this.logger.logQuery(this.queryString, params);
    const stmt = { sql: this.queryString, args: params };
    return (this.tx ? this.tx.execute(stmt) : this.client.execute(stmt)).then(({ rows }) => rows);
  }
};
function normalizeRow(obj) {
  return Object.keys(obj).reduce((acc, key) => {
    if (Object.prototype.propertyIsEnumerable.call(obj, key)) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
__name(normalizeRow, "normalizeRow");
function normalizeFieldValue(value) {
  if (value instanceof ArrayBuffer) {
    if (typeof Buffer !== "undefined") {
      if (!(value instanceof Buffer)) {
        return Buffer.from(value);
      }
      return value;
    }
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(value);
    }
    throw new Error("TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.");
  }
  return value;
}
__name(normalizeFieldValue, "normalizeFieldValue");
var LibSQLDatabase = class extends BaseSQLiteDatabase {
  static {
    __name(this, "LibSQLDatabase");
  }
  static [entityKind] = "LibSQLDatabase";
  async batch(batch) {
    return await this.session.batch(batch);
  }
};
function drizzle(client10, config = {}) {
  const dialect = new SQLiteAsyncDialect();
  let logger2;
  if (config.logger === true) {
    logger2 = new DefaultLogger();
  } else if (config.logger !== false) {
    logger2 = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new LibSQLSession(client10, dialect, schema, { logger: logger2 }, void 0);
  return new LibSQLDatabase("async", dialect, session, schema);
}
__name(drizzle, "drizzle");

// ../../node_modules/sst/node/config/index.js
var Config = /* @__PURE__ */ createProxy("Config");
var metadata = parseMetadataEnvironment();
var parameters = flattenValues(getVariables2("Parameter"));
var secrets = flattenValues(getVariables2("Secret"));
Object.assign(Config, metadata, parameters, secrets);
function parseMetadataEnvironment() {
  return {
    APP: process.env.SST_APP,
    STAGE: process.env.SST_STAGE
  };
}
__name(parseMetadataEnvironment, "parseMetadataEnvironment");
function flattenValues(configValues) {
  const acc = {};
  Object.keys(configValues).forEach((name2) => {
    acc[name2] = configValues[name2].value;
  });
  return acc;
}
__name(flattenValues, "flattenValues");

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters9 = /* @__PURE__ */ __name((options) => {
  return {
    ...options,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "events"
  };
}, "resolveClientEndpointParameters");

// ../../node_modules/@aws-sdk/client-eventbridge/package.json
var package_default9 = {
  name: "@aws-sdk/client-eventbridge",
  description: "AWS SDK for JavaScript Eventbridge Client for Node.js, Browser and React Native",
  version: "3.379.1",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:docs": "typedoc",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo eventbridge",
    test: "yarn test:unit",
    "test:unit": "ts-mocha test/**/*.spec.ts"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sts": "3.379.1",
    "@aws-sdk/credential-provider-node": "3.379.1",
    "@aws-sdk/middleware-host-header": "3.379.1",
    "@aws-sdk/middleware-logger": "3.378.0",
    "@aws-sdk/middleware-recursion-detection": "3.378.0",
    "@aws-sdk/middleware-signing": "3.379.1",
    "@aws-sdk/middleware-user-agent": "3.379.1",
    "@aws-sdk/signature-v4-multi-region": "3.378.0",
    "@aws-sdk/types": "3.378.0",
    "@aws-sdk/util-endpoints": "3.378.0",
    "@aws-sdk/util-user-agent-browser": "3.378.0",
    "@aws-sdk/util-user-agent-node": "3.378.0",
    "@smithy/config-resolver": "^2.0.1",
    "@smithy/fetch-http-handler": "^2.0.1",
    "@smithy/hash-node": "^2.0.1",
    "@smithy/invalid-dependency": "^2.0.1",
    "@smithy/middleware-content-length": "^2.0.1",
    "@smithy/middleware-endpoint": "^2.0.1",
    "@smithy/middleware-retry": "^2.0.1",
    "@smithy/middleware-serde": "^2.0.1",
    "@smithy/middleware-stack": "^2.0.0",
    "@smithy/node-config-provider": "^2.0.1",
    "@smithy/node-http-handler": "^2.0.1",
    "@smithy/protocol-http": "^2.0.1",
    "@smithy/smithy-client": "^2.0.1",
    "@smithy/types": "^2.0.2",
    "@smithy/url-parser": "^2.0.1",
    "@smithy/util-base64": "^2.0.0",
    "@smithy/util-body-length-browser": "^2.0.0",
    "@smithy/util-body-length-node": "^2.0.0",
    "@smithy/util-defaults-mode-browser": "^2.0.1",
    "@smithy/util-defaults-mode-node": "^2.0.1",
    "@smithy/util-retry": "^2.0.0",
    "@smithy/util-utf8": "^2.0.0",
    tslib: "^2.5.0"
  },
  devDependencies: {
    "@smithy/service-client-documentation-generator": "^2.0.0",
    "@tsconfig/node14": "1.0.3",
    "@types/node": "^14.14.31",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typedoc: "0.23.23",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=14.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-eventbridge",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-eventbridge"
  }
};

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
init_dist_es9();
var SignatureV4MultiRegion = class {
  static {
    __name(this, "SignatureV4MultiRegion");
  }
  constructor(options) {
    this.sigv4Signer = new SignatureV4(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(originalRequest, options);
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let CrtSignerV42;
      try {
        CrtSignerV42 = typeof __require === "function" && (init_dist_es11(), __toCommonJS(dist_es_exports2)).CrtSignerV4;
        if (typeof CrtSignerV42 !== "function")
          throw new Error();
      } catch (e10) {
        e10.message = `${e10.message}
Please check if you have installed "@aws-sdk/signature-v4-crt" package explicitly. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
        throw e10;
      }
      this.sigv4aSigner = new CrtSignerV42({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/runtimeConfig.shared.js
init_dist_es7();

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/endpoint/ruleset.js
var B3 = "required";
var C3 = "type";
var D3 = "fn";
var E3 = "argv";
var F3 = "ref";
var a9 = false;
var b9 = true;
var c9 = "isSet";
var d9 = "tree";
var e9 = "booleanEquals";
var f9 = "endpoint";
var g9 = "error";
var h9 = "stringEquals";
var i9 = { [B3]: false, [C3]: "String" };
var j9 = { [B3]: true, "default": false, [C3]: "Boolean" };
var k9 = { [F3]: "EndpointId" };
var l9 = { [D3]: c9, [E3]: [{ [F3]: "Region" }] };
var m9 = { [F3]: "Region" };
var n9 = { [D3]: "aws.partition", [E3]: [m9], "assign": "PartitionResult" };
var o9 = { [F3]: "UseFIPS" };
var p9 = { [F3]: "Endpoint" };
var q9 = { "authSchemes": [{ "name": "sigv4a", "signingName": "events", "signingRegionSet": ["*"] }] };
var r9 = {};
var s9 = { [D3]: e9, [E3]: [{ [F3]: "UseDualStack" }, true] };
var t5 = { [D3]: e9, [E3]: [true, { [D3]: "getAttr", [E3]: [{ [F3]: "PartitionResult" }, "supportsDualStack"] }] };
var u5 = { [g9]: "DualStack is enabled but this partition does not support DualStack", [C3]: g9 };
var v6 = { [D3]: e9, [E3]: [o9, true] };
var w3 = { [D3]: e9, [E3]: [true, { [D3]: "getAttr", [E3]: [{ [F3]: "PartitionResult" }, "supportsFIPS"] }] };
var x3 = [{ [D3]: c9, [E3]: [p9] }];
var y3 = [s9];
var z4 = [t5];
var A3 = [v6];
var _data9 = { version: "1.0", parameters: { Region: i9, UseDualStack: j9, UseFIPS: j9, Endpoint: i9, EndpointId: i9 }, rules: [{ conditions: [{ [D3]: c9, [E3]: [k9] }, l9, n9], [C3]: d9, rules: [{ conditions: [{ [D3]: "isValidHostLabel", [E3]: [k9, b9] }], [C3]: d9, rules: [{ [C3]: d9, rules: [{ conditions: [{ [D3]: e9, [E3]: [o9, a9] }], [C3]: d9, rules: [{ [C3]: d9, rules: [{ conditions: x3, endpoint: { url: p9, properties: q9, headers: r9 }, [C3]: f9 }, { conditions: y3, [C3]: d9, rules: [{ conditions: z4, [C3]: d9, rules: [{ endpoint: { url: "https://{EndpointId}.endpoint.events.{PartitionResult#dualStackDnsSuffix}", properties: q9, headers: r9 }, [C3]: f9 }] }, u5] }, { endpoint: { url: "https://{EndpointId}.endpoint.events.{PartitionResult#dnsSuffix}", properties: q9, headers: r9 }, [C3]: f9 }] }] }, { error: "Invalid Configuration: FIPS is not supported with EventBridge multi-region endpoints.", [C3]: g9 }] }] }, { error: "EndpointId must be a valid host label.", [C3]: g9 }] }, { conditions: x3, [C3]: d9, rules: [{ conditions: A3, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [C3]: g9 }, { [C3]: d9, rules: [{ conditions: y3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [C3]: g9 }, { endpoint: { url: p9, properties: r9, headers: r9 }, [C3]: f9 }] }] }, { [C3]: d9, rules: [{ conditions: [l9], [C3]: d9, rules: [{ conditions: [n9], [C3]: d9, rules: [{ conditions: [v6, s9], [C3]: d9, rules: [{ conditions: [w3, t5], [C3]: d9, rules: [{ [C3]: d9, rules: [{ endpoint: { url: "https://events-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: r9, headers: r9 }, [C3]: f9 }] }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [C3]: g9 }] }, { conditions: A3, [C3]: d9, rules: [{ conditions: [w3], [C3]: d9, rules: [{ [C3]: d9, rules: [{ conditions: [{ [D3]: h9, [E3]: [m9, "us-gov-east-1"] }], endpoint: { url: "https://events.us-gov-east-1.amazonaws.com", properties: r9, headers: r9 }, [C3]: f9 }, { conditions: [{ [D3]: h9, [E3]: [m9, "us-gov-west-1"] }], endpoint: { url: "https://events.us-gov-west-1.amazonaws.com", properties: r9, headers: r9 }, [C3]: f9 }, { endpoint: { url: "https://events-fips.{Region}.{PartitionResult#dnsSuffix}", properties: r9, headers: r9 }, [C3]: f9 }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", [C3]: g9 }] }, { conditions: y3, [C3]: d9, rules: [{ conditions: z4, [C3]: d9, rules: [{ [C3]: d9, rules: [{ endpoint: { url: "https://events.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: r9, headers: r9 }, [C3]: f9 }] }] }, u5] }, { [C3]: d9, rules: [{ endpoint: { url: "https://events.{Region}.{PartitionResult#dnsSuffix}", properties: r9, headers: r9 }, [C3]: f9 }] }] }] }, { error: "Invalid Configuration: Missing Region", [C3]: g9 }] }] };
var ruleSet9 = _data9;

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver9 = /* @__PURE__ */ __name((endpointParams, context8 = {}) => {
  return resolveEndpoint2(ruleSet9, {
    endpointParams,
    logger: context8.logger
  });
}, "defaultEndpointResolver");

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/runtimeConfig.shared.js
var getRuntimeConfig16 = /* @__PURE__ */ __name((config) => ({
  apiVersion: "2015-10-07",
  base64Decoder: config?.base64Decoder ?? fromBase64,
  base64Encoder: config?.base64Encoder ?? toBase64,
  disableHostPrefix: config?.disableHostPrefix ?? false,
  endpointProvider: config?.endpointProvider ?? defaultEndpointResolver9,
  logger: config?.logger ?? new NoOpLogger(),
  serviceId: config?.serviceId ?? "EventBridge",
  signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
  urlParser: config?.urlParser ?? parseUrl,
  utf8Decoder: config?.utf8Decoder ?? fromUtf84,
  utf8Encoder: config?.utf8Encoder ?? toUtf84
}), "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/runtimeConfig.js
var getRuntimeConfig17 = /* @__PURE__ */ __name((config) => {
  emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
  const clientSharedValues = getRuntimeConfig16(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? decorateDefaultCredentialProvider4(defaultProvider2),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent2({ serviceId: clientSharedValues.serviceId, clientVersion: package_default9.version }),
    maxAttempts: config?.maxAttempts ?? loadConfig(NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
    region: config?.region ?? loadConfig(NODE_REGION_CONFIG_OPTIONS, NODE_REGION_CONFIG_FILE_OPTIONS),
    requestHandler: config?.requestHandler ?? new NodeHttpHandler(defaultConfigProvider),
    retryMode: config?.retryMode ?? loadConfig({
      ...NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE
    }),
    sha256: config?.sha256 ?? Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? loadConfig(NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
    useFipsEndpoint: config?.useFipsEndpoint ?? loadConfig(NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
  };
}, "getRuntimeConfig");

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/EventBridgeClient.js
var EventBridgeClient = class extends Client {
  static {
    __name(this, "EventBridgeClient");
  }
  constructor(configuration) {
    const _config_0 = getRuntimeConfig17(configuration);
    const _config_1 = resolveClientEndpointParameters9(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig2(_config_4);
    const _config_6 = resolveAwsAuthConfig2(_config_5);
    const _config_7 = resolveUserAgentConfig2(_config_6);
    super(_config_7);
    this.config = _config_7;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin2(this.config));
    this.middlewareStack.use(getLoggerPlugin2(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin2(this.config));
    this.middlewareStack.use(getAwsAuthPlugin2(this.config));
    this.middlewareStack.use(getUserAgentPlugin2(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/models/EventBridgeServiceException.js
var EventBridgeServiceException = class _EventBridgeServiceException extends ServiceException {
  static {
    __name(this, "EventBridgeServiceException");
  }
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, _EventBridgeServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/models/models_0.js
var InternalException = class _InternalException extends EventBridgeServiceException {
  static {
    __name(this, "InternalException");
  }
  constructor(opts) {
    super({
      name: "InternalException",
      $fault: "server",
      ...opts
    });
    this.name = "InternalException";
    this.$fault = "server";
    Object.setPrototypeOf(this, _InternalException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/protocols/Aws_json1_1.js
var se_PutEventsCommand = /* @__PURE__ */ __name(async (input, context8) => {
  const headers = sharedHeaders2("PutEvents");
  let body;
  body = JSON.stringify(se_PutEventsRequest(input, context8));
  return buildHttpRpcRequest5(context8, headers, "/", void 0, body);
}, "se_PutEventsCommand");
var de_PutEventsCommand = /* @__PURE__ */ __name(async (output, context8) => {
  if (output.statusCode >= 300) {
    return de_PutEventsCommandError(output, context8);
  }
  const data = await parseBody9(output.body, context8);
  let contents = {};
  contents = _json(data);
  const response = {
    $metadata: deserializeMetadata10(output),
    ...contents
  };
  return response;
}, "de_PutEventsCommand");
var de_PutEventsCommandError = /* @__PURE__ */ __name(async (output, context8) => {
  const parsedOutput = {
    ...output,
    body: await parseErrorBody9(output.body, context8)
  };
  const errorCode = loadRestJsonErrorCode6(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.eventbridge#InternalException":
      throw await de_InternalExceptionRes(parsedOutput, context8);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError10({
        output,
        parsedBody,
        errorCode
      });
  }
}, "de_PutEventsCommandError");
var de_InternalExceptionRes = /* @__PURE__ */ __name(async (parsedOutput, context8) => {
  const body = parsedOutput.body;
  const deserialized = _json(body);
  const exception = new InternalException({
    $metadata: deserializeMetadata10(parsedOutput),
    ...deserialized
  });
  return decorateServiceException(exception, body);
}, "de_InternalExceptionRes");
var se_PutEventsRequest = /* @__PURE__ */ __name((input, context8) => {
  return take(input, {
    EndpointId: [],
    Entries: (_) => se_PutEventsRequestEntryList(_, context8)
  });
}, "se_PutEventsRequest");
var se_PutEventsRequestEntry = /* @__PURE__ */ __name((input, context8) => {
  return take(input, {
    Detail: [],
    DetailType: [],
    EventBusName: [],
    Resources: _json,
    Source: [],
    Time: (_) => Math.round(_.getTime() / 1e3),
    TraceHeader: []
  });
}, "se_PutEventsRequestEntry");
var se_PutEventsRequestEntryList = /* @__PURE__ */ __name((input, context8) => {
  return input.filter((e10) => e10 != null).map((entry) => {
    return se_PutEventsRequestEntry(entry, context8);
  });
}, "se_PutEventsRequestEntryList");
var deserializeMetadata10 = /* @__PURE__ */ __name((output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), "deserializeMetadata");
var collectBodyString9 = /* @__PURE__ */ __name((streamBody, context8) => collectBody(streamBody, context8).then((body) => context8.utf8Encoder(body)), "collectBodyString");
var throwDefaultError10 = withBaseException(EventBridgeServiceException);
var buildHttpRpcRequest5 = /* @__PURE__ */ __name(async (context8, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath14 } = await context8.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath14.endsWith("/") ? basePath14.slice(0, -1) + path : basePath14 + path,
    headers
  };
  if (resolvedHostname !== void 0) {
    contents.hostname = resolvedHostname;
  }
  if (body !== void 0) {
    contents.body = body;
  }
  return new HttpRequest(contents);
}, "buildHttpRpcRequest");
function sharedHeaders2(operation) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSEvents.${operation}`
  };
}
__name(sharedHeaders2, "sharedHeaders");
var parseBody9 = /* @__PURE__ */ __name((streamBody, context8) => collectBodyString9(streamBody, context8).then((encoded) => {
  if (encoded.length) {
    return JSON.parse(encoded);
  }
  return {};
}), "parseBody");
var parseErrorBody9 = /* @__PURE__ */ __name(async (errorBody, context8) => {
  const value = await parseBody9(errorBody, context8);
  value.message = value.message ?? value.Message;
  return value;
}, "parseErrorBody");
var loadRestJsonErrorCode6 = /* @__PURE__ */ __name((output, data) => {
  const findKey = /* @__PURE__ */ __name((object, key) => Object.keys(object).find((k10) => k10.toLowerCase() === key.toLowerCase()), "findKey");
  const sanitizeErrorCode = /* @__PURE__ */ __name((rawValue) => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  }, "sanitizeErrorCode");
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
}, "loadRestJsonErrorCode");

// ../../node_modules/@aws-sdk/client-eventbridge/dist-es/commands/PutEventsCommand.js
var PutEventsCommand = class _PutEventsCommand extends Command {
  static {
    __name(this, "PutEventsCommand");
  }
  static getEndpointParameterInstructions() {
    return {
      EndpointId: { type: "contextParams", name: "EndpointId" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
  constructor(input) {
    super();
    this.input = input;
  }
  resolveMiddleware(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    this.middlewareStack.use(getEndpointPlugin(configuration, _PutEventsCommand.getEndpointParameterInstructions()));
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const clientName = "EventBridgeClient";
    const commandName = "PutEventsCommand";
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: (_) => _,
      outputFilterSensitiveLog: (_) => _
    };
    const { requestHandler } = configuration;
    return stack.resolve((request3) => requestHandler.handle(request3.request, options || {}), handlerExecutionContext);
  }
  serialize(input, context8) {
    return se_PutEventsCommand(input, context8);
  }
  deserialize(output, context8) {
    return de_PutEventsCommand(output, context8);
  }
};

// ../../node_modules/sst/node/event-bus/index.js
var EventBus = /* @__PURE__ */ createProxy("EventBus");
var client = new EventBridgeClient({});
function EventHandler(_events, cb) {
  return async (event) => {
    await cb({
      type: event["detail-type"],
      properties: event.detail.properties,
      metadata: event.detail.metadata
    });
  };
}
__name(EventHandler, "EventHandler");

// ../../packages/functions/extract/src/get-members.ts
var getMembers = /* @__PURE__ */ __name(async ({ externalRepositoryId, namespaceName, repositoryName, repositoryId, perPage, page }, { integrations, db: db8, entities }) => {
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const { members: members2, pagination } = await integrations.sourceControl.fetchMembers(externalRepositoryId, namespaceName, repositoryName, page, perPage);
  const insertedMembers = await db8.transaction(async (tx) => {
    return Promise.all(members2.map(
      (member) => tx.insert(entities.members).values(member).onConflictDoUpdate({ target: entities.members.externalId, set: { username: member.username } }).returning().get()
    ));
  });
  await db8.insert(entities.repositoriesToMembers).values(insertedMembers.map((member) => ({ memberId: member.id, repositoryId }))).onConflictDoNothing().run();
  return {
    members: insertedMembers,
    paginationInfo: pagination
  };
}, "getMembers");

// ../../packages/functions/extract/src/get-merge-requests.ts
var getMergeRequests = /* @__PURE__ */ __name(async ({ externalRepositoryId, namespaceName, repositoryName, repositoryId, page, perPage }, { integrations, db: db8, entities }) => {
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const { mergeRequests: mergeRequests2, pagination } = await integrations.sourceControl.fetchMergeRequests(externalRepositoryId, namespaceName, repositoryName, repositoryId, {}, page, perPage);
  const insertedMergeRequests = await db8.transaction(async (tx) => {
    return Promise.all(mergeRequests2.map(
      (mergeRequest) => tx.insert(entities.mergeRequests).values(mergeRequest).onConflictDoUpdate({ target: entities.mergeRequests.externalId, set: { updatedAt: /* @__PURE__ */ new Date() } }).returning().get()
    ));
  });
  return {
    mergeRequests: insertedMergeRequests,
    paginationInfo: pagination
  };
}, "getMergeRequests");

// ../../packages/functions/extract/src/get-merge-request-diffs.ts
var getMergeRequestsDiffs = /* @__PURE__ */ __name(async ({ mergeRequestId, namespaceId, repositoryId, page, perPage }, { db: db8, entities, integrations }) => {
  const namespace = await db8.select().from(entities.namespaces).where(eq(entities.namespaces.id, namespaceId)).get();
  if (!namespace)
    throw new Error(`Invalid namespace: ${namespaceId}`);
  const repository = await db8.select().from(entities.repositories).where(eq(entities.repositories.id, repositoryId)).get();
  if (!repository)
    throw new Error(`Invalid repository: ${repositoryId}`);
  const mergeRequest = await db8.select().from(entities.mergeRequests).where(eq(entities.mergeRequests.id, mergeRequestId)).get();
  if (!mergeRequest)
    throw new Error(`Invalid mergeRequest: ${mergeRequestId}`);
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const { mergeRequestDiffs: mergeRequestDiffs2, pagination } = await integrations.sourceControl.fetchMergeRequestDiffs(repository, namespace, mergeRequest, page, perPage);
  const insertedMergeRequestDiffs = await db8.transaction(async (tx) => {
    return Promise.all(mergeRequestDiffs2.map(
      (mergeRequestDiff) => tx.insert(entities.mergeRequestDiffs).values(mergeRequestDiff).onConflictDoUpdate({
        target: [entities.mergeRequestDiffs.mergeRequestId, entities.mergeRequestDiffs.newPath],
        set: {
          diff: mergeRequestDiff.diff,
          newPath: mergeRequestDiff.newPath,
          oldPath: mergeRequestDiff.oldPath,
          aMode: mergeRequestDiff.aMode,
          bMode: mergeRequestDiff.bMode,
          newFile: mergeRequestDiff.newFile,
          renamedFile: mergeRequestDiff.renamedFile,
          deletedFile: mergeRequestDiff.deletedFile,
          _updatedAt: /* @__PURE__ */ new Date()
        }
      }).returning().get()
    ));
  });
  return {
    mergeRequestDiffs: insertedMergeRequestDiffs,
    paginationInfo: pagination
  };
}, "getMergeRequestsDiffs");

// ../../packages/functions/extract/src/get-merge-request-commits.ts
var getMergeRequestCommits = /* @__PURE__ */ __name(async ({ mergeRequestId, namespaceId, repositoryId }, { integrations, db: db8, entities }) => {
  const namespace = await db8.select().from(entities.namespaces).where(eq(entities.namespaces.id, namespaceId)).get();
  if (!namespace)
    throw new Error(`Invalid namespace: ${namespaceId}`);
  const repository = await db8.select().from(entities.repositories).where(eq(entities.repositories.id, repositoryId)).get();
  if (!repository)
    throw new Error(`Invalid repository: ${repositoryId}`);
  const mergeRequest = await db8.select().from(entities.mergeRequests).where(eq(entities.mergeRequests.id, mergeRequestId)).get();
  if (!mergeRequest)
    throw new Error(`Invalid mergeRequest: ${mergeRequestId}`);
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const { mergeRequestCommits: mergeRequestCommits2 } = await integrations.sourceControl.fetchMergeRequestCommits(repository, namespace, mergeRequest, {});
  const insertedMergeRequestCommits = await db8.transaction(async (tx) => {
    return Promise.all(mergeRequestCommits2.map(
      (mergeRequestCommit) => tx.insert(entities.mergeRequestCommits).values(mergeRequestCommit).onConflictDoUpdate({
        target: entities.mergeRequestCommits.externalId,
        set: {
          createdAt: mergeRequestCommit.createdAt,
          committedDate: mergeRequestCommit.committedDate,
          title: mergeRequestCommit.title,
          message: mergeRequestCommit.message,
          _updatedAt: /* @__PURE__ */ new Date()
        }
      }).returning().get()
    ));
  });
  return {
    mergeRequestCommits: insertedMergeRequestCommits
  };
}, "getMergeRequestCommits");

// ../../packages/functions/extract/src/get-merge-request-notes.ts
var getMergeRequestNotes = /* @__PURE__ */ __name(async ({ repositoryId, namespaceId, mergeRequestId }, { db: db8, entities, integrations }) => {
  const namespace = await db8.select().from(entities.namespaces).where(eq(entities.namespaces.id, namespaceId)).get();
  if (!namespace)
    throw new Error(`Invalid namespace: ${namespaceId}`);
  const repository = await db8.select().from(entities.repositories).where(eq(entities.repositories.id, repositoryId)).get();
  if (!repository)
    throw new Error(`Invalid repository: ${repositoryId}`);
  const mergeRequest = await db8.select().from(entities.mergeRequests).where(eq(entities.mergeRequests.id, mergeRequestId)).get();
  if (!mergeRequest)
    throw new Error(`Invalid mergeRequest: ${mergeRequestId}`);
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const { mergeRequestNotes: mergeRequestNotes2 } = await integrations.sourceControl.fetchMergeRequestNotes(repository, namespace, mergeRequest);
  const insertedMergeRequestNotes = await db8.transaction(
    async (tx) => Promise.all(mergeRequestNotes2.map(
      (mergeRequestNote) => tx.insert(entities.mergeRequestNotes).values(mergeRequestNote).onConflictDoUpdate({
        target: entities.mergeRequestNotes.externalId,
        set: {
          updatedAt: mergeRequestNote.updatedAt
        }
      }).returning().get()
    ))
  );
  return {
    mergeRequestNotes: insertedMergeRequestNotes
  };
}, "getMergeRequestNotes");

// ../../packages/functions/extract/src/get-member-info.ts
var getMemberInfo = /* @__PURE__ */ __name(async ({ memberId }, { integrations, db: db8, entities }) => {
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const member = await db8.select({ username: entities.members.username }).from(entities.members).where(eq(entities.members.id, memberId)).get();
  if (!member) {
    console.error(`Member ${memberId} not found`);
    throw new Error(`Member ${memberId} not found`);
  }
  const { member: fetchedMember } = await integrations.sourceControl.fetchUserInfo(member.username);
  const insertedMember = await db8.update(entities.members).set(fetchedMember).where(eq(entities.members.id, memberId)).returning().get();
  return {
    member: insertedMember
  };
}, "getMemberInfo");

// ../../packages/functions/extract/src/get-namespace-members.ts
var getNamespaceMembers = /* @__PURE__ */ __name(async ({ externalNamespaceId, namespaceName, repositoryId, perPage, page }, { integrations, db: db8, entities }) => {
  if (!integrations.sourceControl) {
    throw new Error("Source control integration not configured");
  }
  const { members: members2, pagination } = await integrations.sourceControl.fetchNamespaceMembers(externalNamespaceId, namespaceName, page, perPage);
  const insertedMembers = await db8.transaction(async (tx) => {
    return Promise.all(members2.map(
      (member) => tx.insert(entities.members).values(member).onConflictDoUpdate({ target: entities.members.externalId, set: { username: member.username } }).returning().get()
    ));
  });
  await db8.insert(entities.repositoriesToMembers).values(insertedMembers.map((member) => ({ memberId: member.id, repositoryId }))).onConflictDoNothing().run();
  return {
    members: insertedMembers,
    paginationInfo: pagination
  };
}, "getNamespaceMembers");

// ../../node_modules/drizzle-orm/sqlite-core/index.mjs
var SQLiteBigIntBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBigIntBuilder");
  }
  static [entityKind] = "SQLiteBigIntBuilder";
  constructor(name2) {
    super(name2, "bigint", "SQLiteBigInt");
  }
  /** @internal */
  build(table) {
    return new SQLiteBigInt(table, this.config);
  }
};
var SQLiteBigInt = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBigInt");
  }
  static [entityKind] = "SQLiteBigInt";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value) {
    return BigInt(value.toString());
  }
  mapToDriverValue(value) {
    return Buffer.from(value.toString());
  }
};
var SQLiteBlobJsonBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBlobJsonBuilder");
  }
  static [entityKind] = "SQLiteBlobJsonBuilder";
  constructor(name2) {
    super(name2, "json", "SQLiteBlobJson");
  }
  /** @internal */
  build(table) {
    return new SQLiteBlobJson(table, this.config);
  }
};
var SQLiteBlobJson = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBlobJson");
  }
  static [entityKind] = "SQLiteBlobJson";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value) {
    return JSON.parse(value.toString());
  }
  mapToDriverValue(value) {
    return Buffer.from(JSON.stringify(value));
  }
};
var SQLiteBlobBufferBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBlobBufferBuilder");
  }
  static [entityKind] = "SQLiteBlobBufferBuilder";
  constructor(name2) {
    super(name2, "buffer", "SQLiteBlobBuffer");
  }
  /** @internal */
  build(table) {
    return new SQLiteBlobBuffer(table, this.config);
  }
};
var SQLiteBlobBuffer = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBlobBuffer");
  }
  static [entityKind] = "SQLiteBlobBuffer";
  getSQLType() {
    return "blob";
  }
};
var SQLiteCustomColumnBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteCustomColumnBuilder");
  }
  static [entityKind] = "SQLiteCustomColumnBuilder";
  constructor(name2, fieldConfig, customTypeParams) {
    super(name2, "custom", "SQLiteCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  /** @internal */
  build(table) {
    return new SQLiteCustomColumn(table, this.config);
  }
};
var SQLiteCustomColumn = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteCustomColumn");
  }
  static [entityKind] = "SQLiteCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
};
var SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBaseIntegerBuilder");
  }
  static [entityKind] = "SQLiteBaseIntegerBuilder";
  constructor(name2, dataType, columnType) {
    super(name2, dataType, columnType);
    this.config.autoIncrement = false;
  }
  primaryKey(config) {
    if (config?.autoIncrement) {
      this.config.autoIncrement = true;
    }
    this.config.hasDefault = true;
    return super.primaryKey();
  }
};
var SQLiteBaseInteger = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBaseInteger");
  }
  static [entityKind] = "SQLiteBaseInteger";
  autoIncrement = this.config.autoIncrement;
  getSQLType() {
    return "integer";
  }
};
var SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
  static {
    __name(this, "SQLiteIntegerBuilder");
  }
  static [entityKind] = "SQLiteIntegerBuilder";
  constructor(name2) {
    super(name2, "number", "SQLiteInteger");
  }
  build(table) {
    return new SQLiteInteger(table, this.config);
  }
};
var SQLiteInteger = class extends SQLiteBaseInteger {
  static {
    __name(this, "SQLiteInteger");
  }
  static [entityKind] = "SQLiteInteger";
};
var SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
  static {
    __name(this, "SQLiteTimestampBuilder");
  }
  static [entityKind] = "SQLiteTimestampBuilder";
  constructor(name2, mode) {
    super(name2, "date", "SQLiteTimestamp");
    this.config.mode = mode;
  }
  /**
   * @deprecated Use `default()` with your own expression instead.
   *
   * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
   */
  defaultNow() {
    return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
  }
  build(table) {
    return new SQLiteTimestamp(table, this.config);
  }
};
var SQLiteTimestamp = class extends SQLiteBaseInteger {
  static {
    __name(this, "SQLiteTimestamp");
  }
  static [entityKind] = "SQLiteTimestamp";
  mode = this.config.mode;
  mapFromDriverValue(value) {
    if (this.config.mode === "timestamp") {
      return new Date(value * 1e3);
    }
    return new Date(value);
  }
  mapToDriverValue(value) {
    const unix = value.getTime();
    if (this.config.mode === "timestamp") {
      return Math.floor(unix / 1e3);
    }
    return unix;
  }
};
var SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
  static {
    __name(this, "SQLiteBooleanBuilder");
  }
  static [entityKind] = "SQLiteBooleanBuilder";
  constructor(name2, mode) {
    super(name2, "boolean", "SQLiteBoolean");
    this.config.mode = mode;
  }
  build(table) {
    return new SQLiteBoolean(table, this.config);
  }
};
var SQLiteBoolean = class extends SQLiteBaseInteger {
  static {
    __name(this, "SQLiteBoolean");
  }
  static [entityKind] = "SQLiteBoolean";
  mode = this.config.mode;
  mapFromDriverValue(value) {
    return Number(value) === 1;
  }
  mapToDriverValue(value) {
    return value ? 1 : 0;
  }
};
function integer(name2, config) {
  if (config?.mode === "timestamp" || config?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name2, config.mode);
  }
  if (config?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name2, config.mode);
  }
  return new SQLiteIntegerBuilder(name2);
}
__name(integer, "integer");
var SQLiteNumericBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteNumericBuilder");
  }
  static [entityKind] = "SQLiteNumericBuilder";
  constructor(name2) {
    super(name2, "string", "SQLiteNumeric");
  }
  /** @internal */
  build(table) {
    return new SQLiteNumeric(table, this.config);
  }
};
var SQLiteNumeric = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteNumeric");
  }
  static [entityKind] = "SQLiteNumeric";
  getSQLType() {
    return "numeric";
  }
};
var SQLiteRealBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteRealBuilder");
  }
  static [entityKind] = "SQLiteRealBuilder";
  constructor(name2) {
    super(name2, "number", "SQLiteReal");
  }
  /** @internal */
  build(table) {
    return new SQLiteReal(table, this.config);
  }
};
var SQLiteReal = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteReal");
  }
  static [entityKind] = "SQLiteReal";
  getSQLType() {
    return "real";
  }
};
var SQLiteTextBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteTextBuilder");
  }
  static [entityKind] = "SQLiteTextBuilder";
  constructor(name2, config) {
    super(name2, "string", "SQLiteText");
    this.config.enumValues = config.enum;
    this.config.length = config.length;
  }
  /** @internal */
  build(table) {
    return new SQLiteText(table, this.config);
  }
};
var SQLiteText = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteText");
  }
  static [entityKind] = "SQLiteText";
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
};
var SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteTextJsonBuilder");
  }
  static [entityKind] = "SQLiteTextJsonBuilder";
  constructor(name2) {
    super(name2, "json", "SQLiteTextJson");
  }
  /** @internal */
  build(table) {
    return new SQLiteTextJson(table, this.config);
  }
};
var SQLiteTextJson = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteTextJson");
  }
  static [entityKind] = "SQLiteTextJson";
  getSQLType() {
    return "text";
  }
  mapFromDriverValue(value) {
    return JSON.parse(value);
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
};
function text(name2, config = {}) {
  return config.mode === "json" ? new SQLiteTextJsonBuilder(name2) : new SQLiteTextBuilder(name2, config);
}
__name(text, "text");
var CheckBuilder2 = class {
  static {
    __name(this, "CheckBuilder");
  }
  name;
  value;
  static [entityKind] = "SQLiteCheckBuilder";
  brand;
  constructor(name2, value) {
    this.name = name2;
    this.value = value;
  }
  build(table) {
    return new Check2(table, this);
  }
};
var Check2 = class {
  static {
    __name(this, "Check");
  }
  table;
  static [entityKind] = "SQLiteCheck";
  name;
  value;
  constructor(table, builder) {
    this.table = table;
    this.name = builder.name;
    this.value = builder.value;
  }
};
var IndexBuilderOn2 = class {
  static {
    __name(this, "IndexBuilderOn");
  }
  name;
  unique;
  static [entityKind] = "SQLiteIndexBuilderOn";
  constructor(name2, unique3) {
    this.name = name2;
    this.unique = unique3;
  }
  on(...columns) {
    return new IndexBuilder2(this.name, columns, this.unique);
  }
};
var IndexBuilder2 = class {
  static {
    __name(this, "IndexBuilder");
  }
  static [entityKind] = "SQLiteIndexBuilder";
  /** @internal */
  config;
  constructor(name2, columns, unique3) {
    this.config = {
      name: name2,
      columns,
      unique: unique3,
      where: void 0
    };
  }
  /**
   * Condition for partial index.
   */
  where(condition) {
    this.config.where = condition;
    return this;
  }
  /** @internal */
  build(table) {
    return new Index2(this.config, table);
  }
};
var Index2 = class {
  static {
    __name(this, "Index");
  }
  static [entityKind] = "SQLiteIndex";
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
};
function uniqueIndex(name2) {
  return new IndexBuilderOn2(name2, true);
}
__name(uniqueIndex, "uniqueIndex");
function primaryKey(...columns) {
  return new PrimaryKeyBuilder2(columns);
}
__name(primaryKey, "primaryKey");
var PrimaryKeyBuilder2 = class {
  static {
    __name(this, "PrimaryKeyBuilder");
  }
  static [entityKind] = "SQLitePrimaryKeyBuilder";
  /** @internal */
  columns;
  constructor(columns) {
    this.columns = columns;
  }
  /** @internal */
  build(table) {
    return new PrimaryKey2(table, this.columns);
  }
};
var PrimaryKey2 = class {
  static {
    __name(this, "PrimaryKey");
  }
  table;
  static [entityKind] = "SQLitePrimaryKey";
  columns;
  constructor(table, columns) {
    this.table = table;
    this.columns = columns;
  }
  getName() {
    return `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};

// ../../node_modules/drizzle-orm/view-23898f21.mjs
var InlineForeignKeys3 = Symbol.for("drizzle:MySqlInlineForeignKeys");
var MySqlTable = class extends Table {
  static {
    __name(this, "MySqlTable");
  }
  static [entityKind] = "MySqlTable";
  /** @internal */
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys3
  });
  /** @internal */
  [Table.Symbol.Columns];
  /** @internal */
  [InlineForeignKeys3] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
function mysqlTableWithSchema(name2, columns, extraConfig, schema, baseName = name2) {
  const rawTable = new MySqlTable(name2, schema, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name3, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys3].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name3, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[MySqlTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
}
__name(mysqlTableWithSchema, "mysqlTableWithSchema");
var mysqlTable = /* @__PURE__ */ __name((name2, columns, extraConfig) => {
  return mysqlTableWithSchema(name2, columns, extraConfig, void 0, name2);
}, "mysqlTable");
var ForeignKeyBuilder3 = class {
  static {
    __name(this, "ForeignKeyBuilder");
  }
  static [entityKind] = "MySqlForeignKeyBuilder";
  /** @internal */
  reference;
  /** @internal */
  _onUpdate;
  /** @internal */
  _onDelete;
  constructor(config, actions) {
    this.reference = () => {
      const { columns, foreignColumns } = config();
      return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  /** @internal */
  build(table) {
    return new ForeignKey3(table, this);
  }
};
var ForeignKey3 = class {
  static {
    __name(this, "ForeignKey");
  }
  table;
  static [entityKind] = "MySqlForeignKey";
  reference;
  onUpdate;
  onDelete;
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  getName() {
    const { columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[MySqlTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[MySqlTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return `${chunks.join("_")}_fk`;
  }
};
function uniqueKeyName3(table, columns) {
  return `${table[MySqlTable.Symbol.Name]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName3, "uniqueKeyName");
var UniqueConstraintBuilder3 = class {
  static {
    __name(this, "UniqueConstraintBuilder");
  }
  name;
  static [entityKind] = "MySqlUniqueConstraintBuilder";
  /** @internal */
  columns;
  constructor(columns, name2) {
    this.name = name2;
    this.columns = columns;
  }
  /** @internal */
  build(table) {
    return new UniqueConstraint3(table, this.columns, this.name);
  }
};
var UniqueOnConstraintBuilder3 = class {
  static {
    __name(this, "UniqueOnConstraintBuilder");
  }
  static [entityKind] = "MySqlUniqueOnConstraintBuilder";
  /** @internal */
  name;
  constructor(name2) {
    this.name = name2;
  }
  on(...columns) {
    return new UniqueConstraintBuilder3(columns, this.name);
  }
};
var UniqueConstraint3 = class {
  static {
    __name(this, "UniqueConstraint");
  }
  table;
  static [entityKind] = "MySqlUniqueConstraint";
  columns;
  name;
  nullsNotDistinct = false;
  constructor(table, columns, name2) {
    this.table = table;
    this.columns = columns;
    this.name = name2 ?? uniqueKeyName3(this.table, this.columns.map((column) => column.name));
  }
  getName() {
    return this.name;
  }
};
var MySqlColumnBuilder = class extends ColumnBuilder {
  static {
    __name(this, "MySqlColumnBuilder");
  }
  static [entityKind] = "MySqlColumnBuilder";
  foreignKeyConfigs = [];
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name2) {
    this.config.isUnique = true;
    this.config.uniqueName = name2;
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return ((ref2, actions2) => {
        const builder = new ForeignKeyBuilder3(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      })(ref, actions);
    });
  }
};
var MySqlColumn = class extends Column {
  static {
    __name(this, "MySqlColumn");
  }
  table;
  static [entityKind] = "MySqlColumn";
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName3(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
};
var MySqlColumnBuilderWithAutoIncrement = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlColumnBuilderWithAutoIncrement");
  }
  static [entityKind] = "MySqlColumnBuilderWithAutoIncrement";
  constructor(name2, dataType, columnType) {
    super(name2, dataType, columnType);
    this.config.autoIncrement = false;
  }
  autoincrement() {
    this.config.autoIncrement = true;
    this.config.hasDefault = true;
    return this;
  }
};
var MySqlColumnWithAutoIncrement = class extends MySqlColumn {
  static {
    __name(this, "MySqlColumnWithAutoIncrement");
  }
  static [entityKind] = "MySqlColumnWithAutoIncrement";
  autoIncrement = this.config.autoIncrement;
};
var MySqlDelete = class extends QueryPromise {
  static {
    __name(this, "MySqlDelete");
  }
  table;
  session;
  dialect;
  static [entityKind] = "MySqlDelete";
  config;
  constructor(table, session, dialect) {
    super();
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.config = { table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare() {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
};
var MySqlInsertBuilder = class {
  static {
    __name(this, "MySqlInsertBuilder");
  }
  table;
  session;
  dialect;
  static [entityKind] = "MySqlInsertBuilder";
  shouldIgnore = false;
  constructor(table, session, dialect) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
  }
  ignore() {
    this.shouldIgnore = true;
    return this;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new MySqlInsert(this.table, mappedValues, this.shouldIgnore, this.session, this.dialect);
  }
};
var MySqlInsert = class extends QueryPromise {
  static {
    __name(this, "MySqlInsert");
  }
  session;
  dialect;
  static [entityKind] = "MySqlInsert";
  config;
  constructor(table, values, ignore, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, ignore };
  }
  onDuplicateKeyUpdate(config) {
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    this.config.onConflict = sql`update ${setSql}`;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare() {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), void 0);
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
};
var MySqlDialect = class {
  static {
    __name(this, "MySqlDialect");
  }
  static [entityKind] = "MySqlDialect";
  async migrate(migrations, session, config) {
    const migrationsTable = config.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			create table if not exists ${sql.identifier(migrationsTable)} (
				id serial primary key,
				hash text not null,
				created_at bigint
			)
		`;
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsTable)} (\`hash\`, \`created_at\`) values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name2) {
    return `\`${name2}\``;
  }
  escapeParam(_num) {
    return `?`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table, where, returning }) {
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const setEntries = Object.entries(set);
    const setSize = setEntries.length;
    return sql.join(setEntries.flatMap(([colName, value], i10) => {
      const col = table[Table.Symbol.Columns][colName];
      const res = sql`${sql.identifier(col.name)} = ${value}`;
      if (i10 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning }) {
    const setSql = this.buildUpdateSet(table, set);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    return sql`update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i10) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c11) => {
            if (is(c11, MySqlColumn)) {
              return sql.identifier(c11.name);
            }
            return c11;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i10 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClause, distinct }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f11 of fieldsList) {
      if (is(f11.field, Column) && getTableName(f11.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, MySqlViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? void 0 : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f11.field.table)) {
        const tableName = getTableName(f11.field.table);
        throw new Error(`Your "${f11.path.join("->")}" field references a column "${tableName}"."${f11.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql`with `];
      for (const [i10, w4] of withList.entries()) {
        withSqlChunks.push(sql`${sql.identifier(w4[SubqueryConfig].alias)} as (${w4[SubqueryConfig].sql})`);
        if (i10 < withList.length - 1) {
          withSqlChunks.push(sql`, `);
        }
      }
      withSqlChunks.push(sql` `);
      withSql = sql.join(withSqlChunks);
    }
    const distinctSql = distinct ? sql` distinct` : void 0;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        return sql`${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table2 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : void 0;
        if (is(table2, MySqlTable)) {
          const tableName = table2[MySqlTable.Symbol.Name];
          const tableSchema = table2[MySqlTable.Symbol.Schema];
          const origTableName = table2[MySqlTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else if (is(table2, View)) {
          const viewName = table2[ViewBaseConfig].name;
          const viewSchema = table2[ViewBaseConfig].schema;
          const origViewName = table2[ViewBaseConfig].originalName;
          const alias = viewName === origViewName ? void 0 : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : void 0}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table2} on ${joinMeta.on}`);
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = limit ? sql` limit ${limit}` : void 0;
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    let lockingClausesSql;
    if (lockingClause) {
      const { config, strength } = lockingClause;
      lockingClausesSql = sql` for ${sql.raw(strength)}`;
      if (config.noWait) {
        lockingClausesSql.append(sql` no wait`);
      } else if (config.skipLocked) {
        lockingClausesSql.append(sql` skip locked`);
      }
    }
    return sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
  }
  buildInsertQuery({ table, values, ignore, onConflict }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
          if (col.defaultFn !== void 0) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const valuesSql = sql.join(valuesSqlList);
    const ignoreSql = ignore ? sql` ignore` : void 0;
    const onConflictSql = onConflict ? sql` on duplicate key ${onConflict}` : void 0;
    return sql`insert${ignoreSql} into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}`;
  }
  sqlToQuery(sql2) {
    return sql2.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString
    });
  }
  buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
    let selection = [];
    let limit, offset, orderBy, where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c11) => config.columns?.[c11] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i10) => eq(aliasedTableColumn(normalizedRelation.references[i10], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_arrayagg(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || (orderBy?.length ?? 0) > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            },
            ...(orderBy?.length ?? 0) > 0 ? [{
              path: [],
              field: sql`row_number() over (order by ${sql.join(orderBy, sql`, `)})`
            }] : []
          ],
          where,
          limit,
          offset
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = void 0;
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
  buildRelationalQueryWithoutLateralSubqueries({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c11) => config.columns?.[c11] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i10) => eq(aliasedTableColumn(normalizedRelation.references[i10], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutLateralSubqueries({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        let fieldSql = sql`(${builtRelation.sql})`;
        if (is(relation, Many)) {
          fieldSql = sql`coalesce(${fieldSql}, json_array())`;
        }
        const field = fieldSql.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(selection.map(({ field: field2 }) => is(field2, MySqlColumn) ? sql.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`json_arrayagg(${field})`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field,
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            },
            ...orderBy.length > 0 ? [{
              path: [],
              field: sql`row_number() over (order by ${sql.join(orderBy, sql`, `)})`
            }] : []
          ],
          where,
          limit,
          offset
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = void 0;
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        where,
        limit,
        offset,
        orderBy
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        where,
        limit,
        offset,
        orderBy
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
var MySqlSelectBuilder = class {
  static {
    __name(this, "MySqlSelectBuilder");
  }
  static [entityKind] = "MySqlSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, MySqlViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new MySqlSelect({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
var MySqlSelectQueryBuilder = class extends TypedQueryBuilder {
  static {
    __name(this, "MySqlSelectQueryBuilder");
  }
  static [entityKind] = "MySqlSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  /** @internal */
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join4) => join4.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
    } else {
      this.config.orderBy = columns;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  offset(offset) {
    this.config.offset = offset;
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
};
var MySqlSelect = class extends MySqlSelectQueryBuilder {
  static {
    __name(this, "MySqlSelect");
  }
  static [entityKind] = "MySqlSelect";
  prepare() {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), fieldsList);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
};
applyMixins(MySqlSelect, [QueryPromise]);
var QueryBuilder3 = class {
  static {
    __name(this, "QueryBuilder");
  }
  static [entityKind] = "MySqlQueryBuilder";
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new MySqlSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new MySqlSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    return { select, selectDistinct };
  }
  select(fields) {
    return new MySqlSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new MySqlSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new MySqlDialect();
    }
    return this.dialect;
  }
};
var RelationalQueryBuilder2 = class {
  static {
    __name(this, "RelationalQueryBuilder");
  }
  fullSchema;
  schema;
  tableNamesMap;
  table;
  tableConfig;
  dialect;
  session;
  mode;
  static [entityKind] = "MySqlRelationalQueryBuilder";
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, mode) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.mode = mode;
  }
  findMany(config) {
    return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many", this.mode);
  }
  findFirst(config) {
    return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first", this.mode);
  }
};
var MySqlRelationalQuery = class extends QueryPromise {
  static {
    __name(this, "MySqlRelationalQuery");
  }
  fullSchema;
  schema;
  tableNamesMap;
  table;
  tableConfig;
  dialect;
  session;
  config;
  queryMode;
  mode;
  static [entityKind] = "MySqlRelationalQuery";
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, queryMode, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.queryMode = queryMode;
    this.mode = mode;
  }
  prepare() {
    const { query, builtQuery } = this._toSQL();
    return this.session.prepareQuery(builtQuery, void 0, (rawRows) => {
      const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection));
      if (this.queryMode === "first") {
        return rows[0];
      }
      return rows;
    });
  }
  _toSQL() {
    const query = this.mode === "planetscale" ? this.dialect.buildRelationalQueryWithoutLateralSubqueries({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }) : this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { builtQuery, query };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return this.prepare().execute();
  }
};
var MySqlDatabase = class {
  static {
    __name(this, "MySqlDatabase");
  }
  dialect;
  session;
  mode;
  static [entityKind] = "MySqlDatabase";
  query;
  constructor(dialect, session, schema, mode) {
    this.dialect = dialect;
    this.session = session;
    this.mode = mode;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder2(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session, this.mode);
      }
    }
  }
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder3());
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new MySqlSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new MySqlSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    return { select, selectDistinct };
  }
  select(fields) {
    return new MySqlSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new MySqlSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new MySqlUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new MySqlInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new MySqlDelete(table, this.session, this.dialect);
  }
  execute(query) {
    return this.session.execute(query.getSQL());
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
};
var PreparedQuery3 = class {
  static {
    __name(this, "PreparedQuery");
  }
  static [entityKind] = "MySqlPreparedQuery";
  /** @internal */
  joinsNotNullableMap;
};
var MySqlSession = class {
  static {
    __name(this, "MySqlSession");
  }
  dialect;
  static [entityKind] = "MySqlSession";
  constructor(dialect) {
    this.dialect = dialect;
  }
  execute(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), void 0).execute();
  }
  getSetTransactionSQL(config) {
    const parts = [];
    if (config.isolationLevel) {
      parts.push(`isolation level ${config.isolationLevel}`);
    }
    return parts.length ? sql.join(["set transaction ", parts.join(" ")]) : void 0;
  }
  getStartTransactionSQL(config) {
    const parts = [];
    if (config.withConsistentSnapshot) {
      parts.push("with consistent snapshot");
    }
    if (config.accessMode) {
      parts.push(config.accessMode);
    }
    return parts.length ? sql.join(["start transaction ", parts.join(" ")]) : void 0;
  }
};
var MySqlTransaction = class extends MySqlDatabase {
  static {
    __name(this, "MySqlTransaction");
  }
  schema;
  nestedIndex;
  static [entityKind] = "MySqlTransaction";
  constructor(dialect, session, schema, nestedIndex, mode) {
    super(dialect, session, schema, mode);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError();
  }
};
var MySqlUpdateBuilder = class {
  static {
    __name(this, "MySqlUpdateBuilder");
  }
  table;
  session;
  dialect;
  static [entityKind] = "MySqlUpdateBuilder";
  constructor(table, session, dialect) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
  }
  set(values) {
    return new MySqlUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
  }
};
var MySqlUpdate = class extends QueryPromise {
  static {
    __name(this, "MySqlUpdate");
  }
  session;
  dialect;
  static [entityKind] = "MySqlUpdate";
  config;
  constructor(table, set, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare() {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
};
var ViewBuilderCore2 = class {
  static {
    __name(this, "ViewBuilderCore");
  }
  name;
  schema;
  static [entityKind] = "MySqlViewBuilder";
  constructor(name2, schema) {
    this.name = name2;
    this.schema = schema;
  }
  config = {};
  algorithm(algorithm) {
    this.config.algorithm = algorithm;
    return this;
  }
  definer(definer) {
    this.config.definer = definer;
    return this;
  }
  sqlSecurity(sqlSecurity) {
    this.config.sqlSecurity = sqlSecurity;
    return this;
  }
  withCheckOption(withCheckOption) {
    this.config.withCheckOption = withCheckOption ?? "cascaded";
    return this;
  }
};
var ViewBuilder3 = class extends ViewBuilderCore2 {
  static {
    __name(this, "ViewBuilder");
  }
  static [entityKind] = "MySqlViewBuilder";
  as(qb) {
    if (typeof qb === "function") {
      qb = qb(new QueryBuilder3());
    }
    const selectionProxy = new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    });
    const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
    return new Proxy(new MySqlView({
      mysqlConfig: this.config,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: aliasedSelection,
        query: qb.getSQL().inlineParams()
      }
    }), selectionProxy);
  }
};
var ManualViewBuilder3 = class extends ViewBuilderCore2 {
  static {
    __name(this, "ManualViewBuilder");
  }
  static [entityKind] = "MySqlManualViewBuilder";
  columns;
  constructor(name2, columns, schema) {
    super(name2, schema);
    this.columns = getTableColumns(mysqlTable(name2, columns));
  }
  existing() {
    return new Proxy(new MySqlView({
      mysqlConfig: void 0,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: this.columns,
        query: void 0
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
  as(query) {
    return new Proxy(new MySqlView({
      mysqlConfig: this.config,
      config: {
        name: this.name,
        schema: this.schema,
        selectedFields: this.columns,
        query: query.inlineParams()
      }
    }), new SelectionProxyHandler({
      alias: this.name,
      sqlBehavior: "error",
      sqlAliasedBehavior: "alias",
      replaceOriginalName: true
    }));
  }
};
var MySqlViewBase = class extends View {
  static {
    __name(this, "MySqlViewBase");
  }
  static [entityKind] = "MySqlViewBase";
};
var MySqlViewConfig = Symbol.for("drizzle:MySqlViewConfig");
var MySqlView = class extends MySqlViewBase {
  static {
    __name(this, "MySqlView");
  }
  static [entityKind] = "MySqlView";
  [MySqlViewConfig];
  constructor({ mysqlConfig, config }) {
    super(config);
    this[MySqlViewConfig] = mysqlConfig;
  }
};
function mysqlViewWithSchema(name2, selection, schema) {
  if (selection) {
    return new ManualViewBuilder3(name2, selection, schema);
  }
  return new ViewBuilder3(name2, schema);
}
__name(mysqlViewWithSchema, "mysqlViewWithSchema");

// ../../node_modules/drizzle-orm/mysql-core/index.mjs
var MySqlBigInt53Builder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlBigInt53Builder");
  }
  static [entityKind] = "MySqlBigInt53Builder";
  constructor(name2) {
    super(name2, "number", "MySqlBigInt53");
  }
  /** @internal */
  build(table) {
    return new MySqlBigInt53(table, this.config);
  }
};
var MySqlBigInt53 = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlBigInt53");
  }
  static [entityKind] = "MySqlBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
};
var MySqlBigInt64Builder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlBigInt64Builder");
  }
  static [entityKind] = "MySqlBigInt64Builder";
  constructor(name2) {
    super(name2, "bigint", "MySqlBigInt64");
  }
  /** @internal */
  build(table) {
    return new MySqlBigInt64(table, this.config);
  }
};
var MySqlBigInt64 = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlBigInt64");
  }
  static [entityKind] = "MySqlBigInt64";
  getSQLType() {
    return "bigint";
  }
  // eslint-disable-next-line unicorn/prefer-native-coercion-functions
  mapFromDriverValue(value) {
    return BigInt(value);
  }
};
var MySqlBinaryBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlBinaryBuilder");
  }
  static [entityKind] = "MySqlBinaryBuilder";
  constructor(name2, length) {
    super(name2, "string", "MySqlBinary");
    this.config.length = length;
  }
  /** @internal */
  build(table) {
    return new MySqlBinary(table, this.config);
  }
};
var MySqlBinary = class extends MySqlColumn {
  static {
    __name(this, "MySqlBinary");
  }
  static [entityKind] = "MySqlBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === void 0 ? `binary` : `binary(${this.length})`;
  }
};
var MySqlBooleanBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlBooleanBuilder");
  }
  static [entityKind] = "MySqlBooleanBuilder";
  constructor(name2) {
    super(name2, "boolean", "MySqlBoolean");
  }
  /** @internal */
  build(table) {
    return new MySqlBoolean(table, this.config);
  }
};
var MySqlBoolean = class extends MySqlColumn {
  static {
    __name(this, "MySqlBoolean");
  }
  static [entityKind] = "MySqlBoolean";
  getSQLType() {
    return "boolean";
  }
  mapFromDriverValue(value) {
    if (typeof value === "boolean") {
      return value;
    }
    return value === 1;
  }
};
var MySqlCharBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlCharBuilder");
  }
  static [entityKind] = "MySqlCharBuilder";
  constructor(name2, config) {
    super(name2, "string", "MySqlChar");
    this.config.length = config.length;
    this.config.enum = config.enum;
  }
  /** @internal */
  build(table) {
    return new MySqlChar(table, this.config);
  }
};
var MySqlChar = class extends MySqlColumn {
  static {
    __name(this, "MySqlChar");
  }
  static [entityKind] = "MySqlChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === void 0 ? `char` : `char(${this.length})`;
  }
};
var MySqlCustomColumnBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlCustomColumnBuilder");
  }
  static [entityKind] = "MySqlCustomColumnBuilder";
  constructor(name2, fieldConfig, customTypeParams) {
    super(name2, "custom", "MySqlCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  /** @internal */
  build(table) {
    return new MySqlCustomColumn(table, this.config);
  }
};
var MySqlCustomColumn = class extends MySqlColumn {
  static {
    __name(this, "MySqlCustomColumn");
  }
  static [entityKind] = "MySqlCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
};
var MySqlDateBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlDateBuilder");
  }
  static [entityKind] = "MySqlDateBuilder";
  constructor(name2) {
    super(name2, "date", "MySqlDate");
  }
  /** @internal */
  build(table) {
    return new MySqlDate(table, this.config);
  }
};
var MySqlDate = class extends MySqlColumn {
  static {
    __name(this, "MySqlDate");
  }
  static [entityKind] = "MySqlDate";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return `date`;
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
};
var MySqlDateStringBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlDateStringBuilder");
  }
  static [entityKind] = "MySqlDateStringBuilder";
  constructor(name2) {
    super(name2, "string", "MySqlDateString");
  }
  /** @internal */
  build(table) {
    return new MySqlDateString(table, this.config);
  }
};
var MySqlDateString = class extends MySqlColumn {
  static {
    __name(this, "MySqlDateString");
  }
  static [entityKind] = "MySqlDateString";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return `date`;
  }
};
var MySqlDateTimeBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlDateTimeBuilder");
  }
  static [entityKind] = "MySqlDateTimeBuilder";
  constructor(name2, config) {
    super(name2, "date", "MySqlDateTime");
    this.config.fsp = config?.fsp;
  }
  /** @internal */
  build(table) {
    return new MySqlDateTime(table, this.config);
  }
};
var MySqlDateTime = class extends MySqlColumn {
  static {
    __name(this, "MySqlDateTime");
  }
  static [entityKind] = "MySqlDateTime";
  fsp;
  constructor(table, config) {
    super(table, config);
    this.fsp = config.fsp;
  }
  getSQLType() {
    const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
    return `datetime${precision}`;
  }
  mapToDriverValue(value) {
    return value.toISOString().replace("T", " ").replace("Z", "");
  }
  mapFromDriverValue(value) {
    return /* @__PURE__ */ new Date(value.replace(" ", "T") + "Z");
  }
};
var MySqlDateTimeStringBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlDateTimeStringBuilder");
  }
  static [entityKind] = "MySqlDateTimeStringBuilder";
  constructor(name2, config) {
    super(name2, "string", "MySqlDateTimeString");
    this.config.fsp = config?.fsp;
  }
  /** @internal */
  build(table) {
    return new MySqlDateTimeString(table, this.config);
  }
};
var MySqlDateTimeString = class extends MySqlColumn {
  static {
    __name(this, "MySqlDateTimeString");
  }
  static [entityKind] = "MySqlDateTimeString";
  fsp;
  constructor(table, config) {
    super(table, config);
    this.fsp = config.fsp;
  }
  getSQLType() {
    const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
    return `datetime${precision}`;
  }
};
var MySqlDecimalBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlDecimalBuilder");
  }
  static [entityKind] = "MySqlDecimalBuilder";
  constructor(name2, precision, scale) {
    super(name2, "string", "MySqlDecimal");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  /** @internal */
  build(table) {
    return new MySqlDecimal(table, this.config);
  }
};
var MySqlDecimal = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlDecimal");
  }
  static [entityKind] = "MySqlDecimal";
  precision = this.config.precision;
  scale = this.config.scale;
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `decimal(${this.precision},${this.scale})`;
    } else if (this.precision === void 0) {
      return "decimal";
    } else {
      return `decimal(${this.precision})`;
    }
  }
};
var MySqlDoubleBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlDoubleBuilder");
  }
  static [entityKind] = "MySqlDoubleBuilder";
  constructor(name2, config) {
    super(name2, "number", "MySqlDouble");
    this.config.precision = config?.precision;
    this.config.scale = config?.scale;
  }
  /** @internal */
  build(table) {
    return new MySqlDouble(table, this.config);
  }
};
var MySqlDouble = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlDouble");
  }
  static [entityKind] = "MySqlDouble";
  precision = this.config.precision;
  scale = this.config.scale;
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `double(${this.precision},${this.scale})`;
    } else if (this.precision === void 0) {
      return "double";
    } else {
      return `double(${this.precision})`;
    }
  }
};
var MySqlEnumColumnBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlEnumColumnBuilder");
  }
  static [entityKind] = "MySqlEnumColumnBuilder";
  constructor(name2, values) {
    super(name2, "string", "MySqlEnumColumn");
    this.config.enumValues = values;
  }
  /** @internal */
  build(table) {
    return new MySqlEnumColumn(table, this.config);
  }
};
var MySqlEnumColumn = class extends MySqlColumn {
  static {
    __name(this, "MySqlEnumColumn");
  }
  static [entityKind] = "MySqlEnumColumn";
  enumValues = this.config.enumValues;
  getSQLType() {
    return `enum(${this.enumValues.map((value) => `'${value}'`).join(",")})`;
  }
};
var MySqlFloatBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlFloatBuilder");
  }
  static [entityKind] = "MySqlFloatBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlFloat");
  }
  /** @internal */
  build(table) {
    return new MySqlFloat(table, this.config);
  }
};
var MySqlFloat = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlFloat");
  }
  static [entityKind] = "MySqlFloat";
  getSQLType() {
    return "float";
  }
};
var MySqlIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlIntBuilder");
  }
  static [entityKind] = "MySqlIntBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlInt");
  }
  /** @internal */
  build(table) {
    return new MySqlInt(table, this.config);
  }
};
var MySqlInt = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlInt");
  }
  static [entityKind] = "MySqlInt";
  getSQLType() {
    return "int";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  }
};
var MySqlJsonBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlJsonBuilder");
  }
  static [entityKind] = "MySqlJsonBuilder";
  constructor(name2) {
    super(name2, "json", "MySqlJson");
  }
  /** @internal */
  build(table) {
    return new MySqlJson(table, this.config);
  }
};
var MySqlJson = class extends MySqlColumn {
  static {
    __name(this, "MySqlJson");
  }
  static [entityKind] = "MySqlJson";
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
};
var MySqlMediumIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlMediumIntBuilder");
  }
  static [entityKind] = "MySqlMediumIntBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlMediumInt");
  }
  /** @internal */
  build(table) {
    return new MySqlMediumInt(table, this.config);
  }
};
var MySqlMediumInt = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlMediumInt");
  }
  static [entityKind] = "MySqlMediumInt";
  getSQLType() {
    return "mediumint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  }
};
var MySqlRealBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlRealBuilder");
  }
  static [entityKind] = "MySqlRealBuilder";
  constructor(name2, config) {
    super(name2, "number", "MySqlReal");
    this.config.precision = config?.precision;
    this.config.scale = config?.scale;
  }
  /** @internal */
  build(table) {
    return new MySqlReal(table, this.config);
  }
};
var MySqlReal = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlReal");
  }
  static [entityKind] = "MySqlReal";
  precision = this.config.precision;
  scale = this.config.scale;
  getSQLType() {
    if (this.precision !== void 0 && this.scale !== void 0) {
      return `real(${this.precision}, ${this.scale})`;
    } else if (this.precision === void 0) {
      return "real";
    } else {
      return `real(${this.precision})`;
    }
  }
};
var MySqlSerialBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlSerialBuilder");
  }
  static [entityKind] = "MySqlSerialBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlSerial");
    this.config.hasDefault = true;
    this.config.autoIncrement = true;
  }
  /** @internal */
  build(table) {
    return new MySqlSerial(table, this.config);
  }
};
var MySqlSerial = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlSerial");
  }
  static [entityKind] = "MySqlSerial";
  getSQLType() {
    return "serial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  }
};
var MySqlSmallIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlSmallIntBuilder");
  }
  static [entityKind] = "MySqlSmallIntBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlSmallInt");
  }
  /** @internal */
  build(table) {
    return new MySqlSmallInt(table, this.config);
  }
};
var MySqlSmallInt = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlSmallInt");
  }
  static [entityKind] = "MySqlSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  }
};
var MySqlTextBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlTextBuilder");
  }
  static [entityKind] = "MySqlTextBuilder";
  constructor(name2, textType, config) {
    super(name2, "string", "MySqlText");
    this.config.textType = textType;
    this.config.enumValues = config.enum;
  }
  /** @internal */
  build(table) {
    return new MySqlText(table, this.config);
  }
};
var MySqlText = class extends MySqlColumn {
  static {
    __name(this, "MySqlText");
  }
  static [entityKind] = "MySqlText";
  textType = this.config.textType;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.textType;
  }
};
var MySqlTimeBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlTimeBuilder");
  }
  static [entityKind] = "MySqlTimeBuilder";
  constructor(name2, config) {
    super(name2, "string", "MySqlTime");
    this.config.fsp = config?.fsp;
  }
  /** @internal */
  build(table) {
    return new MySqlTime(table, this.config);
  }
};
var MySqlTime = class extends MySqlColumn {
  static {
    __name(this, "MySqlTime");
  }
  static [entityKind] = "MySqlTime";
  fsp = this.config.fsp;
  getSQLType() {
    const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
    return `time${precision}`;
  }
};
var MySqlDateColumnBaseBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlDateColumnBaseBuilder");
  }
  static [entityKind] = "MySqlDateColumnBuilder";
  defaultNow() {
    return this.default(sql`(now())`);
  }
  // "on update now" also adds an implicit default value to the column - https://dev.mysql.com/doc/refman/8.0/en/timestamp-initialization.html
  onUpdateNow() {
    this.config.hasOnUpdateNow = true;
    this.config.hasDefault = true;
    return this;
  }
};
var MySqlDateBaseColumn = class extends MySqlColumn {
  static {
    __name(this, "MySqlDateBaseColumn");
  }
  static [entityKind] = "MySqlDateColumn";
  hasOnUpdateNow = this.config.hasOnUpdateNow;
};
var MySqlTimestampBuilder = class extends MySqlDateColumnBaseBuilder {
  static {
    __name(this, "MySqlTimestampBuilder");
  }
  static [entityKind] = "MySqlTimestampBuilder";
  constructor(name2, config) {
    super(name2, "date", "MySqlTimestamp");
    this.config.fsp = config?.fsp;
  }
  /** @internal */
  build(table) {
    return new MySqlTimestamp(table, this.config);
  }
};
var MySqlTimestamp = class extends MySqlDateBaseColumn {
  static {
    __name(this, "MySqlTimestamp");
  }
  static [entityKind] = "MySqlTimestamp";
  fsp = this.config.fsp;
  getSQLType() {
    const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
    return `timestamp${precision}`;
  }
  mapFromDriverValue(value) {
    return /* @__PURE__ */ new Date(value + "+0000");
  }
  mapToDriverValue(value) {
    return value.toISOString().slice(0, -1).replace("T", " ");
  }
};
var MySqlTimestampStringBuilder = class extends MySqlDateColumnBaseBuilder {
  static {
    __name(this, "MySqlTimestampStringBuilder");
  }
  static [entityKind] = "MySqlTimestampStringBuilder";
  constructor(name2, config) {
    super(name2, "string", "MySqlTimestampString");
    this.config.fsp = config?.fsp;
  }
  /** @internal */
  build(table) {
    return new MySqlTimestampString(table, this.config);
  }
};
var MySqlTimestampString = class extends MySqlDateBaseColumn {
  static {
    __name(this, "MySqlTimestampString");
  }
  static [entityKind] = "MySqlTimestampString";
  fsp = this.config.fsp;
  getSQLType() {
    const precision = this.fsp === void 0 ? "" : `(${this.fsp})`;
    return `timestamp${precision}`;
  }
};
var MySqlTinyIntBuilder = class extends MySqlColumnBuilderWithAutoIncrement {
  static {
    __name(this, "MySqlTinyIntBuilder");
  }
  static [entityKind] = "MySqlTinyIntBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlTinyInt");
  }
  /** @internal */
  build(table) {
    return new MySqlTinyInt(table, this.config);
  }
};
var MySqlTinyInt = class extends MySqlColumnWithAutoIncrement {
  static {
    __name(this, "MySqlTinyInt");
  }
  static [entityKind] = "MySqlTinyInt";
  getSQLType() {
    return "tinyint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  }
};
var MySqlVarBinaryBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlVarBinaryBuilder");
  }
  static [entityKind] = "MySqlVarBinaryBuilder";
  /** @internal */
  constructor(name2, config) {
    super(name2, "string", "MySqlVarBinary");
    this.config.length = config?.length;
  }
  /** @internal */
  build(table) {
    return new MySqlVarBinary(table, this.config);
  }
};
var MySqlVarBinary = class extends MySqlColumn {
  static {
    __name(this, "MySqlVarBinary");
  }
  static [entityKind] = "MySqlVarBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === void 0 ? `varbinary` : `varbinary(${this.length})`;
  }
};
var MySqlVarCharBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlVarCharBuilder");
  }
  static [entityKind] = "MySqlVarCharBuilder";
  /** @internal */
  constructor(name2, config) {
    super(name2, "string", "MySqlVarChar");
    this.config.length = config.length;
    this.config.enum = config.enum;
  }
  /** @internal */
  build(table) {
    return new MySqlVarChar(table, this.config);
  }
};
var MySqlVarChar = class extends MySqlColumn {
  static {
    __name(this, "MySqlVarChar");
  }
  static [entityKind] = "MySqlVarChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
  }
};
var MySqlYearBuilder = class extends MySqlColumnBuilder {
  static {
    __name(this, "MySqlYearBuilder");
  }
  static [entityKind] = "MySqlYearBuilder";
  constructor(name2) {
    super(name2, "number", "MySqlYear");
  }
  /** @internal */
  build(table) {
    return new MySqlYear(table, this.config);
  }
};
var MySqlYear = class extends MySqlColumn {
  static {
    __name(this, "MySqlYear");
  }
  static [entityKind] = "MySqlYear";
  getSQLType() {
    return `year`;
  }
};
var CheckBuilder3 = class {
  static {
    __name(this, "CheckBuilder");
  }
  name;
  value;
  static [entityKind] = "MySqlCheckBuilder";
  brand;
  constructor(name2, value) {
    this.name = name2;
    this.value = value;
  }
  /** @internal */
  build(table) {
    return new Check3(table, this);
  }
};
var Check3 = class {
  static {
    __name(this, "Check");
  }
  table;
  static [entityKind] = "MySqlCheck";
  name;
  value;
  constructor(table, builder) {
    this.table = table;
    this.name = builder.name;
    this.value = builder.value;
  }
};
var IndexBuilderOn3 = class {
  static {
    __name(this, "IndexBuilderOn");
  }
  name;
  unique;
  static [entityKind] = "MySqlIndexBuilderOn";
  constructor(name2, unique3) {
    this.name = name2;
    this.unique = unique3;
  }
  on(...columns) {
    return new IndexBuilder3(this.name, columns, this.unique);
  }
};
var IndexBuilder3 = class {
  static {
    __name(this, "IndexBuilder");
  }
  static [entityKind] = "MySqlIndexBuilder";
  /** @internal */
  config;
  constructor(name2, columns, unique3) {
    this.config = {
      name: name2,
      columns,
      unique: unique3
    };
  }
  using(using) {
    this.config.using = using;
    return this;
  }
  algorythm(algorythm) {
    this.config.algorythm = algorythm;
    return this;
  }
  lock(lock) {
    this.config.lock = lock;
    return this;
  }
  /** @internal */
  build(table) {
    return new Index3(this.config, table);
  }
};
var Index3 = class {
  static {
    __name(this, "Index");
  }
  static [entityKind] = "MySqlIndex";
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
};
var PrimaryKeyBuilder3 = class {
  static {
    __name(this, "PrimaryKeyBuilder");
  }
  static [entityKind] = "MySqlPrimaryKeyBuilder";
  /** @internal */
  columns;
  constructor(columns) {
    this.columns = columns;
  }
  /** @internal */
  build(table) {
    return new PrimaryKey3(table, this.columns);
  }
};
var PrimaryKey3 = class {
  static {
    __name(this, "PrimaryKey");
  }
  table;
  static [entityKind] = "MySqlPrimaryKey";
  columns;
  constructor(table, columns) {
    this.table = table;
    this.columns = columns;
  }
  getName() {
    return `${this.table[MySqlTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};
var MySqlSchema = class {
  static {
    __name(this, "MySqlSchema");
  }
  schemaName;
  static [entityKind] = "MySqlSchema";
  constructor(schemaName) {
    this.schemaName = schemaName;
  }
  table = (name2, columns, extraConfig) => {
    return mysqlTableWithSchema(name2, columns, extraConfig, this.schemaName);
  };
  view = (name2, columns) => {
    return mysqlViewWithSchema(name2, columns, this.schemaName);
  };
};

// ../../node_modules/drizzle-orm/pg-core/index.mjs
var PgBigInt53Builder = class extends PgColumnBuilder {
  static {
    __name(this, "PgBigInt53Builder");
  }
  static [entityKind] = "PgBigInt53Builder";
  constructor(name2) {
    super(name2, "number", "PgBigInt53");
  }
  /** @internal */
  build(table) {
    return new PgBigInt53(table, this.config);
  }
};
var PgBigInt53 = class extends PgColumn {
  static {
    __name(this, "PgBigInt53");
  }
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
};
var PgBigInt64Builder = class extends PgColumnBuilder {
  static {
    __name(this, "PgBigInt64Builder");
  }
  static [entityKind] = "PgBigInt64Builder";
  constructor(name2) {
    super(name2, "bigint", "PgBigInt64");
  }
  /** @internal */
  build(table) {
    return new PgBigInt64(table, this.config);
  }
};
var PgBigInt64 = class extends PgColumn {
  static {
    __name(this, "PgBigInt64");
  }
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  // eslint-disable-next-line unicorn/prefer-native-coercion-functions
  mapFromDriverValue(value) {
    return BigInt(value);
  }
};
var PgBigSerial53Builder = class extends PgColumnBuilder {
  static {
    __name(this, "PgBigSerial53Builder");
  }
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name2) {
    super(name2, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  /** @internal */
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
};
var PgBigSerial53 = class extends PgColumn {
  static {
    __name(this, "PgBigSerial53");
  }
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
};
var PgBigSerial64Builder = class extends PgColumnBuilder {
  static {
    __name(this, "PgBigSerial64Builder");
  }
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name2) {
    super(name2, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  /** @internal */
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
};
var PgBigSerial64 = class extends PgColumn {
  static {
    __name(this, "PgBigSerial64");
  }
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  // eslint-disable-next-line unicorn/prefer-native-coercion-functions
  mapFromDriverValue(value) {
    return BigInt(value);
  }
};
var PgBooleanBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgBooleanBuilder");
  }
  static [entityKind] = "PgBooleanBuilder";
  constructor(name2) {
    super(name2, "boolean", "PgBoolean");
  }
  /** @internal */
  build(table) {
    return new PgBoolean(table, this.config);
  }
};
var PgBoolean = class extends PgColumn {
  static {
    __name(this, "PgBoolean");
  }
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
};
var PgCharBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgCharBuilder");
  }
  static [entityKind] = "PgCharBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  /** @internal */
  build(table) {
    return new PgChar(table, this.config);
  }
};
var PgChar = class extends PgColumn {
  static {
    __name(this, "PgChar");
  }
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === void 0 ? `char` : `char(${this.length})`;
  }
};
var PgCidrBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgCidrBuilder");
  }
  static [entityKind] = "PgCidrBuilder";
  constructor(name2) {
    super(name2, "string", "PgCidr");
  }
  /** @internal */
  build(table) {
    return new PgCidr(table, this.config);
  }
};
var PgCidr = class extends PgColumn {
  static {
    __name(this, "PgCidr");
  }
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
};
var PgCustomColumnBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgCustomColumnBuilder");
  }
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name2, fieldConfig, customTypeParams) {
    super(name2, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  /** @internal */
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
};
var PgCustomColumn = class extends PgColumn {
  static {
    __name(this, "PgCustomColumn");
  }
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
};
var PgDoublePrecisionBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgDoublePrecisionBuilder");
  }
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name2) {
    super(name2, "number", "PgDoublePrecision");
  }
  /** @internal */
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
};
var PgDoublePrecision = class extends PgColumn {
  static {
    __name(this, "PgDoublePrecision");
  }
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
};
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
var PgEnumColumnBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgEnumColumnBuilder");
  }
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name2, enumInstance) {
    super(name2, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table) {
    return new PgEnumColumn(table, this.config);
  }
};
var PgEnumColumn = class extends PgColumn {
  static {
    __name(this, "PgEnumColumn");
  }
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};
var PgInetBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgInetBuilder");
  }
  static [entityKind] = "PgInetBuilder";
  constructor(name2) {
    super(name2, "string", "PgInet");
  }
  /** @internal */
  build(table) {
    return new PgInet(table, this.config);
  }
};
var PgInet = class extends PgColumn {
  static {
    __name(this, "PgInet");
  }
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
};
var PgIntegerBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgIntegerBuilder");
  }
  static [entityKind] = "PgIntegerBuilder";
  constructor(name2) {
    super(name2, "number", "PgInteger");
  }
  /** @internal */
  build(table) {
    return new PgInteger(table, this.config);
  }
};
var PgInteger = class extends PgColumn {
  static {
    __name(this, "PgInteger");
  }
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
};
var PgIntervalBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgIntervalBuilder");
  }
  static [entityKind] = "PgIntervalBuilder";
  constructor(name2, intervalConfig) {
    super(name2, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  /** @internal */
  build(table) {
    return new PgInterval(table, this.config);
  }
};
var PgInterval = class extends PgColumn {
  static {
    __name(this, "PgInterval");
  }
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
};
var PgMacaddrBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgMacaddrBuilder");
  }
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name2) {
    super(name2, "string", "PgMacaddr");
  }
  /** @internal */
  build(table) {
    return new PgMacaddr(table, this.config);
  }
};
var PgMacaddr = class extends PgColumn {
  static {
    __name(this, "PgMacaddr");
  }
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
};
var PgMacaddr8Builder = class extends PgColumnBuilder {
  static {
    __name(this, "PgMacaddr8Builder");
  }
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name2) {
    super(name2, "string", "PgMacaddr8");
  }
  /** @internal */
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
};
var PgMacaddr8 = class extends PgColumn {
  static {
    __name(this, "PgMacaddr8");
  }
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
};
var PgRealBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgRealBuilder");
  }
  static [entityKind] = "PgRealBuilder";
  constructor(name2, length) {
    super(name2, "number", "PgReal");
    this.config.length = length;
  }
  /** @internal */
  build(table) {
    return new PgReal(table, this.config);
  }
};
var PgReal = class extends PgColumn {
  static {
    __name(this, "PgReal");
  }
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
};
var PgSerialBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgSerialBuilder");
  }
  static [entityKind] = "PgSerialBuilder";
  constructor(name2) {
    super(name2, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  /** @internal */
  build(table) {
    return new PgSerial(table, this.config);
  }
};
var PgSerial = class extends PgColumn {
  static {
    __name(this, "PgSerial");
  }
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
};
var PgSmallIntBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgSmallIntBuilder");
  }
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name2) {
    super(name2, "number", "PgSmallInt");
  }
  /** @internal */
  build(table) {
    return new PgSmallInt(table, this.config);
  }
};
var PgSmallInt = class extends PgColumn {
  static {
    __name(this, "PgSmallInt");
  }
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
};
var PgSmallSerialBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgSmallSerialBuilder");
  }
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name2) {
    super(name2, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  /** @internal */
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
};
var PgSmallSerial = class extends PgColumn {
  static {
    __name(this, "PgSmallSerial");
  }
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
};
var PgTextBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgTextBuilder");
  }
  static [entityKind] = "PgTextBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  /** @internal */
  build(table) {
    return new PgText(table, this.config);
  }
};
var PgText = class extends PgColumn {
  static {
    __name(this, "PgText");
  }
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
};
var PgVarcharBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgVarcharBuilder");
  }
  static [entityKind] = "PgVarcharBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  /** @internal */
  build(table) {
    return new PgVarchar(table, this.config);
  }
};
var PgVarchar = class extends PgColumn {
  static {
    __name(this, "PgVarchar");
  }
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === void 0 ? `varchar` : `varchar(${this.length})`;
  }
};
var PgSchema = class {
  static {
    __name(this, "PgSchema");
  }
  schemaName;
  static [entityKind] = "PgSchema";
  constructor(schemaName) {
    this.schemaName = schemaName;
  }
  table = (name2, columns, extraConfig) => {
    return pgTableWithSchema(name2, columns, extraConfig, this.schemaName);
  };
  view = (name2, columns) => {
    return pgViewWithSchema(name2, columns, this.schemaName);
  };
  materializedView = (name2, columns) => {
    return pgMaterializedViewWithSchema(name2, columns, this.schemaName);
  };
};

// ../../node_modules/drizzle-zod/index.mjs
var m10 = z2.union([z2.string(), z2.number(), z2.boolean(), z2.null()]);
var f10 = z2.lazy(() => z2.union([m10, z2.array(f10), z2.record(f10)]));
function c10(t6, n10) {
  const r10 = getTableColumns(t6), o10 = Object.entries(r10);
  let i10 = Object.fromEntries(o10.map(([e10, t7]) => [e10, p10(t7)]));
  n10 && (i10 = Object.assign(i10, Object.fromEntries(Object.entries(n10).map(([e10, t7]) => [e10, "function" == typeof t7 ? t7(i10) : t7]))));
  for (const [e10, t7] of o10)
    t7.notNull ? t7.hasDefault && (i10[e10] = i10[e10].optional()) : i10[e10] = i10[e10].nullable().optional();
  return z2.object(i10);
}
__name(c10, "c");
function b10(t6, n10) {
  const r10 = getTableColumns(t6), o10 = Object.entries(r10);
  let i10 = Object.fromEntries(o10.map(([e10, t7]) => [e10, p10(t7)]));
  n10 && (i10 = Object.assign(i10, Object.fromEntries(Object.entries(n10).map(([e10, t7]) => [e10, "function" == typeof t7 ? t7(i10) : t7]))));
  for (const [e10, t7] of o10)
    t7.notNull || (i10[e10] = i10[e10].nullable());
  return z2.object(i10);
}
__name(b10, "b");
function p10(e10) {
  let m11;
  if (function(e11) {
    return "enumValues" in e11 && Array.isArray(e11.enumValues) && e11.enumValues.length > 0;
  }(e10) && (m11 = e10.enumValues.length ? z2.enum(e10.enumValues) : z2.string()), !m11) {
    if (is(e10, PgUUID))
      m11 = z2.string().uuid();
    else if ("custom" === e10.dataType)
      m11 = z2.any();
    else if ("json" === e10.dataType)
      m11 = f10;
    else if ("array" === e10.dataType)
      m11 = z2.array(p10(e10.baseColumn));
    else if ("number" === e10.dataType)
      m11 = z2.number();
    else if ("bigint" === e10.dataType)
      m11 = z2.bigint();
    else if ("boolean" === e10.dataType)
      m11 = z2.boolean();
    else if ("date" === e10.dataType)
      m11 = z2.date();
    else if ("string" === e10.dataType) {
      let i10 = z2.string();
      (is(e10, PgChar) || is(e10, PgVarchar) || is(e10, MySqlVarChar) || is(e10, MySqlVarBinary) || is(e10, MySqlChar) || is(e10, SQLiteText)) && "number" == typeof e10.length && (i10 = i10.max(e10.length)), m11 = i10;
    }
  }
  return m11 || (m11 = z2.any()), m11;
}
__name(p10, "p");

// ../../packages/schemas/extract/src/repositories.ts
var repositories = sqliteTable("repositories", {
  id: integer("id").primaryKey(),
  externalId: integer("external_id").notNull(),
  name: text("name").notNull(),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (projects) => ({
  uniqueExternalId: uniqueIndex("repositories_external_id_idx").on(projects.externalId)
}));
var NewRepositorySchema = c10(repositories, {
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});
var RepositorySchema = b10(repositories, {
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});

// ../../packages/schemas/extract/src/namespaces.ts
var namespaces = sqliteTable("namespaces", {
  id: integer("id").primaryKey(),
  externalId: integer("external_id").notNull(),
  name: text("name").notNull(),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (namespaces2) => ({
  uniqueExternalId: uniqueIndex("namespaces_external_id_idx").on(namespaces2.externalId)
}));
var NewNamespaceSchema = c10(namespaces, {
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});
var NamespaceSchema = b10(namespaces, {
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});

// ../../packages/schemas/extract/src/merge-requests.ts
var mergeRequests = sqliteTable(
  "merge_requests",
  {
    id: integer("id").primaryKey(),
    /* Gitlab -> id */
    externalId: integer("external_id").notNull(),
    /* Gitlab -> iid, GitHub -> number */
    mergeRequestId: integer("merge_request_id").notNull(),
    repositoryId: integer("repository_id").notNull(),
    title: text("title").notNull(),
    webUrl: text("web_url").notNull(),
    createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" }),
    mergedAt: integer("merged_at", { mode: "timestamp_ms" }),
    closedAt: integer("closed_at", { mode: "timestamp_ms" }),
    authorExternalId: integer("author_external_id"),
    state: text("state"),
    targetBranch: text("target_branch"),
    sourceBranch: text("source_branch"),
    _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
    _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
  },
  (mergeRequests2) => ({
    uniqueExternalId: uniqueIndex("merge_requests_external_id_idx").on(
      mergeRequests2.externalId
    )
  })
);
var MergeRequestSchema = b10(mergeRequests, {
  createdAt: z2.coerce.date(),
  updatedAt: z2.coerce.date(),
  mergedAt: z2.coerce.date(),
  closedAt: z2.coerce.date(),
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});
var NewMergeRequestSchema = c10(mergeRequests, {
  createdAt: z2.coerce.date(),
  updatedAt: z2.coerce.date(),
  mergedAt: z2.coerce.date(),
  closedAt: z2.coerce.date(),
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});

// ../../packages/schemas/extract/src/merge-request-diffs.ts
var mergeRequestDiffs = sqliteTable("merge_request_diffs", {
  id: integer("id").primaryKey(),
  /* Gitlab -> iid */
  mergeRequestId: integer("merge_request_id").notNull(),
  newPath: text("new_path").notNull(),
  oldPath: text("old_path").notNull(),
  aMode: text("a_mode").notNull(),
  bMode: text("b_mode").notNull(),
  newFile: integer("new_file", { mode: "boolean" }).notNull(),
  renamedFile: integer("renamed_file", { mode: "boolean" }).notNull(),
  deletedFile: integer("deleted_file", { mode: "boolean" }).notNull(),
  diff: text("diff").notNull(),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (diffs) => ({
  uniqueMergeRequestId: uniqueIndex("diffs_merge_request_id_newPath_idx").on(diffs.mergeRequestId, diffs.newPath)
}));

// ../../packages/schemas/extract/src/merge-request-commits.ts
var mergeRequestCommits = sqliteTable("merge_request_commits", {
  id: integer("id").primaryKey(),
  /* Gitlab -> iid */
  mergeRequestId: integer("merge_request_id").notNull(),
  externalId: text("external_id").notNull(),
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  authoredDate: integer("authored_date", { mode: "timestamp_ms" }).notNull(),
  committedDate: integer("committed_date", { mode: "timestamp_ms" }).notNull(),
  title: text("title").notNull(),
  message: text("message").notNull(),
  authorName: text("author_name").notNull(),
  authorEmail: text("author_email").notNull(),
  committerName: text("committer_name"),
  committerEmail: text("committer_email"),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (commits) => ({
  uniqueExternalId: uniqueIndex("merge_request_commits_external_id_idx").on(commits.externalId)
}));
var MergeRequestCommitSchema = c10(mergeRequestCommits, {
  createdAt: z2.coerce.date(),
  authoredDate: z2.coerce.date(),
  committedDate: z2.coerce.date(),
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});
var NewMergeRequestCommitSchema = c10(mergeRequestCommits, {
  createdAt: z2.coerce.date(),
  authoredDate: z2.coerce.date(),
  committedDate: z2.coerce.date(),
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});

// ../../packages/schemas/extract/src/members.ts
var members = sqliteTable("members", {
  id: integer("id").primaryKey(),
  externalId: integer("external_id").notNull(),
  name: text("name"),
  username: text("username").notNull(),
  email: text("email"),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (members2) => ({
  uniqueGitlabId: uniqueIndex("members_external_id_idx").on(members2.externalId)
}));
var MemberSchema = b10(members, {
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});
var NewMemberSchema = c10(members, {
  _createdAt: z2.coerce.date(),
  _updatedAt: z2.coerce.date()
});

// ../../packages/schemas/extract/src/repositories-to-members.ts
var repositoriesToMembers = sqliteTable("repositories_to_members", {
  repositoryId: integer("repository_id").notNull(),
  memberId: integer("member_id").notNull(),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (repositoriesToMembers2) => ({
  pk: primaryKey(repositoriesToMembers2.repositoryId, repositoriesToMembers2.memberId)
}));

// ../../packages/schemas/extract/src/merge-request-notes.ts
var mergeRequestNotes = sqliteTable("merge_request_notes", {
  id: integer("id").primaryKey(),
  externalId: integer("external_id").notNull(),
  mergeRequestId: integer("merge_request_id").notNull(),
  // internalId not mergeRequestId
  createdAt: integer("created_at", { mode: "timestamp_ms" }).notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" }).notNull(),
  authorUsername: text("author_username").notNull(),
  authorExternalId: integer("author_external_id").notNull(),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (notes) => ({
  uniqueExternalId: uniqueIndex("merge_request_notes_external_id_idx").on(notes.externalId)
}));

// ../../packages/schemas/extract/src/git-identities.ts
var gitIdentities = sqliteTable("git_identities", {
  id: integer("id").primaryKey(),
  repositoryId: integer("repository_id").notNull(),
  email: text("email").notNull(),
  name: text("name").notNull(),
  _createdAt: integer("__created_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`),
  _updatedAt: integer("__updated_at", { mode: "timestamp_ms" }).default(sql`CURRENT_TIMESTAMP`)
}, (gitIdentities2) => ({
  uniqueRepositoryIdEmailName: uniqueIndex("repository_id_email_name_idx").on(gitIdentities2.repositoryId, gitIdentities2.email, gitIdentities2.name)
}));

// ../../node_modules/@gitbeaker/core/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  Agents: () => Agents,
  AlertManagement: () => AlertManagement,
  ApplicationAppearance: () => ApplicationAppearance,
  ApplicationPlanLimits: () => ApplicationPlanLimits,
  ApplicationSettings: () => ApplicationSettings,
  ApplicationStatistics: () => ApplicationStatistics,
  Applications: () => Applications,
  AuditEvents: () => AuditEvents,
  Avatar: () => Avatar,
  Branches: () => Branches,
  BroadcastMessages: () => BroadcastMessages,
  CommitDiscussions: () => CommitDiscussions,
  Commits: () => Commits,
  Composer: () => Composer,
  Conan: () => Conan,
  ContainerRegistry: () => ContainerRegistry,
  DashboardAnnotations: () => DashboardAnnotations,
  Debian: () => Debian,
  DependencyProxy: () => DependencyProxy,
  DeployKeys: () => DeployKeys,
  DeployTokens: () => DeployTokens,
  Deployments: () => Deployments,
  DockerfileTemplates: () => DockerfileTemplates,
  Environments: () => Environments,
  EpicAwardEmojis: () => EpicAwardEmojis,
  EpicDiscussions: () => EpicDiscussions,
  EpicIssues: () => EpicIssues,
  EpicLabelEvents: () => EpicLabelEvents,
  EpicLinks: () => EpicLinks,
  EpicNotes: () => EpicNotes,
  Epics: () => Epics,
  ErrorTrackingClientKeys: () => ErrorTrackingClientKeys,
  ErrorTrackingSettings: () => ErrorTrackingSettings,
  Events: () => Events,
  Experiments: () => Experiments,
  ExternalStatusChecks: () => ExternalStatusChecks,
  FeatureFlagUserLists: () => FeatureFlagUserLists,
  FeatureFlags: () => FeatureFlags,
  FreezePeriods: () => FreezePeriods,
  GeoNodes: () => GeoNodes,
  GitLabCIYMLTemplates: () => GitLabCIYMLTemplates,
  GitignoreTemplates: () => GitignoreTemplates,
  Gitlab: () => Gitlab,
  GitlabPages: () => GitlabPages,
  GoProxy: () => GoProxy,
  GroupAccessRequests: () => GroupAccessRequests,
  GroupAccessTokens: () => GroupAccessTokens,
  GroupActivityAnalytics: () => GroupActivityAnalytics,
  GroupBadges: () => GroupBadges,
  GroupCustomAttributes: () => GroupCustomAttributes,
  GroupDORA4Metrics: () => GroupDORA4Metrics,
  GroupHooks: () => GroupHooks,
  GroupImportExports: () => GroupImportExports,
  GroupInvitations: () => GroupInvitations,
  GroupIssueBoards: () => GroupIssueBoards,
  GroupIterations: () => GroupIterations,
  GroupLDAPLinks: () => GroupLDAPLinks,
  GroupLabels: () => GroupLabels,
  GroupMemberRoles: () => GroupMemberRoles,
  GroupMembers: () => GroupMembers,
  GroupMilestones: () => GroupMilestones,
  GroupProtectedEnvironments: () => GroupProtectedEnvironments,
  GroupPushRules: () => GroupPushRules,
  GroupRelationExports: () => GroupRelationExports,
  GroupReleases: () => GroupReleases,
  GroupRepositoryStorageMoves: () => GroupRepositoryStorageMoves,
  GroupSAMLIdentities: () => GroupSAMLIdentities,
  GroupSCIMIdentities: () => GroupSCIMIdentities,
  GroupVariables: () => GroupVariables,
  GroupWikis: () => GroupWikis,
  Groups: () => Groups,
  Helm: () => Helm,
  Import: () => Import,
  InstanceLevelCICDVariables: () => InstanceLevelCICDVariables,
  Integrations: () => Integrations,
  IssueAwardEmojis: () => IssueAwardEmojis,
  IssueDiscussions: () => IssueDiscussions,
  IssueIterationEvents: () => IssueIterationEvents,
  IssueLabelEvents: () => IssueLabelEvents,
  IssueLinks: () => IssueLinks,
  IssueMilestoneEvents: () => IssueMilestoneEvents,
  IssueNoteAwardEmojis: () => IssueNoteAwardEmojis,
  IssueNotes: () => IssueNotes,
  IssueStateEvents: () => IssueStateEvents,
  IssueWeightEvents: () => IssueWeightEvents,
  Issues: () => Issues,
  IssuesStatistics: () => IssuesStatistics,
  JobArtifacts: () => JobArtifacts,
  Jobs: () => Jobs,
  Keys: () => Keys,
  License: () => License,
  LicenseTemplates: () => LicenseTemplates,
  LinkedEpics: () => LinkedEpics,
  Lint: () => Lint,
  Markdown: () => Markdown,
  Maven: () => Maven,
  MergeRequestApprovals: () => MergeRequestApprovals,
  MergeRequestAwardEmojis: () => MergeRequestAwardEmojis,
  MergeRequestContextCommits: () => MergeRequestContextCommits,
  MergeRequestDiscussions: () => MergeRequestDiscussions,
  MergeRequestDraftNotes: () => MergeRequestDraftNotes,
  MergeRequestLabelEvents: () => MergeRequestLabelEvents,
  MergeRequestMilestoneEvents: () => MergeRequestMilestoneEvents,
  MergeRequestNoteAwardEmojis: () => MergeRequestNoteAwardEmojis,
  MergeRequestNotes: () => MergeRequestNotes,
  MergeRequests: () => MergeRequests,
  MergeTrains: () => MergeTrains,
  Metadata: () => Metadata,
  Migrations: () => Migrations,
  NPM: () => NPM,
  Namespaces: () => Namespaces,
  NotificationSettings: () => NotificationSettings,
  NuGet: () => NuGet,
  PackageRegistry: () => PackageRegistry,
  Packages: () => Packages,
  PagesDomains: () => PagesDomains,
  PersonalAccessTokens: () => PersonalAccessTokens,
  PipelineScheduleVariables: () => PipelineScheduleVariables,
  PipelineSchedules: () => PipelineSchedules,
  PipelineTriggerTokens: () => PipelineTriggerTokens,
  Pipelines: () => Pipelines,
  ProductAnalytics: () => ProductAnalytics,
  ProjectAccessRequests: () => ProjectAccessRequests,
  ProjectAccessTokens: () => ProjectAccessTokens,
  ProjectAliases: () => ProjectAliases,
  ProjectBadges: () => ProjectBadges,
  ProjectCustomAttributes: () => ProjectCustomAttributes,
  ProjectDORA4Metrics: () => ProjectDORA4Metrics,
  ProjectHooks: () => ProjectHooks,
  ProjectImportExports: () => ProjectImportExports,
  ProjectInvitations: () => ProjectInvitations,
  ProjectIssueBoards: () => ProjectIssueBoards,
  ProjectIterations: () => ProjectIterations,
  ProjectLabels: () => ProjectLabels,
  ProjectMembers: () => ProjectMembers,
  ProjectMilestones: () => ProjectMilestones,
  ProjectProtectedEnvironments: () => ProjectProtectedEnvironments,
  ProjectPushRules: () => ProjectPushRules,
  ProjectRelationsExport: () => ProjectRelationsExport,
  ProjectReleases: () => ProjectReleases,
  ProjectRemoteMirrors: () => ProjectRemoteMirrors,
  ProjectRepositoryStorageMoves: () => ProjectRepositoryStorageMoves,
  ProjectSnippetAwardEmojis: () => ProjectSnippetAwardEmojis,
  ProjectSnippetDiscussions: () => ProjectSnippetDiscussions,
  ProjectSnippetNotes: () => ProjectSnippetNotes,
  ProjectSnippets: () => ProjectSnippets,
  ProjectStatistics: () => ProjectStatistics,
  ProjectTemplates: () => ProjectTemplates,
  ProjectVariables: () => ProjectVariables,
  ProjectVulnerabilities: () => ProjectVulnerabilities,
  ProjectWikis: () => ProjectWikis,
  Projects: () => Projects,
  ProtectedBranches: () => ProtectedBranches,
  ProtectedTags: () => ProtectedTags,
  PyPI: () => PyPI,
  ReleaseLinks: () => ReleaseLinks,
  Repositories: () => Repositories,
  RepositoryFiles: () => RepositoryFiles,
  RepositorySubmodules: () => RepositorySubmodules,
  ResourceGroups: () => ResourceGroups,
  RubyGems: () => RubyGems,
  Runners: () => Runners,
  Search: () => Search,
  SecureFiles: () => SecureFiles,
  ServiceData: () => ServiceData,
  SidekiqMetrics: () => SidekiqMetrics,
  SidekiqQueues: () => SidekiqQueues,
  SnippetRepositoryStorageMoves: () => SnippetRepositoryStorageMoves,
  Snippets: () => Snippets,
  Suggestions: () => Suggestions,
  SystemHooks: () => SystemHooks,
  Tags: () => Tags,
  TodoLists: () => TodoLists,
  Topics: () => Topics,
  UserCustomAttributes: () => UserCustomAttributes,
  UserEmails: () => UserEmails,
  UserGPGKeys: () => UserGPGKeys,
  UserImpersonationTokens: () => UserImpersonationTokens,
  UserSSHKeys: () => UserSSHKeys,
  UserStarredMetricsDashboard: () => UserStarredMetricsDashboard,
  Users: () => Users
});

// ../../node_modules/@gitbeaker/requester-utils/dist/index.mjs
var import_qs = __toESM(require_lib3(), 1);
var import_xcase = __toESM(require_es5(), 1);
function formatQuery(params = {}) {
  const decamelized = (0, import_xcase.decamelizeKeys)(params);
  return (0, import_qs.stringify)(decamelized, { arrayFormat: "brackets" });
}
__name(formatQuery, "formatQuery");
function isFormData(object) {
  return typeof object === "object" && object.constructor.name === "FormData";
}
__name(isFormData, "isFormData");
async function defaultOptionsHandler(resourceOptions, {
  body,
  searchParams,
  sudo,
  signal,
  asStream = false,
  method = "GET"
} = {}) {
  const { headers: preconfiguredHeaders, authHeaders, url: url12 } = resourceOptions;
  const headers = { ...preconfiguredHeaders };
  const defaultOptions = {
    method,
    asStream,
    signal,
    prefixUrl: url12
  };
  defaultOptions.headers = headers;
  if (sudo)
    defaultOptions.headers.sudo = `${sudo}`;
  if (body) {
    if (isFormData(body)) {
      defaultOptions.body = body;
    } else {
      defaultOptions.body = JSON.stringify((0, import_xcase.decamelizeKeys)(body));
      defaultOptions.headers["content-type"] = "application/json";
    }
  }
  const [authHeaderKey, authHeaderFn] = Object.entries(authHeaders)[0];
  defaultOptions.headers[authHeaderKey] = await authHeaderFn();
  const q10 = formatQuery(searchParams);
  if (q10)
    defaultOptions.searchParams = q10;
  return Promise.resolve(defaultOptions);
}
__name(defaultOptionsHandler, "defaultOptionsHandler");
function createRequesterFn(optionsHandler, requestHandler) {
  const methods = ["get", "post", "put", "patch", "delete"];
  return (serviceOptions) => {
    const requester = {};
    methods.forEach((m11) => {
      requester[m11] = async (endpoint3, options) => {
        const defaultRequestOptions = await defaultOptionsHandler(serviceOptions, {
          ...options,
          method: m11.toUpperCase()
        });
        const requestOptions = await optionsHandler(serviceOptions, defaultRequestOptions);
        return requestHandler(endpoint3, requestOptions);
      };
    });
    return requester;
  };
}
__name(createRequesterFn, "createRequesterFn");
function extendClass(Base, customConfig = {}) {
  return class extends Base {
    constructor(...options) {
      const [config, ...opts] = options;
      super({ ...customConfig, ...config }, ...opts);
    }
  };
}
__name(extendClass, "extendClass");
function presetResourceArguments(resources2, customConfig = {}) {
  const updated = {};
  Object.entries(resources2).filter(([, s10]) => typeof s10 === "function").forEach(([k10, r10]) => {
    updated[k10] = extendClass(r10, customConfig);
  });
  return updated;
}
__name(presetResourceArguments, "presetResourceArguments");
function getDynamicToken(tokenArgument) {
  return tokenArgument instanceof Function ? tokenArgument() : Promise.resolve(tokenArgument);
}
__name(getDynamicToken, "getDynamicToken");
var BaseResource = class {
  static {
    __name(this, "BaseResource");
  }
  url;
  requester;
  queryTimeout;
  headers;
  authHeaders;
  camelize;
  rejectUnauthorized;
  constructor({
    sudo,
    profileToken,
    camelize,
    requesterFn: requesterFn2,
    profileMode = "execution",
    host = "https://gitlab.com",
    prefixUrl = "",
    rejectUnauthorized = true,
    queryTimeout = 3e5,
    ...tokens
  }) {
    if (!requesterFn2)
      throw new ReferenceError("requesterFn must be passed");
    this.url = [host, "api", "v4", prefixUrl].join("/");
    this.headers = {};
    this.authHeaders = {};
    this.rejectUnauthorized = rejectUnauthorized;
    this.camelize = camelize;
    this.queryTimeout = queryTimeout;
    if ("oauthToken" in tokens)
      this.authHeaders.authorization = async () => {
        const token = await getDynamicToken(tokens.oauthToken);
        return `Bearer ${token}`;
      };
    else if ("jobToken" in tokens)
      this.authHeaders["job-token"] = async () => getDynamicToken(tokens.jobToken);
    else if ("token" in tokens)
      this.authHeaders["private-token"] = async () => getDynamicToken(tokens.token);
    else {
      throw new ReferenceError("A token, oauthToken or jobToken must be passed");
    }
    if (profileToken) {
      this.headers["X-Profile-Token"] = profileToken;
      this.headers["X-Profile-Mode"] = profileMode;
    }
    if (sudo)
      this.headers.Sudo = `${sudo}`;
    this.requester = requesterFn2({ ...this });
  }
};

// ../../node_modules/@gitbeaker/core/dist/index.mjs
var import_xcase2 = __toESM(require_es5(), 1);
var import_qs2 = __toESM(require_lib3(), 1);
function appendFormFromObject(object) {
  const form = new FormData();
  Object.entries(object).forEach(([k10, v7]) => {
    if (!v7)
      return;
    if (Array.isArray(v7))
      form.append(k10, v7[0], v7[1]);
    else
      form.append(k10, v7);
  });
  return form;
}
__name(appendFormFromObject, "appendFormFromObject");
function endpoint(strings, ...values) {
  return values.reduce(
    (string, value, index2) => string + encodeURIComponent(value) + strings[index2 + 1],
    strings[0]
  );
}
__name(endpoint, "endpoint");
function parseLinkHeader(linkString) {
  const output = {};
  const regex = /<([^>]+)>; rel="([^"]+)"/g;
  let m11;
  while (m11 = regex.exec(linkString)) {
    const [, v7, k10] = m11;
    output[k10] = v7;
  }
  return output;
}
__name(parseLinkHeader, "parseLinkHeader");
function reformatObjectOptions(obj, prefixKey, decamelizeValues = false) {
  const formatted = decamelizeValues ? (0, import_xcase2.decamelizeKeys)(obj) : obj;
  return import_qs2.default.stringify({ [prefixKey]: formatted }, { encode: false }).split("&").reduce((acc, cur) => {
    const [key, val2] = cur.split("=");
    acc[key] = val2;
    return acc;
  }, {});
}
__name(reformatObjectOptions, "reformatObjectOptions");
function packageResponse(response, showExpanded) {
  return showExpanded ? {
    data: response.body,
    status: response.status,
    headers: response.headers
  } : response.body;
}
__name(packageResponse, "packageResponse");
function getStream(response, showExpanded) {
  return packageResponse(response, showExpanded);
}
__name(getStream, "getStream");
function getSingle(camelize, response, showExpanded) {
  const { status, headers } = response;
  let { body } = response;
  if (camelize)
    body = (0, import_xcase2.camelizeKeys)(body);
  return packageResponse({ body, status, headers }, showExpanded);
}
__name(getSingle, "getSingle");
async function getManyMore(camelize, getFn, endpoint22, response, requestOptions, acc) {
  const { sudo, showExpanded, maxPages, pagination, page, perPage, idAfter, orderBy, sort } = requestOptions;
  if (camelize)
    response.body = (0, import_xcase2.camelizeKeys)(response?.body);
  const newAcc = [...acc || [], ...response.body];
  const withinBounds = maxPages && perPage ? newAcc.length / +perPage < maxPages : true;
  const { next = "" } = parseLinkHeader(response.headers.link);
  if (!(page && (acc || []).length === 0) && next && withinBounds) {
    const parsedQueryString = (0, import_qs2.parse)(next.split("?")[1]);
    const qs = { ...(0, import_xcase2.camelizeKeys)(parsedQueryString) };
    const newOpts = {
      ...qs,
      maxPages,
      sudo,
      showExpanded
    };
    const nextResponse = await getFn(endpoint22, {
      searchParams: qs,
      sudo
    });
    return getManyMore(camelize, getFn, endpoint22, nextResponse, newOpts, newAcc);
  }
  if (!showExpanded)
    return newAcc;
  const paginationInfo = pagination === "keyset" ? {
    idAfter: idAfter ? +idAfter : null,
    perPage: perPage ? +perPage : null,
    orderBy,
    sort
  } : {
    total: parseInt(response.headers["x-total"], 10),
    next: parseInt(response.headers["x-next-page"], 10) || null,
    current: parseInt(response.headers["x-page"], 10) || 1,
    previous: parseInt(response.headers["x-prev-page"], 10) || null,
    perPage: parseInt(response.headers["x-per-page"], 10),
    totalPages: parseInt(response.headers["x-total-pages"], 10)
  };
  return {
    data: newAcc,
    paginationInfo
  };
}
__name(getManyMore, "getManyMore");
function get() {
  return async (service, endpoint22, options) => {
    const { asStream, sudo, showExpanded, maxPages, ...searchParams } = options || {};
    const signal = service.queryTimeout ? AbortSignal.timeout(service.queryTimeout) : void 0;
    const response = await service.requester.get(endpoint22, {
      searchParams,
      sudo,
      asStream,
      signal
    });
    const camelizeResponseBody = service.camelize || false;
    if (asStream)
      return getStream(response, showExpanded);
    if (!Array.isArray(response.body))
      return getSingle(
        camelizeResponseBody,
        response,
        showExpanded
      );
    const reqOpts = {
      sudo,
      showExpanded,
      maxPages,
      ...searchParams
    };
    return getManyMore(
      camelizeResponseBody,
      (ep, op) => service.requester.get(ep, { ...op, signal }),
      endpoint22,
      response,
      reqOpts
    );
  };
}
__name(get, "get");
function post() {
  return async (service, endpoint22, { searchParams, isForm, sudo, showExpanded, ...options } = {}) => {
    const body = isForm ? appendFormFromObject(options) : options;
    const response = await service.requester.post(endpoint22, {
      searchParams,
      body,
      sudo,
      signal: service.queryTimeout ? AbortSignal.timeout(service.queryTimeout) : void 0
    });
    if (service.camelize)
      response.body = (0, import_xcase2.camelizeKeys)(response.body);
    return packageResponse(response, showExpanded);
  };
}
__name(post, "post");
function put() {
  return async (service, endpoint22, { searchParams, isForm, sudo, showExpanded, ...options } = {}) => {
    const body = isForm ? appendFormFromObject(options) : options;
    const response = await service.requester.put(endpoint22, {
      body,
      searchParams,
      sudo,
      signal: service.queryTimeout ? AbortSignal.timeout(service.queryTimeout) : void 0
    });
    if (service.camelize)
      response.body = (0, import_xcase2.camelizeKeys)(response.body);
    return packageResponse(response, showExpanded);
  };
}
__name(put, "put");
function patch() {
  return async (service, endpoint22, { searchParams, isForm, sudo, showExpanded, ...options } = {}) => {
    const body = isForm ? appendFormFromObject(options) : options;
    const response = await service.requester.patch(endpoint22, {
      body,
      searchParams,
      sudo,
      signal: service.queryTimeout ? AbortSignal.timeout(service.queryTimeout) : void 0
    });
    if (service.camelize)
      response.body = (0, import_xcase2.camelizeKeys)(response.body);
    return packageResponse(response, showExpanded);
  };
}
__name(patch, "patch");
function del() {
  return async (service, endpoint22, { sudo, showExpanded, searchParams, ...options } = {}) => {
    const response = await service.requester.delete(endpoint22, {
      body: options,
      searchParams,
      sudo,
      signal: service.queryTimeout ? AbortSignal.timeout(service.queryTimeout) : void 0
    });
    return packageResponse(response, showExpanded);
  };
}
__name(del, "del");
var RequestHelper = {
  post,
  put,
  patch,
  get,
  del
};
var Agents = class extends BaseResource {
  static {
    __name(this, "Agents");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/cluster_agents`,
      options
    );
  }
  allTokens(projectId, agentId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/cluster_agents/${agentId}/tokens`,
      options
    );
  }
  createToken(projectId, agentId, name2, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/cluster_agents/${agentId}/tokens`,
      {
        name: name2,
        ...options
      }
    );
  }
  show(projectId, agentId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/cluster_agents/${agentId}`,
      options
    );
  }
  showToken(projectId, agentId, tokenId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/cluster_agents/${agentId}/tokens/${tokenId}`,
      options
    );
  }
  register(projectId, name2, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/cluster_agents`,
      {
        name: name2,
        ...options
      }
    );
  }
  removeToken(projectId, agentId, tokenId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/cluster_agents/${agentId}/tokens/${tokenId}`,
      options
    );
  }
  unregister(projectId, agentId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/cluster_agents/${agentId}`,
      options
    );
  }
};
var AlertManagement = class extends BaseResource {
  static {
    __name(this, "AlertManagement");
  }
  allMetricImages(projectId, alertIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/alert_management_alerts/${alertIId}/metric_images`,
      options
    );
  }
  editMetricImage(projectId, alertIId, imageId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/alert_management_alerts/${alertIId}/metric_images/${imageId}`,
      options
    );
  }
  removeMetricImage(projectId, alertIId, imageId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/alert_management_alerts/${alertIId}/metric_images/${imageId}`,
      options
    );
  }
  uploadMetricImage(projectId, alertIId, metricImage, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/alert_management_alerts/${alertIId}/metric_images`,
      {
        isForm: true,
        file: [metricImage.content, metricImage.filename],
        ...options
      }
    );
  }
};
var ApplicationAppearance = class extends BaseResource {
  static {
    __name(this, "ApplicationAppearance");
  }
  show(options) {
    return RequestHelper.get()(
      this,
      "application/appearence",
      options
    );
  }
  edit({
    logo,
    pwaIcon,
    ...options
  } = {}) {
    if (logo || pwaIcon) {
      const opts = {
        ...options,
        isForm: true
      };
      if (logo)
        opts.logo = [logo.content, logo.filename];
      if (pwaIcon)
        opts.pwaIcon = [pwaIcon.content, pwaIcon.filename];
      return RequestHelper.put()(this, "application/appearence", opts);
    }
    return RequestHelper.put()(
      this,
      "application/appearence",
      options
    );
  }
};
var ApplicationPlanLimits = class extends BaseResource {
  static {
    __name(this, "ApplicationPlanLimits");
  }
  show(options) {
    return RequestHelper.get()(
      this,
      "application/plan_limits",
      options
    );
  }
  edit(planName, options = {}) {
    const {
      ciPipelineSize,
      ciActiveJobs,
      ciActivePipelines,
      ciProjectSubscriptions,
      ciPipelineSchedules,
      ciNeedsSizeLimit,
      ciRegisteredGroupRunners,
      ciRegisteredProjectRunners,
      conanMaxFileSize,
      genericPackagesMaxFileSize,
      helmMaxFileSize,
      mavenMaxFileSize,
      npmMaxFileSize,
      nugetMaxFileSize,
      pypiMaxFileSize,
      terraformModuleMaxFileSize,
      storageSizeLimit,
      ...opts
    } = options;
    return RequestHelper.put()(this, "application/plan_limits", {
      searchParams: {
        planName,
        ciPipelineSize,
        ciActiveJobs,
        ciActivePipelines,
        ciProjectSubscriptions,
        ciPipelineSchedules,
        ciNeedsSizeLimit,
        ciRegisteredGroupRunners,
        ciRegisteredProjectRunners,
        conanMaxFileSize,
        genericPackagesMaxFileSize,
        helmMaxFileSize,
        mavenMaxFileSize,
        npmMaxFileSize,
        nugetMaxFileSize,
        pypiMaxFileSize,
        terraformModuleMaxFileSize,
        storageSizeLimit
      },
      opts
    });
  }
};
var Applications = class extends BaseResource {
  static {
    __name(this, "Applications");
  }
  all(options) {
    return RequestHelper.get()(this, "applications", options);
  }
  create(name2, redirectUri, scopes, options) {
    return RequestHelper.post()(this, "applications", {
      name: name2,
      redirectUri,
      scopes,
      ...options
    });
  }
  remove(applicationId, options) {
    return RequestHelper.del()(this, `applications/${applicationId}`, options);
  }
};
var ApplicationSettings = class extends BaseResource {
  static {
    __name(this, "ApplicationSettings");
  }
  show(options) {
    return RequestHelper.get()(this, "application/settings", options);
  }
  edit(options) {
    return RequestHelper.put()(this, "application/settings", options);
  }
};
var ApplicationStatistics = class extends BaseResource {
  static {
    __name(this, "ApplicationStatistics");
  }
  show(options) {
    return RequestHelper.get()(this, "application/statistics", options);
  }
};
function url({
  projectId,
  groupId
} = {}) {
  let prefix = "";
  if (projectId)
    prefix = endpoint`projects/${projectId}/`;
  else if (groupId)
    prefix = endpoint`groups/${groupId}/`;
  return `${prefix}audit_events`;
}
__name(url, "url");
var AuditEvents = class extends BaseResource {
  static {
    __name(this, "AuditEvents");
  }
  all({
    projectId,
    groupId,
    ...options
  } = {}) {
    const uri = url({ projectId, groupId });
    return RequestHelper.get()(
      this,
      uri,
      options
    );
  }
  show(auditEventId, {
    projectId,
    groupId,
    ...options
  } = {}) {
    const uri = url({ projectId, groupId });
    return RequestHelper.get()(this, `${uri}/${auditEventId}`, options);
  }
};
var Avatar = class extends BaseResource {
  static {
    __name(this, "Avatar");
  }
  show(email, options) {
    return RequestHelper.get()(this, "avatar", { email, ...options });
  }
};
var BroadcastMessages = class extends BaseResource {
  static {
    __name(this, "BroadcastMessages");
  }
  all(options) {
    return RequestHelper.get()(this, "broadcast_messages", options);
  }
  create(options) {
    return RequestHelper.post()(this, "broadcast_messages", options);
  }
  edit(broadcastMessageId, options) {
    return RequestHelper.put()(
      this,
      `broadcast_messages/${broadcastMessageId}`,
      options
    );
  }
  remove(broadcastMessageId, options) {
    return RequestHelper.del()(this, `broadcast_messages/${broadcastMessageId}`, options);
  }
  show(broadcastMessageId, options) {
    return RequestHelper.get()(
      this,
      `broadcast_messages/${broadcastMessageId}`,
      options
    );
  }
};
var Composer = class extends BaseResource {
  static {
    __name(this, "Composer");
  }
  create(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/packages/composer`,
      options
    );
  }
  download(projectId, packageName, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/composer/archives/${packageName}`,
      {
        searchParams: { sha },
        ...options
      }
    );
  }
  showMetadata(groupId, packageName, options) {
    let url12;
    if (options && options.sha) {
      url12 = endpoint`groups/${groupId}/-/packages/composer/${packageName}$${options.sha}`;
    } else {
      url12 = endpoint`groups/${groupId}/-/packages/composer/p2/${packageName}`;
    }
    return RequestHelper.get()(this, url12, options);
  }
  showPackages(groupId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/-/packages/composer/p/${sha}`,
      options
    );
  }
  showBaseRepository(groupId, options) {
    const clonedService = { ...this };
    if (options && options.composerVersion === "2") {
      clonedService.headers["User-Agent"] = "Composer/2";
    }
    return RequestHelper.get()(
      clonedService,
      endpoint`groups/${groupId}/-/packages/composer/packages`,
      options
    );
  }
};
function url2(projectId) {
  return projectId ? endpoint`projects/${projectId}/packages/conan/v1` : "packages/conan/v1";
}
__name(url2, "url2");
var Conan = class extends BaseResource {
  static {
    __name(this, "Conan");
  }
  authenticate({
    projectId,
    ...options
  } = {}) {
    return RequestHelper.get()(this, `${url2(projectId)}/users/authenticate`, options);
  }
  checkCredentials({
    projectId,
    ...options
  } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(this, `${prefix}/users/check_credentials`, options);
  }
  downloadPackageFile(packageName, packageVersion, packageUsername, packageChannel, conanPackageReference, recipeRevision, packageRevision, filename, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/${recipeRevision}/package/${conanPackageReference}/${packageRevision}/${filename}`,
      options
    );
  }
  downloadRecipeFile(packageName, packageVersion, packageUsername, packageChannel, recipeRevision, filename, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/${recipeRevision}/export/${filename}`,
      options
    );
  }
  showPackageUploadUrls(packageName, packageVersion, packageUsername, packageChannel, conanPackageReference, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/packages/${conanPackageReference}/upload_urls`,
      options
    );
  }
  showPackageDownloadUrls(packageName, packageVersion, packageUsername, packageChannel, conanPackageReference, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/packages/${conanPackageReference}/download_urls`,
      options
    );
  }
  showPackageManifest(packageName, packageVersion, packageUsername, packageChannel, conanPackageReference, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/packages/${conanPackageReference}/digest`,
      options
    );
  }
  showPackageSnapshot(packageName, packageVersion, packageUsername, packageChannel, conanPackageReference, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/packages/${conanPackageReference}`,
      options
    );
  }
  ping({
    projectId,
    ...options
  } = {}) {
    return RequestHelper.post()(this, `${url2(projectId)}/ping`, options);
  }
  showRecipeUploadUrls(packageName, packageVersion, packageUsername, packageChannel, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/upload_urls`,
      options
    );
  }
  showRecipeDownloadUrls(packageName, packageVersion, packageUsername, packageChannel, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/download_urls`,
      options
    );
  }
  showRecipeManifest(packageName, packageVersion, packageUsername, packageChannel, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/digest`,
      options
    );
  }
  showRecipeSnapshot(packageName, packageVersion, packageUsername, packageChannel, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}`,
      options
    );
  }
  removePackageFile(packageName, packageVersion, packageUsername, packageChannel, { projectId, ...options } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/conans/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}`,
      options
    );
  }
  search({
    projectId,
    ...options
  } = {}) {
    const prefix = url2(projectId);
    return RequestHelper.get()(this, `${prefix}/conans/search`, options);
  }
  uploadPackageFile(packageFile, packageName, packageVersion, packageUsername, packageChannel, conanPackageReference, recipeRevision, packageRevision, options) {
    const prefix = url2();
    return RequestHelper.get()(
      this,
      `${prefix}/files/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/${recipeRevision}/package/${conanPackageReference}/${packageRevision}/${packageFile.filename}`,
      {
        isForm: true,
        ...options,
        file: [packageFile.content, packageFile.filename]
      }
    );
  }
  uploadRecipeFile(packageFile, packageName, packageVersion, packageUsername, packageChannel, recipeRevision, options) {
    const prefix = url2();
    return RequestHelper.get()(
      this,
      `${prefix}/files/${packageName}/${packageVersion}/${packageUsername}/${packageChannel}/${recipeRevision}/export/${packageFile.filename}`,
      {
        isForm: true,
        ...options,
        file: [packageFile.content, packageFile.filename]
      }
    );
  }
};
var DashboardAnnotations = class extends BaseResource {
  static {
    __name(this, "DashboardAnnotations");
  }
  create(dashboardPath, startingAt, description, {
    environmentId,
    clusterId,
    ...options
  } = {}) {
    let url12;
    if (environmentId)
      url12 = endpoint`environments/${environmentId}/metrics_dashboard/annotations`;
    else if (clusterId)
      url12 = endpoint`clusters/${clusterId}/metrics_dashboard/annotations`;
    else
      throw new Error(
        "Missing required argument. Please supply a environmentId or a cluserId in the options parameter."
      );
    return RequestHelper.post()(this, url12, {
      dashboardPath,
      startingAt,
      description,
      ...options
    });
  }
};
function url3({
  projectId,
  groupId
} = {}) {
  if (projectId)
    return endpoint`/projects/${projectId}/packages/debian`;
  if (groupId)
    return endpoint`/groups/${groupId}/-/packages/debian`;
  throw new Error(
    "Missing required argument. Please supply a projectId or a groupId in the options parameter"
  );
}
__name(url3, "url3");
var Debian = class extends BaseResource {
  static {
    __name(this, "Debian");
  }
  downloadBinaryFileIndex(distribution, component, architecture, {
    projectId,
    groupId,
    ...options
  }) {
    const prefix = url3({
      projectId,
      groupId
    });
    return RequestHelper.get()(
      this,
      `${prefix}/dists/${distribution}/${component}/binary-${architecture}/Packages`,
      options
    );
  }
  downloadDistributionReleaseFile(distribution, {
    projectId,
    groupId,
    ...options
  }) {
    const prefix = url3({
      projectId,
      groupId
    });
    return RequestHelper.get()(
      this,
      `${prefix}/dists/${distribution}/Release`,
      options
    );
  }
  downloadSignedDistributionReleaseFile(distribution, {
    projectId,
    groupId,
    ...options
  }) {
    const prefix = url3({
      projectId,
      groupId
    });
    return RequestHelper.get()(
      this,
      `${prefix}/dists/${distribution}/InRelease`,
      options
    );
  }
  downloadReleaseFileSignature(distribution, {
    projectId,
    groupId,
    ...options
  }) {
    const prefix = url3({
      projectId,
      groupId
    });
    return RequestHelper.get()(
      this,
      `${prefix}/dists/${distribution}/Release.gpg`,
      options
    );
  }
  downloadPackageFile(projectId, distribution, letter, packageName, packageVersion, filename, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/debian/pool/${distribution}/${letter}/${packageName}/${packageVersion}/${filename}`,
      options
    );
  }
  uploadPackageFile(projectId, packageFile, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/packages/debian/${packageFile.filename}`,
      {
        isForm: true,
        ...options,
        file: [packageFile.content, packageFile.filename]
      }
    );
  }
};
var DependencyProxy = class extends BaseResource {
  static {
    __name(this, "DependencyProxy");
  }
  remove(groupId, options) {
    return RequestHelper.post()(this, `groups/${groupId}/dependency_proxy/cache`, options);
  }
};
var DeployKeys = class extends BaseResource {
  static {
    __name(this, "DeployKeys");
  }
  all({
    projectId,
    userId,
    ...options
  } = {}) {
    let url12;
    if (projectId) {
      url12 = endpoint`projects/${projectId}/deploy_keys`;
    } else if (userId) {
      url12 = endpoint`users/${userId}/project_deploy_keys`;
    } else {
      url12 = "deploy_keys";
    }
    return RequestHelper.get()(this, url12, options);
  }
  create(projectId, title, key, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/deploy_keys`,
      {
        title,
        key,
        ...options
      }
    );
  }
  edit(projectId, keyId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/deploy_keys/${keyId}`,
      options
    );
  }
  enable(projectId, keyId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/deploy_keys/${keyId}/enable`,
      options
    );
  }
  remove(projectId, keyId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/deploy_keys/${keyId}`, options);
  }
  show(projectId, keyId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/deploy_keys/${keyId}`,
      options
    );
  }
};
var DeployTokens = class extends BaseResource {
  static {
    __name(this, "DeployTokens");
  }
  all({
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/deploy_tokens`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/deploy_tokens`;
    else
      url12 = "deploy_tokens";
    return RequestHelper.get()(this, url12, options);
  }
  create(name2, scopes, {
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/deploy_tokens`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/deploy_tokens`;
    else {
      throw new Error(
        "Missing required argument. Please supply a projectId or a groupId in the options parameter."
      );
    }
    return RequestHelper.post()(this, url12, {
      name: name2,
      scopes,
      ...options
    });
  }
  remove(tokenId, {
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/deploy_tokens/${tokenId}`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/deploy_tokens/${tokenId}`;
    else {
      throw new Error(
        "Missing required argument. Please supply a projectId or a groupId in the options parameter."
      );
    }
    return RequestHelper.del()(this, url12, options);
  }
  show(tokenId, {
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/deploy_tokens/${tokenId}`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/deploy_tokens/${tokenId}`;
    else {
      throw new Error(
        "Missing required argument. Please supply a projectId or a groupId in the options parameter."
      );
    }
    return RequestHelper.get()(
      this,
      url12,
      options
    );
  }
};
var ResourceAccessRequests = class extends BaseResource {
  static {
    __name(this, "ResourceAccessRequests");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/access_requests`,
      options
    );
  }
  request(resourceId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/access_requests`,
      options
    );
  }
  approve(resourceId, userId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/access_requests/${userId}/approve`,
      options
    );
  }
  deny(resourceId, userId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/access_requests/${userId}`, options);
  }
};
var ResourceAccessTokens = class extends BaseResource {
  static {
    __name(this, "ResourceAccessTokens");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/access_tokens`,
      options
    );
  }
  create(resourceId, name2, scopes, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/access_tokens`, {
      name: name2,
      scopes,
      ...options
    });
  }
  revoke(resourceId, tokenId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/access_tokens/${tokenId}`, options);
  }
  show(resourceId, tokenId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/access_tokens/${tokenId}`,
      options
    );
  }
};
function url4(resourceId, resourceType2, resourceId2, awardId) {
  const [rId, rId2] = [resourceId, resourceId2].map(encodeURIComponent);
  const output = [rId, resourceType2, rId2];
  output.push("award_emoji");
  if (awardId)
    output.push(awardId);
  return output.join("/");
}
__name(url4, "url4");
var ResourceAwardEmojis = class extends BaseResource {
  static {
    __name(this, "ResourceAwardEmojis");
  }
  resourceType2;
  constructor(resourceType1, resourceType2, options) {
    super({ prefixUrl: resourceType1, ...options });
    this.resourceType2 = resourceType2;
  }
  all(resourceId, resourceIId, options) {
    return RequestHelper.get()(
      this,
      url4(resourceId, this.resourceType2, resourceIId),
      options
    );
  }
  award(resourceId, resourceIId, name2, options) {
    return RequestHelper.post()(
      this,
      url4(resourceId, this.resourceType2, resourceIId),
      {
        name: name2,
        ...options
      }
    );
  }
  remove(resourceId, resourceIId, awardId, options) {
    return RequestHelper.del()(
      this,
      url4(resourceId, this.resourceType2, resourceIId, awardId),
      options
    );
  }
  show(resourceId, resourceIId, awardId, options) {
    return RequestHelper.get()(
      this,
      url4(resourceId, this.resourceType2, resourceIId, awardId),
      options
    );
  }
};
function url5(resourceId, resourceType2, resourceId2, noteId, awardId) {
  const [rId, rId2] = [resourceId, resourceId2].map(encodeURIComponent);
  const output = [rId, resourceType2, rId2];
  output.push("notes");
  output.push(noteId);
  output.push("award_emoji");
  if (awardId)
    output.push(awardId);
  return output.join("/");
}
__name(url5, "url5");
var ResourceNoteAwardEmojis = class extends BaseResource {
  static {
    __name(this, "ResourceNoteAwardEmojis");
  }
  resourceType;
  constructor(resourceType, options) {
    super({ prefixUrl: "projects", ...options });
    this.resourceType = resourceType;
  }
  all(projectId, resourceIId, noteId, options) {
    return RequestHelper.get()(
      this,
      url5(projectId, this.resourceType, resourceIId, noteId),
      options
    );
  }
  award(projectId, resourceIId, noteId, name2, options) {
    return RequestHelper.post()(
      this,
      url5(projectId, this.resourceType, resourceIId, noteId),
      {
        name: name2,
        ...options
      }
    );
  }
  remove(projectId, resourceIId, noteId, awardId, options) {
    return RequestHelper.del()(
      this,
      url5(projectId, this.resourceType, resourceIId, noteId, awardId),
      options
    );
  }
  show(projectId, resourceIId, noteId, awardId, options) {
    return RequestHelper.get()(
      this,
      url5(projectId, this.resourceType, resourceIId, noteId, awardId),
      options
    );
  }
};
var ResourceBadges = class extends BaseResource {
  static {
    __name(this, "ResourceBadges");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  add(resourceId, linkUrl, imageUrl, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/badges`, {
      linkUrl,
      imageUrl,
      ...options
    });
  }
  all(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/badges`, options);
  }
  edit(resourceId, badgeId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/badges/${badgeId}`,
      options
    );
  }
  preview(resourceId, linkUrl, imageUrl, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/badges/render`, {
      linkUrl,
      imageUrl,
      ...options
    });
  }
  remove(resourceId, badgeId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/badges/${badgeId}`, options);
  }
  show(resourceId, badgeId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/badges/${badgeId}`,
      options
    );
  }
};
var ResourceCustomAttributes = class extends BaseResource {
  static {
    __name(this, "ResourceCustomAttributes");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/custom_attributes`,
      options
    );
  }
  remove(resourceId, customAttributeId, options) {
    return RequestHelper.del()(
      this,
      endpoint`${resourceId}/custom_attributes/${customAttributeId}`,
      options
    );
  }
  set(resourceId, customAttributeId, value, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/custom_attributes/${customAttributeId}`,
      {
        value,
        ...options
      }
    );
  }
  show(resourceId, customAttributeId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/custom_attributes/${customAttributeId}`,
      options
    );
  }
};
var ResourceDORA4Metrics = class extends BaseResource {
  static {
    __name(this, "ResourceDORA4Metrics");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, metric, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/dora/metrics`, {
      metric,
      ...options
    });
  }
};
var ResourceDiscussions = class extends BaseResource {
  static {
    __name(this, "ResourceDiscussions");
  }
  resource2Type;
  constructor(resourceType, resource2Type, options) {
    super({ prefixUrl: resourceType, ...options });
    this.resource2Type = resource2Type;
  }
  addNote(resourceId, resource2Id, discussionId, noteId, body, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/discussions/${discussionId}/notes`,
      { searchParams: { body }, noteId, ...options }
    );
  }
  all(resourceId, resource2Id, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/discussions`,
      options
    );
  }
  create(resourceId, resource2Id, body, {
    position,
    ...options
  } = {}) {
    const opts = { ...options };
    if (position) {
      Object.assign(opts, reformatObjectOptions(position, "position", true));
      opts.isForm = true;
      opts.body = body;
    } else {
      opts.searchParams = { body };
    }
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/discussions`,
      opts
    );
  }
  editNote(resourceId, resource2Id, discussionId, noteId, { body, ...options } = {}) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/discussions/${discussionId}/notes/${noteId}`,
      {
        searchParams: { body },
        ...options
      }
    );
  }
  removeNote(resourceId, resource2Id, discussionId, noteId, options) {
    return RequestHelper.del()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/discussions/${discussionId}/notes/${noteId}`,
      options
    );
  }
  show(resourceId, resource2Id, discussionId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/discussions/${discussionId}`,
      options
    );
  }
};
var ResourceIssueBoards = class extends BaseResource {
  static {
    __name(this, "ResourceIssueBoards");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/boards`, options);
  }
  allLists(resourceId, boardId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/boards/${boardId}/lists`,
      options
    );
  }
  create(resourceId, name2, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/boards`, {
      name: name2,
      ...options
    });
  }
  createList(resourceId, boardId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/boards/${boardId}/lists`,
      options
    );
  }
  edit(resourceId, boardId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/boards/${boardId}`,
      options
    );
  }
  editList(resourceId, boardId, listId, position, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/boards/${boardId}/lists/${listId}`,
      {
        position,
        ...options
      }
    );
  }
  remove(resourceId, boardId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/boards/${boardId}`, options);
  }
  removeList(resourceId, boardId, listId, options) {
    return RequestHelper.del()(
      this,
      endpoint`${resourceId}/boards/${boardId}/lists/${listId}`,
      options
    );
  }
  show(resourceId, boardId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/boards/${boardId}`,
      options
    );
  }
  showList(resourceId, boardId, listId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/boards/${boardId}/lists/${listId}`,
      options
    );
  }
};
var ResourceLabels = class extends BaseResource {
  static {
    __name(this, "ResourceLabels");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/labels`, options);
  }
  create(resourceId, labelName, color, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/labels`, {
      name: labelName,
      color,
      ...options
    });
  }
  edit(resourceId, labelId, options) {
    if (!options?.newName && !options?.color)
      throw new Error(
        "Missing required argument. Please supply a color or a newName in the options parameter."
      );
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/labels/${labelId}`,
      options
    );
  }
  promote(resourceId, labelId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/labels/${labelId}/promote`,
      options
    );
  }
  remove(resourceId, labelId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/labels/${labelId}`, options);
  }
  show(resourceId, labelId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/labels/${labelId}`,
      options
    );
  }
  subscribe(resourceId, labelId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/issues/${labelId}/subscribe`,
      options
    );
  }
  unsubscribe(resourceId, labelId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/issues/${labelId}/unsubscribe`,
      options
    );
  }
};
var ResourceMembers = class extends BaseResource {
  static {
    __name(this, "ResourceMembers");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  add(resourceId, userId, accessLevel, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/members`, {
      userId: String(userId),
      accessLevel,
      ...options
    });
  }
  all(resourceId, {
    includeInherited,
    ...options
  } = {}) {
    let url12 = endpoint`${resourceId}/members`;
    if (includeInherited)
      url12 += "/all";
    return RequestHelper.get()(this, url12, options);
  }
  edit(resourceId, userId, accessLevel, options) {
    return RequestHelper.put()(this, endpoint`${resourceId}/members/${userId}`, {
      accessLevel,
      ...options
    });
  }
  show(resourceId, userId, { includeInherited, ...options } = {}) {
    const [rId, uId] = [resourceId, userId].map(encodeURIComponent);
    const url12 = [rId, "members"];
    if (includeInherited)
      url12.push("all");
    url12.push(uId);
    return RequestHelper.get()(this, url12.join("/"), options);
  }
  remove(resourceId, userId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/members/${userId}`, options);
  }
};
var ResourceMilestones = class extends BaseResource {
  static {
    __name(this, "ResourceMilestones");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/milestones`,
      options
    );
  }
  allAssignedIssues(resourceId, milestoneId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/milestones/${milestoneId}/issues`,
      options
    );
  }
  allAssignedMergeRequests(resourceId, milestoneId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/milestones/${milestoneId}/merge_requests`,
      options
    );
  }
  allBurndownChartEvents(resourceId, milestoneId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/milestones/${milestoneId}/burndown_events`,
      options
    );
  }
  create(resourceId, title, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/milestones`, {
      title,
      ...options
    });
  }
  edit(resourceId, milestoneId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/milestones/${milestoneId}`,
      options
    );
  }
  remove(resourceId, milestoneId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/milestones/${milestoneId}`, options);
  }
  show(resourceId, milestoneId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/milestones/${milestoneId}`,
      options
    );
  }
};
var ResourceNotes = class extends BaseResource {
  static {
    __name(this, "ResourceNotes");
  }
  resource2Type;
  constructor(resourceType, resource2Type, options) {
    super({ prefixUrl: resourceType, ...options });
    this.resource2Type = resource2Type;
  }
  all(resourceId, resource2Id, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/notes`,
      options
    );
  }
  create(resourceId, resource2Id, body, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/notes`,
      {
        body,
        ...options
      }
    );
  }
  edit(resourceId, resource2Id, noteId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/notes/${noteId}`,
      options
    );
  }
  remove(resourceId, resource2Id, noteId, options) {
    return RequestHelper.del()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/notes/${noteId}`,
      options
    );
  }
  show(resourceId, resource2Id, noteId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/notes/${noteId}`,
      options
    );
  }
};
var ResourceTemplates = class extends BaseResource {
  static {
    __name(this, "ResourceTemplates");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: ["templates", resourceType].join("/"), ...options });
  }
  all(options) {
    process.emitWarning(
      'This API will be deprecated as of Gitlabs v5 API. Please make the switch to "ProjectTemplates".',
      "DeprecationWarning"
    );
    return RequestHelper.get()(this, "", options);
  }
  show(key, options) {
    process.emitWarning(
      'This API will be deprecated as of Gitlabs v5 API. Please make the switch to "ProjectTemplates".',
      "DeprecationWarning"
    );
    return RequestHelper.get()(this, encodeURIComponent(key), options);
  }
};
var ResourceVariables = class extends BaseResource {
  static {
    __name(this, "ResourceVariables");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/variables`, options);
  }
  create(resourceId, key, value, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/variables`, {
      key,
      value,
      ...options
    });
  }
  edit(resourceId, key, value, options) {
    return RequestHelper.put()(this, endpoint`${resourceId}/variables/${key}`, {
      value,
      ...options
    });
  }
  show(resourceId, key, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/variables/${key}`,
      options
    );
  }
  remove(resourceId, key, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/variables/${key}`, options);
  }
};
var ResourceWikis = class extends BaseResource {
  static {
    __name(this, "ResourceWikis");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/wikis`, options);
  }
  create(resourceId, content, title, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/wikis`, {
      content,
      title,
      ...options
    });
  }
  edit(resourceId, slug, options) {
    return RequestHelper.put()(this, endpoint`${resourceId}/wikis/${slug}`, options);
  }
  remove(resourceId, slug, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/wikis/${slug}`, options);
  }
  show(resourceId, slug, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/wikis/${slug}`, options);
  }
  uploadAttachment(resourceId, file, options) {
    return RequestHelper.post()(
      this,
      endpoint`${resourceId}/wikis/attachments`,
      {
        ...options,
        isForm: true,
        file: [file.content, file.filename]
      }
    );
  }
};
var ResourceHooks = class extends BaseResource {
  static {
    __name(this, "ResourceHooks");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  add(resourceId, url12, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/hooks`, {
      url: url12,
      ...options
    });
  }
  all(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/hooks`, options);
  }
  edit(resourceId, hookId, url12, options) {
    return RequestHelper.put()(this, endpoint`${resourceId}/hooks/${hookId}`, {
      url: url12,
      ...options
    });
  }
  remove(resourceId, hookId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/hooks/${hookId}`, options);
  }
  show(resourceId, hookId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/hooks/${hookId}`,
      options
    );
  }
};
var ResourcePushRules = class extends BaseResource {
  static {
    __name(this, "ResourcePushRules");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  create(resourceId, options) {
    return RequestHelper.post()(this, endpoint`${resourceId}/push_rule`, options);
  }
  edit(resourceId, options) {
    return RequestHelper.put()(this, endpoint`${resourceId}/push_rule`, options);
  }
  remove(resourceId, options) {
    return RequestHelper.del()(this, endpoint`${resourceId}/push_rule`, options);
  }
  show(resourceId, options) {
    return RequestHelper.get()(this, endpoint`${resourceId}/push_rule`, options);
  }
};
var ResourceRepositoryStorageMoves = class extends BaseResource {
  static {
    __name(this, "ResourceRepositoryStorageMoves");
  }
  resourceType;
  resourceTypeSingular;
  constructor(resourceType, options) {
    super(options);
    this.resourceType = resourceType;
    this.resourceTypeSingular = resourceType.substring(0, resourceType.length - 1);
  }
  all(options) {
    const resourceId = options?.[`${this.resourceTypeSingular}Id`];
    const url12 = resourceId ? endpoint`${this.resourceType}/${resourceId}/repository_storage_moves` : `${this.resourceTypeSingular}_repository_storage_moves`;
    return RequestHelper.get()(this, url12, options);
  }
  show(repositoryStorageId, options) {
    const resourceId = options?.[`${this.resourceTypeSingular}Id`];
    const url12 = resourceId ? endpoint`${this.resourceType}/${resourceId}/repository_storage_moves` : `${this.resourceTypeSingular}_repository_storage_moves`;
    return RequestHelper.get()(
      this,
      `${url12}/${repositoryStorageId}`,
      options
    );
  }
  schedule(sourceStorageName, options) {
    const resourceId = options?.[`${this.resourceTypeSingular}Id`];
    const url12 = resourceId ? endpoint`${this.resourceType}/${resourceId}/repository_storage_moves` : `${this.resourceTypeSingular}_repository_storage_moves`;
    return RequestHelper.post()(this, url12, {
      sourceStorageName,
      ...options
    });
  }
};
var ResourceInvitations = class extends BaseResource {
  static {
    __name(this, "ResourceInvitations");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  add(resourceId, accessLevel, options) {
    if (!options?.email && !options?.userId)
      throw new Error(
        "Missing required argument. Please supply a email or a userId in the options parameter."
      );
    return RequestHelper.post()(this, endpoint`${resourceId}/invitations`, {
      accessLevel,
      ...options
    });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/invitations`,
      options
    );
  }
  edit(resourceId, email, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/invitations/${email}`,
      options
    );
  }
  remove(resourceId, email, options) {
    return RequestHelper.put()(
      this,
      endpoint`${resourceId}/invitations/${email}`,
      options
    );
  }
};
var ResourceIterations = class extends BaseResource {
  static {
    __name(this, "ResourceIterations");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/iterations`,
      options
    );
  }
};
var ResourceProtectedEnvironments = class extends BaseResource {
  static {
    __name(this, "ResourceProtectedEnvironments");
  }
  constructor(resourceType, options) {
    super({ prefixUrl: resourceType, ...options });
  }
  all(resourceId, options) {
    return RequestHelper.get()(
      this,
      `${resourceId}/protected_environments`,
      options
    );
  }
  create(resourceId, name2, deployAccessLevel, options) {
    return RequestHelper.post()(
      this,
      `${resourceId}/protected_environments`,
      {
        name: name2,
        deployAccessLevel,
        ...options
      }
    );
  }
  edit(resourceId, name2, options) {
    return RequestHelper.put()(
      this,
      `${resourceId}/protected_environments/${name2}`,
      options
    );
  }
  show(resourceId, name2, options) {
    return RequestHelper.get()(
      this,
      `${resourceId}/protected_environments/${name2}`,
      options
    );
  }
  remove(resourceId, name2, options) {
    return RequestHelper.del()(this, `${resourceId}/protected_environments/${name2}`, options);
  }
};
var ResourceIterationEvents = class extends BaseResource {
  static {
    __name(this, "ResourceIterationEvents");
  }
  resource2Type;
  constructor(resourceType, resource2Type, options) {
    super({ prefixUrl: resourceType, ...options });
    this.resource2Type = resource2Type;
  }
  all(resourceId, resource2Id, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_iteration_events`,
      options
    );
  }
  show(resourceId, resource2Id, iterationEventId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_iteration_events/${iterationEventId}`,
      options
    );
  }
};
var ResourceLabelEvents = class extends BaseResource {
  static {
    __name(this, "ResourceLabelEvents");
  }
  resource2Type;
  constructor(resourceType, resource2Type, options) {
    super({ prefixUrl: resourceType, ...options });
    this.resource2Type = resource2Type;
  }
  all(resourceId, resource2Id, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_label_events`,
      options
    );
  }
  show(resourceId, resource2Id, labelEventId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_label_events/${labelEventId}`,
      options
    );
  }
};
var ResourceMilestoneEvents = class extends BaseResource {
  static {
    __name(this, "ResourceMilestoneEvents");
  }
  resource2Type;
  constructor(resourceType, resource2Type, options) {
    super({ prefixUrl: resourceType, ...options });
    this.resource2Type = resource2Type;
  }
  all(resourceId, resource2Id, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_milestone_events`,
      options
    );
  }
  show(resourceId, resource2Id, milestoneEventId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_milestone_events/${milestoneEventId}`,
      options
    );
  }
};
var ResourceStateEvents = class extends BaseResource {
  static {
    __name(this, "ResourceStateEvents");
  }
  resource2Type;
  constructor(resourceType, resource2Type, options) {
    super({ prefixUrl: resourceType, ...options });
    this.resource2Type = resource2Type;
  }
  all(resourceId, resource2Id, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_state_events`,
      options
    );
  }
  show(resourceId, resource2Id, stateEventId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${resourceId}/${this.resource2Type}/${resource2Id}/resource_state_events/${stateEventId}`,
      options
    );
  }
};
var DockerfileTemplates = class extends ResourceTemplates {
  static {
    __name(this, "DockerfileTemplates");
  }
  constructor(options) {
    super("dockerfiles", options);
  }
};
var Events = class extends BaseResource {
  static {
    __name(this, "Events");
  }
  all({
    projectId,
    userId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/events`;
    else if (userId)
      url12 = endpoint`users/${userId}/events`;
    else
      url12 = "events";
    return RequestHelper.get()(this, url12, options);
  }
};
var Experiments = class extends BaseResource {
  static {
    __name(this, "Experiments");
  }
  all(options) {
    return RequestHelper.get()(this, "experiments", options);
  }
};
var GeoNodes = class extends BaseResource {
  static {
    __name(this, "GeoNodes");
  }
  all(options) {
    return RequestHelper.get()(this, "geo_nodes", options);
  }
  allStatuses(options) {
    return RequestHelper.get()(this, "geo_nodes/statuses", options);
  }
  allFailures(options) {
    return RequestHelper.get()(this, "geo_nodes/current/failures", options);
  }
  create(name2, url12, options) {
    return RequestHelper.post()(this, "geo_nodes", { name: name2, url: url12, ...options });
  }
  edit(geonodeId, options) {
    return RequestHelper.put()(this, `geo_nodes/${geonodeId}`, options);
  }
  repair(geonodeId, options) {
    return RequestHelper.post()(this, `geo_nodes/${geonodeId}/repair`, options);
  }
  remove(geonodeId, options) {
    return RequestHelper.del()(this, `geo_nodes/${geonodeId}`, options);
  }
  show(geonodeId, options) {
    return RequestHelper.get()(this, `geo_nodes/${geonodeId}`, options);
  }
  showStatus(geonodeId, options) {
    return RequestHelper.get()(this, `geo_nodes/${geonodeId}/status`, options);
  }
};
var GitignoreTemplates = class extends ResourceTemplates {
  static {
    __name(this, "GitignoreTemplates");
  }
  constructor(options) {
    super("gitignores", options);
  }
};
var GitLabCIYMLTemplates = class extends ResourceTemplates {
  static {
    __name(this, "GitLabCIYMLTemplates");
  }
  constructor(options) {
    super("gitlab_ci_ymls", options);
  }
};
var Import = class extends BaseResource {
  static {
    __name(this, "Import");
  }
  importGithubRepository(personalAccessToken, repositoryId, targetNamespace, options) {
    return RequestHelper.post()(this, "import/github", {
      personalAccessToken,
      repoId: repositoryId,
      targetNamespace,
      ...options
    });
  }
  cancelGithubRepositoryImport(projectId, options) {
    return RequestHelper.post()(this, "import/github/cancel", {
      projectId,
      ...options
    });
  }
  importGithubGists(personalAccessToken, options) {
    return RequestHelper.post()(this, "import/github/gists", {
      personalAccessToken,
      ...options
    });
  }
  importBitbucketServerRepository(bitbucketServerUrl, bitbucketServerUsername, personalAccessToken, bitbucketServerProject, bitbucketServerRepository, options) {
    return RequestHelper.post()(this, "import/bitbucket_server", {
      bitbucketServerUrl,
      bitbucketServerUsername,
      personalAccessToken,
      bitbucketServerProject,
      bitbucketServerRepo: bitbucketServerRepository,
      ...options
    });
  }
};
var InstanceLevelCICDVariables = class extends BaseResource {
  static {
    __name(this, "InstanceLevelCICDVariables");
  }
  all(options) {
    return RequestHelper.get()(this, "admin/ci/variables", options);
  }
  create(key, value, options) {
    return RequestHelper.post()(this, "admin/ci/variables", {
      key,
      value,
      ...options
    });
  }
  edit(keyId, value, options) {
    return RequestHelper.put()(this, endpoint`admin/ci/variables/${keyId}`, {
      value,
      ...options
    });
  }
  show(keyId, options) {
    return RequestHelper.get()(
      this,
      endpoint`admin/ci/variables/${keyId}`,
      options
    );
  }
  remove(keyId, options) {
    return RequestHelper.get()(this, endpoint`admin/ci/variables/${keyId}`, options);
  }
};
var Keys = class extends BaseResource {
  static {
    __name(this, "Keys");
  }
  show({
    keyId,
    fingerprint,
    ...options
  } = {}) {
    let url12;
    if (keyId)
      url12 = `keys/${keyId}`;
    else if (fingerprint)
      url12 = `keys?fingerprint=${fingerprint}`;
    else {
      throw new Error(
        "Missing required argument. Please supply a fingerprint or a keyId in the options parameter"
      );
    }
    return RequestHelper.get()(this, url12, options);
  }
};
var License = class extends BaseResource {
  static {
    __name(this, "License");
  }
  add(license, options) {
    return RequestHelper.post()(this, "license", {
      searchParams: { license },
      ...options
    });
  }
  all(options) {
    return RequestHelper.get()(this, "licenses", options);
  }
  show(options) {
    return RequestHelper.get()(this, "license", options);
  }
  remove(licenceId, options) {
    return RequestHelper.del()(this, `license/${licenceId}`, options);
  }
  recalculateBillableUsers(licenceId, options) {
    return RequestHelper.put()(
      this,
      `license/${licenceId}/refresh_billable_users`,
      options
    );
  }
};
var LicenseTemplates = class extends ResourceTemplates {
  static {
    __name(this, "LicenseTemplates");
  }
  constructor(options) {
    super("Licenses", options);
  }
};
var Lint = class extends BaseResource {
  static {
    __name(this, "Lint");
  }
  check(projectId, options) {
    return RequestHelper.get()(this, endpoint`projects/${projectId}/ci/lint`, options);
  }
  lint(projectId, content, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/ci/lint`, {
      ...options,
      content
    });
  }
};
var Markdown = class extends BaseResource {
  static {
    __name(this, "Markdown");
  }
  render(text2, options) {
    return RequestHelper.post()(this, "markdown", { text: text2, ...options });
  }
};
var Maven = class extends BaseResource {
  static {
    __name(this, "Maven");
  }
  downloadPackageFile(path, filename, {
    projectId,
    groupId,
    ...options
  }) {
    let url12 = endpoint`packages/maven/${path}/${filename}`;
    if (projectId)
      url12 = endpoint`projects/${projectId}/${url12}`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/-/${url12}`;
    return RequestHelper.get()(this, url12, options);
  }
  uploadPackageFile(projectId, path, packageFile, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/packages/maven/${path}/${packageFile.filename}`,
      {
        isForm: true,
        ...options,
        file: [packageFile.content, packageFile.filename]
      }
    );
  }
};
var Metadata = class extends BaseResource {
  static {
    __name(this, "Metadata");
  }
  show(options) {
    return RequestHelper.get()(this, "metadata", options);
  }
};
var Migrations = class extends BaseResource {
  static {
    __name(this, "Migrations");
  }
  all(options) {
    return RequestHelper.get()(this, "bulk_imports", options);
  }
  create(configuration, entities, options) {
    return RequestHelper.post()(this, "bulk_imports", {
      configuration,
      entities,
      ...options
    });
  }
  allEntities({
    bulkImportId,
    ...options
  } = {}) {
    const url12 = bulkImportId ? endpoint`bulk_imports/${bulkImportId}/entities` : "bulk_imports/entities";
    return RequestHelper.get()(this, url12, options);
  }
  show(bulkImportId, options) {
    return RequestHelper.get()(
      this,
      `bulk_imports/${bulkImportId}`,
      options
    );
  }
  showEntity(bulkImportId, entitityId, options) {
    return RequestHelper.get()(
      this,
      `bulk_imports/${bulkImportId}/entities/${entitityId}`,
      options
    );
  }
};
var Namespaces = class extends BaseResource {
  static {
    __name(this, "Namespaces");
  }
  all(options) {
    return RequestHelper.get()(this, "namespaces", options);
  }
  exists(namespaceId, options) {
    return RequestHelper.get()(
      this,
      endpoint`namespaces/${namespaceId}/exists`,
      options
    );
  }
  show(namespaceId, options) {
    return RequestHelper.get()(this, endpoint`namespaces/${namespaceId}`, options);
  }
};
function url6({
  projectId,
  groupId
} = {}) {
  let prefix = "";
  if (projectId)
    prefix = endpoint`projects/${projectId}/`;
  if (groupId)
    prefix = endpoint`groups/${groupId}/`;
  return `${prefix}notification_settings`;
}
__name(url6, "url6");
var NotificationSettings = class extends BaseResource {
  static {
    __name(this, "NotificationSettings");
  }
  edit({
    groupId,
    projectId,
    ...options
  } = {}) {
    const uri = url6({ groupId, projectId });
    return RequestHelper.put()(this, uri, options);
  }
  show({
    groupId,
    projectId,
    ...options
  } = {}) {
    const uri = url6({ groupId, projectId });
    return RequestHelper.get()(this, uri, options);
  }
};
function url7(projectId) {
  return projectId ? endpoint`/projects/${projectId}/packages/npm` : "packages/npm";
}
__name(url7, "url7");
var NPM = class extends BaseResource {
  static {
    __name(this, "NPM");
  }
  downloadPackageFile(projectId, packageName, filename, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/npm/${packageName}/-/${filename}`,
      options
    );
  }
  removeDistTag(packageName, tag, options) {
    const prefix = url7(options?.projectId);
    return RequestHelper.del()(
      this,
      `${prefix}/-/package/${packageName}/dist-tags/${tag}`,
      options
    );
  }
  setDistTag(packageName, tag, options) {
    const prefix = url7(options?.projectId);
    return RequestHelper.put()(
      this,
      `${prefix}/-/package/${packageName}/dist-tags/${tag}`,
      options
    );
  }
  showDistTags(packageName, options) {
    const prefix = url7(options?.projectId);
    return RequestHelper.get()(
      this,
      `${prefix}/-/package/${packageName}/dist-tags`,
      options
    );
  }
  showMetadata(packageName, options) {
    const prefix = url7(options?.projectId);
    return RequestHelper.get()(this, `${prefix}/${packageName}`, options);
  }
  uploadPackageFile(projectId, packageName, versions3, metadata2, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/packages/npm/${packageName}`,
      {
        ...options,
        versions: versions3,
        ...metadata2
      }
    );
  }
};
function url8({
  projectId,
  groupId
} = {}) {
  if (projectId)
    return endpoint`/projects/${projectId}/packages/nuget`;
  if (groupId)
    return endpoint`/groups/${groupId}/-/packages/nuget`;
  throw new Error(
    "Missing required argument. Please supply a projectId or a groupId in the options parameter"
  );
}
__name(url8, "url8");
var NuGet = class extends BaseResource {
  static {
    __name(this, "NuGet");
  }
  downloadPackageFile(projectId, packageName, packageVersion, filename, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/nuget/download/${packageName}/${packageVersion}/${filename}`,
      options
    );
  }
  search(q10, {
    projectId,
    groupId,
    ...options
  }) {
    const uri = url8({ projectId, groupId });
    return RequestHelper.get()(this, `${uri}/query`, { q: q10, ...options });
  }
  showMetadata(packageName, {
    projectId,
    groupId,
    ...options
  }) {
    const uri = url8({ projectId, groupId });
    return RequestHelper.get()(
      this,
      `${uri}/metadata/${packageName}/index`,
      options
    );
  }
  showPackageIndex(projectId, packageName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/nuget/download/${packageName}/index`,
      options
    );
  }
  showServiceIndex({
    projectId,
    groupId,
    ...options
  }) {
    const uri = url8({ projectId, groupId });
    return RequestHelper.get()(
      this,
      `${uri}/index`,
      options
    );
  }
  showVersionMetadata(packageName, packageVersion, {
    projectId,
    groupId,
    ...options
  }) {
    const uri = url8({ projectId, groupId });
    return RequestHelper.get()(
      this,
      `${uri}/metadata/${packageName}/${packageVersion}`,
      options
    );
  }
  uploadPackageFile(projectId, packageName, packageVersion, packageFile, options) {
    return RequestHelper.put()(this, endpoint`projects/${projectId}/packages/nuget`, {
      isForm: true,
      ...options,
      packageName,
      packageVersion,
      file: [packageFile.content, packageFile.filename]
    });
  }
  uploadSymbolPackage(projectId, packageName, packageVersion, packageFile, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/packages/nuget/symbolpackage`,
      {
        isForm: true,
        ...options,
        packageName,
        packageVersion,
        file: [packageFile.content, packageFile.filename]
      }
    );
  }
};
var PersonalAccessTokens = class extends BaseResource {
  static {
    __name(this, "PersonalAccessTokens");
  }
  all(options) {
    return RequestHelper.get()(
      this,
      "personal_access_tokens",
      options
    );
  }
  // Convience method - Also located in Users
  create(userId, name2, scopes, options) {
    return RequestHelper.post()(
      this,
      endpoint`users/${userId}/personal_access_tokens`,
      {
        name: name2,
        scopes,
        ...options
      }
    );
  }
  remove({
    tokenId,
    ...options
  } = {}) {
    const url12 = tokenId ? endpoint`personal_access_tokens/${tokenId}` : "personal_access_tokens/self";
    return RequestHelper.del()(this, url12, options);
  }
  show({
    tokenId,
    ...options
  } = {}) {
    const url12 = tokenId ? endpoint`personal_access_tokens/${tokenId}` : "personal_access_tokens/self";
    return RequestHelper.get()(this, url12, options);
  }
};
var PyPI = class extends BaseResource {
  static {
    __name(this, "PyPI");
  }
  downloadPackageFile(sha, fileIdentifier, {
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId) {
      url12 = endpoint`projects/${projectId}/packages/pypi/files/${sha}/${fileIdentifier}`;
    } else if (groupId) {
      url12 = endpoint`groups/${groupId}/packages/pypi/files/${sha}/${fileIdentifier}`;
    } else {
      throw new Error(
        "Missing required argument. Please supply a projectId or a groupId in the options parameter"
      );
    }
    return RequestHelper.get()(this, url12, options);
  }
  showPackageDescriptor(packageName, {
    projectId,
    groupId,
    ...options
  }) {
    let url12;
    if (projectId) {
      url12 = endpoint`projects/${projectId}/packages/pypi/simple/${packageName}`;
    } else if (groupId) {
      url12 = endpoint`groups/${groupId}/packages/pypi/simple/${packageName}`;
    } else {
      throw new Error(
        "Missing required argument. Please supply a projectId or a groupId in the options parameter"
      );
    }
    return RequestHelper.get()(this, url12, options);
  }
  uploadPackageFile(projectId, packageFile, options) {
    return RequestHelper.put()(this, endpoint`projects/${projectId}/packages/pypi`, {
      ...options,
      isForm: true,
      file: [packageFile.content, packageFile.filename]
    });
  }
};
var RubyGems = class extends BaseResource {
  static {
    __name(this, "RubyGems");
  }
  allDependencies(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/rubygems/api/v1/dependencies`,
      options
    );
  }
  downloadGemFile(projectId, fileName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/rubygems/gems/${fileName}`,
      options
    );
  }
  uploadGemFile(projectId, packageFile, options) {
    return RequestHelper.post()(this, `projects/${projectId}/packages/rubygems/api/v1/gems`, {
      isForm: true,
      ...options,
      file: [packageFile.content, packageFile.filename]
    });
  }
};
var Search = class extends BaseResource {
  static {
    __name(this, "Search");
  }
  all(scope, search, options) {
    const { projectId, groupId, ...opts } = options || {};
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/`;
    else
      url12 = "";
    return RequestHelper.get()(this, `${url12}search`, {
      scope,
      search,
      ...opts
    });
  }
};
var ServiceData = class extends BaseResource {
  static {
    __name(this, "ServiceData");
  }
  showMetricDefinitions(options) {
    return RequestHelper.get()(this, "usage_data/metric_definitions", options);
  }
  showServicePingSQLQueries(options) {
    return RequestHelper.get()(this, "usage_data/queries", options);
  }
  showUsageDataNonSQLMetrics(options) {
    return RequestHelper.get()(
      this,
      "usage_data/non_sql_metrics",
      options
    );
  }
};
var SidekiqMetrics = class extends BaseResource {
  static {
    __name(this, "SidekiqMetrics");
  }
  queueMetrics() {
    return RequestHelper.get()(this, "sidekiq/queue_metrics");
  }
  processMetrics() {
    return RequestHelper.get()(this, "sidekiq/process_metrics");
  }
  jobStats() {
    return RequestHelper.get()(this, "sidekiq/job_stats");
  }
  compoundMetrics() {
    return RequestHelper.get()(this, "sidekiq/compound_metrics");
  }
};
var SidekiqQueues = class extends BaseResource {
  static {
    __name(this, "SidekiqQueues");
  }
  remove(queueName, options) {
    return RequestHelper.get()(
      this,
      endpoint`admin/sidekiq/queues/${queueName}`,
      options
    );
  }
};
var SnippetRepositoryStorageMoves = class extends ResourceRepositoryStorageMoves {
  static {
    __name(this, "SnippetRepositoryStorageMoves");
  }
  constructor(options) {
    super("snippets", options);
  }
};
var Snippets = class extends BaseResource {
  static {
    __name(this, "Snippets");
  }
  all({
    public: ppublic,
    ...options
  } = {}) {
    const url12 = ppublic ? "snippets/public" : "snippets";
    return RequestHelper.get()(this, url12, options);
  }
  create(title, options) {
    return RequestHelper.post()(this, "snippets", {
      title,
      ...options
    });
  }
  edit(snippetId, options) {
    return RequestHelper.put()(this, `snippets/${snippetId}`, options);
  }
  remove(snippetId, options) {
    return RequestHelper.del()(this, `snippets/${snippetId}`, options);
  }
  show(snippetId, options) {
    return RequestHelper.get()(this, `snippets/${snippetId}`, options);
  }
  showContent(snippetId, options) {
    return RequestHelper.get()(this, `snippets/${snippetId}/raw`, options);
  }
  showRepositoryFileContent(snippetId, ref, filePath, options) {
    return RequestHelper.get()(
      this,
      endpoint`snippets/${snippetId}/files/${ref}/${filePath}/raw`,
      options
    );
  }
  showUserAgentDetails(snippetId, options) {
    return RequestHelper.get()(
      this,
      `snippets/${snippetId}/user_agent_detail`,
      options
    );
  }
};
var Suggestions = class extends BaseResource {
  static {
    __name(this, "Suggestions");
  }
  edit(suggestionId, options) {
    return RequestHelper.put()(
      this,
      `suggestions/${suggestionId}/apply`,
      options
    );
  }
  editBatch(suggestionIds, options) {
    return RequestHelper.put()(this, `suggestions/batch_apply`, {
      ...options,
      ids: suggestionIds
    });
  }
};
var SystemHooks = class extends BaseResource {
  static {
    __name(this, "SystemHooks");
  }
  all(options) {
    return RequestHelper.get()(this, "hooks", options);
  }
  // Convenience method
  add(url12, options) {
    return this.create(url12, options);
  }
  create(url12, options) {
    return RequestHelper.post()(this, "hooks", {
      url: url12,
      ...options
    });
  }
  test(hookId, options) {
    return RequestHelper.post()(this, `hooks/${hookId}`, options);
  }
  remove(hookId, options) {
    return RequestHelper.del()(this, `hooks/${hookId}`, options);
  }
  show(hookId, options) {
    return RequestHelper.post()(this, `hooks/${hookId}`, options);
  }
};
var TodoLists = class extends BaseResource {
  static {
    __name(this, "TodoLists");
  }
  all(options) {
    return RequestHelper.get()(this, "todos", options);
  }
  done({
    todoId,
    ...options
  } = {}) {
    let prefix = "todos";
    if (todoId)
      prefix += `/${todoId}`;
    return RequestHelper.post()(
      this,
      `${prefix}/mark_as_done`,
      options
    );
  }
};
var Topics = class extends BaseResource {
  static {
    __name(this, "Topics");
  }
  all(options) {
    return RequestHelper.get()(this, "topics", options);
  }
  create(name2, {
    avatar,
    ...options
  } = {}) {
    const opts = {
      name: name2,
      ...options
    };
    if (avatar) {
      opts.isForm = true;
      opts.file = [avatar.content, avatar.filename];
    }
    return RequestHelper.post()(this, "topics", opts);
  }
  edit(topicId, {
    avatar,
    ...options
  } = {}) {
    const opts = { ...options };
    if (avatar) {
      opts.isForm = true;
      opts.file = [avatar.content, avatar.filename];
    }
    return RequestHelper.put()(this, `topics/${topicId}`, opts);
  }
  merge(sourceTopicId, targetTopicId, options) {
    return RequestHelper.post()(this, `topics/merge`, {
      sourceTopicId,
      targetTopicId,
      ...options
    });
  }
  remove(topicId, options) {
    return RequestHelper.del()(this, `topics/${topicId}`, options);
  }
  show(topicId, options) {
    return RequestHelper.get()(this, `topics/${topicId}`, options);
  }
};
var Branches = class extends BaseResource {
  static {
    __name(this, "Branches");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/branches`,
      options
    );
  }
  create(projectId, branchName, ref, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/branches`,
      {
        branch: branchName,
        ref,
        ...options
      }
    );
  }
  remove(projectId, branchName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/repository/branches/${branchName}`,
      options
    );
  }
  removeMerged(projectId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/repository/merged_branches`,
      options
    );
  }
  show(projectId, branchName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/branches/${branchName}`,
      options
    );
  }
};
var CommitDiscussions = class extends ResourceDiscussions {
  static {
    __name(this, "CommitDiscussions");
  }
  constructor(options) {
    super("projects", "repository/commits", options);
  }
};
var Commits = class extends BaseResource {
  static {
    __name(this, "Commits");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits`,
      options
    );
  }
  allComments(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/comments`,
      options
    );
  }
  allDiscussions(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/discussions`,
      options
    );
  }
  allMergeRequests(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/merge_requests`,
      options
    );
  }
  allReferences(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/refs`,
      options
    );
  }
  allStatuses(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/statuses`,
      options
    );
  }
  cherryPick(projectId, sha, branch, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/cherry_pick`,
      {
        branch,
        ...options
      }
    );
  }
  create(projectId, branch, message, actions = [], options = {}) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/commits`,
      {
        branch,
        commitMessage: message,
        actions,
        ...options
      }
    );
  }
  createComment(projectId, sha, note, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/comments`,
      {
        note,
        ...options
      }
    );
  }
  editStatus(projectId, sha, state, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/statuses/${sha}`,
      {
        state,
        ...options
      }
    );
  }
  revert(projectId, sha, branch, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/revert`,
      {
        ...options,
        branch
      }
    );
  }
  show(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}`,
      options
    );
  }
  showDiff(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/diff`,
      options
    );
  }
  showGPGSignature(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/commits/${sha}/signature`,
      options
    );
  }
};
var ContainerRegistry = class extends BaseResource {
  static {
    __name(this, "ContainerRegistry");
  }
  allRepositories({
    groupId,
    projectId,
    ...options
  } = {}) {
    let url12;
    if (groupId)
      url12 = endpoint`groups/${groupId}/registry/repositories`;
    else if (projectId)
      url12 = endpoint`projects/${projectId}/registry/repositories`;
    else
      throw new Error(
        "Missing required argument. Please supply a groupId or a projectId in the options parameter."
      );
    return RequestHelper.get()(this, url12, options);
  }
  allTags(projectId, repositoryId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/registry/repositories/${repositoryId}/tags`,
      options
    );
  }
  editRegistryVisibility(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}`,
      options
    );
  }
  removeRepository(projectId, repositoryId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/registry/repositories/${repositoryId}`,
      options
    );
  }
  removeTag(projectId, repositoryId, tagName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/registry/repositories/${repositoryId}/tags/${tagName}`,
      options
    );
  }
  removeTags(projectId, repositoryId, nameRegexDelete, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/registry/repositories/${repositoryId}/tags`,
      {
        nameRegexDelete,
        ...options
      }
    );
  }
  showRepository(repositoryId, options) {
    return RequestHelper.get()(
      this,
      endpoint`registry/repositories/${repositoryId}`,
      options
    );
  }
  showTag(projectId, repositoryId, tagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/registry/repositories/${repositoryId}/tags/${tagName}`,
      options
    );
  }
};
var Deployments = class extends BaseResource {
  static {
    __name(this, "Deployments");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/deployments`,
      options
    );
  }
  allMergeRequests(projectId, deploymentId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/deployments/${deploymentId}/merge_requests`,
      options
    );
  }
  create(projectId, environment, sha, ref, tag, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/deployments`,
      {
        environment,
        sha,
        ref,
        tag,
        ...options
      }
    );
  }
  edit(projectId, deploymentId, status, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/deployments/${deploymentId}`,
      {
        ...options,
        status
      }
    );
  }
  remove(projectId, deploymentId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/deployments/${deploymentId}`,
      options
    );
  }
  setApproval(projectId, deploymentId, status, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/deployments/${deploymentId}/approval`,
      {
        ...options,
        status
      }
    );
  }
  show(projectId, deploymentId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/deployments/${deploymentId}`,
      options
    );
  }
};
var Environments = class extends BaseResource {
  static {
    __name(this, "Environments");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/environments`,
      options
    );
  }
  create(projectId, name2, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/environments`,
      {
        name: name2,
        ...options
      }
    );
  }
  edit(projectId, environmentId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/environments/${environmentId}`,
      options
    );
  }
  remove(projectId, environmentId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/environments/${environmentId}`,
      options
    );
  }
  removeReviewApps(projectId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/environments/review_apps`, options);
  }
  show(projectId, environmentId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/environments/${environmentId}`,
      options
    );
  }
  stop(projectId, environmentId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/environments/${environmentId}/stop`,
      options
    );
  }
  stopStale(projectId, before, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/environments/stop_stale`,
      {
        searchParams: { before },
        ...options
      }
    );
  }
};
var ErrorTrackingClientKeys = class extends BaseResource {
  static {
    __name(this, "ErrorTrackingClientKeys");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/error_tracking/client_keys`,
      options
    );
  }
  create(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/error_tracking/client_keys`,
      options
    );
  }
  remove(projectId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/error_tracking/client_keys`,
      options
    );
  }
};
var ErrorTrackingSettings = class extends BaseResource {
  static {
    __name(this, "ErrorTrackingSettings");
  }
  create(projectId, active, integrated, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/error_tracking/settings`,
      {
        searchParams: {
          active,
          integrated
        },
        ...options
      }
    );
  }
  edit(projectId, active, { integrated, ...options } = {}) {
    return RequestHelper.patch()(
      this,
      endpoint`projects/${projectId}/error_tracking/settings`,
      {
        searchParams: {
          active,
          integrated
        },
        ...options
      }
    );
  }
  show(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/error_tracking/settings`,
      options
    );
  }
};
var ExternalStatusChecks = class extends BaseResource {
  static {
    __name(this, "ExternalStatusChecks");
  }
  all(projectId, options) {
    const { mergerequestIId, ...opts } = options || {};
    let url12 = endpoint`projects/${projectId}`;
    if (mergerequestIId) {
      url12 += endpoint`/merge_requests/${mergerequestIId}/status_checks`;
    } else {
      url12 += "/external_status_checks";
    }
    return RequestHelper.get()(this, url12, opts);
  }
  create(projectId, name2, externalUrl, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/external_status_checks`,
      {
        name: name2,
        externalUrl,
        ...options
      }
    );
  }
  edit(projectId, externalStatusCheckId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/external_status_checks/${externalStatusCheckId}`,
      options
    );
  }
  remove(projectId, externalStatusCheckId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/external_status_checks/${externalStatusCheckId}`,
      options
    );
  }
  set(projectId, mergerequestIId, sha, externalStatusCheckId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/status_check_responses`,
      {
        sha,
        externalStatusCheckId,
        ...options
      }
    );
  }
};
var FeatureFlags = class extends BaseResource {
  static {
    __name(this, "FeatureFlags");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/feature_flags`,
      options
    );
  }
  create(projectId, flagName, version3, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/feature_flags`,
      {
        name: flagName,
        version: version3,
        ...options
      }
    );
  }
  edit(projectId, featureFlagName, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/feature_flags/${featureFlagName}`,
      options
    );
  }
  remove(projectId, flagName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/feature_flags/${flagName}`,
      options
    );
  }
  show(projectId, flagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/feature_flags/${flagName}`,
      options
    );
  }
};
var FeatureFlagUserLists = class extends BaseResource {
  static {
    __name(this, "FeatureFlagUserLists");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/feature_flags_user_lists`,
      options
    );
  }
  create(projectId, name2, userXids, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/feature_flags_user_lists`,
      {
        name: name2,
        userXids,
        ...options
      }
    );
  }
  edit(projectId, featureFlagUserListIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/feature_flags_user_lists/${featureFlagUserListIId}`,
      options
    );
  }
  remove(projectId, featureFlagUserListIId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/feature_flags_user_lists/${featureFlagUserListIId}`,
      options
    );
  }
  show(projectId, featureFlagUserListIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/feature_flags_user_lists/${featureFlagUserListIId}`,
      options
    );
  }
};
var FreezePeriods = class extends BaseResource {
  static {
    __name(this, "FreezePeriods");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/freeze_periods`,
      options
    );
  }
  create(projectId, freezeStart, freezeEnd, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/freeze_periods`,
      {
        freezeStart,
        freezeEnd,
        ...options
      }
    );
  }
  edit(projectId, freezePeriodId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/freeze_periods/${freezePeriodId}`,
      options
    );
  }
  remove(projectId, freezePeriodId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/freeze_periods/${freezePeriodId}`,
      options
    );
  }
  show(projectId, freezePeriodId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/freeze_periods/${freezePeriodId}`,
      options
    );
  }
};
var GitlabPages = class extends BaseResource {
  static {
    __name(this, "GitlabPages");
  }
  remove(projectId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/pages`, options);
  }
};
var GoProxy = class extends BaseResource {
  static {
    __name(this, "GoProxy");
  }
  all(projectId, moduleName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/go/${moduleName}/@v/list`,
      options
    );
  }
  showVersionMetadata(projectId, moduleName, moduleVersion, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/go/${moduleName}/@v/${moduleVersion}.info`,
      options
    );
  }
  downloadModuleFile(projectId, moduleName, moduleVersion, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/go/${moduleName}/@v/${moduleVersion}.mod`,
      options
    );
  }
  downloadModuleSource(projectId, moduleName, moduleVersion, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/go/${moduleName}/@v/${moduleVersion}.zip`,
      options
    );
  }
};
var Helm = class extends BaseResource {
  static {
    __name(this, "Helm");
  }
  downloadChartIndex(projectId, channel, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/helm/${channel}/index.yaml`,
      options
    );
  }
  downloadChart(projectId, channel, filename, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/helm/${channel}/charts/${filename}.tgz`,
      options
    );
  }
  import(projectId, channel, chart, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/packages/helm/api/${channel}/charts`,
      {
        isForm: true,
        ...options,
        chart: [chart.content, chart.filename]
      }
    );
  }
};
var Integrations = class extends BaseResource {
  static {
    __name(this, "Integrations");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/integrations`,
      options
    );
  }
  edit(projectId, integrationName, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/integrations/${integrationName}`,
      options
    );
  }
  disable(projectId, integrationName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/integrations/${integrationName}`,
      options
    );
  }
  show(projectId, integrationName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/integrations/${integrationName}`,
      options
    );
  }
};
var IssueAwardEmojis = class extends ResourceAwardEmojis {
  static {
    __name(this, "IssueAwardEmojis");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var IssueDiscussions = class extends ResourceDiscussions {
  static {
    __name(this, "IssueDiscussions");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var IssueIterationEvents = class extends ResourceIterationEvents {
  static {
    __name(this, "IssueIterationEvents");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var IssueLabelEvents = class extends ResourceLabelEvents {
  static {
    __name(this, "IssueLabelEvents");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var IssueLinks = class extends BaseResource {
  static {
    __name(this, "IssueLinks");
  }
  all(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/links`,
      options
    );
  }
  create(projectId, issueIId, targetProjectId, targetIssueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/links`,
      {
        targetProjectId,
        targetIssueIid: targetIssueIId,
        ...options
      }
    );
  }
  remove(projectId, issueIId, issueLinkId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/links/${issueLinkId}`,
      options
    );
  }
};
var IssueMilestoneEvents = class extends ResourceMilestoneEvents {
  static {
    __name(this, "IssueMilestoneEvents");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var IssueNoteAwardEmojis = class extends ResourceNoteAwardEmojis {
  static {
    __name(this, "IssueNoteAwardEmojis");
  }
  constructor(options) {
    super("issues", options);
  }
};
var IssueNotes = class extends ResourceNotes {
  static {
    __name(this, "IssueNotes");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var Issues = class extends BaseResource {
  static {
    __name(this, "Issues");
  }
  addSpentTime(projectId, issueIId, duration, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/add_spent_time`,
      {
        duration,
        ...options
      }
    );
  }
  addTimeEstimate(projectId, issueIId, duration, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/time_estimate`,
      {
        duration,
        ...options
      }
    );
  }
  all({
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/issues`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/issues`;
    else
      url12 = "issues";
    return RequestHelper.get()(this, url12, options);
  }
  allMetricImages(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/metric_images`,
      options
    );
  }
  allParticipants(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/participants`,
      options
    );
  }
  allRelatedMergeRequests(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/related_merge_requests`,
      options
    );
  }
  create(projectId, title, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/issues`, {
      ...options,
      title
    });
  }
  createTodo(projectId, issueIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/todo`,
      options
    );
  }
  clone(projectId, issueIId, destinationProjectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/clone`,
      {
        toProjectId: destinationProjectId,
        ...options
      }
    );
  }
  edit(projectId, issueIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}`,
      options
    );
  }
  editMetricImage(projectId, issueIId, imageId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/metric_images/${imageId}`,
      options
    );
  }
  move(projectId, issueIId, destinationProjectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/move`,
      {
        toProjectId: destinationProjectId,
        ...options
      }
    );
  }
  // Includes /promote already!
  promote(projectId, issueIId, body, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/notes`,
      {
        searchParams: {
          body: `${body} 
 /promote`
        },
        ...options
      }
    );
  }
  remove(projectId, issueIId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/issues/${issueIId}`, options);
  }
  removeMetricImage(projectId, issueIId, imageId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/metric_images/${imageId}`,
      options
    );
  }
  reorder(projectId, issueIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/reorder`,
      options
    );
  }
  resetSpentTime(projectId, issueIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/reset_spent_time`,
      options
    );
  }
  resetTimeEstimate(projectId, issueIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/reset_time_estimate`,
      options
    );
  }
  show(issueId, { projectId, ...options } = {}) {
    const url12 = projectId ? endpoint`projects/${projectId}/issues/${issueId}` : `issues/${issueId}`;
    return RequestHelper.get()(this, url12, options);
  }
  subscribe(projectId, issueIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/subscribe`,
      options
    );
  }
  allClosedByMergeRequestst(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/closed_by`,
      options
    );
  }
  showTimeStats(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/time_stats`,
      options
    );
  }
  unsubscribe(projectId, issueIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/unsubscribe`,
      options
    );
  }
  uploadMetricImage(projectId, issueIId, metricImage, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/metric_images`,
      {
        isForm: true,
        ...options,
        file: [metricImage.content, metricImage.filename]
      }
    );
  }
  showUserAgentDetails(projectId, issueIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/issues/${issueIId}/user_agent_details`,
      options
    );
  }
};
var IssuesStatistics = class extends BaseResource {
  static {
    __name(this, "IssuesStatistics");
  }
  all({
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/issues_statistics`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/issues_statistics`;
    else
      url12 = "issues_statistics";
    return RequestHelper.get()(this, url12, options);
  }
};
var IssueStateEvents = class extends ResourceStateEvents {
  static {
    __name(this, "IssueStateEvents");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
var IssueWeightEvents = class extends ResourceStateEvents {
  static {
    __name(this, "IssueWeightEvents");
  }
  constructor(options) {
    super("projects", "issues", options);
  }
};
function generateDownloadPathForJob(projectId, jobId, artifactPath) {
  let url12 = endpoint`projects/${projectId}/jobs/${jobId}/artifacts`;
  if (artifactPath)
    url12 += `/${artifactPath}`;
  return url12;
}
__name(generateDownloadPathForJob, "generateDownloadPathForJob");
function generateDownloadPath(projectId, ref, artifactPath) {
  let url12 = endpoint`projects/${projectId}/jobs/artifacts/${ref}`;
  if (artifactPath) {
    url12 += endpoint`/raw/${artifactPath}`;
  } else {
    url12 += endpoint`/download`;
  }
  return url12;
}
__name(generateDownloadPath, "generateDownloadPath");
var JobArtifacts = class extends BaseResource {
  static {
    __name(this, "JobArtifacts");
  }
  downloadArchive(projectId, {
    jobId,
    artifactPath,
    ref,
    ...options
  } = {}) {
    let url12;
    if (jobId)
      url12 = generateDownloadPathForJob(projectId, jobId, artifactPath);
    else if (options?.job && ref)
      url12 = generateDownloadPath(projectId, ref, artifactPath);
    else
      throw new Error(
        "Missing one of the required parameters. See typing documentation for available arguments."
      );
    return RequestHelper.get()(this, url12, options);
  }
  keep(projectId, jobId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}/artifacts/keep`,
      options
    );
  }
  remove(projectId, { jobId, ...options } = {}) {
    let url12;
    if (jobId) {
      url12 = endpoint`projects/${projectId}/jobs/${jobId}/artifacts`;
    } else {
      url12 = endpoint`projects/${projectId}/artifacts`;
    }
    return RequestHelper.del()(this, url12, options);
  }
};
var Jobs = class extends BaseResource {
  static {
    __name(this, "Jobs");
  }
  all(projectId, {
    pipelineId,
    ...options
  } = {}) {
    const url12 = pipelineId ? endpoint`projects/${projectId}/pipelines/${pipelineId}/jobs` : endpoint`projects/${projectId}/jobs`;
    return RequestHelper.get()(this, url12, options);
  }
  allPipelineBridges(projectId, pipelineId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}/bridges`,
      options
    );
  }
  cancel(projectId, jobId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}/cancel`,
      options
    );
  }
  erase(projectId, jobId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}/erase`,
      options
    );
  }
  play(projectId, jobId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}/play`,
      options
    );
  }
  retry(projectId, jobId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}/retry`,
      options
    );
  }
  show(projectId, jobId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}`,
      options
    );
  }
  showConnectedJob(options) {
    if (!this.headers["job-token"])
      throw new Error('Missing required header "job-token"');
    return RequestHelper.get()(this, "job", options);
  }
  showConnectedJobK8Agents(options) {
    if (!this.headers["job-token"])
      throw new Error('Missing required header "job-token"');
    return RequestHelper.get()(this, "job/allowed_agents", options);
  }
  showLog(projectId, jobId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/jobs/${jobId}/trace`,
      options
    );
  }
};
var MergeRequestApprovals = class extends BaseResource {
  static {
    __name(this, "MergeRequestApprovals");
  }
  allApprovalRules(projectId, { mergerequestIId, ...options } = {}) {
    let url12;
    if (mergerequestIId) {
      url12 = endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approval_rules`;
    } else {
      url12 = endpoint`projects/${projectId}/approval_rules`;
    }
    return RequestHelper.get()(this, url12, options);
  }
  approve(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approve`,
      options
    );
  }
  createApprovalRule(projectId, name2, approvalsRequired, {
    mergerequestIId,
    ...options
  } = {}) {
    let url12;
    if (mergerequestIId) {
      url12 = endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approval_rules`;
    } else {
      url12 = endpoint`projects/${projectId}/approval_rules`;
    }
    return RequestHelper.post()(this, url12, { name: name2, approvalsRequired, ...options });
  }
  editApprovalRule(projectId, approvalRuleId, name2, approvalsRequired, {
    mergerequestIId,
    ...options
  } = {}) {
    let url12;
    if (mergerequestIId) {
      url12 = endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approval_rules/${approvalRuleId}`;
    } else {
      url12 = endpoint`projects/${projectId}/approval_rules/${approvalRuleId}`;
    }
    return RequestHelper.put()(this, url12, { name: name2, approvalsRequired, ...options });
  }
  editConfiguration(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/approvals`,
      options
    );
  }
  removeApprovalRule(projectId, approvalRuleId, {
    mergerequestIId,
    ...options
  } = {}) {
    let url12;
    if (mergerequestIId) {
      url12 = endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approval_rules/${approvalRuleId}`;
    } else {
      url12 = endpoint`projects/${projectId}/approval_rules/${approvalRuleId}`;
    }
    return RequestHelper.del()(this, url12, options);
  }
  showApprovalRule(projectId, approvalRuleId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/approval_rules/${approvalRuleId}`,
      options
    );
  }
  showApprovalState(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approval_state`,
      options
    );
  }
  showConfiguration(projectId, { mergerequestIId, ...options } = {}) {
    let url12;
    if (mergerequestIId) {
      url12 = endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/approvals`;
    } else {
      url12 = endpoint`projects/${projectId}/approvals`;
    }
    return RequestHelper.get()(this, url12, options);
  }
  unapprove(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/unapprove`,
      options
    );
  }
};
var MergeRequestAwardEmojis = class extends ResourceAwardEmojis {
  static {
    __name(this, "MergeRequestAwardEmojis");
  }
  constructor(options) {
    super("projects", "merge_requests", options);
  }
};
var MergeRequestContextCommits = class extends BaseResource {
  static {
    __name(this, "MergeRequestContextCommits");
  }
  all(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/context_commits`,
      options
    );
  }
  create(projectId, commits, { mergerequestIId, ...options } = {}) {
    const prefix = endpoint`projects/${projectId}/merge_requests`;
    const url12 = mergerequestIId ? `${prefix}/${mergerequestIId}/context_commits` : prefix;
    return RequestHelper.post()(this, url12, {
      commits,
      ...options
    });
  }
  remove(projectId, mergerequestIId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/context_commits`,
      options
    );
  }
};
var MergeRequestDiscussions = class extends ResourceDiscussions {
  static {
    __name(this, "MergeRequestDiscussions");
  }
  constructor(options) {
    super("projects", "merge_requests", options);
  }
  resolve(projectId, mergerequestId, discussionId, resolved, options) {
    return RequestHelper.put()(
      this,
      endpoint`${projectId}/merge_requests/${mergerequestId}/discussions/${discussionId}`,
      {
        searchParams: { resolved },
        ...options
      }
    );
  }
};
var MergeRequestLabelEvents = class extends ResourceLabelEvents {
  static {
    __name(this, "MergeRequestLabelEvents");
  }
  constructor(options) {
    super("projects", "merge_requests", options);
  }
};
var MergeRequestMilestoneEvents = class extends ResourceMilestoneEvents {
  static {
    __name(this, "MergeRequestMilestoneEvents");
  }
  constructor(options) {
    super("projects", "merge_requests", options);
  }
};
var MergeRequestDraftNotes = class extends BaseResource {
  static {
    __name(this, "MergeRequestDraftNotes");
  }
  all(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes`,
      options
    );
  }
  create(projectId, mergerequestIId, note, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes`,
      {
        ...options,
        note
      }
    );
  }
  edit(projectId, mergerequestIId, draftNoteId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes/${draftNoteId}`,
      options
    );
  }
  publish(projectId, mergerequestIId, draftNoteId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes/${draftNoteId}/publish`,
      options
    );
  }
  publishBulk(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes/bulk_publish`,
      options
    );
  }
  remove(projectId, mergerequestIId, draftNoteId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes/${draftNoteId}`,
      options
    );
  }
  show(projectId, mergerequestIId, draftNoteId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/draft_notes/${draftNoteId}`,
      options
    );
  }
};
var MergeRequestNotes = class extends ResourceNotes {
  static {
    __name(this, "MergeRequestNotes");
  }
  constructor(options) {
    super("projects", "merge_requests", options);
  }
};
var MergeRequestNoteAwardEmojis = class extends ResourceNoteAwardEmojis {
  static {
    __name(this, "MergeRequestNoteAwardEmojis");
  }
  constructor(options) {
    super("merge_requests", options);
  }
};
var MergeRequests = class extends BaseResource {
  static {
    __name(this, "MergeRequests");
  }
  // convenience method
  accept(projectId, mergerequestIId, options) {
    return this.merge(projectId, mergerequestIId, options);
  }
  addSpentTime(projectId, mergerequestIId, duration, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/add_spent_time`,
      {
        duration,
        ...options
      }
    );
  }
  all({
    projectId,
    groupId,
    ...options
  } = {}) {
    let prefix = "";
    if (projectId) {
      prefix = endpoint`projects/${projectId}/`;
    } else if (groupId) {
      prefix = endpoint`groups/${groupId}/`;
    }
    return RequestHelper.get()(this, `${prefix}merge_requests`, options);
  }
  allDiffs(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/diffs`,
      options
    );
  }
  allCommits(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/commits`,
      options
    );
  }
  allDiffVersions(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/versions`,
      options
    );
  }
  allIssuesClosed(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/closes_issues`,
      options
    );
  }
  allParticipants(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/participants`,
      options
    );
  }
  allPipelines(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/pipelines`,
      options
    );
  }
  cancelOnPipelineSuccess(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/cancel_merge_when_pipeline_succeeds`,
      options
    );
  }
  create(projectId, sourceBranch, targetBranch, title, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests`,
      {
        sourceBranch,
        targetBranch,
        title,
        ...options
      }
    );
  }
  createPipeline(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/pipelines`,
      options
    );
  }
  createTodo(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/todo`,
      options
    );
  }
  edit(projectId, mergerequestIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}`,
      options
    );
  }
  merge(projectId, mergerequestIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/merge`,
      options
    );
  }
  mergeToDefault(projectId, mergerequestIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/merge_ref`,
      options
    );
  }
  rebase(projectId, mergerequestIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/rebase`,
      options
    );
  }
  remove(projectId, mergerequestIId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}`,
      options
    );
  }
  resetSpentTime(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/reset_spent_time`,
      options
    );
  }
  resetTimeEstimate(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/reset_time_estimate`,
      options
    );
  }
  setTimeEstimate(projectId, mergerequestIId, duration, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/time_estimate`,
      {
        duration,
        ...options
      }
    );
  }
  show(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}`,
      options
    );
  }
  showChanges(projectId, mergerequestIId, options) {
    process.emitWarning(
      'This endpoint was deprecated in Gitlab API 15.7 and will be removed in API v5. Please use the "allDiffs" function instead.',
      "DeprecationWarning"
    );
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/changes`,
      options
    );
  }
  showDiffVersion(projectId, mergerequestIId, versionId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/versions/${versionId}`,
      options
    );
  }
  showTimeStats(projectId, mergerequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/time_stats`,
      options
    );
  }
  subscribe(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/subscribe`,
      options
    );
  }
  unsubscribe(projectId, mergerequestIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/merge_requests/${mergerequestIId}/unsubscribe`,
      options
    );
  }
};
var MergeTrains = class extends BaseResource {
  static {
    __name(this, "MergeTrains");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_trains`,
      options
    );
  }
  showStatus(projectId, mergeRequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_trains/merge_requests/${mergeRequestIId}`,
      options
    );
  }
  addMergeRequest(projectId, mergeRequestIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/merge_trains/merge_requests/${mergeRequestIId}`,
      options
    );
  }
};
var PackageRegistry = class extends BaseResource {
  static {
    __name(this, "PackageRegistry");
  }
  publish(projectId, packageName, packageVersion, packageFile, {
    contentType,
    ...options
  } = {}) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/packages/generic/${packageName}/${packageVersion}/${packageFile.filename}`,
      {
        isForm: true,
        file: [packageFile.content, packageFile.filename],
        ...options
      }
    );
  }
  download(projectId, packageName, packageVersion, filename, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/generic/${packageName}/${packageVersion}/${filename}`,
      options
    );
  }
};
var Packages = class extends BaseResource {
  static {
    __name(this, "Packages");
  }
  all({
    projectId,
    groupId,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/packages`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/packages`;
    else {
      throw new Error(
        "Missing required argument. Please supply a projectId or a groupId in the options parameter."
      );
    }
    return RequestHelper.get()(this, url12, options);
  }
  allFiles(projectId, packageId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/${packageId}/package_files`,
      options
    );
  }
  remove(projectId, packageId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/packages/${packageId}`,
      options
    );
  }
  removeFile(projectId, packageId, projectFileId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/packages/${packageId}/package_files/${projectFileId}`,
      options
    );
  }
  show(projectId, packageId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/packages/${packageId}`,
      options
    );
  }
};
var PagesDomains = class extends BaseResource {
  static {
    __name(this, "PagesDomains");
  }
  all({
    projectId,
    ...options
  } = {}) {
    const prefix = projectId ? endpoint`projects/${projectId}/` : "";
    return RequestHelper.get()(this, `${prefix}pages/domains`, options);
  }
  create(projectId, domain, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pages/domains`,
      {
        domain,
        ...options
      }
    );
  }
  edit(projectId, domain, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/pages/domains/${domain}`,
      options
    );
  }
  show(projectId, domain, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pages/domains/${domain}`,
      options
    );
  }
  remove(projectId, domain, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/pages/domains/${domain}`,
      options
    );
  }
};
var Pipelines = class extends BaseResource {
  static {
    __name(this, "Pipelines");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipelines`,
      options
    );
  }
  allVariables(projectId, pipelineId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}/variables`,
      options
    );
  }
  cancel(projectId, pipelineId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}/cancel`,
      options
    );
  }
  create(projectId, ref, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipeline`,
      {
        ref,
        ...options
      }
    );
  }
  remove(projectId, pipelineId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}`,
      options
    );
  }
  retry(projectId, pipelineId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}/retry`,
      options
    );
  }
  show(projectId, pipelineId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}`,
      options
    );
  }
  showTestReport(projectId, pipelineId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}/test_report`,
      options
    );
  }
  showTestReportSummary(projectId, pipelineId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipelines/${pipelineId}/test_report_summary`,
      options
    );
  }
};
var PipelineSchedules = class extends BaseResource {
  static {
    __name(this, "PipelineSchedules");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules`,
      options
    );
  }
  allTriggeredPipelines(projectId, pipelineScheduleId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/pipelines`,
      options
    );
  }
  create(projectId, description, ref, cron, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules`,
      {
        description,
        ref,
        cron,
        ...options
      }
    );
  }
  edit(projectId, pipelineScheduleId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}`,
      options
    );
  }
  remove(projectId, pipelineScheduleId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}`,
      options
    );
  }
  run(projectId, pipelineScheduleId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/play`,
      options
    );
  }
  show(projectId, pipelineScheduleId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}`,
      options
    );
  }
  takeOwnership(projectId, pipelineScheduleId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/take_ownership`,
      options
    );
  }
};
var PipelineScheduleVariables = class extends BaseResource {
  static {
    __name(this, "PipelineScheduleVariables");
  }
  all(projectId, pipelineScheduleId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/variables`,
      options
    );
  }
  create(projectId, pipelineScheduleId, key, value, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/variables`,
      {
        ...options,
        key,
        value
      }
    );
  }
  edit(projectId, pipelineScheduleId, key, value, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/variables/${key}`,
      {
        ...options,
        value
      }
    );
  }
  remove(projectId, pipelineScheduleId, key, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/pipeline_schedules/${pipelineScheduleId}/variables/${key}`,
      options
    );
  }
};
var PipelineTriggerTokens = class extends BaseResource {
  static {
    __name(this, "PipelineTriggerTokens");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/triggers`,
      options
    );
  }
  create(projectId, description, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/triggers`,
      {
        description,
        ...options
      }
    );
  }
  edit(projectId, triggerId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/triggers/${triggerId}`,
      options
    );
  }
  remove(projectId, triggerId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/triggers/${triggerId}`,
      options
    );
  }
  show(projectId, triggerId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/triggers/${triggerId}`,
      options
    );
  }
  trigger(projectId, ref, token, { variables, ...options } = {}) {
    const opts = {
      ...options,
      searchParams: {
        token,
        ref
      }
    };
    if (variables) {
      opts.isForm = true;
      Object.assign(opts, reformatObjectOptions(variables, "variables"));
    }
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/trigger/pipeline`,
      opts
    );
  }
};
var ProductAnalytics = class extends BaseResource {
  static {
    __name(this, "ProductAnalytics");
  }
  allFunnels(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/product_analytics/funnels`,
      options
    );
  }
  load(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/product_analytics/request/load`,
      options
    );
  }
  dryRun(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/product_analytics/request/dry-run`,
      options
    );
  }
  showMetadata(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/product_analytics/request/meta`,
      options
    );
  }
};
var ProjectAccessRequests = class extends ResourceAccessRequests {
  static {
    __name(this, "ProjectAccessRequests");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectAccessTokens = class extends ResourceAccessTokens {
  static {
    __name(this, "ProjectAccessTokens");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectAliases = class extends BaseResource {
  static {
    __name(this, "ProjectAliases");
  }
  all(options) {
    return RequestHelper.get()(this, "project_aliases", options);
  }
  create(projectId, name2, options) {
    return RequestHelper.post()(this, "project_aliases", {
      name: name2,
      projectId,
      ...options
    });
  }
  edit(name2, options) {
    return RequestHelper.post()(this, `project_aliases/${name2}`, options);
  }
  remove(name2, options) {
    return RequestHelper.del()(this, `project_aliases/${name2}`, options);
  }
};
var ProjectBadges = class extends ResourceBadges {
  static {
    __name(this, "ProjectBadges");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectCustomAttributes = class extends ResourceCustomAttributes {
  static {
    __name(this, "ProjectCustomAttributes");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectDORA4Metrics = class extends ResourceDORA4Metrics {
  static {
    __name(this, "ProjectDORA4Metrics");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectHooks = class extends ResourceHooks {
  static {
    __name(this, "ProjectHooks");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectImportExports = class extends BaseResource {
  static {
    __name(this, "ProjectImportExports");
  }
  download(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/export/download`,
      options
    );
  }
  import(file, path, options) {
    return RequestHelper.post()(this, "projects/import", {
      isForm: true,
      ...options,
      file: [file.content, file.filename],
      path
    });
  }
  importRemote(url12, path, options) {
    return RequestHelper.post()(this, "projects/remote-import", {
      ...options,
      path,
      url: url12
    });
  }
  importRemoteS3(accessKeyId, bucketName, fileKey, path, region, secretAccessKey, options) {
    return RequestHelper.post()(this, "projects/remote-import", {
      ...options,
      accessKeyId,
      bucketName,
      fileKey,
      path,
      region,
      secretAccessKey
    });
  }
  showExportStatus(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/export`,
      options
    );
  }
  showImportStatus(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/import`,
      options
    );
  }
  scheduleExport(projectId, uploadConfig, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/export`, {
      ...options,
      upload: uploadConfig
    });
  }
};
var ProjectInvitations = class extends ResourceInvitations {
  static {
    __name(this, "ProjectInvitations");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectIssueBoards = class extends ResourceIssueBoards {
  static {
    __name(this, "ProjectIssueBoards");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectIterations = class extends ResourceIterations {
  static {
    __name(this, "ProjectIterations");
  }
  constructor(options) {
    super("project", options);
  }
};
var ProjectLabels = class extends ResourceLabels {
  static {
    __name(this, "ProjectLabels");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectMembers = class extends ResourceMembers {
  static {
    __name(this, "ProjectMembers");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectMilestones = class extends ResourceMilestones {
  static {
    __name(this, "ProjectMilestones");
  }
  constructor(options) {
    super("projects", options);
  }
  promote(projectId, milestoneId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${projectId}/milestones/${milestoneId}/promote`,
      options
    );
  }
};
var ProjectProtectedEnvironments = class extends ResourceProtectedEnvironments {
  static {
    __name(this, "ProjectProtectedEnvironments");
  }
  constructor(options) {
    super("groups", options);
  }
};
var ProjectPushRules = class extends ResourcePushRules {
  static {
    __name(this, "ProjectPushRules");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectRelationsExport = class extends BaseResource {
  static {
    __name(this, "ProjectRelationsExport");
  }
  download(projectId, relation, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/export_relations/download`,
      {
        relation,
        ...options
      }
    );
  }
  showExportStatus(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/export_relations/status`,
      options
    );
  }
  scheduleExport(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/export_relations`,
      options
    );
  }
};
var ProjectReleases = class extends BaseResource {
  static {
    __name(this, "ProjectReleases");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases`,
      options
    );
  }
  create(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/releases`,
      options
    );
  }
  createEvidence(projectId, tagName, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/evidence`,
      options
    );
  }
  edit(projectId, tagName, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}`,
      options
    );
  }
  download(projectId, tagName, filepath, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/downloads/${filepath}`,
      options
    );
  }
  downloadLatest(projectId, filepath, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/permalink/latest/downloads/${filepath}`,
      options
    );
  }
  remove(projectId, tagName, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/releases/${tagName}`, options);
  }
  show(projectId, tagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}`,
      options
    );
  }
  showLatest(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/permalink/latest`,
      options
    );
  }
  showLatestEvidence(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/permalink/latest/evidence`,
      options
    );
  }
};
var ProjectRemoteMirrors = class extends BaseResource {
  static {
    __name(this, "ProjectRemoteMirrors");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/remote_mirrors`,
      options
    );
  }
  // Helper method - Duplicated from Projects
  createPullMirror(projectId, url12, mirror, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/mirror/pull`,
      {
        importUrl: url12,
        mirror,
        ...options
      }
    );
  }
  createPushMirror(projectId, url12, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/remote_mirrors`,
      {
        url: url12,
        ...options
      }
    );
  }
  edit(projectId, mirrorId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/remote_mirrors/${mirrorId}`,
      options
    );
  }
  remove(name2, options) {
    return RequestHelper.del()(this, `project_aliases/${name2}`, options);
  }
  show(projectId, mirrorId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/remote_mirrors/${mirrorId}`,
      options
    );
  }
};
var ProjectRepositoryStorageMoves = class extends ResourceRepositoryStorageMoves {
  static {
    __name(this, "ProjectRepositoryStorageMoves");
  }
  constructor(options) {
    super("projects", options);
  }
};
var Projects = class extends BaseResource {
  static {
    __name(this, "Projects");
  }
  all({
    userId,
    starredOnly,
    ...options
  } = {}) {
    let uri;
    if (userId && starredOnly)
      uri = endpoint`users/${userId}/starred_projects`;
    else if (userId)
      uri = endpoint`users/${userId}/projects`;
    else
      uri = "projects";
    return RequestHelper.get()(this, uri, options);
  }
  allTransferLocations(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/transfer_locations`,
      options
    );
  }
  allUsers(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/users`,
      options
    );
  }
  allGroups(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/groups`,
      options
    );
  }
  allSharableGroups(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/share_locations`,
      options
    );
  }
  allForks(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/forks`,
      options
    );
  }
  allStarrers(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/starrers`,
      options
    );
  }
  allStoragePaths(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/storage`,
      options
    );
  }
  archive(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/archive`,
      options
    );
  }
  create({
    userId,
    avatar,
    ...options
  } = {}) {
    const url12 = userId ? `projects/user/${userId}` : "projects";
    if (avatar) {
      return RequestHelper.post()(this, url12, {
        ...options,
        isForm: true,
        avatar: [avatar.content, avatar.filename]
      });
    }
    return RequestHelper.post()(this, url12, { ...options, avatar });
  }
  createForkRelationship(projectId, forkedFromId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/fork/${forkedFromId}`,
      options
    );
  }
  // Helper method - Duplicated from ProjectRemoteMirrors
  createPullMirror(projectId, url12, mirror, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/mirror/pull`,
      {
        importUrl: url12,
        mirror,
        ...options
      }
    );
  }
  downloadSnapshot(projectId, options) {
    return RequestHelper.get()(this, endpoint`projects/${projectId}/snapshot`, options);
  }
  edit(projectId, { avatar, ...options } = {}) {
    const url12 = endpoint`projects/${projectId}`;
    if (avatar) {
      return RequestHelper.put()(this, url12, {
        ...options,
        isForm: true,
        avatar: [avatar.content, avatar.filename]
      });
    }
    return RequestHelper.put()(this, url12, { ...options, avatar });
  }
  fork(projectId, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/fork`, options);
  }
  housekeeping(projectId, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/housekeeping`, options);
  }
  importProjectMembers(projectId, sourceProjectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/import_project_members/${sourceProjectId}`,
      options
    );
  }
  remove(projectId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}`, options);
  }
  removeForkRelationship(projectId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/fork`, options);
  }
  removeAvatar(projectId, options) {
    return RequestHelper.put()(this, endpoint`projects/${projectId}`, {
      ...options,
      avatar: ""
    });
  }
  restore(projectId, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/restore`, options);
  }
  search(projectName, options) {
    return RequestHelper.get()(this, "projects", {
      search: projectName,
      ...options
    });
  }
  share(projectId, groupId, groupAccess, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/share`, {
      groupId,
      groupAccess,
      ...options
    });
  }
  show(projectId, options) {
    return RequestHelper.get()(this, endpoint`projects/${projectId}`, options);
  }
  showLanguages(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/languages`,
      options
    );
  }
  showPullMirror(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/mirror/pull`,
      options
    );
  }
  star(projectId, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/star`, options);
  }
  transfer(projectId, namespaceId, options) {
    return RequestHelper.put()(this, endpoint`projects/${projectId}/transfer`, {
      ...options,
      namespace: namespaceId
    });
  }
  unarchive(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/unarchive`,
      options
    );
  }
  unshare(projectId, groupId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/share/${groupId}`, options);
  }
  unstar(projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/unstar`,
      options
    );
  }
  /* Upload file to be used a reference within an issue, merge request or
     comment
  */
  uploadForReference(projectId, file, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/uploads`,
      {
        ...options,
        isForm: true,
        file: [file.content, file.filename]
      }
    );
  }
  uploadAvatar(projectId, avatar, options) {
    return RequestHelper.put()(this, endpoint`projects/${projectId}`, {
      ...options,
      isForm: true,
      avatar: [avatar.content, avatar.filename]
    });
  }
};
var ProjectSnippetAwardEmojis = class extends ResourceAwardEmojis {
  static {
    __name(this, "ProjectSnippetAwardEmojis");
  }
  constructor(options) {
    super("projects", "snippets", options);
  }
};
var ProjectSnippetDiscussions = class extends ResourceDiscussions {
  static {
    __name(this, "ProjectSnippetDiscussions");
  }
  constructor(options) {
    super("projects", "snippets", options);
  }
};
var ProjectSnippetNotes = class extends ResourceNotes {
  static {
    __name(this, "ProjectSnippetNotes");
  }
  constructor(options) {
    super("projects", "snippets", options);
  }
};
var ProjectSnippets = class extends BaseResource {
  static {
    __name(this, "ProjectSnippets");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/snippets`,
      options
    );
  }
  create(projectId, title, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/snippets`,
      {
        title,
        ...options
      }
    );
  }
  edit(projectId, snippetId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/snippets/${snippetId}`,
      options
    );
  }
  remove(projectId, snippetId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/snippets/${snippetId}`,
      options
    );
  }
  show(projectId, snippetId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/snippets/${snippetId}`,
      options
    );
  }
  showContent(projectId, snippetId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/snippets/${snippetId}/raw`,
      options
    );
  }
  showRepositoryFileContent(projectId, snippetId, ref, filePath, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/snippets/${snippetId}/files/${ref}/${filePath}/raw`,
      options
    );
  }
  showUserAgentDetails(projectId, snippetId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/snippets/${snippetId}/user_agent_detail`,
      options
    );
  }
};
var ProjectStatistics = class extends BaseResource {
  static {
    __name(this, "ProjectStatistics");
  }
  show(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/statistics`,
      options
    );
  }
};
var ProjectTemplates = class extends BaseResource {
  static {
    __name(this, "ProjectTemplates");
  }
  all(projectId, type, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/templates/${type}`,
      options
    );
  }
  show(projectId, type, name2, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/templates/${type}/${name2}`,
      options
    );
  }
};
var ProjectVariables = class extends ResourceVariables {
  static {
    __name(this, "ProjectVariables");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProjectVulnerabilities = class extends BaseResource {
  static {
    __name(this, "ProjectVulnerabilities");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/vulnerabilities`,
      options
    );
  }
  create(projectId, findingId, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/vulnerabilities`,
      {
        ...options,
        searchParams: {
          findingId
        }
      }
    );
  }
};
var ProjectWikis = class extends ResourceWikis {
  static {
    __name(this, "ProjectWikis");
  }
  constructor(options) {
    super("projects", options);
  }
};
var ProtectedBranches = class extends BaseResource {
  static {
    __name(this, "ProtectedBranches");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/protected_branches`,
      options
    );
  }
  create(projectId, branchName, options) {
    const { sudo, showExpanded, ...opts } = options || {};
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/protected_branches`,
      {
        searchParams: {
          ...opts,
          name: branchName
        },
        sudo,
        showExpanded
      }
    );
  }
  // Convenience method - create
  protect(projectId, branchName, options) {
    return this.create(projectId, branchName, options);
  }
  edit(projectId, branchName, options) {
    return RequestHelper.patch()(
      this,
      endpoint`projects/${projectId}/protected_branches/${branchName}`,
      options
    );
  }
  show(projectId, branchName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/protected_branches/${branchName}`,
      options
    );
  }
  remove(projectId, branchName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/protected_branches/${branchName}`,
      options
    );
  }
  // Convenience method - remove
  unprotect(projectId, branchName, options) {
    return this.remove(projectId, branchName, options);
  }
};
var ProtectedTags = class extends BaseResource {
  static {
    __name(this, "ProtectedTags");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/protected_tags`,
      options
    );
  }
  create(projectId, tagName, options) {
    const { sudo, showExpanded, ...opts } = options || {};
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/protected_tags`,
      {
        searchParams: {
          name: tagName,
          ...opts
        },
        sudo,
        showExpanded
      }
    );
  }
  // Convenience method - create
  protect(projectId, tagName, options) {
    return this.create(projectId, tagName, options);
  }
  show(projectId, tagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/protected_tags/${tagName}`,
      options
    );
  }
  remove(projectId, tagName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/protected_tags/${tagName}`,
      options
    );
  }
  // Convenience method - remove
  unprotect(projectId, tagName, options) {
    return this.remove(projectId, tagName, options);
  }
};
var ReleaseLinks = class extends BaseResource {
  static {
    __name(this, "ReleaseLinks");
  }
  all(projectId, tagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/assets/links`,
      options
    );
  }
  create(projectId, tagName, name2, url12, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/assets/links`,
      {
        name: name2,
        url: url12,
        ...options
      }
    );
  }
  edit(projectId, tagName, linkId, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/assets/links/${linkId}`,
      options
    );
  }
  remove(projectId, tagName, linkId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/assets/links/${linkId}`,
      options
    );
  }
  show(projectId, tagName, linkId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/releases/${tagName}/assets/links/${linkId}`,
      options
    );
  }
};
var Repositories = class extends BaseResource {
  static {
    __name(this, "Repositories");
  }
  allContributors(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/contributors`,
      options
    );
  }
  allRepositoryTrees(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/tree`,
      options
    );
  }
  compare(projectId, from, to, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/compare`,
      {
        from,
        to,
        ...options
      }
    );
  }
  editChangelog(projectId, version3, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/changelog`,
      { ...options, version: version3 }
    );
  }
  mergeBase(projectId, refs, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/merge_base`,
      {
        ...options,
        refs
      }
    );
  }
  showArchive(projectId, {
    fileType = "tar.gz",
    ...options
  } = {}) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/archive.${fileType}`,
      options
    );
  }
  showBlob(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/blobs/${sha}`,
      options
    );
  }
  showBlobRaw(projectId, sha, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/blobs/${sha}/raw`,
      options
    );
  }
  showChangelog(projectId, version3, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/changelog`,
      { ...options, version: version3 }
    );
  }
};
var RepositoryFiles = class extends BaseResource {
  static {
    __name(this, "RepositoryFiles");
  }
  allFileBlames(projectId, filePath, ref, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/files/${filePath}/blame`,
      {
        ref,
        ...options
      }
    );
  }
  create(projectId, filePath, branch, content, commitMessage, options) {
    return RequestHelper.post()(
      this,
      endpoint`projects/${projectId}/repository/files/${filePath}`,
      {
        branch,
        content,
        commitMessage,
        ...options
      }
    );
  }
  edit(projectId, filePath, branch, content, commitMessage, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/repository/files/${filePath}`,
      {
        branch,
        content,
        commitMessage,
        ...options
      }
    );
  }
  remove(projectId, filePath, branch, commitMessage, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/repository/files/${filePath}`, {
      branch,
      commitMessage,
      ...options
    });
  }
  show(projectId, filePath, ref, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/files/${filePath}`,
      {
        ref,
        ...options
      }
    );
  }
  showRaw(projectId, filePath, ref, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/files/${filePath}/raw`,
      {
        ref,
        ...options
      }
    );
  }
};
var RepositorySubmodules = class extends BaseResource {
  static {
    __name(this, "RepositorySubmodules");
  }
  edit(projectId, submodule, branch, commitSha, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/repository/submodules/${submodule}`,
      {
        branch,
        commitSha,
        ...options
      }
    );
  }
};
var ResourceGroups = class extends BaseResource {
  static {
    __name(this, "ResourceGroups");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/resource_groups`,
      options
    );
  }
  edit(projectId, key, options) {
    return RequestHelper.put()(
      this,
      endpoint`projects/${projectId}/resource_groups/${key}`,
      options
    );
  }
  show(projectId, key, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/resource_groups/${key}`,
      options
    );
  }
  allUpcomingJobs(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/resource_groups/upcoming_jobs`,
      options
    );
  }
};
var Runners = class extends BaseResource {
  static {
    __name(this, "Runners");
  }
  all({
    projectId,
    groupId,
    owned,
    ...options
  } = {}) {
    let url12;
    if (projectId)
      url12 = endpoint`projects/${projectId}/runners`;
    else if (groupId)
      url12 = endpoint`groups/${groupId}/runners`;
    else if (owned)
      url12 = "runners";
    else
      url12 = "runners/all";
    return RequestHelper.get()(this, url12, options);
  }
  allJobs(runnerId, options) {
    return RequestHelper.get()(this, `runners/${runnerId}/jobs`, options);
  }
  // https://docs.gitlab.com/15.9/ee/api/runners.html#register-a-new-runner
  create(token, options) {
    return RequestHelper.post()(this, `runners`, {
      token,
      ...options
    });
  }
  edit(runnerId, options) {
    return RequestHelper.put()(this, `runners/${runnerId}`, options);
  }
  enable(projectId, runnerId, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/runners`, {
      runnerId,
      ...options
    });
  }
  disable(projectId, runnerId, options) {
    return RequestHelper.del()(this, endpoint`projects/${projectId}/runners/${runnerId}`, options);
  }
  // Create - Convenience method
  register(token, options) {
    return this.create(token, options);
  }
  remove({
    runnerId,
    token,
    ...options
  }) {
    let url12;
    if (runnerId)
      url12 = `runners/${runnerId}`;
    else if (token) {
      url12 = "runners";
    } else
      throw new Error(
        "Missing required argument. Please supply a runnerId or a token in the options parameter"
      );
    return RequestHelper.del()(this, url12, {
      token,
      ...options
    });
  }
  resetRegistrationToken({
    runnerId,
    token,
    ...options
  } = {}) {
    let url12;
    if (runnerId)
      url12 = endpoint`runners/${runnerId}/reset_registration_token`;
    else if (token)
      url12 = "runners/reset_registration_token";
    else {
      throw new Error("Missing either runnerId or token parameters");
    }
    return RequestHelper.post()(this, url12, {
      token,
      ...options
    });
  }
  show(runnerId, options) {
    return RequestHelper.get()(this, `runners/${runnerId}`, options);
  }
  verify(options) {
    return RequestHelper.post()(this, `runners/verify`, options);
  }
};
var SecureFiles = class extends BaseResource {
  static {
    __name(this, "SecureFiles");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/secure_files`,
      options
    );
  }
  create(projectId, name2, file, options) {
    return RequestHelper.post()(this, `projects/${projectId}/secure_files`, {
      isForm: true,
      ...options,
      file: [file.content, file.filename],
      name: name2
    });
  }
  download(projectId, secureFileId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/secure_files/${secureFileId}/download`,
      options
    );
  }
  remove(projectId, secureFileId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/secure_files/${secureFileId}`,
      options
    );
  }
  show(projectId, secureFileId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/secure_files/${secureFileId}`,
      options
    );
  }
};
var Tags = class extends BaseResource {
  static {
    __name(this, "Tags");
  }
  all(projectId, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/tags`,
      options
    );
  }
  create(projectId, tagName, ref, options) {
    return RequestHelper.post()(this, endpoint`projects/${projectId}/repository/tags`, {
      searchParams: {
        tagName,
        ref
      },
      ...options
    });
  }
  remove(projectId, tagName, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/repository/tags/${tagName}`,
      options
    );
  }
  show(projectId, tagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/tags/${tagName}`,
      options
    );
  }
  showSignature(projectId, tagName, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/repository/tags/${tagName}/signature`,
      options
    );
  }
};
var UserStarredMetricsDashboard = class extends BaseResource {
  static {
    __name(this, "UserStarredMetricsDashboard");
  }
  create(projectId, dashboardPath, options) {
    return RequestHelper.get()(
      this,
      endpoint`projects/${projectId}/metrics/user_starred_dashboards`,
      {
        dashboardPath,
        ...options
      }
    );
  }
  remove(projectId, options) {
    return RequestHelper.del()(
      this,
      endpoint`projects/${projectId}/metrics/user_starred_dashboards`,
      options
    );
  }
};
var EpicAwardEmojis = class extends ResourceAwardEmojis {
  static {
    __name(this, "EpicAwardEmojis");
  }
  constructor(options) {
    super("epics", "issues", options);
  }
};
var EpicDiscussions = class extends ResourceDiscussions {
  static {
    __name(this, "EpicDiscussions");
  }
  constructor(options) {
    super("groups", "epics", options);
  }
};
var EpicIssues = class extends BaseResource {
  static {
    __name(this, "EpicIssues");
  }
  all(groupId, epicIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/issues`,
      options
    );
  }
  assign(groupId, epicIId, epicIssueId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/issues/${epicIssueId}`,
      options
    );
  }
  edit(groupId, epicIId, epicIssueId, options) {
    return RequestHelper.put()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/issues/${epicIssueId}`,
      options
    );
  }
  remove(groupId, epicIId, epicIssueId, options) {
    return RequestHelper.del()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/issues/${epicIssueId}`,
      options
    );
  }
};
var EpicLabelEvents = class extends ResourceLabelEvents {
  static {
    __name(this, "EpicLabelEvents");
  }
  constructor(options) {
    super("groups", "epic", options);
  }
};
var EpicLinks = class extends BaseResource {
  static {
    __name(this, "EpicLinks");
  }
  all(groupId, epicIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/links`,
      options
    );
  }
  assign(groupId, epicIId, childEpicId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/links/${childEpicId}`,
      options
    );
  }
  create(groupId, epicIId, title, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/links`,
      {
        searchParams: {
          title
        },
        ...options
      }
    );
  }
  reorder(groupId, epicIId, childEpicId, options) {
    return RequestHelper.put()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/links/${childEpicId}`,
      options
    );
  }
  unassign(groupId, epicIId, childEpicId, options) {
    return RequestHelper.del()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/links/${childEpicId}`,
      options
    );
  }
};
var EpicNotes = class extends ResourceNotes {
  static {
    __name(this, "EpicNotes");
  }
  constructor(options) {
    super("groups", "epics", options);
  }
};
var Epics = class extends BaseResource {
  static {
    __name(this, "Epics");
  }
  all(groupId, options) {
    return RequestHelper.get()(this, endpoint`groups/${groupId}/epics`, options);
  }
  create(groupId, title, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/epics`, {
      title,
      ...options
    });
  }
  createTodo(groupId, epicIId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/todos`,
      options
    );
  }
  edit(groupId, epicIId, options) {
    return RequestHelper.put()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}`,
      options
    );
  }
  remove(groupId, epicIId, options) {
    return RequestHelper.del()(this, endpoint`groups/${groupId}/epics/${epicIId}`, options);
  }
  show(groupId, epicIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}`,
      options
    );
  }
};
var GroupAccessRequests = class extends ResourceAccessRequests {
  static {
    __name(this, "GroupAccessRequests");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupAccessTokens = class extends ResourceAccessTokens {
  static {
    __name(this, "GroupAccessTokens");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupActivityAnalytics = class extends BaseResource {
  static {
    __name(this, "GroupActivityAnalytics");
  }
  showIssuesCount(groupPath, options) {
    return RequestHelper.get()(
      this,
      "analytics/group_activity/issues_count",
      {
        searchParams: {
          groupPath
        },
        ...options
      }
    );
  }
  showMergeRequestsCount(groupPath, options) {
    return RequestHelper.get()(
      this,
      "analytics/group_activity/merge_requests_count",
      {
        searchParams: {
          groupPath
        },
        ...options
      }
    );
  }
  showNewMembersCount(groupPath, options) {
    return RequestHelper.get()(
      this,
      "analytics/group_activity/new_members_count",
      {
        searchParams: {
          groupPath
        },
        ...options
      }
    );
  }
};
var GroupBadges = class extends ResourceBadges {
  static {
    __name(this, "GroupBadges");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupCustomAttributes = class extends ResourceCustomAttributes {
  static {
    __name(this, "GroupCustomAttributes");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupDORA4Metrics = class extends ResourceDORA4Metrics {
  static {
    __name(this, "GroupDORA4Metrics");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupHooks = class extends ResourceHooks {
  static {
    __name(this, "GroupHooks");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupImportExports = class extends BaseResource {
  static {
    __name(this, "GroupImportExports");
  }
  download(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/export/download`,
      options
    );
  }
  import(file, path, { parentId, name: name2, ...options }) {
    return RequestHelper.post()(this, "groups/import", {
      isForm: true,
      ...options,
      file: [file.content, file.filename],
      path,
      name: name2 || path.split("/").at(0),
      parentId
    });
  }
  scheduleExport(groupId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/export`,
      options
    );
  }
};
var GroupInvitations = class extends ResourceInvitations {
  static {
    __name(this, "GroupInvitations");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupIssueBoards = class extends ResourceIssueBoards {
  static {
    __name(this, "GroupIssueBoards");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupIterations = class extends ResourceIterations {
  static {
    __name(this, "GroupIterations");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupLabels = class extends ResourceLabels {
  static {
    __name(this, "GroupLabels");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupLDAPLinks = class extends BaseResource {
  static {
    __name(this, "GroupLDAPLinks");
  }
  add(groupId, groupAccess, provider, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/ldap_group_links`, {
      groupAccess,
      provider,
      ...options
    });
  }
  all(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/ldap_group_links`,
      options
    );
  }
  remove(groupId, provider, options) {
    return RequestHelper.del()(this, endpoint`groups/${groupId}/ldap_group_links`, {
      provider,
      ...options
    });
  }
  sync(groupId, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/ldap_sync`, options);
  }
};
var GroupMembers = class extends ResourceMembers {
  static {
    __name(this, "GroupMembers");
  }
  constructor(options) {
    super("groups", options);
  }
  allBillable(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${groupId}/billable_members`,
      options
    );
  }
  allPending(groupId, options) {
    return RequestHelper.get()(this, endpoint`${groupId}/pending_members`, options);
  }
  allBillableMemberships(groupId, userId, options) {
    return RequestHelper.get()(
      this,
      endpoint`${groupId}/billable_members/${userId}/memberships`,
      options
    );
  }
  approve(groupId, userId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${groupId}/members/${userId}/approve`,
      options
    );
  }
  approveAll(groupId, options) {
    return RequestHelper.put()(
      this,
      endpoint`${groupId}/members/approve_all`,
      options
    );
  }
  removeBillable(groupId, userId, options) {
    return RequestHelper.del()(this, endpoint`${groupId}/billable_members/${userId}`, options);
  }
  removeOverrideFlag(groupId, userId, options) {
    return RequestHelper.del()(
      this,
      endpoint`${groupId}/members/${userId}/override`,
      options
    );
  }
  setOverrideFlag(groupId, userId, options) {
    return RequestHelper.post()(
      this,
      endpoint`${groupId}/members/${userId}/override`,
      options
    );
  }
};
var GroupMemberRoles = class extends BaseResource {
  static {
    __name(this, "GroupMemberRoles");
  }
  add(groupId, baseAccessLevel, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/members`, {
      baseAccessLevel,
      ...options
    });
  }
  all(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/member_roles`,
      options
    );
  }
  remove(groupId, memberRoleId, options) {
    return RequestHelper.del()(
      this,
      endpoint`groups/${groupId}/member_roles/${memberRoleId}`,
      options
    );
  }
};
var GroupMilestones = class extends ResourceMilestones {
  static {
    __name(this, "GroupMilestones");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupProtectedEnvironments = class extends ResourceProtectedEnvironments {
  static {
    __name(this, "GroupProtectedEnvironments");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupPushRules = class extends ResourcePushRules {
  static {
    __name(this, "GroupPushRules");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupRelationExports = class extends BaseResource {
  static {
    __name(this, "GroupRelationExports");
  }
  download(groupId, relation, options) {
    return RequestHelper.get()(this, endpoint`groups/${groupId}/export_relations/download`, {
      searchParams: { relation },
      ...options
    });
  }
  exportStatus(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/export_relations`,
      options
    );
  }
  scheduleExport(groupId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/export_relations`,
      options
    );
  }
};
var GroupReleases = class extends BaseResource {
  static {
    __name(this, "GroupReleases");
  }
  all(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/releases`,
      options
    );
  }
};
var GroupRepositoryStorageMoves = class extends ResourceRepositoryStorageMoves {
  static {
    __name(this, "GroupRepositoryStorageMoves");
  }
  constructor(options) {
    super("groups", options);
  }
};
var Groups = class extends BaseResource {
  static {
    __name(this, "Groups");
  }
  all(options) {
    return RequestHelper.get()(this, "groups", options);
  }
  allDescendantGroups(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/descendant_groups`,
      options
    );
  }
  allProjects(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/projects`,
      options
    );
  }
  allSharedProjects(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/projects/shared`,
      options
    );
  }
  allSubgroups(groupId, options) {
    return RequestHelper.get()(this, endpoint`groups/${groupId}/subgroups`, options);
  }
  allProvisionedUsers(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/provisioned_users`,
      options
    );
  }
  allTransferLocations(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/transfer_locations`,
      options
    );
  }
  create(name2, path, { avatar, ...options } = {}) {
    if (avatar) {
      return RequestHelper.post()(this, "groups", {
        ...options,
        isForm: true,
        avatar: [avatar.content, avatar.filename],
        name: name2,
        path
      });
    }
    return RequestHelper.post()(this, "groups", { name: name2, path, ...options });
  }
  downloadAvatar(groupId, options) {
    return RequestHelper.get()(this, endpoint`groups/${groupId}/avatar`, options);
  }
  edit(groupId, { avatar, ...options } = {}) {
    if (avatar) {
      return RequestHelper.post()(this, endpoint`groups/${groupId}`, {
        ...options,
        isForm: true,
        avatar: [avatar.content, avatar.filename]
      });
    }
    return RequestHelper.put()(this, endpoint`groups/${groupId}`, options);
  }
  remove(groupId, options) {
    return RequestHelper.del()(this, endpoint`groups/${groupId}`, options);
  }
  removeAvatar(groupId, options) {
    return RequestHelper.put()(this, endpoint`groups/${groupId}`, {
      ...options,
      avatar: ""
    });
  }
  restore(groupId, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/restore`, options);
  }
  search(nameOrPath, options) {
    return RequestHelper.get()(this, "groups", {
      search: nameOrPath,
      ...options
    });
  }
  share(groupId, sharedGroupId, groupAccess, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/share`, {
      groupId: sharedGroupId,
      groupAccess,
      ...options
    });
  }
  show(groupId, options) {
    return RequestHelper.get()(this, endpoint`groups/${groupId}`, options);
  }
  transfer(groupId, options) {
    return RequestHelper.post()(this, endpoint`groups/${groupId}/transfer`, options);
  }
  transferProject(groupId, projectId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/projects/${projectId}`,
      options
    );
  }
  unshare(groupId, sharedGroupId, options) {
    return RequestHelper.del()(this, endpoint`groups/${groupId}/share/${sharedGroupId}`, options);
  }
  uploadAvatar(groupId, content, { filename, ...options } = {}) {
    return RequestHelper.put()(this, endpoint`groups/${groupId}/avatar`, {
      isForm: true,
      ...options,
      file: [content, filename]
    });
  }
};
var GroupSAMLIdentities = class extends BaseResource {
  static {
    __name(this, "GroupSAMLIdentities");
  }
  all(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/saml/identities`,
      options
    );
  }
  edit(groupId, identityId, options) {
    return RequestHelper.patch()(
      this,
      endpoint`groups/${groupId}/saml/${identityId}`,
      options
    );
  }
};
var GroupSCIMIdentities = class extends BaseResource {
  static {
    __name(this, "GroupSCIMIdentities");
  }
  all(groupId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/scim/identities`,
      options
    );
  }
  edit(groupId, identityId, options) {
    return RequestHelper.patch()(
      this,
      endpoint`groups/${groupId}/scim/${identityId}`,
      options
    );
  }
};
var GroupVariables = class extends ResourceVariables {
  static {
    __name(this, "GroupVariables");
  }
  constructor(options) {
    super("groups", options);
  }
};
var GroupWikis = class extends ResourceWikis {
  static {
    __name(this, "GroupWikis");
  }
  constructor(options) {
    super("groups", options);
  }
};
var LinkedEpics = class extends BaseResource {
  static {
    __name(this, "LinkedEpics");
  }
  all(groupId, epicIId, options) {
    return RequestHelper.get()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/related_epics`,
      options
    );
  }
  create(groupId, epicIId, targetEpicIId, targetGroupId, options) {
    return RequestHelper.post()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/related_epics`,
      {
        searchParams: {
          targetGroupId,
          targetEpicIid: targetEpicIId
        },
        ...options
      }
    );
  }
  remove(groupId, epicIId, relatedEpicLinkId, options) {
    return RequestHelper.del()(
      this,
      endpoint`groups/${groupId}/epics/${epicIId}/related_epics/${relatedEpicLinkId}`,
      options
    );
  }
};
var UserCustomAttributes = class extends ResourceCustomAttributes {
  static {
    __name(this, "UserCustomAttributes");
  }
  constructor(options) {
    super("users", options);
  }
};
var url9 = /* @__PURE__ */ __name((userId) => userId ? `users/${userId}/emails` : "user/emails", "url9");
var UserEmails = class extends BaseResource {
  static {
    __name(this, "UserEmails");
  }
  // Convenience method for create
  add(email, options) {
    return this.create(email, options);
  }
  all({
    userId,
    ...options
  } = {}) {
    return RequestHelper.get()(
      this,
      url9(userId),
      options
    );
  }
  create(email, {
    userId,
    ...options
  } = {}) {
    return RequestHelper.post()(this, url9(userId), {
      email,
      ...options
    });
  }
  show(emailId, options) {
    return RequestHelper.get()(this, `user/emails/${emailId}`, options);
  }
  remove(emailId, { userId, ...options } = {}) {
    return RequestHelper.del()(
      this,
      `${url9(userId)}/${emailId}`,
      options
    );
  }
};
var url10 = /* @__PURE__ */ __name((userId) => userId ? `users/${userId}/gpg_keys` : "user/gpg_keys", "url10");
var UserGPGKeys = class extends BaseResource {
  static {
    __name(this, "UserGPGKeys");
  }
  // Convienence method
  add(key, options) {
    return this.create(key, options);
  }
  all({
    userId,
    ...options
  } = {}) {
    return RequestHelper.get()(this, url10(userId), options);
  }
  create(key, { userId, ...options } = {}) {
    return RequestHelper.post()(this, url10(userId), {
      key,
      ...options
    });
  }
  show(keyId, { userId, ...options } = {}) {
    return RequestHelper.get()(this, `${url10(userId)}/${keyId}`, options);
  }
  remove(keyId, { userId, ...options } = {}) {
    return RequestHelper.del()(this, `${url10(userId)}/${keyId}`, options);
  }
};
var UserImpersonationTokens = class extends BaseResource {
  static {
    __name(this, "UserImpersonationTokens");
  }
  all(userId, options) {
    return RequestHelper.get()(
      this,
      `users/${userId}/impersonation_tokens`,
      options
    );
  }
  create(userId, name2, scopes, options) {
    return RequestHelper.post()(
      this,
      `users/${userId}/impersonation_tokens`,
      {
        name: name2,
        scopes,
        ...options
      }
    );
  }
  show(userId, tokenId, options) {
    return RequestHelper.get()(
      this,
      `users/${userId}/impersonation_tokens/${tokenId}`,
      options
    );
  }
  remove(userId, tokenId, options) {
    return RequestHelper.del()(this, `users/${userId}/impersonation_tokens/${tokenId}`, options);
  }
  // Convienence method
  revoke(userId, tokenId, options) {
    return this.remove(userId, tokenId, options);
  }
};
var Users = class extends BaseResource {
  static {
    __name(this, "Users");
  }
  activate(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/activate`, options);
  }
  all(options) {
    return RequestHelper.get()(this, "users", options);
  }
  allActivities(options) {
    return RequestHelper.get()(this, "user/activities", options);
  }
  allEvents(userId, options) {
    return RequestHelper.get()(this, endpoint`users/${userId}/events`, options);
  }
  allFollowers(userId, options) {
    return RequestHelper.get()(this, endpoint`users/${userId}/followers`, options);
  }
  allFollowing(userId, options) {
    return RequestHelper.get()(this, endpoint`users/${userId}/following`, options);
  }
  allMemberships(userId, options) {
    return RequestHelper.get()(
      this,
      endpoint`users/${userId}/memberships`,
      options
    );
  }
  allProjects(userId, options) {
    return RequestHelper.get()(this, endpoint`users/${userId}/projects`, options);
  }
  allContributedProjects(userId, options) {
    return RequestHelper.get()(
      this,
      endpoint`users/${userId}/contributed_projects`,
      options
    );
  }
  allStarredProjects(userId, options) {
    return RequestHelper.get()(
      this,
      endpoint`users/${userId}/starred_projects`,
      options
    );
  }
  approve(userId, options) {
    return RequestHelper.post()(
      this,
      endpoint`users/${userId}/approve`,
      options
    );
  }
  ban(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/ban`, options);
  }
  block(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/block`, options);
  }
  deactivate(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/deactivate`, options);
  }
  disableTwoFactor(userId, options) {
    return RequestHelper.patch()(this, endpoint`users/${userId}/disable_two_factor`, options);
  }
  follow(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/follow`, options);
  }
  create(options) {
    return RequestHelper.post()(this, "users", options);
  }
  createPersonalAccessToken(userId, name2, scopes, options) {
    return RequestHelper.post()(
      this,
      endpoint`users/${userId}/personal_access_tokens`,
      {
        name: name2,
        scopes,
        ...options
      }
    );
  }
  createCIRunner(runnerType, options) {
    return RequestHelper.post()(this, "user/runners", {
      ...options,
      runnerType
    });
  }
  edit(userId, options) {
    return RequestHelper.put()(this, endpoint`users/${userId}`, options);
  }
  editStatus(options) {
    return RequestHelper.put()(this, "user/status", options);
  }
  editCurrentUserPreferences(viewDiffsFileByFile, showWhitespaceInDiffs, options) {
    return RequestHelper.get()(this, "user/preferences", {
      viewDiffsFileByFile,
      showWhitespaceInDiffs,
      ...options
    });
  }
  reject(userId, options) {
    return RequestHelper.post()(
      this,
      endpoint`users/${userId}/reject`,
      options
    );
  }
  show(userId, options) {
    return RequestHelper.get()(
      this,
      endpoint`users/${userId}`,
      options
    );
  }
  showCount(options) {
    return RequestHelper.get()(this, "user_counts", options);
  }
  showAssociationsCount(userId, options) {
    return RequestHelper.get()(
      this,
      `users/${userId}/associations_count`,
      options
    );
  }
  showCurrentUser(options) {
    return RequestHelper.get()(this, "user", options);
  }
  showCurrentUserPreferences(options) {
    return RequestHelper.get()(this, "user/preferences", options);
  }
  showStatus(options) {
    let url12;
    if (options?.iDOrUsername)
      url12 = `users/${options?.iDOrUsername}/status`;
    else
      url12 = "user/status";
    return RequestHelper.get()(this, url12, options);
  }
  remove(userId, options) {
    return RequestHelper.del()(this, endpoint`users/${userId}`, options);
  }
  removeAuthenticationIdentity(userId, provider, options) {
    return RequestHelper.del()(this, endpoint`users/${userId}/identities/${provider}`, options);
  }
  unban(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/unban`, options);
  }
  unblock(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/unblock`, options);
  }
  unfollow(userId, options) {
    return RequestHelper.post()(this, endpoint`users/${userId}/unfollow`, options);
  }
};
var url11 = /* @__PURE__ */ __name((userId) => userId ? `users/${userId}/keys` : "user/keys", "url11");
var UserSSHKeys = class extends BaseResource {
  static {
    __name(this, "UserSSHKeys");
  }
  // Convienence method for create
  add(title, key, options) {
    return this.create(title, key, options);
  }
  all({
    userId,
    ...options
  } = {}) {
    return RequestHelper.get()(
      this,
      url11(userId),
      options
    );
  }
  create(title, key, {
    userId,
    ...options
  } = {}) {
    return RequestHelper.post()(this, url11(userId), {
      title,
      key,
      ...options
    });
  }
  show(keyId, { userId, ...options } = {}) {
    return RequestHelper.get()(
      this,
      `${url11(userId)}/${keyId}`,
      options
    );
  }
  remove(keyId, { userId, ...options } = {}) {
    return RequestHelper.del()(this, `${url11(userId)}/${keyId}`, options);
  }
};
var resources = {
  Agents,
  AlertManagement,
  ApplicationAppearance,
  ApplicationPlanLimits,
  Applications,
  ApplicationSettings,
  ApplicationStatistics,
  AuditEvents,
  Avatar,
  BroadcastMessages,
  Composer,
  Conan,
  DashboardAnnotations,
  Debian,
  DependencyProxy,
  DeployKeys,
  DeployTokens,
  DockerfileTemplates,
  Events,
  Experiments,
  GeoNodes,
  GitignoreTemplates,
  GitLabCIYMLTemplates,
  Import,
  InstanceLevelCICDVariables,
  Keys,
  License,
  LicenseTemplates,
  Lint,
  Markdown,
  Maven,
  Metadata,
  Migrations,
  Namespaces,
  NotificationSettings,
  NPM,
  NuGet,
  PersonalAccessTokens,
  PyPI,
  RubyGems,
  Search,
  ServiceData,
  SidekiqMetrics,
  SidekiqQueues,
  SnippetRepositoryStorageMoves,
  Snippets,
  Suggestions,
  SystemHooks,
  TodoLists,
  Topics,
  Branches,
  CommitDiscussions,
  Commits,
  ContainerRegistry,
  Deployments,
  Environments,
  ErrorTrackingClientKeys,
  ErrorTrackingSettings,
  ExternalStatusChecks,
  FeatureFlags,
  FeatureFlagUserLists,
  FreezePeriods,
  GitlabPages,
  GoProxy,
  Helm,
  Integrations,
  IssueAwardEmojis,
  IssueDiscussions,
  IssueIterationEvents,
  IssueLabelEvents,
  IssueLinks,
  IssueMilestoneEvents,
  IssueNoteAwardEmojis,
  IssueNotes,
  Issues,
  IssuesStatistics,
  IssueStateEvents,
  IssueWeightEvents,
  JobArtifacts,
  Jobs,
  MergeRequestApprovals,
  MergeRequestAwardEmojis,
  MergeRequestContextCommits,
  MergeRequestDiscussions,
  MergeRequestLabelEvents,
  MergeRequestMilestoneEvents,
  MergeRequestDraftNotes,
  MergeRequestNotes,
  MergeRequestNoteAwardEmojis,
  MergeRequests,
  MergeTrains,
  PackageRegistry,
  Packages,
  PagesDomains,
  Pipelines,
  PipelineSchedules,
  PipelineScheduleVariables,
  PipelineTriggerTokens,
  ProductAnalytics,
  ProjectAccessRequests,
  ProjectAccessTokens,
  ProjectAliases,
  ProjectBadges,
  ProjectCustomAttributes,
  ProjectDORA4Metrics,
  ProjectHooks,
  ProjectImportExports,
  ProjectInvitations,
  ProjectIssueBoards,
  ProjectIterations,
  ProjectLabels,
  ProjectMembers,
  ProjectMilestones,
  ProjectProtectedEnvironments,
  ProjectPushRules,
  ProjectRelationsExport,
  ProjectReleases,
  ProjectRemoteMirrors,
  ProjectRepositoryStorageMoves,
  Projects,
  ProjectSnippetAwardEmojis,
  ProjectSnippetDiscussions,
  ProjectSnippetNotes,
  ProjectSnippets,
  ProjectStatistics,
  ProjectTemplates,
  ProjectVariables,
  ProjectVulnerabilities,
  ProjectWikis,
  ProtectedBranches,
  ProtectedTags,
  ReleaseLinks,
  Repositories,
  RepositoryFiles,
  RepositorySubmodules,
  ResourceGroups,
  Runners,
  SecureFiles,
  Tags,
  UserStarredMetricsDashboard,
  EpicAwardEmojis,
  EpicDiscussions,
  EpicIssues,
  EpicLabelEvents,
  EpicLinks,
  EpicNotes,
  Epics,
  GroupAccessRequests,
  GroupAccessTokens,
  GroupActivityAnalytics,
  GroupBadges,
  GroupCustomAttributes,
  GroupDORA4Metrics,
  GroupHooks,
  GroupImportExports,
  GroupInvitations,
  GroupIssueBoards,
  GroupIterations,
  GroupLabels,
  GroupLDAPLinks,
  GroupMembers,
  GroupMemberRoles,
  GroupMilestones,
  GroupProtectedEnvironments,
  GroupPushRules,
  GroupRelationExports,
  GroupReleases,
  GroupRepositoryStorageMoves,
  Groups,
  GroupSAMLIdentities,
  GroupSCIMIdentities,
  GroupVariables,
  GroupWikis,
  LinkedEpics,
  UserCustomAttributes,
  UserEmails,
  UserGPGKeys,
  UserImpersonationTokens,
  Users,
  UserSSHKeys
};
var Gitlab = class extends BaseResource {
  static {
    __name(this, "Gitlab");
  }
  constructor(options) {
    super(options);
    Object.keys(resources).forEach((s10) => {
      this[s10] = new resources[s10](options);
    });
  }
};

// ../../node_modules/@gitbeaker/rest/dist/index.mjs
async function defaultOptionsHandler2(resourceOptions, requestOptions) {
  const options = { ...requestOptions };
  if (resourceOptions.url.includes("https") && resourceOptions.rejectUnauthorized != null && resourceOptions.rejectUnauthorized === false) {
    if (typeof window !== "object") {
      const { Agent } = await import("https");
      options.agent = new Agent({
        rejectUnauthorized: false
      });
    }
  }
  return options;
}
__name(defaultOptionsHandler2, "defaultOptionsHandler");
async function processBody(response) {
  const contentType = (response.headers.get("content-type") || "").split(";")[0].trim();
  if (contentType === "application/json") {
    return response.json().then((v7) => v7 || {});
  }
  if (contentType.startsWith("text/")) {
    return response.text().then((t6) => t6 || "");
  }
  return response.blob();
}
__name(processBody, "processBody");
function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
__name(delay, "delay");
async function parseResponse(response, asStream = false) {
  const { status, headers: rawHeaders } = response;
  const headers = Object.fromEntries(rawHeaders.entries());
  let body;
  if (asStream) {
    body = response.body;
  } else {
    body = status === 204 ? null : await processBody(response);
  }
  return { body, headers, status };
}
__name(parseResponse, "parseResponse");
async function throwFailedRequestError(request3, response) {
  const content = await response.text();
  const contentType = response.headers.get("Content-Type");
  let description = "API Request Error";
  if (contentType?.includes("application/json")) {
    const output = JSON.parse(content);
    description = JSON.stringify(output.error || output.message, null, 2);
  } else {
    description = content;
  }
  throw new Error(response.statusText, {
    cause: {
      description,
      request: request3,
      response
    }
  });
}
__name(throwFailedRequestError, "throwFailedRequestError");
function getConditionalMode(endpoint3) {
  if (endpoint3.includes("repository/archive"))
    return "same-origin";
  return void 0;
}
__name(getConditionalMode, "getConditionalMode");
async function defaultRequestHandler(endpoint3, options) {
  const retryCodes = [429, 502];
  const maxRetries = 10;
  const { prefixUrl, asStream, searchParams, ...opts } = options || {};
  let baseUrl;
  if (prefixUrl)
    baseUrl = prefixUrl.endsWith("/") ? prefixUrl : `${prefixUrl}/`;
  const url12 = new URL(endpoint3, baseUrl);
  url12.search = searchParams || "";
  const mode = getConditionalMode(endpoint3);
  for (let i10 = 0; i10 < maxRetries; i10 += 1) {
    const request3 = new Request(url12, { ...opts, mode });
    const response = await fetch(request3).catch((e10) => {
      if (e10.name === "TimeoutError" || e10.name === "AbortError") {
        throw new Error("Query timeout was reached");
      }
      throw e10;
    });
    if (response.ok)
      return parseResponse(response, asStream);
    if (!retryCodes.includes(response.status))
      await throwFailedRequestError(request3, response);
    await delay(2 ** i10 * 0.25);
    continue;
  }
  throw new Error(
    `Could not successfully complete this request due to Error 429. Check the applicable rate limits for this endpoint.`
  );
}
__name(defaultRequestHandler, "defaultRequestHandler");
var requesterFn = createRequesterFn(defaultOptionsHandler2, defaultRequestHandler);
var API = presetResourceArguments(dist_exports, { requesterFn });
var {
  Agents: Agents2,
  AlertManagement: AlertManagement2,
  ApplicationAppearance: ApplicationAppearance2,
  ApplicationPlanLimits: ApplicationPlanLimits2,
  Applications: Applications2,
  ApplicationSettings: ApplicationSettings2,
  ApplicationStatistics: ApplicationStatistics2,
  AuditEvents: AuditEvents2,
  Avatar: Avatar2,
  BroadcastMessages: BroadcastMessages2,
  Composer: Composer2,
  Conan: Conan2,
  DashboardAnnotations: DashboardAnnotations2,
  Debian: Debian2,
  DependencyProxy: DependencyProxy2,
  DeployKeys: DeployKeys2,
  DeployTokens: DeployTokens2,
  DockerfileTemplates: DockerfileTemplates2,
  Events: Events2,
  Experiments: Experiments2,
  GeoNodes: GeoNodes2,
  GitignoreTemplates: GitignoreTemplates2,
  GitLabCIYMLTemplates: GitLabCIYMLTemplates2,
  Import: Import2,
  InstanceLevelCICDVariables: InstanceLevelCICDVariables2,
  Keys: Keys2,
  License: License2,
  LicenseTemplates: LicenseTemplates2,
  Lint: Lint2,
  Markdown: Markdown2,
  Maven: Maven2,
  Metadata: Metadata2,
  Migrations: Migrations2,
  Namespaces: Namespaces2,
  NotificationSettings: NotificationSettings2,
  NPM: NPM2,
  NuGet: NuGet2,
  PersonalAccessTokens: PersonalAccessTokens2,
  PyPI: PyPI2,
  RubyGems: RubyGems2,
  Search: Search2,
  ServiceData: ServiceData2,
  SidekiqMetrics: SidekiqMetrics2,
  SidekiqQueues: SidekiqQueues2,
  SnippetRepositoryStorageMoves: SnippetRepositoryStorageMoves2,
  Snippets: Snippets2,
  Suggestions: Suggestions2,
  SystemHooks: SystemHooks2,
  TodoLists: TodoLists2,
  Topics: Topics2,
  Branches: Branches2,
  CommitDiscussions: CommitDiscussions2,
  Commits: Commits2,
  ContainerRegistry: ContainerRegistry2,
  Deployments: Deployments2,
  Environments: Environments2,
  ErrorTrackingClientKeys: ErrorTrackingClientKeys2,
  ErrorTrackingSettings: ErrorTrackingSettings2,
  ExternalStatusChecks: ExternalStatusChecks2,
  FeatureFlags: FeatureFlags2,
  FeatureFlagUserLists: FeatureFlagUserLists2,
  FreezePeriods: FreezePeriods2,
  GitlabPages: GitlabPages2,
  GoProxy: GoProxy2,
  Helm: Helm2,
  Integrations: Integrations2,
  IssueAwardEmojis: IssueAwardEmojis2,
  IssueDiscussions: IssueDiscussions2,
  IssueIterationEvents: IssueIterationEvents2,
  IssueLabelEvents: IssueLabelEvents2,
  IssueLinks: IssueLinks2,
  IssueMilestoneEvents: IssueMilestoneEvents2,
  IssueNoteAwardEmojis: IssueNoteAwardEmojis2,
  IssueNotes: IssueNotes2,
  Issues: Issues2,
  IssuesStatistics: IssuesStatistics2,
  IssueStateEvents: IssueStateEvents2,
  IssueWeightEvents: IssueWeightEvents2,
  JobArtifacts: JobArtifacts2,
  Jobs: Jobs2,
  MergeRequestApprovals: MergeRequestApprovals2,
  MergeRequestAwardEmojis: MergeRequestAwardEmojis2,
  MergeRequestContextCommits: MergeRequestContextCommits2,
  MergeRequestDiscussions: MergeRequestDiscussions2,
  MergeRequestLabelEvents: MergeRequestLabelEvents2,
  MergeRequestMilestoneEvents: MergeRequestMilestoneEvents2,
  MergeRequestDraftNotes: MergeRequestDraftNotes2,
  MergeRequestNotes: MergeRequestNotes2,
  MergeRequestNoteAwardEmojis: MergeRequestNoteAwardEmojis2,
  MergeRequests: MergeRequests2,
  MergeTrains: MergeTrains2,
  PackageRegistry: PackageRegistry2,
  Packages: Packages2,
  PagesDomains: PagesDomains2,
  Pipelines: Pipelines2,
  PipelineSchedules: PipelineSchedules2,
  PipelineScheduleVariables: PipelineScheduleVariables2,
  PipelineTriggerTokens: PipelineTriggerTokens2,
  ProductAnalytics: ProductAnalytics2,
  ProjectAccessRequests: ProjectAccessRequests2,
  ProjectAccessTokens: ProjectAccessTokens2,
  ProjectAliases: ProjectAliases2,
  ProjectBadges: ProjectBadges2,
  ProjectCustomAttributes: ProjectCustomAttributes2,
  ProjectDORA4Metrics: ProjectDORA4Metrics2,
  ProjectHooks: ProjectHooks2,
  ProjectImportExports: ProjectImportExports2,
  ProjectInvitations: ProjectInvitations2,
  ProjectIssueBoards: ProjectIssueBoards2,
  ProjectIterations: ProjectIterations2,
  ProjectLabels: ProjectLabels2,
  ProjectMembers: ProjectMembers2,
  ProjectMilestones: ProjectMilestones2,
  ProjectProtectedEnvironments: ProjectProtectedEnvironments2,
  ProjectPushRules: ProjectPushRules2,
  ProjectRelationsExport: ProjectRelationsExport2,
  ProjectReleases: ProjectReleases2,
  ProjectRemoteMirrors: ProjectRemoteMirrors2,
  ProjectRepositoryStorageMoves: ProjectRepositoryStorageMoves2,
  Projects: Projects2,
  ProjectSnippetAwardEmojis: ProjectSnippetAwardEmojis2,
  ProjectSnippetDiscussions: ProjectSnippetDiscussions2,
  ProjectSnippetNotes: ProjectSnippetNotes2,
  ProjectSnippets: ProjectSnippets2,
  ProjectStatistics: ProjectStatistics2,
  ProjectTemplates: ProjectTemplates2,
  ProjectVariables: ProjectVariables2,
  ProjectVulnerabilities: ProjectVulnerabilities2,
  ProjectWikis: ProjectWikis2,
  ProtectedBranches: ProtectedBranches2,
  ProtectedTags: ProtectedTags2,
  ReleaseLinks: ReleaseLinks2,
  Repositories: Repositories2,
  RepositoryFiles: RepositoryFiles2,
  RepositorySubmodules: RepositorySubmodules2,
  ResourceGroups: ResourceGroups2,
  Runners: Runners2,
  SecureFiles: SecureFiles2,
  Tags: Tags2,
  UserStarredMetricsDashboard: UserStarredMetricsDashboard2,
  EpicAwardEmojis: EpicAwardEmojis2,
  EpicDiscussions: EpicDiscussions2,
  EpicIssues: EpicIssues2,
  EpicLabelEvents: EpicLabelEvents2,
  EpicLinks: EpicLinks2,
  EpicNotes: EpicNotes2,
  Epics: Epics2,
  GroupAccessRequests: GroupAccessRequests2,
  GroupAccessTokens: GroupAccessTokens2,
  GroupActivityAnalytics: GroupActivityAnalytics2,
  GroupBadges: GroupBadges2,
  GroupCustomAttributes: GroupCustomAttributes2,
  GroupDORA4Metrics: GroupDORA4Metrics2,
  GroupHooks: GroupHooks2,
  GroupImportExports: GroupImportExports2,
  GroupInvitations: GroupInvitations2,
  GroupIssueBoards: GroupIssueBoards2,
  GroupIterations: GroupIterations2,
  GroupLabels: GroupLabels2,
  GroupLDAPLinks: GroupLDAPLinks2,
  GroupMembers: GroupMembers2,
  GroupMemberRoles: GroupMemberRoles2,
  GroupMilestones: GroupMilestones2,
  GroupProtectedEnvironments: GroupProtectedEnvironments2,
  GroupPushRules: GroupPushRules2,
  GroupRelationExports: GroupRelationExports2,
  GroupReleases: GroupReleases2,
  GroupRepositoryStorageMoves: GroupRepositoryStorageMoves2,
  Groups: Groups2,
  GroupSAMLIdentities: GroupSAMLIdentities2,
  GroupSCIMIdentities: GroupSCIMIdentities2,
  GroupVariables: GroupVariables2,
  GroupWikis: GroupWikis2,
  LinkedEpics: LinkedEpics2,
  UserCustomAttributes: UserCustomAttributes2,
  UserEmails: UserEmails2,
  UserGPGKeys: UserGPGKeys2,
  UserImpersonationTokens: UserImpersonationTokens2,
  Users: Users2,
  UserSSHKeys: UserSSHKeys2,
  Gitlab: Gitlab2
} = API;

// ../../packages/integrations/source-control/src/gitlab/index.ts
var GitlabSourceControl = class {
  static {
    __name(this, "GitlabSourceControl");
  }
  constructor(token) {
    this.api = new Gitlab2({
      oauthToken: token
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await, @typescript-eslint/no-unused-vars
  async fetchUserInfo(_username) {
    throw new Error("Method not implemented.");
  }
  async fetchNamespaceMembers(externalNamespaceId, _namespaceName, page, perPage) {
    const { data, paginationInfo } = await this.api.GroupMembers.all(externalNamespaceId, {
      perPage,
      page: page || 1,
      pagination: "offset",
      showExpanded: true
    });
    return {
      members: data.map((member) => ({
        externalId: member.id,
        name: member.name,
        username: member.username
      })),
      pagination: {
        page: paginationInfo.current,
        perPage: paginationInfo.perPage,
        totalPages: paginationInfo.totalPages
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async fetchRepository(externalRepositoryId, namespaceName, repositoryName) {
    const project = await this.api.Projects.show(externalRepositoryId);
    const namespace = project.namespace;
    return {
      repository: {
        externalId: project.id,
        name: project.name
      },
      namespace: {
        externalId: namespace.id,
        name: namespace.name
      }
    };
  }
  async fetchMembers(externalRepositoryId, namespaceName, repositoryName, page, perPage) {
    const { data, paginationInfo } = await this.api.ProjectMembers.all(externalRepositoryId, {
      includeInherited: true,
      perPage,
      page: page || 1,
      pagination: "offset",
      showExpanded: true
    });
    return {
      members: data.map((member) => ({
        externalId: member.id,
        name: member.name,
        username: member.username,
        email: member.email
      })),
      pagination: {
        page: paginationInfo.current,
        perPage: paginationInfo.perPage,
        totalPages: paginationInfo.totalPages
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async fetchMergeRequests(externalRepositoryId, namespaceName = "", repositoryName = "", repositoryId, creationPeriod = {}, page, perPage) {
    const { data, paginationInfo } = await this.api.MergeRequests.all({
      projectId: externalRepositoryId,
      page: page || 1,
      perPage,
      pagination: "offset",
      showExpanded: true,
      createdAfter: creationPeriod.from?.toISOString(),
      createdBefore: creationPeriod.to?.toISOString()
    });
    return {
      mergeRequests: data.map((mr) => ({
        externalId: mr.id,
        mergeRequestId: mr.iid,
        repositoryId,
        title: mr.title,
        webUrl: mr.web_url,
        createdAt: new Date(mr.created_at),
        updatedAt: mr.updated_at ? new Date(mr.updated_at) : void 0,
        mergedAt: mr.merged_at ? new Date(mr.merged_at) : void 0,
        closedAt: mr.closed_at ? new Date(mr.closed_at) : void 0,
        authorExternalId: mr.author?.id,
        state: mr.state,
        targetBranch: mr.target_branch,
        sourceBranch: mr.source_branch
      })),
      pagination: {
        page: paginationInfo.current,
        perPage: paginationInfo.perPage,
        totalPages: paginationInfo.totalPages
      }
    };
  }
  async fetchMergeRequestDiffs(repository, namespace, mergeRequest, page, perPage) {
    const { data, paginationInfo } = await this.api.MergeRequests.allDiffs(repository.externalId, mergeRequest.mergeRequestId, {
      showExpanded: true,
      page: page || 1,
      perPage,
      pagination: "offset"
    });
    return {
      mergeRequestDiffs: data.map((mergeRequestDiff) => ({
        mergeRequestId: mergeRequest.mergeRequestId,
        diff: mergeRequestDiff.diff,
        newPath: mergeRequestDiff.new_path,
        oldPath: mergeRequestDiff.old_path,
        aMode: mergeRequestDiff.a_mode,
        bMode: mergeRequestDiff.b_mode,
        newFile: mergeRequestDiff.new_file,
        renamedFile: mergeRequestDiff.renamed_file,
        deletedFile: mergeRequestDiff.deleted_file
      })),
      pagination: {
        page: paginationInfo.current,
        perPage: paginationInfo.perPage,
        totalPages: paginationInfo.totalPages
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async fetchMergeRequestCommits(repository, namespace, mergeRequest, creationPeriod = {}) {
    const { data } = await this.api.MergeRequests.allCommits(
      repository.externalId,
      mergeRequest.mergeRequestId,
      {
        showExpanded: true
      }
    );
    return {
      mergeRequestCommits: data.map((mrc) => ({
        mergeRequestId: mergeRequest.mergeRequestId,
        externalId: mrc.id,
        createdAt: new Date(mrc.created_at),
        authoredDate: new Date(mrc.authored_date || ""),
        committedDate: new Date(mrc.committed_date || ""),
        title: mrc.title,
        message: mrc.message,
        authorName: mrc.author_name || "",
        authorEmail: mrc.author_email || "",
        committerName: mrc.committer_name || "",
        committerEmail: mrc.committer_email || ""
      }))
    };
  }
  async fetchMergeRequestNotes(repository, namespace, mergeRequest) {
    const { data } = await this.api.MergeRequestNotes.all(repository.externalId, mergeRequest.mergeRequestId, {
      showExpanded: true
    });
    return {
      mergeRequestNotes: data.map((mergeRequestNote) => ({
        externalId: mergeRequestNote.id,
        mergeRequestId: mergeRequest.id,
        createdAt: new Date(mergeRequestNote.created_at),
        updatedAt: new Date(mergeRequestNote.updated_at),
        authorUsername: mergeRequestNote.author.username,
        authorExternalId: mergeRequestNote.author.id
      }))
    };
  }
};

// ../../node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}
__name(getUserAgent, "getUserAgent");

// ../../node_modules/@octokit/core/dist-web/index.js
var import_before_after_hook = __toESM(require_before_after_hook());

// ../../node_modules/@octokit/endpoint/dist-src/version.js
var VERSION2 = "9.0.0";

// ../../node_modules/@octokit/endpoint/dist-src/defaults.js
var userAgent = `octokit-endpoint.js/${VERSION2} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};

// ../../node_modules/@octokit/endpoint/dist-src/util/lowercase-keys.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
__name(lowercaseKeys, "lowercaseKeys");

// ../../node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o10) {
  return Object.prototype.toString.call(o10) === "[object Object]";
}
__name(isObject, "isObject");
function isPlainObject(o10) {
  var ctor, prot;
  if (isObject(o10) === false)
    return false;
  ctor = o10.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
__name(isPlainObject, "isPlainObject");

// ../../node_modules/@octokit/endpoint/dist-src/util/merge-deep.js
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
__name(mergeDeep, "mergeDeep");

// ../../node_modules/@octokit/endpoint/dist-src/util/remove-undefined-properties.js
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
__name(removeUndefinedProperties, "removeUndefinedProperties");

// ../../node_modules/@octokit/endpoint/dist-src/merge.js
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url12] = route.split(" ");
    options = Object.assign(url12 ? { method, url: url12 } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
__name(merge, "merge");

// ../../node_modules/@octokit/endpoint/dist-src/util/add-query-parameters.js
function addQueryParameters(url12, parameters2) {
  const separator = /\?/.test(url12) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url12;
  }
  return url12 + separator + names.map((name2) => {
    if (name2 === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name2}=${encodeURIComponent(parameters2[name2])}`;
  }).join("&");
}
__name(addQueryParameters, "addQueryParameters");

// ../../node_modules/@octokit/endpoint/dist-src/util/extract-url-variable-names.js
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
__name(removeNonChars, "removeNonChars");
function extractUrlVariableNames(url12) {
  const matches = url12.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a10, b11) => a10.concat(b11), []);
}
__name(extractUrlVariableNames, "extractUrlVariableNames");

// ../../node_modules/@octokit/endpoint/dist-src/util/omit.js
function omit(object, keysToOmit) {
  return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}
__name(omit, "omit");

// ../../node_modules/@octokit/endpoint/dist-src/util/url-template.js
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
__name(encodeReserved, "encodeReserved");
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c11) {
    return "%" + c11.charCodeAt(0).toString(16).toUpperCase();
  });
}
__name(encodeUnreserved, "encodeUnreserved");
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
__name(encodeValue, "encodeValue");
function isDefined(value) {
  return value !== void 0 && value !== null;
}
__name(isDefined, "isDefined");
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
__name(isKeyOperator, "isKeyOperator");
function getValues(context8, operator, key, modifier) {
  var value = context8[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k10) {
            if (isDefined(value[k10])) {
              result.push(encodeValue(operator, value[k10], k10));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k10) {
            if (isDefined(value[k10])) {
              tmp.push(encodeUnreserved(k10));
              tmp.push(encodeValue(operator, value[k10].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
__name(getValues, "getValues");
function parseUrl2(template) {
  return {
    expand: expand.bind(null, template)
  };
}
__name(parseUrl2, "parseUrl");
function expand(template, context8) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context8, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
}
__name(expand, "expand");

// ../../node_modules/@octokit/endpoint/dist-src/parse.js
function parse3(options) {
  let method = options.method.toUpperCase();
  let url12 = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url12);
  url12 = parseUrl2(url12).expand(parameters2);
  if (!/^http/.test(url12)) {
    url12 = options.baseUrl + url12;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url12.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url12 = addQueryParameters(url12, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url: url12, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
__name(parse3, "parse");

// ../../node_modules/@octokit/endpoint/dist-src/endpoint-with-defaults.js
function endpointWithDefaults(defaults, route, options) {
  return parse3(merge(defaults, route, options));
}
__name(endpointWithDefaults, "endpointWithDefaults");

// ../../node_modules/@octokit/endpoint/dist-src/with-defaults.js
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint3 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint3, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse: parse3
  });
}
__name(withDefaults, "withDefaults");

// ../../node_modules/@octokit/endpoint/dist-src/index.js
var endpoint2 = withDefaults(null, DEFAULTS);

// ../../node_modules/@octokit/request/dist-src/version.js
var VERSION3 = "8.1.1";

// ../../node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  static {
    __name(this, "Deprecation");
  }
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// ../../node_modules/@octokit/request-error/dist-src/index.js
var import_once = __toESM(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  static {
    __name(this, "RequestError");
  }
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(
          new Deprecation(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        );
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(
          new Deprecation(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        );
        return headers || {};
      }
    });
  }
};

// ../../node_modules/@octokit/request/dist-src/get-buffer-response.js
function getBufferResponse(response) {
  return response.arrayBuffer();
}
__name(getBufferResponse, "getBufferResponse");

// ../../node_modules/@octokit/request/dist-src/fetch-wrapper.js
function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url12;
  let { fetch: fetch4 } = globalThis;
  if (requestOptions.request?.fetch) {
    fetch4 = requestOptions.request.fetch;
  }
  if (!fetch4) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch4(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    signal: requestOptions.request?.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url12 = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url: url12,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url: url12,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url: url12,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url: url12,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    throw new RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}
__name(fetchWrapper, "fetchWrapper");
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json();
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
__name(getResponseData, "getResponseData");
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
__name(toErrorMessage, "toErrorMessage");

// ../../node_modules/@octokit/request/dist-src/with-defaults.js
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint3 = oldEndpoint.defaults(newDefaults);
  const newApi = /* @__PURE__ */ __name(function(route, parameters2) {
    const endpointOptions = endpoint3.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint3.parse(endpointOptions));
    }
    const request3 = /* @__PURE__ */ __name((route2, parameters22) => {
      return fetchWrapper(
        endpoint3.parse(endpoint3.merge(route2, parameters22))
      );
    }, "request");
    Object.assign(request3, {
      endpoint: endpoint3,
      defaults: withDefaults2.bind(null, endpoint3)
    });
    return endpointOptions.request.hook(request3, endpointOptions);
  }, "newApi");
  return Object.assign(newApi, {
    endpoint: endpoint3,
    defaults: withDefaults2.bind(null, endpoint3)
  });
}
__name(withDefaults2, "withDefaults");

// ../../node_modules/@octokit/request/dist-src/index.js
var request2 = withDefaults2(endpoint2, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION3} ${getUserAgent()}`
  }
});

// ../../node_modules/@octokit/graphql/dist-web/index.js
var VERSION4 = "7.0.1";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e10) => ` - ${e10.message}`).join("\n");
}
__name(_buildMessageForResponseErrors, "_buildMessageForResponseErrors");
var GraphqlResponseError = class extends Error {
  static {
    __name(this, "GraphqlResponseError");
  }
  constructor(request22, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request22;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request22, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request22.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request22(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
__name(graphql, "graphql");
function withDefaults3(request22, newDefaults) {
  const newRequest = request22.defaults(newDefaults);
  const newApi = /* @__PURE__ */ __name((query, options) => {
    return graphql(newRequest, query, options);
  }, "newApi");
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
__name(withDefaults3, "withDefaults");
var graphql2 = withDefaults3(request2, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION4} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}
__name(withCustomRequest, "withCustomRequest");

// ../../node_modules/@octokit/auth-token/dist-src/auth.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
__name(auth, "auth");

// ../../node_modules/@octokit/auth-token/dist-src/with-authorization-prefix.js
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
__name(withAuthorizationPrefix, "withAuthorizationPrefix");

// ../../node_modules/@octokit/auth-token/dist-src/hook.js
async function hook(token, request3, route, parameters2) {
  const endpoint3 = request3.endpoint.merge(
    route,
    parameters2
  );
  endpoint3.headers.authorization = withAuthorizationPrefix(token);
  return request3(endpoint3);
}
__name(hook, "hook");

// ../../node_modules/@octokit/auth-token/dist-src/index.js
var createTokenAuth = /* @__PURE__ */ __name(function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
}, "createTokenAuth2");

// ../../node_modules/@octokit/core/dist-web/index.js
var VERSION5 = "5.0.0";
var Octokit = class {
  static {
    __name(this, "Octokit");
  }
  static {
    this.VERSION = VERSION5;
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      static {
        __name(this, "OctokitWithDefaults");
      }
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  static {
    this.plugins = [];
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static {
        __name(this, "NewOctokit");
      }
      static {
        this.plugins = currentPlugins.concat(
          newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
        );
      }
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook2 = new import_before_after_hook.Collection();
    const requestDefaults = {
      baseUrl: request2.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = [
      options.userAgent,
      `octokit-core.js/${VERSION5} ${getUserAgent()}`
    ].filter(Boolean).join(" ");
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request2.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: () => {
        },
        info: () => {
        },
        warn: console.warn.bind(console),
        error: console.error.bind(console)
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    classConstructor.plugins.forEach((plugin) => {
      Object.assign(this, plugin(this, options));
    });
  }
};

// ../../node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION6 = "4.0.0";

// ../../node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
  octokit.hook.wrap("request", (request3, options) => {
    octokit.log.debug("request", options);
    const start = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path = requestOptions.url.replace(options.baseUrl, "");
    return request3(options).then((response) => {
      octokit.log.info(
        `${requestOptions.method} ${path} - ${response.status} in ${Date.now() - start}ms`
      );
      return response;
    }).catch((error) => {
      octokit.log.info(
        `${requestOptions.method} ${path} - ${error.status} in ${Date.now() - start}ms`
      );
      throw error;
    });
  });
}
__name(requestLog, "requestLog");
requestLog.VERSION = VERSION6;

// ../../node_modules/@octokit/plugin-paginate-rest/dist-web/index.js
var VERSION7 = "8.0.0";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
__name(normalizePaginatedListResponse, "normalizePaginatedListResponse");
function iterator(octokit, route, parameters2) {
  const options = typeof route === "function" ? route.endpoint(parameters2) : octokit.request.endpoint(route, parameters2);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url12 = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url12)
          return { done: true };
        try {
          const response = await requestMethod({ method, url: url12, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url12 = ((normalizedResponse.headers.link || "").match(
            /<([^>]+)>;\s*rel="next"/
          ) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url12 = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
__name(iterator, "iterator");
function paginate(octokit, route, parameters2, mapFn) {
  if (typeof parameters2 === "function") {
    mapFn = parameters2;
    parameters2 = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters2)[Symbol.asyncIterator](),
    mapFn
  );
}
__name(paginate, "paginate");
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    __name(done, "done");
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
__name(gather, "gather");
var composePaginateRest = Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
__name(paginateRest, "paginateRest");
paginateRest.VERSION = VERSION7;

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION8 = "9.0.0";

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    addSelectedRepoToRequiredWorkflow: [
      "PUT /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createRequiredWorkflow: ["POST /orgs/{org}/actions/required_workflows"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteRequiredWorkflow: [
      "DELETE /orgs/{org}/actions/required_workflows/{required_workflow_id}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getEnvironmentPublicKey: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoRequiredWorkflow: [
      "GET /repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}"
    ],
    getRepoRequiredWorkflowUsage: [
      "GET /repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/timing"
    ],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getRequiredWorkflow: [
      "GET /orgs/{org}/actions/required_workflows/{required_workflow_id}"
    ],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoRequiredWorkflows: [
      "GET /repos/{org}/{repo}/actions/required_workflows"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRequiredWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs"
    ],
    listRequiredWorkflows: ["GET /orgs/{org}/actions/required_workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelectedRepositoriesRequiredWorkflow: [
      "GET /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromRequiredWorkflow: [
      "DELETE /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedReposToRequiredWorkflow: [
      "PUT /orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    updateRequiredWorkflow: [
      "PATCH /orgs/{org}/actions/required_workflows/{required_workflow_id}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteCodespacesBillingUsers: [
      "DELETE /orgs/{org}/codespaces/billing/selected_users"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setCodespacesBilling: ["PUT /orgs/{org}/codespaces/billing"],
    setCodespacesBillingUsers: [
      "POST /orgs/{org}/codespaces/billing/selected_users"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: ["PUT /repos/{owner}/{repo}/import"],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /organizations/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /organizations/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: [
      "GET /organizations/{org}/personal-access-token-requests"
    ],
    listPatGrants: ["GET /organizations/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /organizations/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /organizations/{org}/personal-access-token-requests"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: [
      "POST /organizations/{org}/personal-access-tokens/{pat_id}"
    ],
    updatePatAccesses: ["POST /organizations/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployment"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
var endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint3] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint3;
    const [method, url12] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url: url12
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
var handler = {
  get({ octokit, scope, cache: cache2 }, methodName) {
    if (cache2[methodName]) {
      return cache2[methodName];
    }
    const { decorations, endpointDefaults } = endpointMethodsMap.get(scope).get(methodName);
    if (decorations) {
      cache2[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache2[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache2[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
__name(endpointsToMethods, "endpointsToMethods");
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name2, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name2 in options2) {
          octokit.log.warn(
            `"${name2}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name2];
          }
          delete options2[name2];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  __name(withDecorations, "withDecorations");
  return Object.assign(withDecorations, requestWithDefaults);
}
__name(decorate, "decorate");

// ../../node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
__name(restEndpointMethods, "restEndpointMethods");
restEndpointMethods.VERSION = VERSION8;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
__name(legacyRestEndpointMethods, "legacyRestEndpointMethods");
legacyRestEndpointMethods.VERSION = VERSION8;

// ../../node_modules/@octokit/rest/dist-web/index.js
var VERSION9 = "20.0.1";
var Octokit2 = Octokit.plugin(
  requestLog,
  legacyRestEndpointMethods,
  paginateRest
).defaults({
  userAgent: `octokit-rest.js/${VERSION9}`
});

// ../../packages/integrations/source-control/src/github/index.ts
var import_parse_link_header = __toESM(require_parse_link_header());
var FILE_STATUS_FLAGS_MAPPING = {
  "modified": {
    newFile: false,
    renamedFile: false,
    deletedFile: false
  },
  "renamed": {
    newFile: false,
    renamedFile: true,
    deletedFile: false
  },
  "added": {
    newFile: true,
    renamedFile: false,
    deletedFile: false
  },
  "changed": {
    newFile: false,
    deletedFile: false,
    renamedFile: false
  },
  "copied": {
    newFile: false,
    deletedFile: false,
    renamedFile: false
  },
  "removed": {
    newFile: false,
    deletedFile: true,
    renamedFile: false
  },
  "unchanged": {
    newFile: false,
    deletedFile: false,
    renamedFile: false
  }
};
var GitHubSourceControl = class {
  static {
    __name(this, "GitHubSourceControl");
  }
  constructor(auth2) {
    this.api = new Octokit2({
      auth: auth2
      // TODO: Need to look into https://github.com/octokit/authentication-strategies.js
    });
  }
  async fetchUserInfo(username) {
    const result = await this.api.users.getByUsername({
      username
    });
    return {
      member: {
        externalId: result.data.id,
        name: result.data.name,
        username: result.data.login,
        email: result.data.email
      }
    };
  }
  async fetchNamespaceMembers(_externalNamespaceId, namespaceName, page, perPage) {
    page = page || 1;
    perPage = perPage || 30;
    const result = await this.api.orgs.listMembers({
      org: namespaceName,
      page,
      per_page: perPage,
      affiliation: "all"
    });
    const linkHeader = (0, import_parse_link_header.default)(result.headers.link) || { next: { per_page: perPage } };
    const pagination = {
      page,
      perPage: "next" in linkHeader ? Number(linkHeader.next?.per_page) : Number(linkHeader.prev?.per_page),
      totalPages: !("last" in linkHeader) ? page : Number(linkHeader.last?.page)
    };
    return {
      members: result.data.map((member) => ({
        externalId: member.id,
        name: member.name,
        username: member.login,
        email: member.email
      })),
      pagination
    };
  }
  async fetchRepository(externalRepositoryId, namespaceName, repositoryName) {
    const result = await this.api.repos.get({
      owner: namespaceName,
      repo: repositoryName
    });
    return {
      repository: {
        externalId: result.data.id,
        name: result.data.name
      },
      namespace: {
        externalId: result.data.owner.id,
        name: result.data.owner.login
      }
    };
  }
  async fetchMembers(externalRepositoryId, namespaceName, repositoryName, page, perPage) {
    page = page || 1;
    perPage = perPage || 30;
    const result = await this.api.repos.listCollaborators({
      owner: namespaceName,
      repo: repositoryName,
      page,
      per_page: perPage,
      affiliation: "all"
    });
    const linkHeader = (0, import_parse_link_header.default)(result.headers.link) || { next: { per_page: perPage } };
    const pagination = {
      page,
      perPage: "next" in linkHeader ? Number(linkHeader.next?.per_page) : Number(linkHeader.prev?.per_page),
      totalPages: !("last" in linkHeader) ? page : Number(linkHeader.last?.page)
    };
    return {
      members: result.data.map((member) => ({
        externalId: member.id,
        name: member.name,
        username: member.login,
        email: member.email
      })),
      pagination
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async fetchMergeRequests(externalRepositoryId, namespaceName, repositoryName, repositoryId, creationPeriod = {}, page, perPage) {
    page = page || 1;
    perPage = perPage || 30;
    const result = await this.api.pulls.list({
      owner: namespaceName,
      repo: repositoryName,
      page,
      per_page: perPage,
      state: "all",
      sort: "created"
    });
    const linkHeader = (0, import_parse_link_header.default)(result.headers.link) || { next: { per_page: perPage } };
    const pagination = {
      page,
      perPage: "next" in linkHeader ? Number(linkHeader.next?.per_page) : Number(linkHeader.prev?.per_page),
      totalPages: !("last" in linkHeader) ? page : Number(linkHeader.last?.page)
    };
    return {
      mergeRequests: result.data.map((mergeRequest) => ({
        externalId: mergeRequest.id,
        mergeRequestId: mergeRequest.number,
        repositoryId,
        title: mergeRequest.title,
        webUrl: mergeRequest.url,
        createdAt: new Date(mergeRequest.created_at),
        updatedAt: new Date(mergeRequest.updated_at),
        mergedAt: mergeRequest.merged_at ? new Date(mergeRequest.merged_at) : void 0,
        closedAt: mergeRequest.closed_at ? new Date(mergeRequest.closed_at) : void 0,
        authorExternalId: mergeRequest.user?.id,
        state: mergeRequest.state,
        targetBranch: mergeRequest.base.ref,
        sourceBranch: mergeRequest.head.ref
      })),
      pagination
    };
  }
  async fetchMergeRequestDiffs(repository, namespace, mergeRequest, page, perPage) {
    page = page || 1;
    perPage = perPage || 30;
    const result = await this.api.pulls.listFiles({
      owner: namespace.name,
      repo: repository.name,
      page,
      per_page: perPage,
      pull_number: mergeRequest.mergeRequestId
    });
    const linkHeader = (0, import_parse_link_header.default)(result.headers.link) || { next: { per_page: perPage } };
    const pagination = {
      page,
      perPage: "next" in linkHeader ? Number(linkHeader.next?.per_page) : Number(linkHeader.prev?.per_page),
      totalPages: !("last" in linkHeader) ? page : Number(linkHeader.last?.page)
    };
    return {
      mergeRequestDiffs: result.data.map((mergeRequestFile) => ({
        mergeRequestId: mergeRequest.mergeRequestId,
        diff: mergeRequestFile.patch || "",
        newPath: mergeRequestFile.filename,
        oldPath: mergeRequestFile.previous_filename || mergeRequestFile.filename,
        aMode: "",
        bMode: "",
        ...FILE_STATUS_FLAGS_MAPPING[mergeRequestFile.status]
      })),
      pagination
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async fetchMergeRequestCommits(repository, namespace, mergeRequest, creationPeriod = {}) {
    const response = await this.api.pulls.listCommits({
      owner: namespace.name,
      repo: repository.name,
      pull_number: mergeRequest.mergeRequestId
    });
    return {
      mergeRequestCommits: response.data.map((mrc) => ({
        mergeRequestId: mergeRequest.mergeRequestId,
        externalId: mrc.sha,
        createdAt: new Date(mrc.commit.committer?.date || ""),
        authoredDate: new Date(mrc.commit.author?.date || ""),
        committedDate: new Date(mrc.commit.committer?.date || ""),
        title: mrc.commit.message,
        message: mrc.commit.message,
        authorName: mrc.commit.author?.name || "",
        authorEmail: mrc.commit.author?.email || "",
        committerName: mrc.commit.committer?.name || "",
        committerEmail: mrc.commit.committer?.email || ""
      }))
    };
  }
  async fetchMergeRequestNotes(repository, namespace, mergeRequest) {
    const response = await this.api.pulls.listReviewComments({
      owner: namespace.name,
      repo: repository.name,
      pull_number: mergeRequest.mergeRequestId
    });
    return {
      mergeRequestNotes: response.data.map((mergeRequestNote) => ({
        externalId: mergeRequestNote.id,
        mergeRequestId: mergeRequest.id,
        createdAt: new Date(mergeRequestNote.created_at),
        updatedAt: new Date(mergeRequestNote.updated_at),
        authorUsername: mergeRequestNote.user.login,
        authorExternalId: mergeRequestNote.user.id
      }))
    };
  }
};

// src/create-event.ts
var client2 = new EventBridgeClient({});
function createEvent({
  source,
  type,
  propertiesShape,
  eventBusName,
  metadataShape
}) {
  const propertiesSchema = z2.object(propertiesShape);
  const metadataSchema3 = z2.object(metadataShape);
  const publish = /* @__PURE__ */ __name(async (properties, metadata2) => {
    await client2.send(new PutEventsCommand({
      Entries: [{
        EventBusName: eventBusName,
        Source: source,
        DetailType: type,
        Detail: JSON.stringify({
          properties: propertiesSchema.parse(properties),
          metadata: metadataSchema3.parse(metadata2)
        })
      }]
    }));
  }, "publish");
  return {
    publish,
    source,
    type,
    shape: {
      properties: {},
      metadata: {},
      metadataFn: void 0
    }
  };
}
__name(createEvent, "createEvent");

// src/events.ts
var extractRepositoryEventSchema = z2.object({
  repositoryId: z2.number(),
  namespaceId: z2.number()
});
var metadataSchema2 = z2.object({
  version: z2.number(),
  timestamp: z2.number(),
  caller: z2.string(),
  sourceControl: z2.literal("github").or(z2.literal("gitlab")),
  userId: z2.string()
});
var extractMergeRequestEventSchema = z2.object({
  mergeRequestIds: z2.array(MergeRequestSchema.shape.id),
  repositoryId: RepositorySchema.shape.id,
  namespaceId: NamespaceSchema.shape.id
});
var extractMergeRequestsEvent = createEvent({
  source: "extract",
  type: "mergeRequest",
  propertiesShape: extractMergeRequestEventSchema.shape,
  eventBusName: EventBus.ExtractBus.eventBusName,
  metadataShape: metadataSchema2.shape
});
var extractRepositoryEvent = createEvent({
  source: "extract",
  type: "repository",
  propertiesShape: extractRepositoryEventSchema.shape,
  eventBusName: EventBus.ExtractBus.eventBusName,
  metadataShape: metadataSchema2.shape
});
var extractMembersEvent = createEvent({
  source: "extract",
  type: "members",
  propertiesShape: z2.object({
    memberIds: z2.array(MemberSchema.shape.id)
  }).shape,
  eventBusName: EventBus.ExtractBus.eventBusName,
  metadataShape: metadataSchema2.shape
});

// ../../node_modules/@clerk/clerk-sdk-node/node_modules/@clerk/backend/dist/esm/index.js
var import_crypto6 = __toESM(require_crypto2());
var fetchApisPolyfill = __toESM(require_fetch());
var import_deepmerge = __toESM(require_cjs());
var import_snakecase_keys = __toESM(require_snakecase_keys());
var import_cookie = __toESM(require_cookie());
var AbstractAPI = class {
  static {
    __name(this, "AbstractAPI");
  }
  constructor(request3) {
    this.request = request3;
  }
  requireId(id) {
    if (!id) {
      throw new Error("A valid resource ID is required.");
    }
  }
};
var SEPARATOR = "/";
var MULTIPLE_SEPARATOR_REGEX = new RegExp(SEPARATOR + "{1,}", "g");
function joinPaths(...args) {
  return args.filter((p11) => p11).join(SEPARATOR).replace(MULTIPLE_SEPARATOR_REGEX, SEPARATOR);
}
__name(joinPaths, "joinPaths");
var basePath = "/allowlist_identifiers";
var AllowlistIdentifierAPI = class extends AbstractAPI {
  static {
    __name(this, "AllowlistIdentifierAPI");
  }
  async getAllowlistIdentifierList() {
    return this.request({
      method: "GET",
      path: basePath
    });
  }
  async createAllowlistIdentifier(params) {
    return this.request({
      method: "POST",
      path: basePath,
      bodyParams: params
    });
  }
  async deleteAllowlistIdentifier(allowlistIdentifierId) {
    this.requireId(allowlistIdentifierId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath, allowlistIdentifierId)
    });
  }
};
var basePath2 = "/clients";
var ClientAPI = class extends AbstractAPI {
  static {
    __name(this, "ClientAPI");
  }
  async getClientList() {
    return this.request({
      method: "GET",
      path: basePath2
    });
  }
  async getClient(clientId) {
    this.requireId(clientId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath2, clientId)
    });
  }
  verifyClient(token) {
    return this.request({
      method: "POST",
      path: joinPaths(basePath2, "verify"),
      bodyParams: { token }
    });
  }
};
var basePath3 = "/domains";
var DomainAPI = class extends AbstractAPI {
  static {
    __name(this, "DomainAPI");
  }
  async deleteDomain(id) {
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath3, id)
    });
  }
};
var basePath4 = "/email_addresses";
var EmailAddressAPI = class extends AbstractAPI {
  static {
    __name(this, "EmailAddressAPI");
  }
  async getEmailAddress(emailAddressId) {
    this.requireId(emailAddressId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath4, emailAddressId)
    });
  }
  async createEmailAddress(params) {
    return this.request({
      method: "POST",
      path: basePath4,
      bodyParams: params
    });
  }
  async updateEmailAddress(emailAddressId, params = {}) {
    this.requireId(emailAddressId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath4, emailAddressId),
      bodyParams: params
    });
  }
  async deleteEmailAddress(emailAddressId) {
    this.requireId(emailAddressId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath4, emailAddressId)
    });
  }
};
var basePath5 = "/emails";
var EmailAPI = class extends AbstractAPI {
  static {
    __name(this, "EmailAPI");
  }
  async createEmail(params) {
    return this.request({
      method: "POST",
      path: basePath5,
      bodyParams: params
    });
  }
};
var InterstitialAPI = class extends AbstractAPI {
  static {
    __name(this, "InterstitialAPI");
  }
  async getInterstitial() {
    return this.request({
      path: "internal/interstitial",
      method: "GET",
      headerParams: {
        "Content-Type": "text/html"
      }
    });
  }
};
var basePath6 = "/invitations";
var InvitationAPI = class extends AbstractAPI {
  static {
    __name(this, "InvitationAPI");
  }
  async getInvitationList(params = {}) {
    return this.request({
      method: "GET",
      path: basePath6,
      queryParams: params
    });
  }
  async createInvitation(params) {
    return this.request({
      method: "POST",
      path: basePath6,
      bodyParams: params
    });
  }
  async revokeInvitation(invitationId) {
    this.requireId(invitationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath6, invitationId, "revoke")
    });
  }
};
var {
  default: fetch3,
  RuntimeAbortController,
  RuntimeBlob,
  RuntimeFormData,
  RuntimeHeaders,
  RuntimeRequest,
  RuntimeResponse
} = fetchApisPolyfill;
var globalFetch = fetch3.bind(globalThis);
var runtime = {
  crypto: import_crypto6.default,
  fetch: globalFetch,
  AbortController: RuntimeAbortController,
  Blob: RuntimeBlob,
  FormData: RuntimeFormData,
  Headers: RuntimeHeaders,
  Request: RuntimeRequest,
  Response: RuntimeResponse
};
var runtime_default = runtime;
var basePath7 = "/organizations";
var OrganizationAPI = class extends AbstractAPI {
  static {
    __name(this, "OrganizationAPI");
  }
  async getOrganizationList(params) {
    return this.request({
      method: "GET",
      path: basePath7,
      queryParams: params
    });
  }
  async createOrganization(params) {
    return this.request({
      method: "POST",
      path: basePath7,
      bodyParams: params
    });
  }
  async getOrganization(params) {
    const organizationIdOrSlug = "organizationId" in params ? params.organizationId : params.slug;
    this.requireId(organizationIdOrSlug);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationIdOrSlug)
    });
  }
  async updateOrganization(organizationId, params) {
    this.requireId(organizationId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId),
      bodyParams: params
    });
  }
  async updateOrganizationLogo(organizationId, params) {
    this.requireId(organizationId);
    const formData = new runtime_default.FormData();
    formData.append("file", params?.file);
    formData.append("uploader_user_id", params?.uploaderUserId);
    return this.request({
      method: "PUT",
      path: joinPaths(basePath7, organizationId, "logo"),
      formData
    });
  }
  async deleteOrganizationLogo(organizationId) {
    this.requireId(organizationId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath7, organizationId, "logo")
    });
  }
  async updateOrganizationMetadata(organizationId, params) {
    this.requireId(organizationId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId, "metadata"),
      bodyParams: params
    });
  }
  async deleteOrganization(organizationId) {
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath7, organizationId)
    });
  }
  async getOrganizationMembershipList(params) {
    const { organizationId, limit, offset } = params;
    this.requireId(organizationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "memberships"),
      queryParams: { limit, offset }
    });
  }
  async createOrganizationMembership(params) {
    const { organizationId, userId, role } = params;
    this.requireId(organizationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath7, organizationId, "memberships"),
      bodyParams: {
        userId,
        role
      }
    });
  }
  async updateOrganizationMembership(params) {
    const { organizationId, userId, role } = params;
    this.requireId(organizationId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId, "memberships", userId),
      bodyParams: {
        role
      }
    });
  }
  async updateOrganizationMembershipMetadata(params) {
    const { organizationId, userId, publicMetadata, privateMetadata } = params;
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath7, organizationId, "memberships", userId, "metadata"),
      bodyParams: {
        publicMetadata,
        privateMetadata
      }
    });
  }
  async deleteOrganizationMembership(params) {
    const { organizationId, userId } = params;
    this.requireId(organizationId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath7, organizationId, "memberships", userId)
    });
  }
  async getPendingOrganizationInvitationList(params) {
    const { organizationId, limit, offset } = params;
    this.requireId(organizationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "invitations", "pending"),
      queryParams: { limit, offset }
    });
  }
  async createOrganizationInvitation(params) {
    const { organizationId, ...bodyParams } = params;
    this.requireId(organizationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath7, organizationId, "invitations"),
      bodyParams: { ...bodyParams }
    });
  }
  async getOrganizationInvitation(params) {
    const { organizationId, invitationId } = params;
    this.requireId(organizationId);
    this.requireId(invitationId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath7, organizationId, "invitations", invitationId)
    });
  }
  async revokeOrganizationInvitation(params) {
    const { organizationId, invitationId, requestingUserId } = params;
    this.requireId(organizationId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath7, organizationId, "invitations", invitationId, "revoke"),
      bodyParams: {
        requestingUserId
      }
    });
  }
};
var basePath8 = "/phone_numbers";
var PhoneNumberAPI = class extends AbstractAPI {
  static {
    __name(this, "PhoneNumberAPI");
  }
  async getPhoneNumber(phoneNumberId) {
    this.requireId(phoneNumberId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath8, phoneNumberId)
    });
  }
  async createPhoneNumber(params) {
    return this.request({
      method: "POST",
      path: basePath8,
      bodyParams: params
    });
  }
  async updatePhoneNumber(phoneNumberId, params = {}) {
    this.requireId(phoneNumberId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath8, phoneNumberId),
      bodyParams: params
    });
  }
  async deletePhoneNumber(phoneNumberId) {
    this.requireId(phoneNumberId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath8, phoneNumberId)
    });
  }
};
var basePath9 = "/redirect_urls";
var RedirectUrlAPI = class extends AbstractAPI {
  static {
    __name(this, "RedirectUrlAPI");
  }
  async getRedirectUrlList() {
    return this.request({
      method: "GET",
      path: basePath9
    });
  }
  async getRedirectUrl(redirectUrlId) {
    this.requireId(redirectUrlId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath9, redirectUrlId)
    });
  }
  async createRedirectUrl(params) {
    return this.request({
      method: "POST",
      path: basePath9,
      bodyParams: params
    });
  }
  async deleteRedirectUrl(redirectUrlId) {
    this.requireId(redirectUrlId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath9, redirectUrlId)
    });
  }
};
var basePath10 = "/sessions";
var SessionAPI = class extends AbstractAPI {
  static {
    __name(this, "SessionAPI");
  }
  async getSessionList(queryParams) {
    return this.request({
      method: "GET",
      path: basePath10,
      queryParams
    });
  }
  async getSession(sessionId) {
    this.requireId(sessionId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath10, sessionId)
    });
  }
  async revokeSession(sessionId) {
    this.requireId(sessionId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath10, sessionId, "revoke")
    });
  }
  async verifySession(sessionId, token) {
    this.requireId(sessionId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath10, sessionId, "verify"),
      bodyParams: { token }
    });
  }
  async getToken(sessionId, template) {
    this.requireId(sessionId);
    return (await this.request({
      method: "POST",
      path: joinPaths(basePath10, sessionId, "tokens", template || "")
    })).jwt;
  }
};
var basePath11 = "/sign_in_tokens";
var SignInTokenAPI = class extends AbstractAPI {
  static {
    __name(this, "SignInTokenAPI");
  }
  async createSignInToken(params) {
    return this.request({
      method: "POST",
      path: basePath11,
      bodyParams: params
    });
  }
  async revokeSignInToken(signInTokenId) {
    this.requireId(signInTokenId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath11, signInTokenId, "revoke")
    });
  }
};
var basePath12 = "/sms_messages";
var SMSMessageAPI = class extends AbstractAPI {
  static {
    __name(this, "SMSMessageAPI");
  }
  async createSMSMessage(params) {
    return this.request({
      method: "POST",
      path: basePath12,
      bodyParams: params
    });
  }
};
var basePath13 = "/users";
var UserAPI = class extends AbstractAPI {
  static {
    __name(this, "UserAPI");
  }
  async getUserList(params = {}) {
    return this.request({
      method: "GET",
      path: basePath13,
      queryParams: params
    });
  }
  async getUser(userId) {
    this.requireId(userId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, userId)
    });
  }
  async createUser(params) {
    return this.request({
      method: "POST",
      path: basePath13,
      bodyParams: params
    });
  }
  async updateUser(userId, params = {}) {
    this.requireId(userId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath13, userId),
      bodyParams: params
    });
  }
  async updateUserProfileImage(userId, params) {
    this.requireId(userId);
    const formData = new runtime_default.FormData();
    formData.append("file", params?.file);
    return this.request({
      method: "POST",
      path: joinPaths(basePath13, userId, "profile_image"),
      formData
    });
  }
  async updateUserMetadata(userId, params) {
    this.requireId(userId);
    return this.request({
      method: "PATCH",
      path: joinPaths(basePath13, userId, "metadata"),
      bodyParams: params
    });
  }
  async deleteUser(userId) {
    this.requireId(userId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath13, userId)
    });
  }
  async getCount(params = {}) {
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, "count"),
      queryParams: params
    });
  }
  async getUserOauthAccessToken(userId, provider) {
    this.requireId(userId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, userId, "oauth_access_tokens", provider)
    });
  }
  async disableUserMFA(userId) {
    this.requireId(userId);
    return this.request({
      method: "DELETE",
      path: joinPaths(basePath13, userId, "mfa")
    });
  }
  async getOrganizationMembershipList(params) {
    const { userId, limit, offset } = params;
    this.requireId(userId);
    return this.request({
      method: "GET",
      path: joinPaths(basePath13, userId, "organization_memberships"),
      queryParams: { limit, offset }
    });
  }
  async verifyPassword(params) {
    const { userId, password } = params;
    this.requireId(userId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath13, userId, "verify_password"),
      bodyParams: { password }
    });
  }
  async verifyTOTP(params) {
    const { userId, code: code2 } = params;
    this.requireId(userId);
    return this.request({
      method: "POST",
      path: joinPaths(basePath13, userId, "verify_totp"),
      bodyParams: { code: code2 }
    });
  }
};
var API_URL = "https://api.clerk.dev";
var API_VERSION = "v1";
var USER_AGENT3 = `@clerk/backend`;
var MAX_CACHE_LAST_UPDATED_AT_SECONDS = 5 * 60;
var Attributes = {
  AuthStatus: "__clerkAuthStatus",
  AuthReason: "__clerkAuthReason",
  AuthMessage: "__clerkAuthMessage"
};
var Cookies = {
  Session: "__session",
  ClientUat: "__client_uat"
};
var Headers2 = {
  AuthStatus: "x-clerk-auth-status",
  AuthReason: "x-clerk-auth-reason",
  AuthMessage: "x-clerk-auth-message",
  EnableDebug: "x-clerk-debug",
  ClerkRedirectTo: "x-clerk-redirect-to",
  Authorization: "authorization",
  ForwardedPort: "x-forwarded-port",
  ForwardedProto: "x-forwarded-proto",
  ForwardedHost: "x-forwarded-host",
  Referrer: "referer",
  UserAgent: "user-agent",
  Origin: "origin",
  Host: "host",
  ContentType: "content-type"
};
var SearchParams = {
  AuthStatus: Headers2.AuthStatus
};
var ContentTypes = {
  Json: "application/json"
};
var constants2 = {
  Attributes,
  Cookies,
  Headers: Headers2,
  SearchParams,
  ContentTypes
};
function assertValidSecretKey(val2) {
  if (!val2 || typeof val2 !== "string") {
    throw Error(
      "Missing Clerk Secret Key or API Key. Go to https://dashboard.clerk.com and get your key for your instance."
    );
  }
}
__name(assertValidSecretKey, "assertValidSecretKey");
var AllowlistIdentifier = class {
  static {
    __name(this, "AllowlistIdentifier");
  }
  constructor(id, identifier, createdAt, updatedAt, invitationId) {
    this.id = id;
    this.identifier = identifier;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.invitationId = invitationId;
  }
  static fromJSON(data) {
    return new AllowlistIdentifier(data.id, data.identifier, data.created_at, data.updated_at, data.invitation_id);
  }
};
var Session = class {
  static {
    __name(this, "Session");
  }
  constructor(id, clientId, userId, status, lastActiveAt, expireAt, abandonAt, createdAt, updatedAt) {
    this.id = id;
    this.clientId = clientId;
    this.userId = userId;
    this.status = status;
    this.lastActiveAt = lastActiveAt;
    this.expireAt = expireAt;
    this.abandonAt = abandonAt;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new Session(
      data.id,
      data.client_id,
      data.user_id,
      data.status,
      data.last_active_at,
      data.expire_at,
      data.abandon_at,
      data.created_at,
      data.updated_at
    );
  }
};
var Client3 = class {
  static {
    __name(this, "Client");
  }
  constructor(id, sessionIds, sessions2, signInId, signUpId, lastActiveSessionId, createdAt, updatedAt) {
    this.id = id;
    this.sessionIds = sessionIds;
    this.sessions = sessions2;
    this.signInId = signInId;
    this.signUpId = signUpId;
    this.lastActiveSessionId = lastActiveSessionId;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new Client3(
      data.id,
      data.session_ids,
      data.sessions.map((x4) => Session.fromJSON(x4)),
      data.sign_in_id,
      data.sign_up_id,
      data.last_active_session_id,
      data.created_at,
      data.updated_at
    );
  }
};
var DeletedObject = class {
  static {
    __name(this, "DeletedObject");
  }
  constructor(object, id, slug, deleted) {
    this.object = object;
    this.id = id;
    this.slug = slug;
    this.deleted = deleted;
  }
  static fromJSON(data) {
    return new DeletedObject(data.object, data.id || null, data.slug || null, data.deleted);
  }
};
var Email = class {
  static {
    __name(this, "Email");
  }
  constructor(id, fromEmailName, emailAddressId, toEmailAddress, subject, body, bodyPlain, status, slug, data, deliveredByClerk) {
    this.id = id;
    this.fromEmailName = fromEmailName;
    this.emailAddressId = emailAddressId;
    this.toEmailAddress = toEmailAddress;
    this.subject = subject;
    this.body = body;
    this.bodyPlain = bodyPlain;
    this.status = status;
    this.slug = slug;
    this.data = data;
    this.deliveredByClerk = deliveredByClerk;
  }
  static fromJSON(data) {
    return new Email(
      data.id,
      data.from_email_name,
      data.email_address_id,
      data.to_email_address,
      data.subject,
      data.body,
      data.body_plain,
      data.status,
      data.slug,
      data.data,
      data.delivered_by_clerk
    );
  }
};
var IdentificationLink = class {
  static {
    __name(this, "IdentificationLink");
  }
  constructor(id, type) {
    this.id = id;
    this.type = type;
  }
  static fromJSON(data) {
    return new IdentificationLink(data.id, data.type);
  }
};
var Verification = class {
  static {
    __name(this, "Verification");
  }
  constructor(status, strategy, externalVerificationRedirectURL = null, attempts = null, expireAt = null, nonce = null) {
    this.status = status;
    this.strategy = strategy;
    this.externalVerificationRedirectURL = externalVerificationRedirectURL;
    this.attempts = attempts;
    this.expireAt = expireAt;
    this.nonce = nonce;
  }
  static fromJSON(data) {
    return new Verification(
      data.status,
      data.strategy,
      data.external_verification_redirect_url ? new URL(data.external_verification_redirect_url) : null,
      data.attempts,
      data.expire_at,
      data.nonce
    );
  }
};
var EmailAddress = class {
  static {
    __name(this, "EmailAddress");
  }
  constructor(id, emailAddress, verification, linkedTo) {
    this.id = id;
    this.emailAddress = emailAddress;
    this.verification = verification;
    this.linkedTo = linkedTo;
  }
  static fromJSON(data) {
    return new EmailAddress(
      data.id,
      data.email_address,
      data.verification && Verification.fromJSON(data.verification),
      data.linked_to.map((link) => IdentificationLink.fromJSON(link))
    );
  }
};
var ExternalAccount = class {
  static {
    __name(this, "ExternalAccount");
  }
  constructor(id, provider, identificationId, externalId, approvedScopes, emailAddress, firstName, lastName, picture, imageUrl, username, publicMetadata = {}, label, verification) {
    this.id = id;
    this.provider = provider;
    this.identificationId = identificationId;
    this.externalId = externalId;
    this.approvedScopes = approvedScopes;
    this.emailAddress = emailAddress;
    this.firstName = firstName;
    this.lastName = lastName;
    this.picture = picture;
    this.imageUrl = imageUrl;
    this.username = username;
    this.publicMetadata = publicMetadata;
    this.label = label;
    this.verification = verification;
  }
  static fromJSON(data) {
    return new ExternalAccount(
      data.id,
      data.provider,
      data.identification_id,
      data.provider_user_id,
      data.approved_scopes,
      data.email_address,
      data.first_name,
      data.last_name,
      data.avatar_url,
      data.image_url,
      data.username,
      data.public_metadata,
      data.label,
      data.verification && Verification.fromJSON(data.verification)
    );
  }
};
var Invitation = class {
  static {
    __name(this, "Invitation");
  }
  constructor(id, emailAddress, publicMetadata, createdAt, updatedAt, status, revoked) {
    this.id = id;
    this.emailAddress = emailAddress;
    this.publicMetadata = publicMetadata;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.status = status;
    this.revoked = revoked;
  }
  static fromJSON(data) {
    return new Invitation(
      data.id,
      data.email_address,
      data.public_metadata,
      data.created_at,
      data.updated_at,
      data.status,
      data.revoked
    );
  }
};
var OauthAccessToken = class {
  static {
    __name(this, "OauthAccessToken");
  }
  constructor(provider, token, publicMetadata = {}, label, scopes, tokenSecret) {
    this.provider = provider;
    this.token = token;
    this.publicMetadata = publicMetadata;
    this.label = label;
    this.scopes = scopes;
    this.tokenSecret = tokenSecret;
  }
  static fromJSON(data) {
    return new OauthAccessToken(
      data.provider,
      data.token,
      data.public_metadata,
      data.label,
      data.scopes,
      data.token_secret
    );
  }
};
var Organization = class {
  static {
    __name(this, "Organization");
  }
  constructor(id, name2, slug, logoUrl, imageUrl, hasImage, createdBy, createdAt, updatedAt, publicMetadata = {}, privateMetadata = {}, maxAllowedMemberships, adminDeleteEnabled) {
    this.id = id;
    this.name = name2;
    this.slug = slug;
    this.logoUrl = logoUrl;
    this.imageUrl = imageUrl;
    this.hasImage = hasImage;
    this.createdBy = createdBy;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
    this.maxAllowedMemberships = maxAllowedMemberships;
    this.adminDeleteEnabled = adminDeleteEnabled;
  }
  static fromJSON(data) {
    return new Organization(
      data.id,
      data.name,
      data.slug,
      data.logo_url,
      data.image_url,
      data.has_image,
      data.created_by,
      data.created_at,
      data.updated_at,
      data.public_metadata,
      data.private_metadata,
      data.max_allowed_memberships,
      data.admin_delete_enabled
    );
  }
};
var OrganizationInvitation = class {
  static {
    __name(this, "OrganizationInvitation");
  }
  constructor(id, emailAddress, role, organizationId, createdAt, updatedAt, status, publicMetadata = {}, privateMetadata = {}) {
    this.id = id;
    this.emailAddress = emailAddress;
    this.role = role;
    this.organizationId = organizationId;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.status = status;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
  }
  static fromJSON(data) {
    return new OrganizationInvitation(
      data.id,
      data.email_address,
      data.role,
      data.organization_id,
      data.created_at,
      data.updated_at,
      data.status,
      data.public_metadata,
      data.private_metadata
    );
  }
};
var OrganizationMembership = class {
  static {
    __name(this, "OrganizationMembership");
  }
  constructor(id, role, publicMetadata = {}, privateMetadata = {}, createdAt, updatedAt, organization, publicUserData) {
    this.id = id;
    this.role = role;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.organization = organization;
    this.publicUserData = publicUserData;
  }
  static fromJSON(data) {
    return new OrganizationMembership(
      data.id,
      data.role,
      data.public_metadata,
      data.private_metadata,
      data.created_at,
      data.updated_at,
      Organization.fromJSON(data.organization),
      OrganizationMembershipPublicUserData.fromJSON(data.public_user_data)
    );
  }
};
var OrganizationMembershipPublicUserData = class {
  static {
    __name(this, "OrganizationMembershipPublicUserData");
  }
  constructor(identifier, firstName, lastName, profileImageUrl, imageUrl, hasImage, userId) {
    this.identifier = identifier;
    this.firstName = firstName;
    this.lastName = lastName;
    this.profileImageUrl = profileImageUrl;
    this.imageUrl = imageUrl;
    this.hasImage = hasImage;
    this.userId = userId;
  }
  static fromJSON(data) {
    return new OrganizationMembershipPublicUserData(
      data.identifier,
      data.first_name,
      data.last_name,
      data.profile_image_url,
      data.image_url,
      data.has_image,
      data.user_id
    );
  }
};
var PhoneNumber = class {
  static {
    __name(this, "PhoneNumber");
  }
  constructor(id, phoneNumber, reservedForSecondFactor, defaultSecondFactor, verification, linkedTo) {
    this.id = id;
    this.phoneNumber = phoneNumber;
    this.reservedForSecondFactor = reservedForSecondFactor;
    this.defaultSecondFactor = defaultSecondFactor;
    this.verification = verification;
    this.linkedTo = linkedTo;
  }
  static fromJSON(data) {
    return new PhoneNumber(
      data.id,
      data.phone_number,
      data.reserved_for_second_factor,
      data.default_second_factor,
      data.verification && Verification.fromJSON(data.verification),
      data.linked_to.map((link) => IdentificationLink.fromJSON(link))
    );
  }
};
var RedirectUrl = class {
  static {
    __name(this, "RedirectUrl");
  }
  constructor(id, url12, createdAt, updatedAt) {
    this.id = id;
    this.url = url12;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new RedirectUrl(data.id, data.url, data.created_at, data.updated_at);
  }
};
var SignInToken = class {
  static {
    __name(this, "SignInToken");
  }
  constructor(id, userId, token, status, url12, createdAt, updatedAt) {
    this.id = id;
    this.userId = userId;
    this.token = token;
    this.status = status;
    this.url = url12;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
  static fromJSON(data) {
    return new SignInToken(data.id, data.user_id, data.token, data.status, data.url, data.created_at, data.updated_at);
  }
};
var SMSMessage = class {
  static {
    __name(this, "SMSMessage");
  }
  constructor(id, fromPhoneNumber, toPhoneNumber, message, status, phoneNumberId, data) {
    this.id = id;
    this.fromPhoneNumber = fromPhoneNumber;
    this.toPhoneNumber = toPhoneNumber;
    this.message = message;
    this.status = status;
    this.phoneNumberId = phoneNumberId;
    this.data = data;
  }
  static fromJSON(data) {
    return new SMSMessage(
      data.id,
      data.from_phone_number,
      data.to_phone_number,
      data.message,
      data.status,
      data.phone_number_id,
      data.data
    );
  }
};
var Token = class {
  static {
    __name(this, "Token");
  }
  constructor(jwt) {
    this.jwt = jwt;
  }
  static fromJSON(data) {
    return new Token(data.jwt);
  }
};
var Web3Wallet = class {
  static {
    __name(this, "Web3Wallet");
  }
  constructor(id, web3Wallet, verification) {
    this.id = id;
    this.web3Wallet = web3Wallet;
    this.verification = verification;
  }
  static fromJSON(data) {
    return new Web3Wallet(data.id, data.web3_wallet, data.verification && Verification.fromJSON(data.verification));
  }
};
var User = class {
  static {
    __name(this, "User");
  }
  constructor(id, passwordEnabled, totpEnabled, backupCodeEnabled, twoFactorEnabled, banned, createdAt, updatedAt, profileImageUrl, imageUrl, hasImage, gender, birthday, primaryEmailAddressId, primaryPhoneNumberId, primaryWeb3WalletId, lastSignInAt, externalId, username, firstName, lastName, publicMetadata = {}, privateMetadata = {}, unsafeMetadata = {}, emailAddresses2 = [], phoneNumbers2 = [], web3Wallets = [], externalAccounts = []) {
    this.id = id;
    this.passwordEnabled = passwordEnabled;
    this.totpEnabled = totpEnabled;
    this.backupCodeEnabled = backupCodeEnabled;
    this.twoFactorEnabled = twoFactorEnabled;
    this.banned = banned;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.profileImageUrl = profileImageUrl;
    this.imageUrl = imageUrl;
    this.hasImage = hasImage;
    this.gender = gender;
    this.birthday = birthday;
    this.primaryEmailAddressId = primaryEmailAddressId;
    this.primaryPhoneNumberId = primaryPhoneNumberId;
    this.primaryWeb3WalletId = primaryWeb3WalletId;
    this.lastSignInAt = lastSignInAt;
    this.externalId = externalId;
    this.username = username;
    this.firstName = firstName;
    this.lastName = lastName;
    this.publicMetadata = publicMetadata;
    this.privateMetadata = privateMetadata;
    this.unsafeMetadata = unsafeMetadata;
    this.emailAddresses = emailAddresses2;
    this.phoneNumbers = phoneNumbers2;
    this.web3Wallets = web3Wallets;
    this.externalAccounts = externalAccounts;
  }
  static fromJSON(data) {
    return new User(
      data.id,
      data.password_enabled,
      data.totp_enabled,
      data.backup_code_enabled,
      data.two_factor_enabled,
      data.banned,
      data.created_at,
      data.updated_at,
      data.profile_image_url,
      data.image_url,
      data.has_image,
      data.gender,
      data.birthday,
      data.primary_email_address_id,
      data.primary_phone_number_id,
      data.primary_web3_wallet_id,
      data.last_sign_in_at,
      data.external_id,
      data.username,
      data.first_name,
      data.last_name,
      data.public_metadata,
      data.private_metadata,
      data.unsafe_metadata,
      (data.email_addresses || []).map((x4) => EmailAddress.fromJSON(x4)),
      (data.phone_numbers || []).map((x4) => PhoneNumber.fromJSON(x4)),
      (data.web3_wallets || []).map((x4) => Web3Wallet.fromJSON(x4)),
      (data.external_accounts || []).map((x4) => ExternalAccount.fromJSON(x4))
    );
  }
};
function deserialize(payload) {
  if (Array.isArray(payload)) {
    return payload.map((item) => jsonToObject(item));
  } else if (isPaginated(payload)) {
    return payload.data.map((item) => jsonToObject(item));
  } else {
    return jsonToObject(payload);
  }
}
__name(deserialize, "deserialize");
function isPaginated(payload) {
  return Array.isArray(payload.data) && payload.data !== void 0;
}
__name(isPaginated, "isPaginated");
function getCount(item) {
  return item.total_count;
}
__name(getCount, "getCount");
function jsonToObject(item) {
  if (typeof item !== "string" && "object" in item && "deleted" in item) {
    return DeletedObject.fromJSON(item);
  }
  switch (item.object) {
    case "allowlist_identifier":
      return AllowlistIdentifier.fromJSON(item);
    case "client":
      return Client3.fromJSON(item);
    case "email_address":
      return EmailAddress.fromJSON(item);
    case "email":
      return Email.fromJSON(item);
    case "invitation":
      return Invitation.fromJSON(item);
    case "oauth_access_token":
      return OauthAccessToken.fromJSON(item);
    case "organization":
      return Organization.fromJSON(item);
    case "organization_invitation":
      return OrganizationInvitation.fromJSON(item);
    case "organization_membership":
      return OrganizationMembership.fromJSON(item);
    case "phone_number":
      return PhoneNumber.fromJSON(item);
    case "redirect_url":
      return RedirectUrl.fromJSON(item);
    case "sign_in_token":
      return SignInToken.fromJSON(item);
    case "session":
      return Session.fromJSON(item);
    case "sms_message":
      return SMSMessage.fromJSON(item);
    case "token":
      return Token.fromJSON(item);
    case "total_count":
      return getCount(item);
    case "user":
      return User.fromJSON(item);
    default:
      return item;
  }
}
__name(jsonToObject, "jsonToObject");
var withLegacyReturn = /* @__PURE__ */ __name((cb) => async (...args) => {
  const { data, errors, status, statusText } = await cb(...args);
  if (errors === null) {
    return data;
  } else {
    throw new ClerkAPIResponseError(statusText || "", {
      data: errors,
      status: status || ""
    });
  }
}, "withLegacyReturn");
function buildRequest(options) {
  const request3 = /* @__PURE__ */ __name(async (requestOptions) => {
    const {
      apiKey,
      secretKey,
      apiUrl = API_URL,
      apiVersion = API_VERSION,
      userAgent: userAgent2 = USER_AGENT3,
      httpOptions = {}
    } = options;
    const { path, method, queryParams, headerParams, bodyParams, formData } = requestOptions;
    const key = secretKey || apiKey;
    assertValidSecretKey(key);
    const url12 = joinPaths(apiUrl, apiVersion, path);
    const finalUrl = new URL(url12);
    if (queryParams) {
      const snakecasedQueryParams = (0, import_snakecase_keys.default)({ ...queryParams });
      for (const [key2, val2] of Object.entries(snakecasedQueryParams)) {
        if (val2) {
          [val2].flat().forEach((v7) => finalUrl.searchParams.append(key2, v7));
        }
      }
    }
    const headers = {
      Authorization: `Bearer ${key}`,
      "Clerk-Backend-SDK": userAgent2,
      ...headerParams
    };
    let res = void 0;
    try {
      if (formData) {
        res = await runtime_default.fetch(finalUrl.href, {
          ...httpOptions,
          method,
          headers,
          body: formData
        });
      } else {
        headers["Content-Type"] = "application/json";
        const hasBody = method !== "GET" && bodyParams && Object.keys(bodyParams).length > 0;
        const body = hasBody ? { body: JSON.stringify((0, import_snakecase_keys.default)(bodyParams, { deep: false })) } : null;
        res = await runtime_default.fetch(
          finalUrl.href,
          (0, import_deepmerge.default)(httpOptions, {
            method,
            headers,
            ...body
          })
        );
      }
      const isJSONResponse = res?.headers && res.headers?.get(constants2.Headers.ContentType) === constants2.ContentTypes.Json;
      const data = await (isJSONResponse ? res.json() : res.text());
      if (!res.ok) {
        throw data;
      }
      return {
        data: deserialize(data),
        errors: null
      };
    } catch (err) {
      if (err instanceof Error) {
        return {
          data: null,
          errors: [
            {
              code: "unexpected_error",
              message: err.message || "Unexpected error"
            }
          ]
        };
      }
      return {
        data: null,
        errors: parseErrors(err),
        // TODO: To be removed with withLegacyReturn
        // @ts-expect-error
        status: res?.status,
        statusText: res?.statusText
      };
    }
  }, "request");
  return withLegacyReturn(request3);
}
__name(buildRequest, "buildRequest");
function parseErrors(data) {
  if (!!data && typeof data === "object" && "errors" in data) {
    const errors = data.errors;
    return errors.length > 0 ? errors.map(parseError) : [];
  }
  return [];
}
__name(parseErrors, "parseErrors");
function parseError(error) {
  return {
    code: error.code,
    message: error.message,
    longMessage: error.long_message,
    meta: {
      paramName: error?.meta?.param_name,
      sessionId: error?.meta?.session_id
    }
  };
}
__name(parseError, "parseError");
var ClerkAPIResponseError = class extends Error {
  static {
    __name(this, "ClerkAPIResponseError");
  }
  constructor(message, { data, status }) {
    super(message);
    Object.setPrototypeOf(this, ClerkAPIResponseError.prototype);
    this.clerkError = true;
    this.message = message;
    this.status = status;
    this.errors = data;
  }
};
function createBackendApiClient(options) {
  const request3 = buildRequest(options);
  return {
    allowlistIdentifiers: new AllowlistIdentifierAPI(request3),
    clients: new ClientAPI(request3),
    emailAddresses: new EmailAddressAPI(request3),
    emails: new EmailAPI(request3),
    interstitial: new InterstitialAPI(request3),
    invitations: new InvitationAPI(request3),
    organizations: new OrganizationAPI(request3),
    phoneNumbers: new PhoneNumberAPI(request3),
    redirectUrls: new RedirectUrlAPI(request3),
    sessions: new SessionAPI(request3),
    signInTokens: new SignInTokenAPI(request3),
    smsMessages: new SMSMessageAPI(request3),
    users: new UserAPI(request3),
    domains: new DomainAPI(request3)
  };
}
__name(createBackendApiClient, "createBackendApiClient");
var createDebug = /* @__PURE__ */ __name((data) => {
  return () => {
    const res = { ...data };
    res.apiKey = (res.apiKey || "").substring(0, 7);
    res.secretKey = (res.secretKey || "").substring(0, 7);
    res.jwtKey = (res.jwtKey || "").substring(0, 7);
    return { ...res };
  };
}, "createDebug");
function signedInAuthObject(sessionClaims, options, debugData) {
  const {
    act: actor,
    sid: sessionId,
    org_id: orgId,
    org_role: orgRole,
    org_slug: orgSlug,
    sub: userId
  } = sessionClaims;
  const { apiKey, secretKey, apiUrl, apiVersion, token, session, user, organization } = options;
  const { sessions: sessions2 } = createBackendApiClient({
    apiKey,
    secretKey,
    apiUrl,
    apiVersion
  });
  const getToken = createGetToken({
    sessionId,
    sessionToken: token,
    fetcher: (...args) => sessions2.getToken(...args)
  });
  return {
    actor,
    sessionClaims,
    sessionId,
    session,
    userId,
    user,
    orgId,
    orgRole,
    orgSlug,
    organization,
    getToken,
    debug: createDebug({ ...options, ...debugData })
  };
}
__name(signedInAuthObject, "signedInAuthObject");
function signedOutAuthObject(debugData) {
  return {
    sessionClaims: null,
    sessionId: null,
    session: null,
    userId: null,
    user: null,
    actor: null,
    orgId: null,
    orgRole: null,
    orgSlug: null,
    organization: null,
    getToken: () => Promise.resolve(null),
    debug: createDebug(debugData)
  };
}
__name(signedOutAuthObject, "signedOutAuthObject");
var createGetToken = /* @__PURE__ */ __name((params) => {
  const { fetcher, sessionToken, sessionId } = params || {};
  return async (options = {}) => {
    if (!sessionId) {
      return null;
    }
    if (options.template) {
      return fetcher(sessionId, options.template);
    }
    return sessionToken;
  };
}, "createGetToken");
function wait(ms) {
  return new Promise((res) => setTimeout(res, ms));
}
__name(wait, "wait");
var MAX_NUMBER_OF_RETRIES = 5;
async function callWithRetry(fn, attempt = 1, maxAttempts = MAX_NUMBER_OF_RETRIES) {
  try {
    return await fn();
  } catch (e10) {
    if (attempt >= maxAttempts) {
      throw e10;
    }
    await wait(2 ** attempt * 100);
    return callWithRetry(fn, attempt + 1);
  }
}
__name(callWithRetry, "callWithRetry");
function isDevelopmentFromApiKey(apiKey) {
  return apiKey.startsWith("test_") || apiKey.startsWith("sk_test_");
}
__name(isDevelopmentFromApiKey, "isDevelopmentFromApiKey");
function isProductionFromApiKey(apiKey) {
  return apiKey.startsWith("live_") || apiKey.startsWith("sk_live_");
}
__name(isProductionFromApiKey, "isProductionFromApiKey");
function isStaging(frontendApi) {
  return frontendApi.endsWith(".lclstage.dev") || frontendApi.endsWith(".stgstage.dev") || frontendApi.endsWith(".clerkstage.dev") || frontendApi.endsWith(".accountsstage.dev");
}
__name(isStaging, "isStaging");
function createDevOrStagingUrlCache() {
  const DEV_OR_STAGING_SUFFIXES = [
    ".lcl.dev",
    ".stg.dev",
    ".lclstage.dev",
    ".stgstage.dev",
    ".dev.lclclerk.com",
    ".stg.lclclerk.com",
    ".accounts.lclclerk.com",
    "accountsstage.dev",
    "accounts.dev"
  ];
  const devOrStagingUrlCache = /* @__PURE__ */ new Map();
  return {
    isDevOrStagingUrl: (url12) => {
      if (!url12) {
        return false;
      }
      const hostname = typeof url12 === "string" ? url12 : url12.hostname;
      let res = devOrStagingUrlCache.get(hostname);
      if (res === void 0) {
        res = DEV_OR_STAGING_SUFFIXES.some((s10) => hostname.endsWith(s10));
        devOrStagingUrlCache.set(hostname, res);
      }
      return res;
    }
  };
}
__name(createDevOrStagingUrlCache, "createDevOrStagingUrlCache");
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();
var PUBLISHABLE_KEY_LIVE_PREFIX = "pk_live_";
var PUBLISHABLE_KEY_TEST_PREFIX = "pk_test_";
function parsePublishableKey(key) {
  key = key || "";
  if (!isPublishableKey(key)) {
    return null;
  }
  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? "production" : "development";
  let frontendApi = isomorphicAtob(key.split("_")[2]);
  if (!frontendApi.endsWith("$")) {
    return null;
  }
  frontendApi = frontendApi.slice(0, -1);
  return {
    instanceType,
    frontendApi
  };
}
__name(parsePublishableKey, "parsePublishableKey");
function isPublishableKey(key) {
  key = key || "";
  const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);
  const hasValidFrontendApiPostfix = isomorphicAtob(key.split("_")[2] || "").endsWith("$");
  return hasValidPrefix && hasValidFrontendApiPostfix;
}
__name(isPublishableKey, "isPublishableKey");
var isomorphicAtob = /* @__PURE__ */ __name((data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") {
    return atob(data);
  } else if (typeof globalThis !== "undefined" && globalThis.Buffer) {
    return new globalThis.Buffer(data, "base64").toString();
  }
  return data;
}, "isomorphicAtob");
var TokenVerificationError = class extends Error {
  static {
    __name(this, "TokenVerificationError");
  }
  constructor({
    action,
    message,
    reason
  }) {
    super(message);
    Object.setPrototypeOf(this, TokenVerificationError.prototype);
    this.reason = reason;
    this.message = message;
    this.action = action;
  }
  getFullMessage() {
    return `${[this.message, this.action].filter((m11) => m11).join(" ")} (reason=${this.reason}, token-carrier=${this.tokenCarrier})`;
  }
};
function addClerkPrefix(str) {
  if (!str) {
    return "";
  }
  let regex;
  if (str.match(/^(clerk\.)+\w*$/)) {
    regex = /(clerk\.)*(?=clerk\.)/;
  } else if (str.match(/\.clerk.accounts/)) {
    return str;
  } else {
    regex = /^(clerk\.)*/gi;
  }
  const stripped = str.replace(regex, "");
  return `clerk.${stripped}`;
}
__name(addClerkPrefix, "addClerkPrefix");
function loadInterstitialFromLocal(options) {
  options.frontendApi = parsePublishableKey(options.publishableKey)?.frontendApi || options.frontendApi || "";
  const domainOnlyInProd = !isDevOrStagingUrl(options.frontendApi) ? addClerkPrefix(options.domain) : "";
  const {
    debugData,
    frontendApi,
    pkgVersion,
    clerkJSUrl,
    clerkJSVersion,
    publishableKey,
    proxyUrl,
    isSatellite = false,
    domain,
    signInUrl
  } = options;
  return `
    <head>
        <meta charset="UTF-8" />
    </head>
    <body>
        <script>
            window.__clerk_frontend_api = '${frontendApi}';
            window.__clerk_debug = ${JSON.stringify(debugData || {})};
            ${proxyUrl ? `window.__clerk_proxy_url = '${proxyUrl}'` : ""}
            ${domain ? `window.__clerk_domain = '${domain}'` : ""}
            window.startClerk = async () => {
                function formRedirect(){
                    const form = '<form method="get" action="" name="redirect"></form>';
                    document.body.innerHTML = document.body.innerHTML + form;

                    const searchParams = new URLSearchParams(window.location.search);
                    for (let paramTuple of searchParams) {
                        const input = document.createElement("input");
                        input.type = "hidden";
                        input.name = paramTuple[0];
                        input.value = paramTuple[1];
                        document.forms.redirect.appendChild(input);
                    }
                    const url = new URL(window.location.origin + window.location.pathname + window.location.hash);
                    window.history.pushState({}, '', url);

                    document.forms.redirect.action = window.location.pathname + window.location.hash;
                    document.forms.redirect.submit();
                }

                const Clerk = window.Clerk;
                try {
                    await Clerk.load({
                        isSatellite: ${isSatellite},
                        isInterstitial: ${true},
                        signInUrl: ${signInUrl ? `'${signInUrl}'` : void 0}
                    });
                    if(Clerk.loaded){
                      if(window.location.href.indexOf("#") === -1){
                        window.location.href = window.location.href;
                      } else if (window.navigator.userAgent.toLowerCase().includes("firefox/")){
                          formRedirect();
                      } else {
                          window.location.reload();
                      }
                    }
                } catch (err) {
                    console.error('Clerk: ', err);
                }
            };
            (() => {
                const script = document.createElement('script');
                ${publishableKey ? `script.setAttribute('data-clerk-publishable-key', '${publishableKey}');` : `script.setAttribute('data-clerk-frontend-api', '${frontendApi}');`}

                ${domain ? `script.setAttribute('data-clerk-domain', '${domain}');` : ""}
                ${proxyUrl ? `script.setAttribute('data-clerk-proxy-url', '${proxyUrl}')` : ""};
                script.async = true;
                script.src = '${clerkJSUrl || getScriptUrl(proxyUrl || domainOnlyInProd || frontendApi, {
    pkgVersion,
    clerkJSVersion
  })}';
                script.crossOrigin = 'anonymous';
                script.addEventListener('load', startClerk);
                document.body.appendChild(script);
            })();
        </script>
    </body>
`;
}
__name(loadInterstitialFromLocal, "loadInterstitialFromLocal");
async function loadInterstitialFromBAPI(options) {
  options.frontendApi = parsePublishableKey(options.publishableKey)?.frontendApi || options.frontendApi || "";
  const url12 = buildPublicInterstitialUrl(options);
  const response = await callWithRetry(
    () => runtime_default.fetch(buildPublicInterstitialUrl(options), {
      method: "GET",
      headers: {
        "Clerk-Backend-SDK": options.userAgent || USER_AGENT3
      }
    })
  );
  if (!response.ok) {
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Error loading Clerk Interstitial from ${url12} with code=${response.status}`,
      reason: "interstitial-remote-failed-to-load"
      /* RemoteInterstitialFailedToLoad */
    });
  }
  return response.text();
}
__name(loadInterstitialFromBAPI, "loadInterstitialFromBAPI");
function buildPublicInterstitialUrl(options) {
  options.frontendApi = parsePublishableKey(options.publishableKey)?.frontendApi || options.frontendApi || "";
  const { apiUrl, frontendApi, pkgVersion, clerkJSVersion, publishableKey, proxyUrl, isSatellite, domain, signInUrl } = options;
  const url12 = new URL(apiUrl);
  url12.pathname = joinPaths(url12.pathname, API_VERSION, "/public/interstitial");
  url12.searchParams.append("clerk_js_version", clerkJSVersion || getClerkJsMajorVersionOrTag(frontendApi, pkgVersion));
  if (publishableKey) {
    url12.searchParams.append("publishable_key", publishableKey);
  } else {
    url12.searchParams.append("frontend_api", frontendApi);
  }
  if (proxyUrl) {
    url12.searchParams.append("proxy_url", proxyUrl);
  }
  if (isSatellite) {
    url12.searchParams.append("is_satellite", "true");
  }
  url12.searchParams.append("sign_in_url", signInUrl || "");
  if (!isDevOrStagingUrl(options.frontendApi)) {
    url12.searchParams.append("use_domain_for_script", "true");
  }
  if (domain) {
    url12.searchParams.append("domain", domain);
  }
  return url12.href;
}
__name(buildPublicInterstitialUrl, "buildPublicInterstitialUrl");
var getClerkJsMajorVersionOrTag = /* @__PURE__ */ __name((frontendApi, pkgVersion) => {
  if (!pkgVersion && isStaging(frontendApi)) {
    return "staging";
  }
  if (!pkgVersion) {
    return "latest";
  }
  if (pkgVersion.includes("next")) {
    return "next";
  }
  return pkgVersion.split(".")[0] || "latest";
}, "getClerkJsMajorVersionOrTag");
var getScriptUrl = /* @__PURE__ */ __name((frontendApi, { pkgVersion, clerkJSVersion }) => {
  const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\/\//, "");
  const major = getClerkJsMajorVersionOrTag(frontendApi, pkgVersion);
  return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;
}, "getScriptUrl");
var createIsomorphicRequest = /* @__PURE__ */ __name((cb) => {
  return cb(runtime_default.Request, runtime_default.Headers);
}, "createIsomorphicRequest");
var buildRequest2 = /* @__PURE__ */ __name((req) => {
  if (!req) {
    return {};
  }
  const cookies = parseIsomorphicRequestCookies(req);
  const headers = getHeaderFromIsomorphicRequest(req);
  const searchParams = getSearchParamsFromIsomorphicRequest(req);
  return {
    cookies,
    headers,
    searchParams
  };
}, "buildRequest2");
var decode2 = /* @__PURE__ */ __name((str) => {
  if (!str) {
    return str;
  }
  return str.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
}, "decode");
var parseIsomorphicRequestCookies = /* @__PURE__ */ __name((req) => {
  const cookies = req.headers && req.headers?.get("cookie") ? (0, import_cookie.parse)(req.headers.get("cookie")) : {};
  return (key) => {
    const value = cookies?.[key];
    if (value === void 0) {
      return void 0;
    }
    return decode2(value);
  };
}, "parseIsomorphicRequestCookies");
var getHeaderFromIsomorphicRequest = /* @__PURE__ */ __name((req) => (key) => req?.headers?.get(key) || void 0, "getHeaderFromIsomorphicRequest");
var getSearchParamsFromIsomorphicRequest = /* @__PURE__ */ __name((req) => req?.url ? new URL(req.url)?.searchParams : void 0, "getSearchParamsFromIsomorphicRequest");
var stripAuthorizationHeader = /* @__PURE__ */ __name((authValue) => {
  return authValue?.replace("Bearer ", "");
}, "stripAuthorizationHeader");
async function signedIn(options, sessionClaims) {
  const {
    apiKey,
    secretKey,
    apiUrl,
    apiVersion,
    cookieToken,
    frontendApi,
    proxyUrl,
    publishableKey,
    domain,
    isSatellite,
    headerToken,
    loadSession,
    loadUser,
    loadOrganization,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl
  } = options;
  const { sid: sessionId, org_id: orgId, sub: userId } = sessionClaims;
  const { sessions: sessions2, users: users2, organizations: organizations2 } = createBackendApiClient({
    apiKey,
    secretKey,
    apiUrl,
    apiVersion
  });
  const [sessionResp, userResp, organizationResp] = await Promise.all([
    loadSession ? sessions2.getSession(sessionId) : Promise.resolve(void 0),
    loadUser ? users2.getUser(userId) : Promise.resolve(void 0),
    loadOrganization && orgId ? organizations2.getOrganization({ organizationId: orgId }) : Promise.resolve(void 0)
  ]);
  const session = sessionResp;
  const user = userResp;
  const organization = organizationResp;
  const authObject = signedInAuthObject(
    sessionClaims,
    {
      secretKey,
      apiKey,
      apiUrl,
      apiVersion,
      token: cookieToken || headerToken || "",
      session,
      user,
      organization
    },
    {
      ...options,
      status: "signed-in"
      /* SignedIn */
    }
  );
  return {
    status: "signed-in",
    reason: null,
    message: null,
    frontendApi,
    proxyUrl,
    publishableKey,
    domain,
    isSatellite,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: true,
    isInterstitial: false,
    isUnknown: false,
    toAuth: () => authObject
  };
}
__name(signedIn, "signedIn");
function signedOut(options, reason, message = "") {
  const {
    frontendApi,
    publishableKey,
    proxyUrl,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl
  } = options;
  return {
    status: "signed-out",
    reason,
    message,
    frontendApi,
    proxyUrl,
    publishableKey,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: false,
    isInterstitial: false,
    isUnknown: false,
    toAuth: () => signedOutAuthObject({ ...options, status: "signed-out", reason, message })
  };
}
__name(signedOut, "signedOut");
function interstitial(options, reason, message = "") {
  const {
    frontendApi,
    publishableKey,
    proxyUrl,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl
  } = options;
  return {
    status: "interstitial",
    reason,
    message,
    frontendApi,
    publishableKey,
    isSatellite,
    domain,
    proxyUrl,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: false,
    isInterstitial: true,
    isUnknown: false,
    toAuth: () => null
  };
}
__name(interstitial, "interstitial");
function unknownState(options, reason, message = "") {
  const { frontendApi, publishableKey, isSatellite, domain, signInUrl, signUpUrl, afterSignInUrl, afterSignUpUrl } = options;
  return {
    status: "unknown",
    reason,
    message,
    frontendApi,
    publishableKey,
    isSatellite,
    domain,
    signInUrl,
    signUpUrl,
    afterSignInUrl,
    afterSignUpUrl,
    isSignedIn: false,
    isInterstitial: false,
    isUnknown: true,
    toAuth: () => null
  };
}
__name(unknownState, "unknownState");
var getFirstValueFromHeader = /* @__PURE__ */ __name((value) => value?.split(",")[0], "getFirstValueFromHeader");
var buildOrigin = /* @__PURE__ */ __name(({ protocol, forwardedProto, forwardedHost, host }) => {
  const resolvedHost = getFirstValueFromHeader(forwardedHost) ?? host;
  const resolvedProtocol = getFirstValueFromHeader(forwardedProto) ?? protocol?.replace(/[:/]/, "");
  if (!resolvedHost || !resolvedProtocol) {
    return "";
  }
  return `${resolvedProtocol}://${resolvedHost}`;
}, "buildOrigin");
function checkCrossOrigin({
  originURL,
  host,
  forwardedHost,
  forwardedProto
}) {
  const finalURL = buildOrigin({ forwardedProto, forwardedHost, protocol: originURL.protocol, host });
  return finalURL && new URL(finalURL).origin !== originURL.origin;
}
__name(checkCrossOrigin, "checkCrossOrigin");
var getErrorObjectByCode = /* @__PURE__ */ __name((errors, code2) => {
  if (!errors) {
    return null;
  }
  return errors.find((err) => err.code === code2);
}, "getErrorObjectByCode");
var base64url = {
  parse(string, opts) {
    return parse22(string, base64UrlEncoding, opts);
  },
  stringify(data, opts) {
    return stringify3(data, base64UrlEncoding, opts);
  }
};
var base64UrlEncoding = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bits: 6
};
function parse22(string, encoding, opts = {}) {
  if (!encoding.codes) {
    encoding.codes = {};
    for (let i10 = 0; i10 < encoding.chars.length; ++i10) {
      encoding.codes[encoding.chars[i10]] = i10;
    }
  }
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError("Invalid padding");
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError("Invalid padding");
    }
  }
  const out = new (opts.out ?? Uint8Array)(end * encoding.bits / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i10 = 0; i10 < end; ++i10) {
    const value = encoding.codes[string[i10]];
    if (value === void 0) {
      throw new SyntaxError("Invalid character " + string[i10]);
    }
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= encoding.bits || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
__name(parse22, "parse2");
function stringify3(data, encoding, opts = {}) {
  const { pad = true } = opts;
  const mask = (1 << encoding.bits) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i10 = 0; i10 < data.length; ++i10) {
    buffer = buffer << 8 | 255 & data[i10];
    bits += 8;
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += "=";
    }
  }
  return out;
}
__name(stringify3, "stringify");
var isArrayString = /* @__PURE__ */ __name((s10) => {
  return Array.isArray(s10) && s10.length > 0 && s10.every((a10) => typeof a10 === "string");
}, "isArrayString");
var assertAudienceClaim = /* @__PURE__ */ __name((aud, audience) => {
  const audienceList = [audience].flat().filter((a10) => !!a10);
  const audList = [aud].flat().filter((a10) => !!a10);
  const shouldVerifyAudience = audienceList.length > 0 && audList.length > 0;
  if (!shouldVerifyAudience) {
    return;
  }
  if (typeof aud === "string") {
    if (!audienceList.includes(aud)) {
      throw new TokenVerificationError({
        action: "Make sure that this is a valid Clerk generate JWT.",
        reason: "token-verification-failed",
        message: `Invalid JWT audience claim (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(
          audienceList
        )}".`
      });
    }
  } else if (isArrayString(aud)) {
    if (!aud.some((a10) => audienceList.includes(a10))) {
      throw new TokenVerificationError({
        action: "Make sure that this is a valid Clerk generate JWT.",
        reason: "token-verification-failed",
        message: `Invalid JWT audience claim array (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(
          audienceList
        )}".`
      });
    }
  }
}, "assertAudienceClaim");
var DEFAULT_CLOCK_SKEW_IN_SECONDS = 5 * 1e3;
var algToHash = {
  RS256: "SHA-256",
  RS384: "SHA-384",
  RS512: "SHA-512",
  ES256: "SHA-256",
  ES384: "SHA-384",
  ES512: "SHA-512"
};
var RSA_ALGORITHM_NAME = "RSASSA-PKCS1-v1_5";
var EC_ALGORITHM_NAME = "ECDSA";
var jwksAlgToCryptoAlg = {
  RS256: RSA_ALGORITHM_NAME,
  RS384: RSA_ALGORITHM_NAME,
  RS512: RSA_ALGORITHM_NAME,
  ES256: EC_ALGORITHM_NAME,
  ES384: EC_ALGORITHM_NAME,
  ES512: EC_ALGORITHM_NAME
};
var algs = Object.keys(algToHash);
async function hasValidSignature(jwt, jwk) {
  const { header, signature, raw } = jwt;
  const encoder2 = new TextEncoder();
  const data = encoder2.encode([raw.header, raw.payload].join("."));
  const cryptoKey = await runtime_default.crypto.subtle.importKey(
    "jwk",
    jwk,
    {
      name: jwksAlgToCryptoAlg[header.alg],
      hash: algToHash[header.alg]
    },
    false,
    ["verify"]
  );
  return runtime_default.crypto.subtle.verify("RSASSA-PKCS1-v1_5", cryptoKey, signature, data);
}
__name(hasValidSignature, "hasValidSignature");
function decodeJwt(token) {
  const tokenParts = (token || "").toString().split(".");
  if (tokenParts.length !== 3) {
    throw new TokenVerificationError({
      reason: "token-invalid",
      message: `Invalid JWT form. A JWT consists of three parts separated by dots.`
    });
  }
  const [rawHeader, rawPayload, rawSignature] = tokenParts;
  const decoder2 = new TextDecoder();
  const header = JSON.parse(decoder2.decode(base64url.parse(rawHeader, { loose: true })));
  const payload = JSON.parse(decoder2.decode(base64url.parse(rawPayload, { loose: true })));
  const signature = base64url.parse(rawSignature, { loose: true });
  return {
    header,
    payload,
    signature,
    raw: {
      header: rawHeader,
      payload: rawPayload,
      signature: rawSignature,
      text: token
    }
  };
}
__name(decodeJwt, "decodeJwt");
async function verifyJwt(token, { audience, authorizedParties, clockSkewInSeconds, clockSkewInMs, issuer, key }) {
  const clockSkew = clockSkewInMs || clockSkewInSeconds || DEFAULT_CLOCK_SKEW_IN_SECONDS;
  const decoded = decodeJwt(token);
  const { header, payload } = decoded;
  const { typ, alg } = header;
  if (typeof typ !== "undefined" && typ !== "JWT") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-invalid",
      message: `Invalid JWT type ${JSON.stringify(typ)}. Expected "JWT".`
    });
  }
  if (!algToHash[alg]) {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-invalid-algorithm",
      message: `Invalid JWT algorithm ${JSON.stringify(alg)}. Supported: ${algs}.`
    });
  }
  const { azp, sub, aud, iss, iat, exp, nbf } = payload;
  if (typeof sub !== "string") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Subject claim (sub) is required and must be a string. Received ${JSON.stringify(sub)}.`
    });
  }
  assertAudienceClaim([aud], [audience]);
  if (azp && authorizedParties && authorizedParties.length > 0 && !authorizedParties.includes(azp)) {
    throw new TokenVerificationError({
      reason: "token-invalid-authorized-parties",
      message: `Invalid JWT Authorized party claim (azp) ${JSON.stringify(azp)}. Expected "${authorizedParties}".`
    });
  }
  if (typeof issuer === "function" && !issuer(iss)) {
    throw new TokenVerificationError({
      reason: "token-invalid-issuer",
      message: "Failed JWT issuer resolver. Make sure that the resolver returns a truthy value."
    });
  } else if (typeof issuer === "string" && iss && iss !== issuer) {
    throw new TokenVerificationError({
      reason: "token-invalid-issuer",
      message: `Invalid JWT issuer claim (iss) ${JSON.stringify(decoded.payload.iss)}. Expected "${issuer}".`
    });
  }
  if (typeof exp !== "number") {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Invalid JWT expiry date claim (exp) ${JSON.stringify(exp)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const expiryDate = /* @__PURE__ */ new Date(0);
  expiryDate.setUTCSeconds(exp);
  const expired = expiryDate.getTime() <= currentDate.getTime() - clockSkew;
  if (expired) {
    throw new TokenVerificationError({
      reason: "token-expired",
      message: `JWT is expired. Expiry date: ${expiryDate}, Current date: ${currentDate}.`
    });
  }
  if (nbf !== void 0) {
    if (typeof nbf !== "number") {
      throw new TokenVerificationError({
        action: "Make sure that this is a valid Clerk generate JWT.",
        reason: "token-verification-failed",
        message: `Invalid JWT not before date claim (nbf) ${JSON.stringify(nbf)}. Expected number.`
      });
    }
    const notBeforeDate = /* @__PURE__ */ new Date(0);
    notBeforeDate.setUTCSeconds(nbf);
    const early = notBeforeDate.getTime() > currentDate.getTime() + clockSkew;
    if (early) {
      throw new TokenVerificationError({
        action: "Make sure your system clock is in sync (e.g. turn off and on automatic time synchronization).",
        reason: "token-not-active-yet",
        message: `JWT cannot be used prior to not before date claim (nbf). Not before date: ${notBeforeDate}; Current date: ${currentDate};`
      });
    }
  }
  if (iat !== void 0) {
    if (typeof iat !== "number") {
      throw new TokenVerificationError({
        action: "Make sure that this is a valid Clerk generate JWT.",
        reason: "token-verification-failed",
        message: `Invalid JWT issued at date claim (iat) ${JSON.stringify(iat)}. Expected number.`
      });
    }
    const issuedAtDate = /* @__PURE__ */ new Date(0);
    issuedAtDate.setUTCSeconds(iat);
    const postIssued = issuedAtDate.getTime() > currentDate.getTime() + clockSkew;
    if (postIssued) {
      throw new TokenVerificationError({
        reason: "token-not-active-yet",
        message: `JWT issued at date claim (iat) is in the future. Issued at date: ${issuedAtDate}; Current date: ${currentDate};`
      });
    }
  }
  let signatureValid;
  try {
    signatureValid = await hasValidSignature(decoded, key);
  } catch (err) {
    throw new TokenVerificationError({
      action: "Make sure that this is a valid Clerk generate JWT.",
      reason: "token-verification-failed",
      message: `Error verifying JWT signature. ${err}`
    });
  }
  if (!signatureValid) {
    throw new TokenVerificationError({
      reason: "token-invalid-signature",
      message: "JWT signature is invalid."
    });
  }
  return payload;
}
__name(verifyJwt, "verifyJwt");
var cache = {};
var lastUpdatedAt = 0;
function getFromCache(kid) {
  return cache[kid];
}
__name(getFromCache, "getFromCache");
function setInCache(jwk, jwksCacheTtlInMs = 1e3 * 60 * 60) {
  cache[jwk.kid] = jwk;
  lastUpdatedAt = Date.now();
  if (jwksCacheTtlInMs >= 0) {
    setTimeout(() => {
      if (jwk) {
        delete cache[jwk.kid];
      } else {
        cache = {};
      }
    }, jwksCacheTtlInMs);
  }
}
__name(setInCache, "setInCache");
var LocalJwkKid = "local";
var PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
var PEM_TRAILER = "-----END PUBLIC KEY-----";
var RSA_PREFIX = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA";
var RSA_SUFFIX = "IDAQAB";
function loadClerkJWKFromLocal(localKey) {
  if (!getFromCache(LocalJwkKid)) {
    if (!localKey) {
      throw new TokenVerificationError({
        action: "Set the CLERK_JWT_KEY environment variable.",
        message: "Missing local JWK.",
        reason: "jwk-local-missing"
        /* LocalJWKMissing */
      });
    }
    const modulus = localKey.replace(/(\r\n|\n|\r)/gm, "").replace(PEM_HEADER, "").replace(PEM_TRAILER, "").replace(RSA_PREFIX, "").replace(RSA_SUFFIX, "").replace(/\+/g, "-").replace(/\//g, "_");
    setInCache(
      {
        kid: "local",
        kty: "RSA",
        alg: "RS256",
        n: modulus,
        e: "AQAB"
      },
      -1
      // local key never expires in cache
    );
  }
  return getFromCache(LocalJwkKid);
}
__name(loadClerkJWKFromLocal, "loadClerkJWKFromLocal");
async function loadClerkJWKFromRemote({
  apiKey,
  secretKey,
  apiUrl = API_URL,
  apiVersion = API_VERSION,
  issuer,
  kid,
  jwksCacheTtlInMs = 1e3 * 60 * 60,
  // 1 hour,
  skipJwksCache
}) {
  const shouldRefreshCache = !getFromCache(kid) && reachedMaxCacheUpdatedAt();
  if (skipJwksCache || shouldRefreshCache) {
    let fetcher;
    const key = secretKey || apiKey;
    if (key) {
      fetcher = /* @__PURE__ */ __name(() => fetchJWKSFromBAPI(apiUrl, key, apiVersion), "fetcher");
    } else if (issuer) {
      fetcher = /* @__PURE__ */ __name(() => fetchJWKSFromFAPI(issuer), "fetcher");
    } else {
      throw new TokenVerificationError({
        action: "Contact support@clerk.com",
        message: "Failed to load JWKS from Clerk Backend or Frontend API.",
        reason: "jwk-remote-failed-to-load"
        /* RemoteJWKFailedToLoad */
      });
    }
    const { keys } = await callWithRetry(fetcher);
    if (!keys || !keys.length) {
      throw new TokenVerificationError({
        action: "Contact support@clerk.com",
        message: "The JWKS endpoint did not contain any signing keys. Contact support@clerk.com.",
        reason: "jwk-remote-failed-to-load"
        /* RemoteJWKFailedToLoad */
      });
    }
    keys.forEach((key2) => setInCache(key2, jwksCacheTtlInMs));
  }
  const jwk = getFromCache(kid);
  if (!jwk) {
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Unable to find a signing key in JWKS that matches the kid='${kid}' of the provided session token. Please make sure that the __session cookie or the HTTP authorization header contain a Clerk-generated session JWT.`,
      reason: "jwk-remote-missing"
      /* RemoteJWKMissing */
    });
  }
  return jwk;
}
__name(loadClerkJWKFromRemote, "loadClerkJWKFromRemote");
async function fetchJWKSFromFAPI(issuer) {
  const url12 = new URL(issuer);
  url12.pathname = joinPaths(url12.pathname, ".well-known/jwks.json");
  const response = await runtime_default.fetch(url12.href);
  if (!response.ok) {
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Error loading Clerk JWKS from ${url12.href} with code=${response.status}`,
      reason: "jwk-remote-failed-to-load"
      /* RemoteJWKFailedToLoad */
    });
  }
  return response.json();
}
__name(fetchJWKSFromFAPI, "fetchJWKSFromFAPI");
async function fetchJWKSFromBAPI(apiUrl, key, apiVersion) {
  if (!key) {
    throw new TokenVerificationError({
      action: "Set the CLERK_SECRET_KEY or CLERK_API_KEY environment variable.",
      message: "Missing Clerk Secret Key or API Key. Go to https://dashboard.clerk.com and get your key for your instance.",
      reason: "jwk-remote-failed-to-load"
      /* RemoteJWKFailedToLoad */
    });
  }
  const url12 = new URL(apiUrl);
  url12.pathname = joinPaths(url12.pathname, apiVersion, "/jwks");
  const response = await runtime_default.fetch(url12.href, {
    headers: {
      Authorization: `Bearer ${key}`,
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    const json2 = await response.json();
    const invalidSecretKeyError = getErrorObjectByCode(
      json2?.errors,
      "clerk_key_invalid"
      /* InvalidSecretKey */
    );
    if (invalidSecretKeyError) {
      const reason = "secret-key-invalid";
      throw new TokenVerificationError({
        action: "Contact support@clerk.com",
        message: invalidSecretKeyError.message,
        reason
      });
    }
    throw new TokenVerificationError({
      action: "Contact support@clerk.com",
      message: `Error loading Clerk JWKS from ${url12.href} with code=${response.status}`,
      reason: "jwk-remote-failed-to-load"
      /* RemoteJWKFailedToLoad */
    });
  }
  return response.json();
}
__name(fetchJWKSFromBAPI, "fetchJWKSFromBAPI");
function reachedMaxCacheUpdatedAt() {
  return Date.now() - lastUpdatedAt >= MAX_CACHE_LAST_UPDATED_AT_SECONDS * 1e3;
}
__name(reachedMaxCacheUpdatedAt, "reachedMaxCacheUpdatedAt");
async function verifyToken(token, options) {
  const {
    apiKey,
    secretKey,
    apiUrl,
    apiVersion,
    audience,
    authorizedParties,
    clockSkewInSeconds,
    clockSkewInMs,
    issuer,
    jwksCacheTtlInMs,
    jwtKey,
    skipJwksCache
  } = options;
  const { header } = decodeJwt(token);
  const { kid } = header;
  let key;
  if (jwtKey) {
    key = loadClerkJWKFromLocal(jwtKey);
  } else if (typeof issuer === "string") {
    key = await loadClerkJWKFromRemote({ issuer, kid, jwksCacheTtlInMs, skipJwksCache });
  } else if (apiKey || secretKey) {
    key = await loadClerkJWKFromRemote({ apiKey, secretKey, apiUrl, apiVersion, kid, jwksCacheTtlInMs, skipJwksCache });
  } else {
    throw new TokenVerificationError({
      action: "Set the CLERK_JWT_KEY environment variable.",
      message: "Failed to resolve JWK during verification.",
      reason: "jwk-failed-to-resolve"
      /* JWKFailedToResolve */
    });
  }
  return await verifyJwt(token, {
    audience,
    authorizedParties,
    clockSkewInSeconds,
    clockSkewInMs,
    key,
    issuer
  });
}
__name(verifyToken, "verifyToken");
var shouldRedirectToSatelliteUrl = /* @__PURE__ */ __name((qp) => !!qp?.get("__clerk_satellite_url"), "shouldRedirectToSatelliteUrl");
var hasJustSynced = /* @__PURE__ */ __name((qp) => qp?.get("__clerk_synced") === "true", "hasJustSynced");
var isReturningFromPrimary = /* @__PURE__ */ __name((qp) => qp?.get("__clerk_referrer_primary") === "true", "isReturningFromPrimary");
var VALID_USER_AGENTS = /^Mozilla\/|(Amazon CloudFront)/;
var isBrowser = /* @__PURE__ */ __name((userAgent2) => VALID_USER_AGENTS.test(userAgent2 || ""), "isBrowser");
var nonBrowserRequestInDevRule = /* @__PURE__ */ __name((options) => {
  const { apiKey, secretKey, userAgent: userAgent2 } = options;
  const key = secretKey || apiKey || "";
  if (isDevelopmentFromApiKey(key) && !isBrowser(userAgent2)) {
    return signedOut(
      options,
      "header-missing-non-browser"
      /* HeaderMissingNonBrowser */
    );
  }
  return void 0;
}, "nonBrowserRequestInDevRule");
var crossOriginRequestWithoutHeader = /* @__PURE__ */ __name((options) => {
  const { origin, host, forwardedHost, forwardedProto } = options;
  const isCrossOrigin = origin && checkCrossOrigin({
    originURL: new URL(origin),
    host,
    forwardedHost,
    forwardedProto
  });
  if (isCrossOrigin) {
    return signedOut(
      options,
      "header-missing-cors"
      /* HeaderMissingCORS */
    );
  }
  return void 0;
}, "crossOriginRequestWithoutHeader");
var isPrimaryInDevAndRedirectsToSatellite = /* @__PURE__ */ __name((options) => {
  const { apiKey, secretKey, isSatellite, searchParams } = options;
  const key = secretKey || apiKey || "";
  const isDev = isDevelopmentFromApiKey(key);
  if (isDev && !isSatellite && shouldRedirectToSatelliteUrl(searchParams)) {
    return interstitial(
      options,
      "primary-responds-to-syncing"
      /* PrimaryRespondsToSyncing */
    );
  }
  return void 0;
}, "isPrimaryInDevAndRedirectsToSatellite");
var potentialFirstLoadInDevWhenUATMissing = /* @__PURE__ */ __name((options) => {
  const { apiKey, secretKey, clientUat } = options;
  const key = secretKey || apiKey || "";
  const res = isDevelopmentFromApiKey(key);
  if (res && !clientUat) {
    return interstitial(
      options,
      "uat-missing"
      /* CookieUATMissing */
    );
  }
  return void 0;
}, "potentialFirstLoadInDevWhenUATMissing");
var potentialRequestAfterSignInOrOutFromClerkHostedUiInDev = /* @__PURE__ */ __name((options) => {
  const { apiKey, secretKey, referrer, host, forwardedHost, forwardedProto } = options;
  const crossOriginReferrer = referrer && checkCrossOrigin({ originURL: new URL(referrer), host, forwardedHost, forwardedProto });
  const key = secretKey || apiKey || "";
  if (isDevelopmentFromApiKey(key) && crossOriginReferrer) {
    return interstitial(
      options,
      "cross-origin-referrer"
      /* CrossOriginReferrer */
    );
  }
  return void 0;
}, "potentialRequestAfterSignInOrOutFromClerkHostedUiInDev");
var satelliteInDevReturningFromPrimary = /* @__PURE__ */ __name((options) => {
  const { apiKey, secretKey, isSatellite, searchParams } = options;
  const key = secretKey || apiKey || "";
  if (isSatellite && isReturningFromPrimary(searchParams) && isDevelopmentFromApiKey(key)) {
    return interstitial(
      options,
      "satellite-returns-from-primary"
      /* SatelliteReturnsFromPrimary */
    );
  }
  return void 0;
}, "satelliteInDevReturningFromPrimary");
var potentialFirstRequestOnProductionEnvironment = /* @__PURE__ */ __name((options) => {
  const { apiKey, secretKey, clientUat, cookieToken } = options;
  const key = secretKey || apiKey || "";
  if (isProductionFromApiKey(key) && !clientUat && !cookieToken) {
    return signedOut(
      options,
      "cookie-and-uat-missing"
      /* CookieAndUATMissing */
    );
  }
  return void 0;
}, "potentialFirstRequestOnProductionEnvironment");
var isNormalSignedOutState = /* @__PURE__ */ __name((options) => {
  const { clientUat } = options;
  if (clientUat === "0") {
    return signedOut(
      options,
      "standard-signed-out"
      /* StandardSignedOut */
    );
  }
  return void 0;
}, "isNormalSignedOutState");
var hasPositiveClientUatButCookieIsMissing = /* @__PURE__ */ __name((options) => {
  const { clientUat, cookieToken } = options;
  if (clientUat && Number.parseInt(clientUat) > 0 && !cookieToken) {
    return interstitial(
      options,
      "cookie-missing"
      /* CookieMissing */
    );
  }
  return void 0;
}, "hasPositiveClientUatButCookieIsMissing");
var hasValidHeaderToken = /* @__PURE__ */ __name(async (options) => {
  const { headerToken } = options;
  const sessionClaims = await verifyRequestState(options, headerToken);
  return await signedIn(options, sessionClaims);
}, "hasValidHeaderToken");
var hasValidCookieToken = /* @__PURE__ */ __name(async (options) => {
  const { cookieToken, clientUat } = options;
  const sessionClaims = await verifyRequestState(options, cookieToken);
  const state = await signedIn(options, sessionClaims);
  const jwt = state.toAuth().sessionClaims;
  const cookieTokenIsOutdated = jwt.iat < Number.parseInt(clientUat);
  if (!clientUat || cookieTokenIsOutdated) {
    return interstitial(
      options,
      "cookie-outdated"
      /* CookieOutDated */
    );
  }
  return state;
}, "hasValidCookieToken");
async function runInterstitialRules(opts, rules) {
  for (const rule of rules) {
    const res = await rule(opts);
    if (res) {
      return res;
    }
  }
  return signedOut(
    opts,
    "unexpected-error"
    /* UnexpectedError */
  );
}
__name(runInterstitialRules, "runInterstitialRules");
async function verifyRequestState(options, token) {
  const { isSatellite, proxyUrl } = options;
  let issuer;
  if (isSatellite) {
    issuer = null;
  } else if (proxyUrl) {
    issuer = proxyUrl;
  } else {
    issuer = /* @__PURE__ */ __name((iss) => iss.startsWith("https://clerk.") || iss.includes(".clerk.accounts"), "issuer");
  }
  return verifyToken(token, { ...options, issuer });
}
__name(verifyRequestState, "verifyRequestState");
var isSatelliteAndNeedsSyncing = /* @__PURE__ */ __name((options) => {
  const { clientUat, isSatellite, searchParams, userAgent: userAgent2 } = options;
  const isSignedOut = !clientUat || clientUat === "0";
  if (isSatellite && isSignedOut && !isBrowser(userAgent2)) {
    return signedOut(
      options,
      "satellite-needs-syncing"
      /* SatelliteCookieNeedsSyncing */
    );
  }
  if (isSatellite && isSignedOut && !hasJustSynced(searchParams)) {
    return interstitial(
      options,
      "satellite-needs-syncing"
      /* SatelliteCookieNeedsSyncing */
    );
  }
  return void 0;
}, "isSatelliteAndNeedsSyncing");
function assertSignInUrlExists(signInUrl, key) {
  if (!signInUrl && isDevelopmentFromApiKey(key)) {
    throw new Error(`Missing signInUrl. Pass a signInUrl for dev instances if an app is satellite`);
  }
}
__name(assertSignInUrlExists, "assertSignInUrlExists");
function assertProxyUrlOrDomain(proxyUrlOrDomain) {
  if (!proxyUrlOrDomain) {
    throw new Error(`Missing domain and proxyUrl. A satellite application needs to specify a domain or a proxyUrl`);
  }
}
__name(assertProxyUrlOrDomain, "assertProxyUrlOrDomain");
async function authenticateRequest(options) {
  const { cookies, headers, searchParams } = buildRequest2(options?.request);
  options = {
    ...options,
    frontendApi: parsePublishableKey(options.publishableKey)?.frontendApi || options.frontendApi,
    apiUrl: options.apiUrl || API_URL,
    apiVersion: options.apiVersion || API_VERSION,
    headerToken: stripAuthorizationHeader(options.headerToken || headers?.(constants2.Headers.Authorization)),
    cookieToken: options.cookieToken || cookies?.(constants2.Cookies.Session),
    clientUat: options.clientUat || cookies?.(constants2.Cookies.ClientUat),
    origin: options.origin || headers?.(constants2.Headers.Origin),
    host: options.host || headers?.(constants2.Headers.Host),
    forwardedHost: options.forwardedHost || headers?.(constants2.Headers.ForwardedHost),
    forwardedPort: options.forwardedPort || headers?.(constants2.Headers.ForwardedPort),
    forwardedProto: options.forwardedProto || headers?.(constants2.Headers.ForwardedProto),
    referrer: options.referrer || headers?.(constants2.Headers.Referrer),
    userAgent: options.userAgent || headers?.(constants2.Headers.UserAgent),
    searchParams: options.searchParams || searchParams || void 0
  };
  assertValidSecretKey(options.secretKey || options.apiKey);
  if (options.isSatellite) {
    assertSignInUrlExists(options.signInUrl, options.secretKey || options.apiKey);
    assertProxyUrlOrDomain(options.proxyUrl || options.domain);
  }
  async function authenticateRequestWithTokenInHeader() {
    try {
      const state = await runInterstitialRules(options, [hasValidHeaderToken]);
      return state;
    } catch (err) {
      return handleError(err, "header");
    }
  }
  __name(authenticateRequestWithTokenInHeader, "authenticateRequestWithTokenInHeader");
  async function authenticateRequestWithTokenInCookie() {
    try {
      const state = await runInterstitialRules(options, [
        crossOriginRequestWithoutHeader,
        nonBrowserRequestInDevRule,
        isSatelliteAndNeedsSyncing,
        satelliteInDevReturningFromPrimary,
        isPrimaryInDevAndRedirectsToSatellite,
        potentialFirstRequestOnProductionEnvironment,
        potentialFirstLoadInDevWhenUATMissing,
        potentialRequestAfterSignInOrOutFromClerkHostedUiInDev,
        hasPositiveClientUatButCookieIsMissing,
        isNormalSignedOutState,
        hasValidCookieToken
      ]);
      return state;
    } catch (err) {
      return handleError(err, "cookie");
    }
  }
  __name(authenticateRequestWithTokenInCookie, "authenticateRequestWithTokenInCookie");
  function handleError(err, tokenCarrier) {
    if (err instanceof TokenVerificationError) {
      err.tokenCarrier = tokenCarrier;
      const reasonToReturnInterstitial = [
        "token-expired",
        "token-not-active-yet"
        /* TokenNotActiveYet */
      ].includes(err.reason);
      if (reasonToReturnInterstitial) {
        if (tokenCarrier === "header") {
          return unknownState(options, err.reason, err.getFullMessage());
        }
        return interstitial(options, err.reason, err.getFullMessage());
      }
      return signedOut(options, err.reason, err.getFullMessage());
    }
    return signedOut(options, "unexpected-error", err.message);
  }
  __name(handleError, "handleError");
  if (options.headerToken) {
    return authenticateRequestWithTokenInHeader();
  }
  return authenticateRequestWithTokenInCookie();
}
__name(authenticateRequest, "authenticateRequest");
var debugRequestState = /* @__PURE__ */ __name((params) => {
  const { frontendApi, isSignedIn, proxyUrl, isInterstitial, reason, message, publishableKey, isSatellite, domain } = params;
  return { frontendApi, isSignedIn, proxyUrl, isInterstitial, reason, message, publishableKey, isSatellite, domain };
}, "debugRequestState");
function createAuthenticateRequest(params) {
  const { apiClient } = params;
  const {
    apiKey: buildtimeApiKey = "",
    secretKey: buildtimeSecretKey = "",
    jwtKey: buildtimeJwtKey = "",
    apiUrl = API_URL,
    apiVersion = API_VERSION,
    frontendApi: buildtimeFrontendApi = "",
    proxyUrl: buildProxyUrl = "",
    publishableKey: buildtimePublishableKey = "",
    isSatellite: buildtimeIsSatellite = false,
    domain: buildtimeDomain = "",
    audience: buildtimeAudience = "",
    userAgent: buildUserAgent
  } = params.options;
  const authenticateRequest22 = /* @__PURE__ */ __name(({
    apiKey: runtimeApiKey,
    secretKey: runtimeSecretKey,
    audience: runtimeAudience,
    frontendApi: runtimeFrontendApi,
    proxyUrl: runtimeProxyUrl,
    publishableKey: runtimePublishableKey,
    jwtKey: runtimeJwtKey,
    isSatellite: runtimeIsSatellite,
    domain: runtimeDomain,
    searchParams,
    ...rest
  }) => {
    return authenticateRequest({
      ...rest,
      apiKey: runtimeApiKey || buildtimeApiKey,
      secretKey: runtimeSecretKey || buildtimeSecretKey,
      audience: runtimeAudience || buildtimeAudience,
      apiUrl,
      apiVersion,
      frontendApi: runtimeFrontendApi || buildtimeFrontendApi,
      proxyUrl: runtimeProxyUrl || buildProxyUrl,
      publishableKey: runtimePublishableKey || buildtimePublishableKey,
      isSatellite: runtimeIsSatellite || buildtimeIsSatellite,
      domain: runtimeDomain || buildtimeDomain,
      jwtKey: runtimeJwtKey || buildtimeJwtKey,
      searchParams
    });
  }, "authenticateRequest2");
  const localInterstitial = /* @__PURE__ */ __name(({
    frontendApi: runtimeFrontendApi,
    publishableKey: runtimePublishableKey,
    proxyUrl: runtimeProxyUrl,
    isSatellite: runtimeIsSatellite,
    domain: runtimeDomain,
    ...rest
  }) => loadInterstitialFromLocal({
    ...rest,
    frontendApi: runtimeFrontendApi || buildtimeFrontendApi,
    proxyUrl: runtimeProxyUrl || buildProxyUrl,
    publishableKey: runtimePublishableKey || buildtimePublishableKey,
    isSatellite: runtimeIsSatellite || buildtimeIsSatellite,
    domain: runtimeDomain || buildtimeDomain
  }), "localInterstitial");
  const remotePublicInterstitial = /* @__PURE__ */ __name(({
    frontendApi: runtimeFrontendApi,
    publishableKey: runtimePublishableKey,
    proxyUrl: runtimeProxyUrl,
    isSatellite: runtimeIsSatellite,
    domain: runtimeDomain,
    userAgent: runtimeUserAgent,
    ...rest
  }) => {
    return loadInterstitialFromBAPI({
      ...rest,
      apiUrl,
      frontendApi: runtimeFrontendApi || buildtimeFrontendApi,
      publishableKey: runtimePublishableKey || buildtimePublishableKey,
      proxyUrl: runtimeProxyUrl || buildProxyUrl,
      isSatellite: runtimeIsSatellite || buildtimeIsSatellite,
      domain: runtimeDomain || buildtimeDomain,
      userAgent: runtimeUserAgent || buildUserAgent
    });
  }, "remotePublicInterstitial");
  const remotePublicInterstitialUrl = buildPublicInterstitialUrl;
  const remotePrivateInterstitial = /* @__PURE__ */ __name(() => apiClient.interstitial.getInterstitial(), "remotePrivateInterstitial");
  return {
    authenticateRequest: authenticateRequest22,
    localInterstitial,
    remotePublicInterstitial,
    remotePrivateInterstitial,
    remotePublicInterstitialUrl,
    debugRequestState
  };
}
__name(createAuthenticateRequest, "createAuthenticateRequest");
function Clerk(options) {
  const opts = { ...options };
  const apiClient = createBackendApiClient(opts);
  const requestState = createAuthenticateRequest({ options: opts, apiClient });
  return {
    ...apiClient,
    ...requestState,
    /**
     * @deprecated This prop has been deprecated and will be removed in the next major release.
     */
    __unstable_options: opts
  };
}
__name(Clerk, "Clerk");

// ../../node_modules/@clerk/clerk-sdk-node/dist/esm/chunk-5MVOX6VR.mjs
function isValidProxyUrl(key) {
  if (!key) {
    return true;
  }
  return isHttpOrHttps(key) || isProxyUrlRelative(key);
}
__name(isValidProxyUrl, "isValidProxyUrl");
function isHttpOrHttps(key) {
  return /^http(s)?:\/\//.test(key || "");
}
__name(isHttpOrHttps, "isHttpOrHttps");
function isProxyUrlRelative(key) {
  return key.startsWith("/");
}
__name(isProxyUrlRelative, "isProxyUrlRelative");
function handleValueOrFn(value, url12, defaultValue) {
  if (typeof value === "function") {
    return value(url12);
  }
  if (typeof value !== "undefined") {
    return value;
  }
  if (typeof defaultValue !== "undefined") {
    return defaultValue;
  }
  return void 0;
}
__name(handleValueOrFn, "handleValueOrFn");
var loadClientEnv = /* @__PURE__ */ __name(() => {
  return {
    publishableKey: process.env.CLERK_PUBLISHABLE_KEY || "",
    frontendApi: process.env.CLERK_FRONTEND_API || "",
    clerkJSUrl: process.env.CLERK_JS || "",
    clerkJSVersion: process.env.CLERK_JS_VERSION || ""
  };
}, "loadClientEnv");
var loadApiEnv = /* @__PURE__ */ __name(() => {
  return {
    secretKey: process.env.CLERK_SECRET_KEY || process.env.CLERK_API_KEY || "",
    apiKey: process.env.CLERK_SECRET_KEY || process.env.CLERK_API_KEY || "",
    apiUrl: process.env.CLERK_API_URL || "https://api.clerk.dev",
    apiVersion: process.env.CLERK_API_VERSION || "v1",
    domain: process.env.CLERK_DOMAIN || "",
    proxyUrl: process.env.CLERK_PROXY_URL || "",
    signInUrl: process.env.CLERK_SIGN_IN_URL || "",
    isSatellite: process.env.CLERK_IS_SATELLITE === "true",
    jwtKey: process.env.CLERK_JWT_KEY || ""
  };
}, "loadApiEnv");
async function loadInterstitial({
  clerkClient: clerkClient22,
  requestState
}) {
  const { clerkJSVersion, clerkJSUrl } = loadClientEnv();
  if (requestState.publishableKey || requestState.frontendApi) {
    return clerkClient22.localInterstitial({
      frontendApi: requestState.frontendApi,
      publishableKey: requestState.publishableKey,
      proxyUrl: requestState.proxyUrl,
      signInUrl: requestState.signInUrl,
      isSatellite: requestState.isSatellite,
      domain: requestState.domain,
      clerkJSVersion,
      clerkJSUrl
    });
  }
  return await clerkClient22.remotePrivateInterstitial();
}
__name(loadInterstitial, "loadInterstitial");
var authenticateRequest2 = /* @__PURE__ */ __name((opts) => {
  const { clerkClient: clerkClient22, apiKey, secretKey, frontendApi, publishableKey, req, options } = opts;
  const { jwtKey, authorizedParties, audience } = options || {};
  const env3 = { ...loadApiEnv(), ...loadClientEnv() };
  const requestUrl = getRequestUrl(req);
  const isSatellite = handleValueOrFn(options?.isSatellite, requestUrl, env3.isSatellite);
  const domain = handleValueOrFn(options?.domain, requestUrl) || env3.domain;
  const signInUrl = options?.signInUrl || env3.signInUrl;
  const proxyUrl = absoluteProxyUrl(
    handleValueOrFn(options?.proxyUrl, requestUrl, env3.proxyUrl),
    requestUrl.toString()
  );
  if (isSatellite && !proxyUrl && !domain) {
    throw new Error(satelliteAndMissingProxyUrlAndDomain);
  }
  if (isSatellite && !isHttpOrHttps(signInUrl) && isDevelopmentFromApiKey2(secretKey || apiKey || "")) {
    throw new Error(satelliteAndMissingSignInUrl);
  }
  return clerkClient22.authenticateRequest({
    audience,
    apiKey,
    secretKey,
    frontendApi,
    publishableKey,
    jwtKey,
    authorizedParties,
    proxyUrl,
    isSatellite,
    domain,
    signInUrl,
    request: createIsomorphicRequest((Request3, Headers3) => {
      const headers = Object.keys(req.headers).reduce(
        (acc, key) => Object.assign(acc, { [key]: req?.headers[key] }),
        {}
      );
      return new Request3(requestUrl, {
        method: req.method,
        headers: new Headers3(headers)
      });
    })
  });
}, "authenticateRequest");
var handleUnknownCase = /* @__PURE__ */ __name((res, requestState) => {
  if (requestState.isUnknown) {
    res.writeHead(401, { "Content-Type": "text/html" });
    res.end();
  }
}, "handleUnknownCase");
var handleInterstitialCase = /* @__PURE__ */ __name((res, requestState, interstitial2) => {
  if (requestState.isInterstitial) {
    res.writeHead(401, { "Content-Type": "text/html" });
    res.end(interstitial2);
  }
}, "handleInterstitialCase");
var decorateResponseWithObservabilityHeaders = /* @__PURE__ */ __name((res, requestState) => {
  requestState.message && res.setHeader(constants2.Headers.AuthMessage, encodeURIComponent(requestState.message));
  requestState.reason && res.setHeader(constants2.Headers.AuthReason, encodeURIComponent(requestState.reason));
  requestState.status && res.setHeader(constants2.Headers.AuthStatus, encodeURIComponent(requestState.status));
}, "decorateResponseWithObservabilityHeaders");
var isDevelopmentFromApiKey2 = /* @__PURE__ */ __name((apiKey) => apiKey.startsWith("test_") || apiKey.startsWith("sk_test_"), "isDevelopmentFromApiKey");
var getRequestUrl = /* @__PURE__ */ __name((req) => {
  return new URL(req.url, `${getRequestProto(req)}://${req.headers.host}`);
}, "getRequestUrl");
var getRequestProto = /* @__PURE__ */ __name((req) => {
  const mightWork = req.connection?.encrypted ? "https" : "http";
  const proto = req.headers[constants2.Headers.ForwardedProto] || mightWork;
  if (!proto) {
    throw new Error(missingProto);
  }
  return proto.split(",")[0].trim();
}, "getRequestProto");
var absoluteProxyUrl = /* @__PURE__ */ __name((relativeOrAbsoluteUrl, baseUrl) => {
  if (!relativeOrAbsoluteUrl || !isValidProxyUrl(relativeOrAbsoluteUrl) || !isProxyUrlRelative(relativeOrAbsoluteUrl)) {
    return relativeOrAbsoluteUrl;
  }
  return new URL(relativeOrAbsoluteUrl, baseUrl).toString();
}, "absoluteProxyUrl");
var satelliteAndMissingProxyUrlAndDomain = "Missing domain and proxyUrl. A satellite application needs to specify a domain or a proxyUrl";
var satelliteAndMissingSignInUrl = `
Invalid signInUrl. A satellite application requires a signInUrl for development instances.
Check if signInUrl is missing from your configuration or if it is not an absolute URL.`;
var missingProto = "Cannot determine the request protocol. Please ensure you've set the X-Forwarded-Proto header with the request protocol (http or https).";
var createClerkExpressRequireAuth = /* @__PURE__ */ __name((createOpts) => {
  const { clerkClient: clerkClient22, frontendApi = "", apiKey = "", secretKey = "", publishableKey = "" } = createOpts;
  return (options = {}) => {
    return async (req, res, next) => {
      const requestState = await authenticateRequest2({
        clerkClient: clerkClient22,
        apiKey,
        secretKey,
        frontendApi,
        publishableKey,
        req,
        options
      });
      decorateResponseWithObservabilityHeaders(res, requestState);
      if (requestState.isUnknown) {
        return handleUnknownCase(res, requestState);
      }
      if (requestState.isInterstitial) {
        const interstitial2 = await loadInterstitial({
          clerkClient: clerkClient22,
          requestState
        });
        return handleInterstitialCase(res, requestState, interstitial2);
      }
      if (requestState.isSignedIn) {
        req.auth = { ...requestState.toAuth(), claims: requestState.toAuth().sessionClaims };
        next();
        return;
      }
      next(new Error("Unauthenticated"));
    };
  };
}, "createClerkExpressRequireAuth");
var createClerkExpressWithAuth = /* @__PURE__ */ __name((createOpts) => {
  const { clerkClient: clerkClient22, frontendApi = "", apiKey = "", secretKey = "", publishableKey = "" } = createOpts;
  return (options = {}) => {
    return async (req, res, next) => {
      const requestState = await authenticateRequest2({
        clerkClient: clerkClient22,
        apiKey,
        secretKey,
        frontendApi,
        publishableKey,
        req,
        options
      });
      decorateResponseWithObservabilityHeaders(res, requestState);
      if (requestState.isUnknown) {
        return handleUnknownCase(res, requestState);
      }
      if (requestState.isInterstitial) {
        const interstitial2 = await loadInterstitial({
          clerkClient: clerkClient22,
          requestState
        });
        return handleInterstitialCase(res, requestState, interstitial2);
      }
      req.auth = {
        ...requestState.toAuth(),
        claims: requestState.toAuth().sessionClaims
      };
      next();
    };
  };
}, "createClerkExpressWithAuth");
function Clerk2(options) {
  const clerkClient22 = Clerk(options);
  const expressWithAuth = createClerkExpressWithAuth({ ...options, clerkClient: clerkClient22 });
  const expressRequireAuth = createClerkExpressRequireAuth({ ...options, clerkClient: clerkClient22 });
  const verifyToken2 = /* @__PURE__ */ __name((token, verifyOpts) => {
    const issuer = /* @__PURE__ */ __name((iss) => iss.startsWith("https://clerk.") || iss.includes(".clerk.accounts"), "issuer");
    return verifyToken(token, { issuer, ...options, ...verifyOpts });
  }, "verifyToken");
  return {
    ...clerkClient22,
    expressWithAuth,
    expressRequireAuth,
    verifyToken: verifyToken2,
    ...createBasePropForRedwoodCompatibility()
  };
}
__name(Clerk2, "Clerk");
var createBasePropForRedwoodCompatibility = /* @__PURE__ */ __name(() => {
  const verifySessionToken = /* @__PURE__ */ __name((token) => {
    const { jwtKey } = loadApiEnv();
    const { payload } = decodeJwt(token);
    return verifyToken(token, {
      issuer: payload.iss,
      jwtKey
    });
  }, "verifySessionToken");
  return { base: { verifySessionToken } };
}, "createBasePropForRedwoodCompatibility");
var clerkClientSingleton = {};
var clerkClient = new Proxy(clerkClientSingleton, {
  get(_target, property) {
    const hasBeenInitialised = !!clerkClientSingleton.authenticateRequest;
    if (hasBeenInitialised) {
      return clerkClientSingleton[property];
    }
    const env3 = { ...loadApiEnv(), ...loadClientEnv() };
    if (env3.secretKey) {
      clerkClientSingleton = Clerk2({ ...env3, userAgent: "@clerk/clerk-sdk-node" });
      return clerkClientSingleton[property];
    }
    return Clerk2({ ...env3, userAgent: "@clerk/clerk-sdk-node" })[property];
  },
  set() {
    return false;
  }
});

// ../../node_modules/@clerk/clerk-sdk-node/dist/esm/index.mjs
var {
  users,
  smsMessages,
  sessions,
  emailAddresses,
  phoneNumbers,
  emails,
  invitations,
  organizations,
  clients,
  allowlistIdentifiers,
  domains
} = clerkClient;

// ../../node_modules/@upstash/redis/esm/pkg/error.js
var UpstashError = class extends Error {
  static {
    __name(this, "UpstashError");
  }
  constructor(message) {
    super(message);
    this.name = "UpstashError";
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/util.js
function parseRecursive(obj) {
  const parsed = Array.isArray(obj) ? obj.map((o10) => {
    try {
      return parseRecursive(o10);
    } catch {
      return o10;
    }
  }) : JSON.parse(obj);
  if (typeof parsed === "number" && parsed.toString() != obj) {
    return obj;
  }
  return parsed;
}
__name(parseRecursive, "parseRecursive");
function parseResponse2(result) {
  try {
    return parseRecursive(result);
  } catch {
    return result;
  }
}
__name(parseResponse2, "parseResponse");

// ../../node_modules/@upstash/redis/esm/pkg/commands/command.js
var defaultSerializer = /* @__PURE__ */ __name((c11) => {
  switch (typeof c11) {
    case "string":
    case "number":
    case "boolean":
      return c11;
    default:
      return JSON.stringify(c11);
  }
}, "defaultSerializer");
var Command2 = class {
  static {
    __name(this, "Command");
  }
  /**
   * Create a new command instance.
   *
   * You can define a custom `deserialize` function. By default we try to deserialize as json.
   */
  constructor(command, opts) {
    Object.defineProperty(this, "command", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "serialize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "deserialize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.serialize = defaultSerializer;
    this.deserialize = typeof opts?.automaticDeserialization === "undefined" || opts.automaticDeserialization ? opts?.deserialize ?? parseResponse2 : (x4) => x4;
    this.command = command.map((c11) => this.serialize(c11));
  }
  /**
   * Execute the command using a client.
   */
  async exec(client10) {
    const { result, error } = await client10.request({
      body: this.command
    });
    if (error) {
      throw new UpstashError(error);
    }
    if (typeof result === "undefined") {
      throw new Error("Request did not return a result");
    }
    return this.deserialize(result);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/append.js
var AppendCommand = class extends Command2 {
  static {
    __name(this, "AppendCommand");
  }
  constructor(cmd, opts) {
    super(["append", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/bitcount.js
var BitCountCommand = class extends Command2 {
  static {
    __name(this, "BitCountCommand");
  }
  constructor([key, start, end], opts) {
    const command = ["bitcount", key];
    if (typeof start === "number") {
      command.push(start);
    }
    if (typeof end === "number") {
      command.push(end);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/bitop.js
var BitOpCommand = class extends Command2 {
  static {
    __name(this, "BitOpCommand");
  }
  constructor(cmd, opts) {
    super(["bitop", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/bitpos.js
var BitPosCommand = class extends Command2 {
  static {
    __name(this, "BitPosCommand");
  }
  constructor(cmd, opts) {
    super(["bitpos", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/dbsize.js
var DBSizeCommand = class extends Command2 {
  static {
    __name(this, "DBSizeCommand");
  }
  constructor(opts) {
    super(["dbsize"], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/decr.js
var DecrCommand = class extends Command2 {
  static {
    __name(this, "DecrCommand");
  }
  constructor(cmd, opts) {
    super(["decr", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/decrby.js
var DecrByCommand = class extends Command2 {
  static {
    __name(this, "DecrByCommand");
  }
  constructor(cmd, opts) {
    super(["decrby", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/del.js
var DelCommand = class extends Command2 {
  static {
    __name(this, "DelCommand");
  }
  constructor(cmd, opts) {
    super(["del", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/echo.js
var EchoCommand = class extends Command2 {
  static {
    __name(this, "EchoCommand");
  }
  constructor(cmd, opts) {
    super(["echo", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/eval.js
var EvalCommand = class extends Command2 {
  static {
    __name(this, "EvalCommand");
  }
  constructor([script, keys, args], opts) {
    super(["eval", script, keys.length, ...keys, ...args ?? []], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/evalsha.js
var EvalshaCommand = class extends Command2 {
  static {
    __name(this, "EvalshaCommand");
  }
  constructor([sha, keys, args], opts) {
    super(["evalsha", sha, keys.length, ...keys, ...args ?? []], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/exists.js
var ExistsCommand = class extends Command2 {
  static {
    __name(this, "ExistsCommand");
  }
  constructor(cmd, opts) {
    super(["exists", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/expire.js
var ExpireCommand = class extends Command2 {
  static {
    __name(this, "ExpireCommand");
  }
  constructor(cmd, opts) {
    super(["expire", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/expireat.js
var ExpireAtCommand = class extends Command2 {
  static {
    __name(this, "ExpireAtCommand");
  }
  constructor(cmd, opts) {
    super(["expireat", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/flushall.js
var FlushAllCommand = class extends Command2 {
  static {
    __name(this, "FlushAllCommand");
  }
  constructor(args, opts) {
    const command = ["flushall"];
    if (args && args.length > 0 && args[0].async) {
      command.push("async");
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/flushdb.js
var FlushDBCommand = class extends Command2 {
  static {
    __name(this, "FlushDBCommand");
  }
  constructor([opts], cmdOpts) {
    const command = ["flushdb"];
    if (opts?.async) {
      command.push("async");
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/get.js
var GetCommand = class extends Command2 {
  static {
    __name(this, "GetCommand");
  }
  constructor(cmd, opts) {
    super(["get", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/getbit.js
var GetBitCommand = class extends Command2 {
  static {
    __name(this, "GetBitCommand");
  }
  constructor(cmd, opts) {
    super(["getbit", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/getdel.js
var GetDelCommand = class extends Command2 {
  static {
    __name(this, "GetDelCommand");
  }
  constructor(cmd, opts) {
    super(["getdel", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/getrange.js
var GetRangeCommand = class extends Command2 {
  static {
    __name(this, "GetRangeCommand");
  }
  constructor(cmd, opts) {
    super(["getrange", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/getset.js
var GetSetCommand = class extends Command2 {
  static {
    __name(this, "GetSetCommand");
  }
  constructor(cmd, opts) {
    super(["getset", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hdel.js
var HDelCommand = class extends Command2 {
  static {
    __name(this, "HDelCommand");
  }
  constructor(cmd, opts) {
    super(["hdel", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hexists.js
var HExistsCommand = class extends Command2 {
  static {
    __name(this, "HExistsCommand");
  }
  constructor(cmd, opts) {
    super(["hexists", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hget.js
var HGetCommand = class extends Command2 {
  static {
    __name(this, "HGetCommand");
  }
  constructor(cmd, opts) {
    super(["hget", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hgetall.js
function deserialize2(result) {
  if (result.length === 0) {
    return null;
  }
  const obj = {};
  while (result.length >= 2) {
    const key = result.shift();
    const value = result.shift();
    try {
      obj[key] = JSON.parse(value);
    } catch {
      obj[key] = value;
    }
  }
  return obj;
}
__name(deserialize2, "deserialize");
var HGetAllCommand = class extends Command2 {
  static {
    __name(this, "HGetAllCommand");
  }
  constructor(cmd, opts) {
    super(["hgetall", ...cmd], {
      deserialize: (result) => deserialize2(result),
      ...opts
    });
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hincrby.js
var HIncrByCommand = class extends Command2 {
  static {
    __name(this, "HIncrByCommand");
  }
  constructor(cmd, opts) {
    super(["hincrby", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hincrbyfloat.js
var HIncrByFloatCommand = class extends Command2 {
  static {
    __name(this, "HIncrByFloatCommand");
  }
  constructor(cmd, opts) {
    super(["hincrbyfloat", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hkeys.js
var HKeysCommand = class extends Command2 {
  static {
    __name(this, "HKeysCommand");
  }
  constructor([key], opts) {
    super(["hkeys", key], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hlen.js
var HLenCommand = class extends Command2 {
  static {
    __name(this, "HLenCommand");
  }
  constructor(cmd, opts) {
    super(["hlen", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hmget.js
function deserialize3(fields, result) {
  if (result.length === 0 || result.every((field) => field === null)) {
    return null;
  }
  const obj = {};
  for (let i10 = 0; i10 < fields.length; i10++) {
    try {
      obj[fields[i10]] = JSON.parse(result[i10]);
    } catch {
      obj[fields[i10]] = result[i10];
    }
  }
  return obj;
}
__name(deserialize3, "deserialize");
var HMGetCommand = class extends Command2 {
  static {
    __name(this, "HMGetCommand");
  }
  constructor([key, ...fields], opts) {
    super(["hmget", key, ...fields], {
      deserialize: (result) => deserialize3(fields, result),
      ...opts
    });
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hmset.js
var HMSetCommand = class extends Command2 {
  static {
    __name(this, "HMSetCommand");
  }
  constructor([key, kv], opts) {
    super([
      "hmset",
      key,
      ...Object.entries(kv).flatMap(([field, value]) => [field, value])
    ], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hrandfield.js
function deserialize4(result) {
  if (result.length === 0) {
    return null;
  }
  const obj = {};
  while (result.length >= 2) {
    const key = result.shift();
    const value = result.shift();
    try {
      obj[key] = JSON.parse(value);
    } catch {
      obj[key] = value;
    }
  }
  return obj;
}
__name(deserialize4, "deserialize");
var HRandFieldCommand = class extends Command2 {
  static {
    __name(this, "HRandFieldCommand");
  }
  constructor(cmd, opts) {
    const command = ["hrandfield", cmd[0]];
    if (typeof cmd[1] === "number") {
      command.push(cmd[1]);
    }
    if (cmd[2]) {
      command.push("WITHVALUES");
    }
    super(command, {
      // @ts-ignore TODO:
      deserialize: cmd[2] ? (result) => deserialize4(result) : opts?.deserialize,
      ...opts
    });
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hscan.js
var HScanCommand = class extends Command2 {
  static {
    __name(this, "HScanCommand");
  }
  constructor([key, cursor, cmdOpts], opts) {
    const command = ["hscan", key, cursor];
    if (cmdOpts?.match) {
      command.push("match", cmdOpts.match);
    }
    if (typeof cmdOpts?.count === "number") {
      command.push("count", cmdOpts.count);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hset.js
var HSetCommand = class extends Command2 {
  static {
    __name(this, "HSetCommand");
  }
  constructor([key, kv], opts) {
    super([
      "hset",
      key,
      ...Object.entries(kv).flatMap(([field, value]) => [field, value])
    ], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hsetnx.js
var HSetNXCommand = class extends Command2 {
  static {
    __name(this, "HSetNXCommand");
  }
  constructor(cmd, opts) {
    super(["hsetnx", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hstrlen.js
var HStrLenCommand = class extends Command2 {
  static {
    __name(this, "HStrLenCommand");
  }
  constructor(cmd, opts) {
    super(["hstrlen", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/hvals.js
var HValsCommand = class extends Command2 {
  static {
    __name(this, "HValsCommand");
  }
  constructor(cmd, opts) {
    super(["hvals", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/incr.js
var IncrCommand = class extends Command2 {
  static {
    __name(this, "IncrCommand");
  }
  constructor(cmd, opts) {
    super(["incr", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/incrby.js
var IncrByCommand = class extends Command2 {
  static {
    __name(this, "IncrByCommand");
  }
  constructor(cmd, opts) {
    super(["incrby", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/incrbyfloat.js
var IncrByFloatCommand = class extends Command2 {
  static {
    __name(this, "IncrByFloatCommand");
  }
  constructor(cmd, opts) {
    super(["incrbyfloat", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_arrappend.js
var JsonArrAppendCommand = class extends Command2 {
  static {
    __name(this, "JsonArrAppendCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.ARRAPPEND", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_arrindex.js
var JsonArrIndexCommand = class extends Command2 {
  static {
    __name(this, "JsonArrIndexCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.ARRINDEX", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_arrinsert.js
var JsonArrInsertCommand = class extends Command2 {
  static {
    __name(this, "JsonArrInsertCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.ARRINSERT", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_arrlen.js
var JsonArrLenCommand = class extends Command2 {
  static {
    __name(this, "JsonArrLenCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.ARRLEN", cmd[0], cmd[1] ?? "$"], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_arrpop.js
var JsonArrPopCommand = class extends Command2 {
  static {
    __name(this, "JsonArrPopCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.ARRPOP", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_arrtrim.js
var JsonArrTrimCommand = class extends Command2 {
  static {
    __name(this, "JsonArrTrimCommand");
  }
  constructor(cmd, opts) {
    const path = cmd[1] ?? "$";
    const start = cmd[2] ?? 0;
    const stop = cmd[3] ?? 0;
    super(["JSON.ARRTRIM", cmd[0], path, start, stop], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_clear.js
var JsonClearCommand = class extends Command2 {
  static {
    __name(this, "JsonClearCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.CLEAR", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_del.js
var JsonDelCommand = class extends Command2 {
  static {
    __name(this, "JsonDelCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.DEL", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_forget.js
var JsonForgetCommand = class extends Command2 {
  static {
    __name(this, "JsonForgetCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.FORGET", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_get.js
var JsonGetCommand = class extends Command2 {
  static {
    __name(this, "JsonGetCommand");
  }
  constructor(cmd, opts) {
    const command = ["JSON.GET"];
    if (typeof cmd[1] === "string") {
      command.push(...cmd);
    } else {
      command.push(cmd[0]);
      if (cmd[1]) {
        if (cmd[1].indent) {
          command.push("INDENT", cmd[1].indent);
        }
        if (cmd[1].newline) {
          command.push("NEWLINE", cmd[1].newline);
        }
        if (cmd[1].space) {
          command.push("SPACE", cmd[1].space);
        }
      }
      command.push(...cmd.slice(2));
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_mget.js
var JsonMGetCommand = class extends Command2 {
  static {
    __name(this, "JsonMGetCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.MGET", ...cmd[0], cmd[1]], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_numincrby.js
var JsonNumIncrByCommand = class extends Command2 {
  static {
    __name(this, "JsonNumIncrByCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.NUMINCRBY", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_nummultby.js
var JsonNumMultByCommand = class extends Command2 {
  static {
    __name(this, "JsonNumMultByCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.NUMMULTBY", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_objkeys.js
var JsonObjKeysCommand = class extends Command2 {
  static {
    __name(this, "JsonObjKeysCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.OBJKEYS", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_objlen.js
var JsonObjLenCommand = class extends Command2 {
  static {
    __name(this, "JsonObjLenCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.OBJLEN", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_resp.js
var JsonRespCommand = class extends Command2 {
  static {
    __name(this, "JsonRespCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.RESP", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_set.js
var JsonSetCommand = class extends Command2 {
  static {
    __name(this, "JsonSetCommand");
  }
  constructor(cmd, opts) {
    const command = ["JSON.SET", cmd[0], cmd[1], cmd[2]];
    if (cmd[3]) {
      if (cmd[3].nx) {
        command.push("NX");
      } else if (cmd[3].xx) {
        command.push("XX");
      }
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_strappend.js
var JsonStrAppendCommand = class extends Command2 {
  static {
    __name(this, "JsonStrAppendCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.STRAPPEND", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_strlen.js
var JsonStrLenCommand = class extends Command2 {
  static {
    __name(this, "JsonStrLenCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.STRLEN", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_toggle.js
var JsonToggleCommand = class extends Command2 {
  static {
    __name(this, "JsonToggleCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.TOGGLE", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/json_type.js
var JsonTypeCommand = class extends Command2 {
  static {
    __name(this, "JsonTypeCommand");
  }
  constructor(cmd, opts) {
    super(["JSON.TYPE", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/keys.js
var KeysCommand = class extends Command2 {
  static {
    __name(this, "KeysCommand");
  }
  constructor(cmd, opts) {
    super(["keys", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lindex.js
var LIndexCommand = class extends Command2 {
  static {
    __name(this, "LIndexCommand");
  }
  constructor(cmd, opts) {
    super(["lindex", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/linsert.js
var LInsertCommand = class extends Command2 {
  static {
    __name(this, "LInsertCommand");
  }
  constructor(cmd, opts) {
    super(["linsert", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/llen.js
var LLenCommand = class extends Command2 {
  static {
    __name(this, "LLenCommand");
  }
  constructor(cmd, opts) {
    super(["llen", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lmove.js
var LMoveCommand = class extends Command2 {
  static {
    __name(this, "LMoveCommand");
  }
  constructor(cmd, opts) {
    super(["lmove", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lpop.js
var LPopCommand = class extends Command2 {
  static {
    __name(this, "LPopCommand");
  }
  constructor(cmd, opts) {
    super(["lpop", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lpos.js
var LPosCommand = class extends Command2 {
  static {
    __name(this, "LPosCommand");
  }
  constructor(cmd, opts) {
    const args = ["lpos", cmd[0], cmd[1]];
    if (typeof cmd[2]?.rank === "number") {
      args.push("rank", cmd[2].rank);
    }
    if (typeof cmd[2]?.count === "number") {
      args.push("count", cmd[2].count);
    }
    if (typeof cmd[2]?.maxLen === "number") {
      args.push("maxLen", cmd[2].maxLen);
    }
    super(args, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lpush.js
var LPushCommand = class extends Command2 {
  static {
    __name(this, "LPushCommand");
  }
  constructor(cmd, opts) {
    super(["lpush", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lpushx.js
var LPushXCommand = class extends Command2 {
  static {
    __name(this, "LPushXCommand");
  }
  constructor(cmd, opts) {
    super(["lpushx", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lrange.js
var LRangeCommand = class extends Command2 {
  static {
    __name(this, "LRangeCommand");
  }
  constructor(cmd, opts) {
    super(["lrange", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lrem.js
var LRemCommand = class extends Command2 {
  static {
    __name(this, "LRemCommand");
  }
  constructor(cmd, opts) {
    super(["lrem", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/lset.js
var LSetCommand = class extends Command2 {
  static {
    __name(this, "LSetCommand");
  }
  constructor(cmd, opts) {
    super(["lset", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/ltrim.js
var LTrimCommand = class extends Command2 {
  static {
    __name(this, "LTrimCommand");
  }
  constructor(cmd, opts) {
    super(["ltrim", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/mget.js
var MGetCommand = class extends Command2 {
  static {
    __name(this, "MGetCommand");
  }
  constructor(cmd, opts) {
    super(["mget", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/mset.js
var MSetCommand = class extends Command2 {
  static {
    __name(this, "MSetCommand");
  }
  constructor([kv], opts) {
    super([
      "mset",
      ...Object.entries(kv).flatMap(([key, value]) => [key, value])
    ], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/msetnx.js
var MSetNXCommand = class extends Command2 {
  static {
    __name(this, "MSetNXCommand");
  }
  constructor([kv], opts) {
    super(["msetnx", ...Object.entries(kv).flatMap((_) => _)], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/persist.js
var PersistCommand = class extends Command2 {
  static {
    __name(this, "PersistCommand");
  }
  constructor(cmd, opts) {
    super(["persist", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/pexpire.js
var PExpireCommand = class extends Command2 {
  static {
    __name(this, "PExpireCommand");
  }
  constructor(cmd, opts) {
    super(["pexpire", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/pexpireat.js
var PExpireAtCommand = class extends Command2 {
  static {
    __name(this, "PExpireAtCommand");
  }
  constructor(cmd, opts) {
    super(["pexpireat", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/ping.js
var PingCommand = class extends Command2 {
  static {
    __name(this, "PingCommand");
  }
  constructor(cmd, opts) {
    const command = ["ping"];
    if (typeof cmd !== "undefined" && typeof cmd[0] !== "undefined") {
      command.push(cmd[0]);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/psetex.js
var PSetEXCommand = class extends Command2 {
  static {
    __name(this, "PSetEXCommand");
  }
  constructor(cmd, opts) {
    super(["psetex", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/pttl.js
var PTtlCommand = class extends Command2 {
  static {
    __name(this, "PTtlCommand");
  }
  constructor(cmd, opts) {
    super(["pttl", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/publish.js
var PublishCommand = class extends Command2 {
  static {
    __name(this, "PublishCommand");
  }
  constructor(cmd, opts) {
    super(["publish", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/randomkey.js
var RandomKeyCommand = class extends Command2 {
  static {
    __name(this, "RandomKeyCommand");
  }
  constructor(opts) {
    super(["randomkey"], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/rename.js
var RenameCommand = class extends Command2 {
  static {
    __name(this, "RenameCommand");
  }
  constructor(cmd, opts) {
    super(["rename", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/renamenx.js
var RenameNXCommand = class extends Command2 {
  static {
    __name(this, "RenameNXCommand");
  }
  constructor(cmd, opts) {
    super(["renamenx", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/rpop.js
var RPopCommand = class extends Command2 {
  static {
    __name(this, "RPopCommand");
  }
  constructor(cmd, opts) {
    super(["rpop", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/rpush.js
var RPushCommand = class extends Command2 {
  static {
    __name(this, "RPushCommand");
  }
  constructor(cmd, opts) {
    super(["rpush", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/rpushx.js
var RPushXCommand = class extends Command2 {
  static {
    __name(this, "RPushXCommand");
  }
  constructor(cmd, opts) {
    super(["rpushx", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sadd.js
var SAddCommand = class extends Command2 {
  static {
    __name(this, "SAddCommand");
  }
  constructor(cmd, opts) {
    super(["sadd", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/scan.js
var ScanCommand = class extends Command2 {
  static {
    __name(this, "ScanCommand");
  }
  constructor([cursor, opts], cmdOpts) {
    const command = ["scan", cursor];
    if (opts?.match) {
      command.push("match", opts.match);
    }
    if (typeof opts?.count === "number") {
      command.push("count", opts.count);
    }
    if (opts?.type && opts.type.length > 0) {
      command.push("type", opts.type);
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/scard.js
var SCardCommand = class extends Command2 {
  static {
    __name(this, "SCardCommand");
  }
  constructor(cmd, opts) {
    super(["scard", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/script_exists.js
var ScriptExistsCommand = class extends Command2 {
  static {
    __name(this, "ScriptExistsCommand");
  }
  constructor(hashes, opts) {
    super(["script", "exists", ...hashes], {
      deserialize: (result) => result,
      ...opts
    });
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/script_flush.js
var ScriptFlushCommand = class extends Command2 {
  static {
    __name(this, "ScriptFlushCommand");
  }
  constructor([opts], cmdOpts) {
    const cmd = ["script", "flush"];
    if (opts?.sync) {
      cmd.push("sync");
    } else if (opts?.async) {
      cmd.push("async");
    }
    super(cmd, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/script_load.js
var ScriptLoadCommand = class extends Command2 {
  static {
    __name(this, "ScriptLoadCommand");
  }
  constructor(args, opts) {
    super(["script", "load", ...args], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sdiff.js
var SDiffCommand = class extends Command2 {
  static {
    __name(this, "SDiffCommand");
  }
  constructor(cmd, opts) {
    super(["sdiff", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sdiffstore.js
var SDiffStoreCommand = class extends Command2 {
  static {
    __name(this, "SDiffStoreCommand");
  }
  constructor(cmd, opts) {
    super(["sdiffstore", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/set.js
var SetCommand = class extends Command2 {
  static {
    __name(this, "SetCommand");
  }
  constructor([key, value, opts], cmdOpts) {
    const command = ["set", key, value];
    if (opts) {
      if ("nx" in opts && opts.nx) {
        command.push("nx");
      } else if ("xx" in opts && opts.xx) {
        command.push("xx");
      }
      if ("get" in opts && opts.get) {
        command.push("get");
      }
      if ("ex" in opts && typeof opts.ex === "number") {
        command.push("ex", opts.ex);
      } else if ("px" in opts && typeof opts.px === "number") {
        command.push("px", opts.px);
      } else if ("exat" in opts && typeof opts.exat === "number") {
        command.push("exat", opts.exat);
      } else if ("pxat" in opts && typeof opts.pxat === "number") {
        command.push("pxat", opts.pxat);
      } else if ("keepTtl" in opts && opts.keepTtl) {
        command.push("keepTtl", opts.keepTtl);
      }
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/setbit.js
var SetBitCommand = class extends Command2 {
  static {
    __name(this, "SetBitCommand");
  }
  constructor(cmd, opts) {
    super(["setbit", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/setex.js
var SetExCommand = class extends Command2 {
  static {
    __name(this, "SetExCommand");
  }
  constructor(cmd, opts) {
    super(["setex", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/setnx.js
var SetNxCommand = class extends Command2 {
  static {
    __name(this, "SetNxCommand");
  }
  constructor(cmd, opts) {
    super(["setnx", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/setrange.js
var SetRangeCommand = class extends Command2 {
  static {
    __name(this, "SetRangeCommand");
  }
  constructor(cmd, opts) {
    super(["setrange", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sinter.js
var SInterCommand = class extends Command2 {
  static {
    __name(this, "SInterCommand");
  }
  constructor(cmd, opts) {
    super(["sinter", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sinterstore.js
var SInterStoreCommand = class extends Command2 {
  static {
    __name(this, "SInterStoreCommand");
  }
  constructor(cmd, opts) {
    super(["sinterstore", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sismember.js
var SIsMemberCommand = class extends Command2 {
  static {
    __name(this, "SIsMemberCommand");
  }
  constructor(cmd, opts) {
    super(["sismember", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/smembers.js
var SMembersCommand = class extends Command2 {
  static {
    __name(this, "SMembersCommand");
  }
  constructor(cmd, opts) {
    super(["smembers", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/smismember.js
var SMIsMemberCommand = class extends Command2 {
  static {
    __name(this, "SMIsMemberCommand");
  }
  constructor(cmd, opts) {
    super(["smismember", cmd[0], ...cmd[1]], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/smove.js
var SMoveCommand = class extends Command2 {
  static {
    __name(this, "SMoveCommand");
  }
  constructor(cmd, opts) {
    super(["smove", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/spop.js
var SPopCommand = class extends Command2 {
  static {
    __name(this, "SPopCommand");
  }
  constructor([key, count], opts) {
    const command = ["spop", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/srandmember.js
var SRandMemberCommand = class extends Command2 {
  static {
    __name(this, "SRandMemberCommand");
  }
  constructor([key, count], opts) {
    const command = ["srandmember", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/srem.js
var SRemCommand = class extends Command2 {
  static {
    __name(this, "SRemCommand");
  }
  constructor(cmd, opts) {
    super(["srem", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sscan.js
var SScanCommand = class extends Command2 {
  static {
    __name(this, "SScanCommand");
  }
  constructor([key, cursor, opts], cmdOpts) {
    const command = ["sscan", key, cursor];
    if (opts?.match) {
      command.push("match", opts.match);
    }
    if (typeof opts?.count === "number") {
      command.push("count", opts.count);
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/strlen.js
var StrLenCommand = class extends Command2 {
  static {
    __name(this, "StrLenCommand");
  }
  constructor(cmd, opts) {
    super(["strlen", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sunion.js
var SUnionCommand = class extends Command2 {
  static {
    __name(this, "SUnionCommand");
  }
  constructor(cmd, opts) {
    super(["sunion", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/sunionstore.js
var SUnionStoreCommand = class extends Command2 {
  static {
    __name(this, "SUnionStoreCommand");
  }
  constructor(cmd, opts) {
    super(["sunionstore", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/time.js
var TimeCommand = class extends Command2 {
  static {
    __name(this, "TimeCommand");
  }
  constructor(opts) {
    super(["time"], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/touch.js
var TouchCommand = class extends Command2 {
  static {
    __name(this, "TouchCommand");
  }
  constructor(cmd, opts) {
    super(["touch", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/ttl.js
var TtlCommand = class extends Command2 {
  static {
    __name(this, "TtlCommand");
  }
  constructor(cmd, opts) {
    super(["ttl", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/type.js
var TypeCommand = class extends Command2 {
  static {
    __name(this, "TypeCommand");
  }
  constructor(cmd, opts) {
    super(["type", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/unlink.js
var UnlinkCommand = class extends Command2 {
  static {
    __name(this, "UnlinkCommand");
  }
  constructor(cmd, opts) {
    super(["unlink", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zadd.js
var ZAddCommand = class extends Command2 {
  static {
    __name(this, "ZAddCommand");
  }
  constructor([key, arg1, ...arg2], opts) {
    const command = ["zadd", key];
    if ("nx" in arg1 && arg1.nx) {
      command.push("nx");
    } else if ("xx" in arg1 && arg1.xx) {
      command.push("xx");
    }
    if ("ch" in arg1 && arg1.ch) {
      command.push("ch");
    }
    if ("incr" in arg1 && arg1.incr) {
      command.push("incr");
    }
    if ("score" in arg1 && "member" in arg1) {
      command.push(arg1.score, arg1.member);
    }
    command.push(...arg2.flatMap(({ score, member }) => [score, member]));
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zcard.js
var ZCardCommand = class extends Command2 {
  static {
    __name(this, "ZCardCommand");
  }
  constructor(cmd, opts) {
    super(["zcard", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zcount.js
var ZCountCommand = class extends Command2 {
  static {
    __name(this, "ZCountCommand");
  }
  constructor(cmd, opts) {
    super(["zcount", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zincrby.js
var ZIncrByCommand = class extends Command2 {
  static {
    __name(this, "ZIncrByCommand");
  }
  constructor(cmd, opts) {
    super(["zincrby", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zinterstore.js
var ZInterStoreCommand = class extends Command2 {
  static {
    __name(this, "ZInterStoreCommand");
  }
  constructor([destination, numKeys, keyOrKeys, opts], cmdOpts) {
    const command = ["zinterstore", destination, numKeys];
    if (Array.isArray(keyOrKeys)) {
      command.push(...keyOrKeys);
    } else {
      command.push(keyOrKeys);
    }
    if (opts) {
      if ("weights" in opts && opts.weights) {
        command.push("weights", ...opts.weights);
      } else if ("weight" in opts && typeof opts.weight === "number") {
        command.push("weights", opts.weight);
      }
      if ("aggregate" in opts) {
        command.push("aggregate", opts.aggregate);
      }
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zlexcount.js
var ZLexCountCommand = class extends Command2 {
  static {
    __name(this, "ZLexCountCommand");
  }
  constructor(cmd, opts) {
    super(["zlexcount", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zpopmax.js
var ZPopMaxCommand = class extends Command2 {
  static {
    __name(this, "ZPopMaxCommand");
  }
  constructor([key, count], opts) {
    const command = ["zpopmax", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zpopmin.js
var ZPopMinCommand = class extends Command2 {
  static {
    __name(this, "ZPopMinCommand");
  }
  constructor([key, count], opts) {
    const command = ["zpopmin", key];
    if (typeof count === "number") {
      command.push(count);
    }
    super(command, opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zrange.js
var ZRangeCommand = class extends Command2 {
  static {
    __name(this, "ZRangeCommand");
  }
  constructor([key, min, max, opts], cmdOpts) {
    const command = ["zrange", key, min, max];
    if (opts?.byScore) {
      command.push("byscore");
    }
    if (opts?.byLex) {
      command.push("bylex");
    }
    if (opts?.rev) {
      command.push("rev");
    }
    if (typeof opts?.count !== "undefined" && typeof opts?.offset !== "undefined") {
      command.push("limit", opts.offset, opts.count);
    }
    if (opts?.withScores) {
      command.push("withscores");
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zrank.js
var ZRankCommand = class extends Command2 {
  static {
    __name(this, "ZRankCommand");
  }
  constructor(cmd, opts) {
    super(["zrank", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zrem.js
var ZRemCommand = class extends Command2 {
  static {
    __name(this, "ZRemCommand");
  }
  constructor(cmd, opts) {
    super(["zrem", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zremrangebylex.js
var ZRemRangeByLexCommand = class extends Command2 {
  static {
    __name(this, "ZRemRangeByLexCommand");
  }
  constructor(cmd, opts) {
    super(["zremrangebylex", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zremrangebyrank.js
var ZRemRangeByRankCommand = class extends Command2 {
  static {
    __name(this, "ZRemRangeByRankCommand");
  }
  constructor(cmd, opts) {
    super(["zremrangebyrank", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zremrangebyscore.js
var ZRemRangeByScoreCommand = class extends Command2 {
  static {
    __name(this, "ZRemRangeByScoreCommand");
  }
  constructor(cmd, opts) {
    super(["zremrangebyscore", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zrevrank.js
var ZRevRankCommand = class extends Command2 {
  static {
    __name(this, "ZRevRankCommand");
  }
  constructor(cmd, opts) {
    super(["zrevrank", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zscan.js
var ZScanCommand = class extends Command2 {
  static {
    __name(this, "ZScanCommand");
  }
  constructor([key, cursor, opts], cmdOpts) {
    const command = ["zscan", key, cursor];
    if (opts?.match) {
      command.push("match", opts.match);
    }
    if (typeof opts?.count === "number") {
      command.push("count", opts.count);
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zscore.js
var ZScoreCommand = class extends Command2 {
  static {
    __name(this, "ZScoreCommand");
  }
  constructor(cmd, opts) {
    super(["zscore", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zunionstore.js
var ZUnionStoreCommand = class extends Command2 {
  static {
    __name(this, "ZUnionStoreCommand");
  }
  constructor([destination, numKeys, keyOrKeys, opts], cmdOpts) {
    const command = ["zunionstore", destination, numKeys];
    if (Array.isArray(keyOrKeys)) {
      command.push(...keyOrKeys);
    } else {
      command.push(keyOrKeys);
    }
    if (opts) {
      if ("weights" in opts && opts.weights) {
        command.push("weights", ...opts.weights);
      } else if ("weight" in opts && typeof opts.weight === "number") {
        command.push("weights", opts.weight);
      }
      if ("aggregate" in opts) {
        command.push("aggregate", opts.aggregate);
      }
    }
    super(command, cmdOpts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zmscore.js
var ZMScoreCommand = class extends Command2 {
  static {
    __name(this, "ZMScoreCommand");
  }
  constructor(cmd, opts) {
    const [key, members2] = cmd;
    super(["zmscore", key, ...members2], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/commands/zdiffstore.js
var ZDiffStoreCommand = class extends Command2 {
  static {
    __name(this, "ZDiffStoreCommand");
  }
  constructor(cmd, opts) {
    super(["zdiffstore", ...cmd], opts);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/pipeline.js
var Pipeline = class {
  static {
    __name(this, "Pipeline");
  }
  constructor(opts) {
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "commands", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "commandOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "multiExec", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "exec", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async () => {
        if (this.commands.length === 0) {
          throw new Error("Pipeline is empty");
        }
        const path = this.multiExec ? ["multi-exec"] : ["pipeline"];
        const res = await this.client.request({
          path,
          body: Object.values(this.commands).map((c11) => c11.command)
        });
        return res.map(({ error, result }, i10) => {
          if (error) {
            throw new UpstashError(`Command ${i10 + 1} [ ${this.commands[i10].command[0]} ] failed: ${error}`);
          }
          return this.commands[i10].deserialize(result);
        });
      }
    });
    Object.defineProperty(this, "append", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new AppendCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "bitcount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new BitCountCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "bitop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (op, destinationKey, sourceKey, ...sourceKeys) => this.chain(new BitOpCommand([op, destinationKey, sourceKey, ...sourceKeys], this.commandOptions))
    });
    Object.defineProperty(this, "bitpos", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new BitPosCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zdiffstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZDiffStoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "dbsize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => this.chain(new DBSizeCommand(this.commandOptions))
    });
    Object.defineProperty(this, "decr", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new DecrCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "decrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new DecrByCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "del", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new DelCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "echo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new EchoCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "eval", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new EvalCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "evalsha", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new EvalshaCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "exists", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ExistsCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "expire", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ExpireCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "expireat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ExpireAtCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "flushall", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (args) => this.chain(new FlushAllCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "flushdb", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new FlushDBCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "get", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new GetCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "getbit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new GetBitCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "getdel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new GetDelCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "getrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new GetRangeCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "getset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, value) => this.chain(new GetSetCommand([key, value], this.commandOptions))
    });
    Object.defineProperty(this, "hdel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HDelCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hexists", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HExistsCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hget", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HGetCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hgetall", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HGetAllCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hincrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HIncrByCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hincrbyfloat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HIncrByFloatCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hkeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HKeysCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hlen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HLenCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hmget", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HMGetCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hmset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, kv) => this.chain(new HMSetCommand([key, kv], this.commandOptions))
    });
    Object.defineProperty(this, "hrandfield", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, count, withValues) => this.chain(new HRandFieldCommand([key, count, withValues], this.commandOptions))
    });
    Object.defineProperty(this, "hscan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HScanCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, kv) => this.chain(new HSetCommand([key, kv], this.commandOptions))
    });
    Object.defineProperty(this, "hsetnx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, field, value) => this.chain(new HSetNXCommand([key, field, value], this.commandOptions))
    });
    Object.defineProperty(this, "hstrlen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HStrLenCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "hvals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new HValsCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "incr", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new IncrCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "incrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new IncrByCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "incrbyfloat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new IncrByFloatCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "keys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new KeysCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "lindex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LIndexCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "linsert", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, direction, pivot, value) => this.chain(new LInsertCommand([key, direction, pivot, value], this.commandOptions))
    });
    Object.defineProperty(this, "llen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LLenCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "lmove", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LMoveCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "lpop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LPopCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "lpos", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LPosCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "lpush", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => this.chain(new LPushCommand([key, ...elements], this.commandOptions))
    });
    Object.defineProperty(this, "lpushx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => this.chain(new LPushXCommand([key, ...elements], this.commandOptions))
    });
    Object.defineProperty(this, "lrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LRangeCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "lrem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, count, value) => this.chain(new LRemCommand([key, count, value], this.commandOptions))
    });
    Object.defineProperty(this, "lset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, index2, value) => this.chain(new LSetCommand([key, index2, value], this.commandOptions))
    });
    Object.defineProperty(this, "ltrim", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new LTrimCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "mget", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new MGetCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "mset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (kv) => this.chain(new MSetCommand([kv], this.commandOptions))
    });
    Object.defineProperty(this, "msetnx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (kv) => this.chain(new MSetNXCommand([kv], this.commandOptions))
    });
    Object.defineProperty(this, "persist", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new PersistCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "pexpire", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new PExpireCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "pexpireat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new PExpireAtCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "ping", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (args) => this.chain(new PingCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "psetex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ttl, value) => this.chain(new PSetEXCommand([key, ttl, value], this.commandOptions))
    });
    Object.defineProperty(this, "pttl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new PTtlCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "publish", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new PublishCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "randomkey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => this.chain(new RandomKeyCommand(this.commandOptions))
    });
    Object.defineProperty(this, "rename", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new RenameCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "renamenx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new RenameNXCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "rpop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new RPopCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "rpush", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => this.chain(new RPushCommand([key, ...elements], this.commandOptions))
    });
    Object.defineProperty(this, "rpushx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => this.chain(new RPushXCommand([key, ...elements], this.commandOptions))
    });
    Object.defineProperty(this, "sadd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...members2) => this.chain(new SAddCommand([key, ...members2], this.commandOptions))
    });
    Object.defineProperty(this, "scan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ScanCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "scard", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SCardCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "scriptExists", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ScriptExistsCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "scriptFlush", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ScriptFlushCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "scriptLoad", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ScriptLoadCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sdiff", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SDiffCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sdiffstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SDiffStoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "set", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, value, opts2) => this.chain(new SetCommand([key, value, opts2], this.commandOptions))
    });
    Object.defineProperty(this, "setbit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SetBitCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "setex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ttl, value) => this.chain(new SetExCommand([key, ttl, value], this.commandOptions))
    });
    Object.defineProperty(this, "setnx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, value) => this.chain(new SetNxCommand([key, value], this.commandOptions))
    });
    Object.defineProperty(this, "setrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SetRangeCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sinter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SInterCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sinterstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SInterStoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sismember", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => this.chain(new SIsMemberCommand([key, member], this.commandOptions))
    });
    Object.defineProperty(this, "smembers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SMembersCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "smismember", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, members2) => this.chain(new SMIsMemberCommand([key, members2], this.commandOptions))
    });
    Object.defineProperty(this, "smove", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (source, destination, member) => this.chain(new SMoveCommand([source, destination, member], this.commandOptions))
    });
    Object.defineProperty(this, "spop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SPopCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "srandmember", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SRandMemberCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "srem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...members2) => this.chain(new SRemCommand([key, ...members2], this.commandOptions))
    });
    Object.defineProperty(this, "sscan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SScanCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "strlen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new StrLenCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sunion", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SUnionCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "sunionstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new SUnionStoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => this.chain(new TimeCommand(this.commandOptions))
    });
    Object.defineProperty(this, "touch", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new TouchCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "ttl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new TtlCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new TypeCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "unlink", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new UnlinkCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zadd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => {
        if ("score" in args[1]) {
          return this.chain(new ZAddCommand([args[0], args[1], ...args.slice(2)], this.commandOptions));
        }
        return this.chain(new ZAddCommand([args[0], args[1], ...args.slice(2)], this.commandOptions));
      }
    });
    Object.defineProperty(this, "zcard", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZCardCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zcount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZCountCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zincrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, increment, member) => this.chain(new ZIncrByCommand([key, increment, member], this.commandOptions))
    });
    Object.defineProperty(this, "zinterstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZInterStoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zlexcount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZLexCountCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zmscore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZMScoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zpopmax", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZPopMaxCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zpopmin", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZPopMinCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZRangeCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zrank", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => this.chain(new ZRankCommand([key, member], this.commandOptions))
    });
    Object.defineProperty(this, "zrem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...members2) => this.chain(new ZRemCommand([key, ...members2], this.commandOptions))
    });
    Object.defineProperty(this, "zremrangebylex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZRemRangeByLexCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zremrangebyrank", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZRemRangeByRankCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zremrangebyscore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZRemRangeByScoreCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zrevrank", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => this.chain(new ZRevRankCommand([key, member], this.commandOptions))
    });
    Object.defineProperty(this, "zscan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZScanCommand(args, this.commandOptions))
    });
    Object.defineProperty(this, "zscore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => this.chain(new ZScoreCommand([key, member], this.commandOptions))
    });
    Object.defineProperty(this, "zunionstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => this.chain(new ZUnionStoreCommand(args, this.commandOptions))
    });
    this.client = opts.client;
    this.commands = [];
    this.commandOptions = opts.commandOptions;
    this.multiExec = opts.multiExec ?? false;
  }
  /**
   * Pushes a command into the pipeline and returns a chainable instance of the
   * pipeline
   */
  chain(command) {
    this.commands.push(command);
    return this;
  }
  /**
   * @see https://redis.io/commands/?group=json
   */
  get json() {
    return {
      /**
       * @see https://redis.io/commands/json.arrappend
       */
      arrappend: (...args) => this.chain(new JsonArrAppendCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.arrindex
       */
      arrindex: (...args) => this.chain(new JsonArrIndexCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.arrinsert
       */
      arrinsert: (...args) => this.chain(new JsonArrInsertCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.arrlen
       */
      arrlen: (...args) => this.chain(new JsonArrLenCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.arrpop
       */
      arrpop: (...args) => this.chain(new JsonArrPopCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.arrtrim
       */
      arrtrim: (...args) => this.chain(new JsonArrTrimCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.clear
       */
      clear: (...args) => this.chain(new JsonClearCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.del
       */
      del: (...args) => this.chain(new JsonDelCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.forget
       */
      forget: (...args) => this.chain(new JsonForgetCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.get
       */
      get: (...args) => this.chain(new JsonGetCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.mget
       */
      mget: (...args) => this.chain(new JsonMGetCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.numincrby
       */
      numincrby: (...args) => this.chain(new JsonNumIncrByCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.nummultby
       */
      nummultby: (...args) => this.chain(new JsonNumMultByCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.objkeys
       */
      objkeys: (...args) => this.chain(new JsonObjKeysCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.objlen
       */
      objlen: (...args) => this.chain(new JsonObjLenCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.resp
       */
      resp: (...args) => this.chain(new JsonRespCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.set
       */
      set: (...args) => this.chain(new JsonSetCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.strappend
       */
      strappend: (...args) => this.chain(new JsonStrAppendCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.strlen
       */
      strlen: (...args) => this.chain(new JsonStrLenCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.toggle
       */
      toggle: (...args) => this.chain(new JsonToggleCommand(args, this.commandOptions)),
      /**
       * @see https://redis.io/commands/json.type
       */
      type: (...args) => this.chain(new JsonTypeCommand(args, this.commandOptions))
    };
  }
};

// ../../node_modules/@upstash/redis/esm/deps/deno.land/x/base64@v0.2.1/base.js
function getLengths(b64) {
  const len = b64.length;
  let validLen = b64.indexOf("=");
  if (validLen === -1) {
    validLen = len;
  }
  const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
__name(getLengths, "getLengths");
function init(lookup2, revLookup2, urlsafe = false) {
  function _byteLength(validLen, placeHoldersLen) {
    return Math.floor((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);
  }
  __name(_byteLength, "_byteLength");
  function tripletToBase64(num) {
    return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
  }
  __name(tripletToBase64, "tripletToBase64");
  function encodeChunk(buf, start, end) {
    const out = new Array((end - start) / 3);
    for (let i10 = start, curTriplet = 0; i10 < end; i10 += 3) {
      out[curTriplet++] = tripletToBase64((buf[i10] << 16) + (buf[i10 + 1] << 8) + buf[i10 + 2]);
    }
    return out.join("");
  }
  __name(encodeChunk, "encodeChunk");
  return {
    // base64 is 4/3 + up to two characters of the original data
    byteLength(b64) {
      return _byteLength.apply(null, getLengths(b64));
    },
    toUint8Array(b64) {
      const [validLen, placeHoldersLen] = getLengths(b64);
      const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));
      const len = placeHoldersLen ? validLen - 4 : validLen;
      let tmp;
      let curByte = 0;
      let i10;
      for (i10 = 0; i10 < len; i10 += 4) {
        tmp = revLookup2[b64.charCodeAt(i10)] << 18 | revLookup2[b64.charCodeAt(i10 + 1)] << 12 | revLookup2[b64.charCodeAt(i10 + 2)] << 6 | revLookup2[b64.charCodeAt(i10 + 3)];
        buf[curByte++] = tmp >> 16 & 255;
        buf[curByte++] = tmp >> 8 & 255;
        buf[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i10)] << 2 | revLookup2[b64.charCodeAt(i10 + 1)] >> 4;
        buf[curByte++] = tmp & 255;
      } else if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i10)] << 10 | revLookup2[b64.charCodeAt(i10 + 1)] << 4 | revLookup2[b64.charCodeAt(i10 + 2)] >> 2;
        buf[curByte++] = tmp >> 8 & 255;
        buf[curByte++] = tmp & 255;
      }
      return buf;
    },
    fromUint8Array(buf) {
      const maxChunkLength = 16383;
      const len = buf.length;
      const extraBytes = len % 3;
      const len2 = len - extraBytes;
      const parts = new Array(Math.ceil(len2 / maxChunkLength) + (extraBytes ? 1 : 0));
      let curChunk = 0;
      let chunkEnd;
      for (let i10 = 0; i10 < len2; i10 += maxChunkLength) {
        chunkEnd = i10 + maxChunkLength;
        parts[curChunk++] = encodeChunk(buf, i10, chunkEnd > len2 ? len2 : chunkEnd);
      }
      let tmp;
      if (extraBytes === 1) {
        tmp = buf[len2];
        parts[curChunk] = lookup2[tmp >> 2] + lookup2[tmp << 4 & 63];
        if (!urlsafe)
          parts[curChunk] += "==";
      } else if (extraBytes === 2) {
        tmp = buf[len2] << 8 | buf[len2 + 1] & 255;
        parts[curChunk] = lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63];
        if (!urlsafe)
          parts[curChunk] += "=";
      }
      return parts.join("");
    }
  };
}
__name(init, "init");

// ../../node_modules/@upstash/redis/esm/deps/deno.land/x/base64@v0.2.1/base64url.js
var lookup = [];
var revLookup = [];
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
for (let i10 = 0, l10 = code.length; i10 < l10; ++i10) {
  lookup[i10] = code[i10];
  revLookup[code.charCodeAt(i10)] = i10;
}
var { byteLength, toUint8Array: toUint8Array3, fromUint8Array: fromUint8Array2 } = init(lookup, revLookup, true);

// ../../node_modules/@upstash/redis/esm/deps/denopkg.com/chiefbiiko/std-encoding@v1.0.0/mod.js
var decoder = new TextDecoder();
var encoder = new TextEncoder();
function toHexString(buf) {
  return buf.reduce((hex, byte) => `${hex}${byte < 16 ? "0" : ""}${byte.toString(16)}`, "");
}
__name(toHexString, "toHexString");
function fromHexString(hex) {
  const len = hex.length;
  if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {
    throw new TypeError("Invalid hex string.");
  }
  hex = hex.toLowerCase();
  const buf = new Uint8Array(Math.floor(len / 2));
  const end = len / 2;
  for (let i10 = 0; i10 < end; ++i10) {
    buf[i10] = parseInt(hex.substr(i10 * 2, 2), 16);
  }
  return buf;
}
__name(fromHexString, "fromHexString");
function decode3(buf, encoding = "utf8") {
  if (/^utf-?8$/i.test(encoding)) {
    return decoder.decode(buf);
  } else if (/^base64$/i.test(encoding)) {
    return fromUint8Array2(buf);
  } else if (/^hex(?:adecimal)?$/i.test(encoding)) {
    return toHexString(buf);
  } else {
    throw new TypeError("Unsupported string encoding.");
  }
}
__name(decode3, "decode");
function encode2(str, encoding = "utf8") {
  if (/^utf-?8$/i.test(encoding)) {
    return encoder.encode(str);
  } else if (/^base64$/i.test(encoding)) {
    return toUint8Array3(str);
  } else if (/^hex(?:adecimal)?$/i.test(encoding)) {
    return fromHexString(str);
  } else {
    throw new TypeError("Unsupported string encoding.");
  }
}
__name(encode2, "encode");

// ../../node_modules/@upstash/redis/esm/deps/deno.land/x/sha1@v1.0.3/mod.js
function rotl(x4, n10) {
  return x4 << n10 | x4 >>> 32 - n10;
}
__name(rotl, "rotl");
var BYTES = 20;
var SHA1 = class _SHA1 {
  static {
    __name(this, "SHA1");
  }
  /** Creates a SHA1 instance. */
  constructor() {
    Object.defineProperty(this, "hashSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: BYTES
    });
    Object.defineProperty(this, "_buf", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(64)
    });
    Object.defineProperty(this, "_bufIdx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_count", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_K", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint32Array([1518500249, 1859775393, 2400959708, 3395469782])
    });
    Object.defineProperty(this, "_H", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_finalized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.init();
  }
  /** Reduces the four input numbers to a single one. */
  static F(t6, b11, c11, d10) {
    if (t6 <= 19) {
      return b11 & c11 | ~b11 & d10;
    } else if (t6 <= 39) {
      return b11 ^ c11 ^ d10;
    } else if (t6 <= 59) {
      return b11 & c11 | b11 & d10 | c11 & d10;
    } else {
      return b11 ^ c11 ^ d10;
    }
  }
  /** Initializes a hash instance. */
  init() {
    this._H = new Uint32Array([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    this._bufIdx = 0;
    this._count = new Uint32Array(2);
    this._buf.fill(0);
    this._finalized = false;
    return this;
  }
  /** Updates a hash with additional message data. */
  update(msg, inputEncoding) {
    if (msg === null) {
      throw new TypeError("msg must be a string or Uint8Array.");
    } else if (typeof msg === "string") {
      msg = encode2(msg, inputEncoding);
    }
    for (let i10 = 0; i10 < msg.length; i10++) {
      this._buf[this._bufIdx++] = msg[i10];
      if (this._bufIdx === 64) {
        this.transform();
        this._bufIdx = 0;
      }
    }
    const c11 = this._count;
    if ((c11[0] += msg.length << 3) < msg.length << 3) {
      c11[1]++;
    }
    c11[1] += msg.length >>> 29;
    return this;
  }
  /** Finalizes a hash with additional message data. */
  digest(outputEncoding) {
    if (this._finalized) {
      throw new Error("digest has already been called.");
    }
    this._finalized = true;
    const b11 = this._buf;
    let idx = this._bufIdx;
    b11[idx++] = 128;
    while (idx !== 56) {
      if (idx === 64) {
        this.transform();
        idx = 0;
      }
      b11[idx++] = 0;
    }
    const c11 = this._count;
    b11[56] = c11[1] >>> 24 & 255;
    b11[57] = c11[1] >>> 16 & 255;
    b11[58] = c11[1] >>> 8 & 255;
    b11[59] = c11[1] >>> 0 & 255;
    b11[60] = c11[0] >>> 24 & 255;
    b11[61] = c11[0] >>> 16 & 255;
    b11[62] = c11[0] >>> 8 & 255;
    b11[63] = c11[0] >>> 0 & 255;
    this.transform();
    const hash = new Uint8Array(BYTES);
    for (let i10 = 0; i10 < 5; i10++) {
      hash[(i10 << 2) + 0] = this._H[i10] >>> 24 & 255;
      hash[(i10 << 2) + 1] = this._H[i10] >>> 16 & 255;
      hash[(i10 << 2) + 2] = this._H[i10] >>> 8 & 255;
      hash[(i10 << 2) + 3] = this._H[i10] >>> 0 & 255;
    }
    this.init();
    return outputEncoding ? decode3(hash, outputEncoding) : hash;
  }
  /** Performs one transformation cycle. */
  transform() {
    const h10 = this._H;
    let a10 = h10[0];
    let b11 = h10[1];
    let c11 = h10[2];
    let d10 = h10[3];
    let e10 = h10[4];
    const w4 = new Uint32Array(80);
    for (let i10 = 0; i10 < 16; i10++) {
      w4[i10] = this._buf[(i10 << 2) + 3] | this._buf[(i10 << 2) + 2] << 8 | this._buf[(i10 << 2) + 1] << 16 | this._buf[i10 << 2] << 24;
    }
    for (let t6 = 0; t6 < 80; t6++) {
      if (t6 >= 16) {
        w4[t6] = rotl(w4[t6 - 3] ^ w4[t6 - 8] ^ w4[t6 - 14] ^ w4[t6 - 16], 1);
      }
      const tmp = rotl(a10, 5) + _SHA1.F(t6, b11, c11, d10) + e10 + w4[t6] + this._K[Math.floor(t6 / 20)] | 0;
      e10 = d10;
      d10 = c11;
      c11 = rotl(b11, 30);
      b11 = a10;
      a10 = tmp;
    }
    h10[0] = h10[0] + a10 | 0;
    h10[1] = h10[1] + b11 | 0;
    h10[2] = h10[2] + c11 | 0;
    h10[3] = h10[3] + d10 | 0;
    h10[4] = h10[4] + e10 | 0;
  }
};
function sha1(msg, inputEncoding, outputEncoding) {
  return new SHA1().update(msg, inputEncoding).digest(outputEncoding);
}
__name(sha1, "sha1");

// ../../node_modules/@upstash/redis/esm/pkg/script.js
var Script = class {
  static {
    __name(this, "Script");
  }
  constructor(redis, script) {
    Object.defineProperty(this, "script", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sha1", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "redis", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.redis = redis;
    this.sha1 = this.digest(script);
    this.script = script;
  }
  /**
   * Send an `EVAL` command to redis.
   */
  async eval(keys, args) {
    return await this.redis.eval(this.script, keys, args);
  }
  /**
   * Calculates the sha1 hash of the script and then calls `EVALSHA`.
   */
  async evalsha(keys, args) {
    return await this.redis.evalsha(this.sha1, keys, args);
  }
  /**
   * Optimistically try to run `EVALSHA` first.
   * If the script is not loaded in redis, it will fall back and try again with `EVAL`.
   *
   * Following calls will be able to use the cached script
   */
  async exec(keys, args) {
    const res = await this.redis.evalsha(this.sha1, keys, args).catch(async (err) => {
      if (err instanceof Error && err.message.toLowerCase().includes("noscript")) {
        return await this.redis.eval(this.script, keys, args);
      }
      throw err;
    });
    return res;
  }
  /**
   * Compute the sha1 hash of the script and return its hex representation.
   */
  digest(s10) {
    const hash = sha1(s10, "utf8", "hex");
    return typeof hash === "string" ? hash : new TextDecoder().decode(hash);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/redis.js
var Redis = class {
  static {
    __name(this, "Redis");
  }
  /**
   * Create a new redis client
   *
   * @example
   * ```typescript
   * const redis = new Redis({
   *  url: "<UPSTASH_REDIS_REST_URL>",
   *  token: "<UPSTASH_REDIS_REST_TOKEN>",
   * });
   * ```
   */
  constructor(client10, opts) {
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "opts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "enableTelemetry", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "use", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (middleware) => {
        const makeRequest = this.client.request.bind(this.client);
        this.client.request = (req) => middleware(req, makeRequest);
      }
    });
    Object.defineProperty(this, "addTelemetry", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (telemetry) => {
        if (!this.enableTelemetry) {
          return;
        }
        try {
          this.client.mergeTelemetry(telemetry);
        } catch {
        }
      }
    });
    Object.defineProperty(this, "pipeline", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => new Pipeline({
        client: this.client,
        commandOptions: this.opts,
        multiExec: false
      })
    });
    Object.defineProperty(this, "multi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => new Pipeline({
        client: this.client,
        commandOptions: this.opts,
        multiExec: true
      })
    });
    Object.defineProperty(this, "append", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new AppendCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "bitcount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new BitCountCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "bitop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (op, destinationKey, sourceKey, ...sourceKeys) => new BitOpCommand([op, destinationKey, sourceKey, ...sourceKeys], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "bitpos", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new BitPosCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "dbsize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => new DBSizeCommand(this.opts).exec(this.client)
    });
    Object.defineProperty(this, "decr", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new DecrCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "decrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new DecrByCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "del", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new DelCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "echo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new EchoCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "eval", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new EvalCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "evalsha", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new EvalshaCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "exists", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ExistsCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "expire", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ExpireCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "expireat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ExpireAtCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "flushall", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (args) => new FlushAllCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "flushdb", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new FlushDBCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "get", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new GetCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "getbit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new GetBitCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "getdel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new GetDelCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "getrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new GetRangeCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "getset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, value) => new GetSetCommand([key, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hdel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HDelCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hexists", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HExistsCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hget", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HGetCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hgetall", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HGetAllCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hincrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HIncrByCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hincrbyfloat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HIncrByFloatCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hkeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HKeysCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hlen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HLenCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hmget", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HMGetCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hmset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, kv) => new HMSetCommand([key, kv], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hrandfield", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, count, withValues) => new HRandFieldCommand([key, count, withValues], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hscan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HScanCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, kv) => new HSetCommand([key, kv], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hsetnx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, field, value) => new HSetNXCommand([key, field, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hstrlen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HStrLenCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "hvals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new HValsCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "incr", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new IncrCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "incrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new IncrByCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "incrbyfloat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new IncrByFloatCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "keys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new KeysCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lindex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LIndexCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "linsert", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, direction, pivot, value) => new LInsertCommand([key, direction, pivot, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "llen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LLenCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lmove", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LMoveCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lpop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LPopCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lpos", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LPosCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lpush", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => new LPushCommand([key, ...elements], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lpushx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => new LPushXCommand([key, ...elements], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LRangeCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lrem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, count, value) => new LRemCommand([key, count, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "lset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, index2, value) => new LSetCommand([key, index2, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "ltrim", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new LTrimCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "mget", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new MGetCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "mset", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (kv) => new MSetCommand([kv], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "msetnx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (kv) => new MSetNXCommand([kv], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "persist", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new PersistCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "pexpire", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new PExpireCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "pexpireat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new PExpireAtCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "ping", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (args) => new PingCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "psetex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ttl, value) => new PSetEXCommand([key, ttl, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "pttl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new PTtlCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "publish", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new PublishCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "randomkey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => new RandomKeyCommand().exec(this.client)
    });
    Object.defineProperty(this, "rename", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new RenameCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "renamenx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new RenameNXCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "rpop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new RPopCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "rpush", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => new RPushCommand([key, ...elements], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "rpushx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...elements) => new RPushXCommand([key, ...elements], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sadd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...members2) => new SAddCommand([key, ...members2], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "scan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ScanCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "scard", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SCardCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "scriptExists", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ScriptExistsCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "scriptFlush", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ScriptFlushCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "scriptLoad", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ScriptLoadCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sdiff", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SDiffCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sdiffstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SDiffStoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "set", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, value, opts2) => new SetCommand([key, value, opts2], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "setbit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SetBitCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "setex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ttl, value) => new SetExCommand([key, ttl, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "setnx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, value) => new SetNxCommand([key, value], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "setrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SetRangeCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sinter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SInterCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sinterstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SInterStoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sismember", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => new SIsMemberCommand([key, member], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "smismember", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, members2) => new SMIsMemberCommand([key, members2], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "smembers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SMembersCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "smove", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (source, destination, member) => new SMoveCommand([source, destination, member], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "spop", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SPopCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "srandmember", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SRandMemberCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "srem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...members2) => new SRemCommand([key, ...members2], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sscan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SScanCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "strlen", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new StrLenCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sunion", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SUnionCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "sunionstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new SUnionStoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => new TimeCommand().exec(this.client)
    });
    Object.defineProperty(this, "touch", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new TouchCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "ttl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new TtlCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new TypeCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "unlink", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new UnlinkCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zadd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => {
        if ("score" in args[1]) {
          return new ZAddCommand([args[0], args[1], ...args.slice(2)], this.opts).exec(this.client);
        }
        return new ZAddCommand([args[0], args[1], ...args.slice(2)], this.opts).exec(this.client);
      }
    });
    Object.defineProperty(this, "zcard", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZCardCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zcount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZCountCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zdiffstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZDiffStoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zincrby", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, increment, member) => new ZIncrByCommand([key, increment, member], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zinterstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZInterStoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zlexcount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZLexCountCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zmscore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZMScoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zpopmax", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZPopMaxCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zpopmin", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZPopMinCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zrange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZRangeCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zrank", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => new ZRankCommand([key, member], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zrem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, ...members2) => new ZRemCommand([key, ...members2], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zremrangebylex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZRemRangeByLexCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zremrangebyrank", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZRemRangeByRankCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zremrangebyscore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZRemRangeByScoreCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zrevrank", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => new ZRevRankCommand([key, member], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zscan", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZScanCommand(args, this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zscore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (key, member) => new ZScoreCommand([key, member], this.opts).exec(this.client)
    });
    Object.defineProperty(this, "zunionstore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => new ZUnionStoreCommand(args, this.opts).exec(this.client)
    });
    this.client = client10;
    this.opts = opts;
    this.enableTelemetry = opts?.enableTelemetry ?? true;
  }
  get json() {
    return {
      /**
       * @see https://redis.io/commands/json.arrappend
       */
      arrappend: (...args) => new JsonArrAppendCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.arrindex
       */
      arrindex: (...args) => new JsonArrIndexCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.arrinsert
       */
      arrinsert: (...args) => new JsonArrInsertCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.arrlen
       */
      arrlen: (...args) => new JsonArrLenCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.arrpop
       */
      arrpop: (...args) => new JsonArrPopCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.arrtrim
       */
      arrtrim: (...args) => new JsonArrTrimCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.clear
       */
      clear: (...args) => new JsonClearCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.del
       */
      del: (...args) => new JsonDelCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.forget
       */
      forget: (...args) => new JsonForgetCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.get
       */
      get: (...args) => new JsonGetCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.mget
       */
      mget: (...args) => new JsonMGetCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.numincrby
       */
      numincrby: (...args) => new JsonNumIncrByCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.nummultby
       */
      nummultby: (...args) => new JsonNumMultByCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.objkeys
       */
      objkeys: (...args) => new JsonObjKeysCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.objlen
       */
      objlen: (...args) => new JsonObjLenCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.resp
       */
      resp: (...args) => new JsonRespCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.set
       */
      set: (...args) => new JsonSetCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.strappend
       */
      strappend: (...args) => new JsonStrAppendCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.strlen
       */
      strlen: (...args) => new JsonStrLenCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.toggle
       */
      toggle: (...args) => new JsonToggleCommand(args, this.opts).exec(this.client),
      /**
       * @see https://redis.io/commands/json.type
       */
      type: (...args) => new JsonTypeCommand(args, this.opts).exec(this.client)
    };
  }
  createScript(script) {
    return new Script(this, script);
  }
};

// ../../node_modules/@upstash/redis/esm/pkg/http.js
var HttpClient3 = class {
  static {
    __name(this, "HttpClient");
  }
  constructor(config) {
    Object.defineProperty(this, "baseUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "retry", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.options = {
      backend: config.options?.backend,
      agent: config.agent,
      responseEncoding: config.responseEncoding ?? "base64",
      cache: config.cache
    };
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.headers = {
      "Content-Type": "application/json",
      ...config.headers
    };
    if (this.options.responseEncoding === "base64") {
      this.headers["Upstash-Encoding"] = "base64";
    }
    if (typeof config?.retry === "boolean" && config?.retry === false) {
      this.retry = {
        attempts: 1,
        backoff: () => 0
      };
    } else {
      this.retry = {
        attempts: config?.retry?.retries ?? 5,
        backoff: config?.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50)
      };
    }
  }
  mergeTelemetry(telemetry) {
    function merge2(obj, key, value) {
      if (!value) {
        return obj;
      }
      if (obj[key]) {
        obj[key] = [obj[key], value].join(",");
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(merge2, "merge");
    this.headers = merge2(this.headers, "Upstash-Telemetry-Runtime", telemetry.runtime);
    this.headers = merge2(this.headers, "Upstash-Telemetry-Platform", telemetry.platform);
    this.headers = merge2(this.headers, "Upstash-Telemetry-Sdk", telemetry.sdk);
  }
  async request(req) {
    const requestOptions = {
      cache: this.options.cache,
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(req.body),
      keepalive: true,
      agent: this.options?.agent,
      /**
       * Fastly specific
       */
      backend: this.options?.backend
    };
    let res = null;
    let error = null;
    for (let i10 = 0; i10 <= this.retry.attempts; i10++) {
      try {
        res = await fetch([this.baseUrl, ...req.path ?? []].join("/"), requestOptions);
        break;
      } catch (err) {
        error = err;
        await new Promise((r10) => setTimeout(r10, this.retry.backoff(i10)));
      }
    }
    if (!res) {
      throw error ?? new Error("Exhausted all retries");
    }
    const body = await res.json();
    if (!res.ok) {
      throw new UpstashError(body.error);
    }
    if (this.options?.responseEncoding === "base64") {
      return Array.isArray(body) ? body.map(decode4) : decode4(body);
    }
    return body;
  }
};
function base64decode(b64) {
  let dec = "";
  try {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for (let i10 = 0; i10 < size; i10++) {
      bytes[i10] = binString.charCodeAt(i10);
    }
    dec = new TextDecoder().decode(bytes);
  } catch {
    dec = b64;
  }
  return dec;
}
__name(base64decode, "base64decode");
function decode4(raw) {
  let result = void 0;
  switch (typeof raw.result) {
    case "undefined":
      return raw;
    case "number": {
      result = raw.result;
      break;
    }
    case "object": {
      if (Array.isArray(raw.result)) {
        result = raw.result.map((v7) => typeof v7 === "string" ? base64decode(v7) : Array.isArray(v7) ? v7.map(base64decode) : v7);
      } else {
        result = null;
      }
      break;
    }
    case "string": {
      result = raw.result === "OK" ? "OK" : base64decode(raw.result);
      break;
    }
    default:
      break;
  }
  return { result, error: raw.error };
}
__name(decode4, "decode");

// ../../node_modules/@upstash/redis/esm/version.js
var VERSION10 = "v1.22.0";

// ../../node_modules/@upstash/redis/esm/platforms/nodejs.js
if (typeof atob === "undefined") {
  global.atob = function(b64) {
    return Buffer.from(b64, "base64").toString("utf-8");
  };
}
var Redis2 = class _Redis extends Redis {
  static {
    __name(this, "Redis");
  }
  constructor(configOrRequester) {
    if ("request" in configOrRequester) {
      super(configOrRequester);
      return;
    }
    if (configOrRequester.url.startsWith(" ") || configOrRequester.url.endsWith(" ") || /\r|\n/.test(configOrRequester.url)) {
      console.warn("The redis url contains whitespace or newline, which can cause errors!");
    }
    if (configOrRequester.token.startsWith(" ") || configOrRequester.token.endsWith(" ") || /\r|\n/.test(configOrRequester.token)) {
      console.warn("The redis token contains whitespace or newline, which can cause errors!");
    }
    const client10 = new HttpClient3({
      baseUrl: configOrRequester.url,
      retry: configOrRequester.retry,
      headers: { authorization: `Bearer ${configOrRequester.token}` },
      agent: configOrRequester.agent,
      responseEncoding: configOrRequester.responseEncoding,
      cache: configOrRequester.cache || "no-store"
    });
    super(client10, {
      automaticDeserialization: configOrRequester.automaticDeserialization,
      enableTelemetry: !process.env.UPSTASH_DISABLE_TELEMETRY
    });
    this.addTelemetry({
      runtime: typeof EdgeRuntime === "string" ? "edge-light" : `node@${process.version}`,
      platform: process.env.VERCEL ? "vercel" : process.env.AWS_REGION ? "aws" : "unknown",
      sdk: `@upstash/redis@${VERSION10}`
    });
  }
  /**
   * Create a new Upstash Redis instance from environment variables.
   *
   * Use this to automatically load connection secrets from your environment
   * variables. For instance when using the Vercel integration.
   *
   * This tries to load `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` from
   * your environment using `process.env`.
   */
  static fromEnv(config) {
    if (typeof process?.env === "undefined") {
      throw new Error('Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');
    }
    const url12 = process?.env["UPSTASH_REDIS_REST_URL"];
    if (!url12) {
      throw new Error("Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");
    }
    const token = process?.env["UPSTASH_REDIS_REST_TOKEN"];
    if (!token) {
      throw new Error("Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`");
    }
    return new _Redis({ ...config, url: url12, token });
  }
};

// src/get-clerk-user-token.ts
var clerkClient2 = Clerk2({ secretKey: Config.CLERK_SECRET_KEY });
var redisClient = new Redis2({
  url: Config.REDIS_URL,
  token: Config.REDIS_TOKEN
});
var encodeUserTokenCacheValue = /* @__PURE__ */ __name((token) => [token, nanoid()].join(" "), "encodeUserTokenCacheValue");
var decodeUserTokenCacheValue = /* @__PURE__ */ __name((value) => value.split(" "), "decodeUserTokenCacheValue");
var fetchClerkUserToken = /* @__PURE__ */ __name(async (userId, provider) => {
  const [userOauthAccessTokenPayload] = await clerkClient2.users.getUserOauthAccessToken(userId, provider);
  if (!userOauthAccessTokenPayload) {
    throw new Error(`Failed to get token for ${userId} and ${provider}`);
  }
  return userOauthAccessTokenPayload.token;
}, "fetchClerkUserToken");
var getClerkUserToken = /* @__PURE__ */ __name(async (userId, provider) => {
  const userTokenCacheKey = `${userId}_${provider}`;
  let encodedUserTokenCacheValue;
  try {
    encodedUserTokenCacheValue = await redisClient.get(userTokenCacheKey);
  } catch (error) {
    console.error("RedisClerkTokenCache: read error");
    console.error(error);
    encodedUserTokenCacheValue = null;
  }
  if (encodedUserTokenCacheValue !== null) {
    const [cachedToken] = decodeUserTokenCacheValue(encodedUserTokenCacheValue);
    return cachedToken;
  }
  const userToken = await fetchClerkUserToken(userId, provider);
  try {
    await redisClient.set(userTokenCacheKey, encodeUserTokenCacheValue(userToken), { ex: Number(Config.REDIS_USER_TOKEN_TTL) });
  } catch (error) {
    console.error("RedisClerkTokenCache: write error");
    console.error(error);
  }
  return userToken;
}, "getClerkUserToken");

// src/extract-merge-requests.ts
var mergeRequestSenderHandler = createMessageHandler({
  kind: "merge-request" /* MergeRequest */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    repository: RepositorySchema,
    namespace: NamespaceSchema,
    pagination: paginationSchema
  }).shape,
  handler: async (message) => {
    if (!message) {
      console.warn("Expected message to have content,but get empty");
      return;
    }
    context.integrations.sourceControl = await initSourceControl(message.metadata.userId, message.metadata.sourceControl);
    const { namespace, pagination, repository } = message.content;
    if (!namespace)
      throw new Error("Invalid namespace id");
    const { mergeRequests: mergeRequests2 } = await getMergeRequests(
      {
        externalRepositoryId: repository.externalId,
        namespaceName: namespace.name,
        repositoryName: repository.name,
        repositoryId: repository.id,
        page: pagination.page,
        perPage: pagination.perPage
      },
      context
    );
    await extractMergeRequestsEvent.publish({ mergeRequestIds: mergeRequests2.map((mr) => mr.id), namespaceId: namespace.id, repositoryId: repository.id }, {
      version: 1,
      caller: "extract-merge-requests",
      sourceControl: message.metadata.sourceControl,
      userId: message.metadata.userId,
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    });
  }
});
var { sender } = mergeRequestSenderHandler;
var client3 = createClient({
  url: Config.DATABASE_URL,
  authToken: Config.DATABASE_AUTH_TOKEN
});
var db = drizzle(client3);
var context = {
  entities: {
    mergeRequests
  },
  integrations: {
    sourceControl: null
  },
  db
};
var initSourceControl = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await getClerkUserToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var eventHandler = EventHandler(extractRepositoryEvent, async (evt) => {
  const repository = await db.select().from(repositories).where(eq(repositories.id, evt.properties.repositoryId)).get();
  const namespace = await db.select().from(namespaces).where(eq(namespaces.id, evt.properties.namespaceId)).get();
  if (!repository)
    throw new Error("invalid repo id");
  if (!namespace)
    throw new Error("Invalid namespace id");
  const sourceControl = evt.metadata.sourceControl;
  context.integrations.sourceControl = await initSourceControl(evt.metadata.userId, sourceControl);
  const { mergeRequests: mergeRequests2, paginationInfo } = await getMergeRequests(
    {
      externalRepositoryId: repository.externalId,
      namespaceName: namespace.name,
      repositoryName: repository.name,
      repositoryId: repository.id,
      perPage: 10
    },
    context
  );
  await extractMergeRequestsEvent.publish({ mergeRequestIds: mergeRequests2.map((mr) => mr.id), namespaceId: namespace.id, repositoryId: repository.id }, {
    version: 1,
    caller: "extract-merge-requests",
    sourceControl,
    userId: evt.metadata.userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
  const arrayOfExtractMergeRequests = [];
  for (let i10 = 2; i10 <= paginationInfo.totalPages; i10++) {
    arrayOfExtractMergeRequests.push({
      repository,
      namespace,
      pagination: {
        page: i10,
        perPage: paginationInfo.perPage,
        totalPages: paginationInfo.totalPages
      }
    });
  }
  await sender.sendAll(arrayOfExtractMergeRequests, {
    version: 1,
    caller: "extract-merge-requests",
    sourceControl,
    userId: evt.metadata.userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/extract-merge-request-diffs.ts
var mergeRequestDiffSenderHandler = createMessageHandler({
  kind: "merge-request-diff" /* MergeRequestDiff */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    mergeRequestId: MergeRequestSchema.shape.id,
    repositoryId: RepositorySchema.shape.id,
    namespaceId: NamespaceSchema.shape.id
  }).shape,
  handler: async (message) => {
    const { sourceControl, userId } = message.metadata;
    const { mergeRequestId, repositoryId, namespaceId } = message.content;
    context2.integrations.sourceControl = await initSourceControl2(userId, sourceControl);
    await getMergeRequestsDiffs({
      mergeRequestId,
      repositoryId,
      namespaceId
    }, context2);
  }
});
var { sender: sender2 } = mergeRequestDiffSenderHandler;
var client4 = createClient({ url: Config.DATABASE_URL, authToken: Config.DATABASE_AUTH_TOKEN });
var initSourceControl2 = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await getClerkUserToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var db2 = drizzle(client4);
var context2 = {
  db: db2,
  entities: {
    mergeRequestDiffs,
    mergeRequests,
    namespaces,
    repositories
  },
  integrations: {
    sourceControl: null
  }
};
var eventHandler2 = EventHandler(extractMergeRequestsEvent, async (ev) => {
  const { sourceControl, userId } = ev.metadata;
  const { mergeRequestIds, repositoryId, namespaceId } = ev.properties;
  const arrayOfExtractMergeRequestData = [];
  for (let i10 = 0; i10 < mergeRequestIds.length; i10 += 1) {
    arrayOfExtractMergeRequestData.push({
      mergeRequestId: mergeRequestIds[i10],
      namespaceId,
      repositoryId
    });
  }
  await sender2.sendAll(arrayOfExtractMergeRequestData, {
    version: 1,
    caller: "extract-merge-request-diffs",
    sourceControl,
    userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/extract-merge-request-commits.ts
var mrcsh = createMessageHandler({
  kind: "merge-request-commit" /* MergeRequestCommit */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    mergeRequestId: MergeRequestSchema.shape.id,
    repositoryId: RepositorySchema.shape.id,
    namespaceId: NamespaceSchema.shape.id
  }).shape,
  handler: async (message) => {
    if (!message) {
      console.warn("Expected message to have content,but get empty");
      return;
    }
    context3.integrations.sourceControl = await initSourceControl3(message.metadata.userId, message.metadata.sourceControl);
    const { mergeRequestId, namespaceId, repositoryId } = message.content;
    await getMergeRequestCommits({
      mergeRequestId,
      namespaceId,
      repositoryId
    }, context3);
  }
});
var { sender: sender3 } = mrcsh;
var client5 = createClient({
  url: Config.DATABASE_URL,
  authToken: Config.DATABASE_AUTH_TOKEN
});
var db3 = drizzle(client5);
var context3 = {
  entities: {
    mergeRequestCommits,
    namespaces,
    repositories,
    mergeRequests
  },
  integrations: {
    sourceControl: null
  },
  db: db3
};
var initSourceControl3 = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await getClerkUserToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var eventHandler3 = EventHandler(extractMergeRequestsEvent, async (evt) => {
  const { mergeRequestIds, namespaceId, repositoryId } = evt.properties;
  const { sourceControl, userId } = evt.metadata;
  const arrayOfExtractMergeRequestData = [];
  for (let i10 = 0; i10 < mergeRequestIds.length; i10 += 1) {
    arrayOfExtractMergeRequestData.push({
      mergeRequestId: mergeRequestIds[i10],
      namespaceId,
      repositoryId
    });
  }
  await sender3.sendAll(arrayOfExtractMergeRequestData, {
    version: 1,
    caller: "extract-merge-request-commits",
    sourceControl,
    userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/extract-member-info.ts
var memberInfoSenderHandler = createMessageHandler({
  kind: "member-info" /* MemberInfo */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    memberId: z2.number()
  }).shape,
  handler: async (message) => {
    const { sourceControl, userId } = message.metadata;
    const { memberId } = message.content;
    context4.integrations.sourceControl = await initSourceControl4(userId, sourceControl);
    await getMemberInfo({ memberId }, context4);
  }
});
var { sender: sender4 } = memberInfoSenderHandler;
var client6 = createClient({ url: Config.DATABASE_URL, authToken: Config.DATABASE_AUTH_TOKEN });
var initSourceControl4 = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await getClerkUserToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var db4 = drizzle(client6);
var context4 = {
  db: db4,
  entities: {
    members
  },
  integrations: {
    sourceControl: null
  }
};
var eventHandler4 = EventHandler(extractMembersEvent, async (ev) => {
  const { sourceControl, userId } = ev.metadata;
  const { memberIds } = ev.properties;
  await sender4.sendAll(memberIds.map((memberId) => ({ memberId })), {
    version: 1,
    caller: "extract-user-info",
    sourceControl,
    userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/extract-merge-request-notes.ts
var client7 = createClient({ url: Config.DATABASE_URL, authToken: Config.DATABASE_AUTH_TOKEN });
var initSourceControl5 = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await getClerkUserToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var db5 = drizzle(client7);
var context5 = {
  db: db5,
  entities: {
    mergeRequestNotes,
    mergeRequests,
    namespaces,
    repositories
  },
  integrations: {
    sourceControl: null
  }
};
var mergeRequestNoteSenderHandler = createMessageHandler({
  kind: "merge-request-note" /* MergeRequestNote */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    mergeRequestId: MergeRequestSchema.shape.id,
    repositoryId: RepositorySchema.shape.id,
    namespaceId: NamespaceSchema.shape.id
  }).shape,
  handler: async (message) => {
    const { userId, sourceControl } = message.metadata;
    const { mergeRequestId, namespaceId, repositoryId } = message.content;
    context5.integrations.sourceControl = await initSourceControl5(userId, sourceControl);
    await getMergeRequestNotes({
      mergeRequestId,
      repositoryId,
      namespaceId
    }, context5);
  }
});
var { sender: mergeRequestNoteQueue } = mergeRequestNoteSenderHandler;
var eventHandler5 = EventHandler(extractMergeRequestsEvent, async (ev) => {
  const { sourceControl, userId } = ev.metadata;
  const { mergeRequestIds, repositoryId, namespaceId } = ev.properties;
  const arrayOfExtractMergeRequestData = [];
  for (let i10 = 0; i10 < mergeRequestIds.length; i10 += 1) {
    arrayOfExtractMergeRequestData.push({
      mergeRequestId: mergeRequestIds[i10],
      namespaceId,
      repositoryId
    });
  }
  await mergeRequestNoteQueue.sendAll(arrayOfExtractMergeRequestData, {
    version: 1,
    caller: "extract-merge-request-diffs",
    sourceControl,
    userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/extract-members.ts
var memberSenderHandler = createMessageHandler({
  kind: "member" /* Member */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    repository: RepositorySchema,
    namespace: NamespaceSchema,
    pagination: paginationSchema
  }).shape,
  handler: async (message) => {
    await extractMembersPage({
      namespace: message.content.namespace,
      paginationInfo: message.content.pagination,
      repository: message.content.repository,
      sourceControl: message.metadata.sourceControl,
      userId: message.metadata.userId
    });
  }
});
var { sender: sender5 } = memberSenderHandler;
var client8 = createClient({ url: Config.DATABASE_URL, authToken: Config.DATABASE_AUTH_TOKEN });
var initSourceControl6 = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await getClerkUserToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var db6 = drizzle(client8);
var context6 = {
  entities: {
    members,
    repositoriesToMembers
  },
  integrations: {
    sourceControl: null
  },
  db: db6
};
var extractMembersPage = /* @__PURE__ */ __name(async ({ namespace, repository, sourceControl, userId, paginationInfo }) => {
  const page = paginationInfo?.page;
  const perPage = paginationInfo?.perPage;
  context6.integrations.sourceControl = await initSourceControl6(userId, sourceControl);
  const { members: members2, paginationInfo: resultPaginationInfo } = await getMembers({
    externalRepositoryId: repository.externalId,
    namespaceName: namespace.name,
    repositoryId: repository.id,
    repositoryName: repository.name,
    perPage,
    page
  }, context6);
  await extractMembersEvent.publish({
    memberIds: members2.map((member) => member.id)
  }, {
    version: 1,
    caller: "extract-member",
    sourceControl,
    userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
  return { members: members2, pagination: resultPaginationInfo };
}, "extractMembersPage");
var eventHandler6 = EventHandler(extractRepositoryEvent, async (ev) => {
  const repository = await db6.select().from(repositories).where(eq(repositories.id, ev.properties.repositoryId)).get();
  const namespace = await db6.select().from(namespaces).where(eq(namespaces.id, ev.properties.namespaceId)).get();
  if (!repository)
    throw new Error("invalid repo id");
  if (!namespace)
    throw new Error("Invalid namespace id");
  const { pagination } = await extractMembersPage({
    namespace,
    repository,
    sourceControl: ev.metadata.sourceControl,
    userId: ev.metadata.userId
  });
  const arrayOfExtractMemberPageMessageContent = [];
  for (let i10 = 2; i10 <= pagination.totalPages; i10++) {
    arrayOfExtractMemberPageMessageContent.push({
      namespace,
      repository,
      pagination: {
        page: i10,
        perPage: pagination.perPage,
        totalPages: pagination.totalPages
      }
    });
  }
  if (arrayOfExtractMemberPageMessageContent.length === 0)
    return;
  await sender5.sendAll(arrayOfExtractMemberPageMessageContent, {
    version: 1,
    caller: "extract-member",
    sourceControl: ev.metadata.sourceControl,
    userId: ev.metadata.userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/extract-namespace-members.ts
var namespaceMemberSenderHandler = createMessageHandler({
  kind: "namespace-member" /* NamespaceMember */,
  metadataShape: metadataSchema.shape,
  contentShape: z2.object({
    repositoryId: RepositorySchema.shape.id,
    namespace: NamespaceSchema,
    pagination: paginationSchema
  }).shape,
  handler: async (message) => {
    await extractNamespaceMembersPage({
      namespace: message.content.namespace,
      paginationInfo: message.content.pagination,
      repositoryId: message.content.repositoryId,
      sourceControl: message.metadata.sourceControl,
      userId: message.metadata.userId
    });
  }
});
var { sender: sender6 } = namespaceMemberSenderHandler;
var clerkClient3 = Clerk2({ secretKey: Config.CLERK_SECRET_KEY });
var client9 = createClient({ url: Config.DATABASE_URL, authToken: Config.DATABASE_AUTH_TOKEN });
var fetchSourceControlAccessToken = /* @__PURE__ */ __name(async (userId, forgeryIdProvider) => {
  const [userOauthAccessTokenPayload, ...rest] = await clerkClient3.users.getUserOauthAccessToken(userId, forgeryIdProvider);
  if (!userOauthAccessTokenPayload)
    throw new Error("Failed to get token");
  if (rest.length !== 0)
    throw new Error("wtf ?");
  return userOauthAccessTokenPayload.token;
}, "fetchSourceControlAccessToken");
var initSourceControl7 = /* @__PURE__ */ __name(async (userId, sourceControl) => {
  const accessToken = await fetchSourceControlAccessToken(userId, `oauth_${sourceControl}`);
  if (sourceControl === "github")
    return new GitHubSourceControl(accessToken);
  if (sourceControl === "gitlab")
    return new GitlabSourceControl(accessToken);
  return null;
}, "initSourceControl");
var db7 = drizzle(client9);
var context7 = {
  entities: {
    members,
    repositoriesToMembers
  },
  integrations: {
    sourceControl: null
  },
  db: db7
};
var extractNamespaceMembersPage = /* @__PURE__ */ __name(async ({ namespace, repositoryId, sourceControl, userId, paginationInfo }) => {
  const page = paginationInfo?.page;
  const perPage = paginationInfo?.perPage;
  context7.integrations.sourceControl = await initSourceControl7(userId, sourceControl);
  const { members: members2, paginationInfo: resultPaginationInfo } = await getNamespaceMembers({
    externalNamespaceId: namespace.externalId,
    namespaceName: namespace.name,
    repositoryId,
    perPage,
    page
  }, context7);
  await extractMembersEvent.publish({
    memberIds: members2.map((member) => member.id)
  }, {
    version: 1,
    caller: "extract-namespace-member",
    sourceControl,
    userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
  return { members: members2, pagination: resultPaginationInfo };
}, "extractNamespaceMembersPage");
var eventHandler7 = EventHandler(extractRepositoryEvent, async (ev) => {
  const repository = await db7.select().from(repositories).where(eq(repositories.id, ev.properties.repositoryId)).get();
  const namespace = await db7.select().from(namespaces).where(eq(namespaces.id, ev.properties.namespaceId)).get();
  if (!repository)
    throw new Error("invalid repo id");
  if (!namespace)
    throw new Error("Invalid namespace id");
  const { pagination } = await extractNamespaceMembersPage({
    namespace,
    repositoryId: ev.properties.repositoryId,
    sourceControl: ev.metadata.sourceControl,
    userId: ev.metadata.userId
  });
  const arrayOfExtractMemberPageMessageContent = [];
  for (let i10 = 2; i10 <= pagination.totalPages; i10++) {
    arrayOfExtractMemberPageMessageContent.push({
      namespace,
      repositoryId: ev.properties.repositoryId,
      pagination: {
        page: i10,
        perPage: pagination.perPage,
        totalPages: pagination.totalPages
      }
    });
  }
  if (arrayOfExtractMemberPageMessageContent.length === 0)
    return;
  await sender6.sendAll(arrayOfExtractMemberPageMessageContent, {
    version: 1,
    caller: "extract-namespace-member",
    sourceControl: ev.metadata.sourceControl,
    userId: ev.metadata.userId,
    timestamp: (/* @__PURE__ */ new Date()).getTime()
  });
});

// src/queue.ts
var messageHandlers = /* @__PURE__ */ new Map();
messageHandlers.set("merge-request" /* MergeRequest */, mergeRequestSenderHandler);
messageHandlers.set("merge-request-diff" /* MergeRequestDiff */, mergeRequestDiffSenderHandler);
messageHandlers.set("merge-request-commit" /* MergeRequestCommit */, mrcsh);
messageHandlers.set("merge-request-note" /* MergeRequestNote */, mergeRequestNoteSenderHandler);
messageHandlers.set("member" /* Member */, memberSenderHandler);
messageHandlers.set("namespace-member" /* NamespaceMember */, namespaceMemberSenderHandler);
messageHandlers.set("member-info" /* MemberInfo */, memberInfoSenderHandler);
var logMap = /* @__PURE__ */ new Map();
logMap.set("merge-request" /* MergeRequest */, ["content.repository.id", "content.namespace.id", "content.pagination"]);
logMap.set("merge-request-diff" /* MergeRequestDiff */, ["content.repositoryId", "content.namespaceId", "content.mergeRequestId"]);
logMap.set("merge-request-commit" /* MergeRequestCommit */, ["content.repositoryId", "content.namespaceId", "content.mergeRequestId"]);
logMap.set("merge-request-note" /* MergeRequestNote */, ["content.repositoryId", "content.namespaceId", "content.mergeRequestId"]);
logMap.set("member" /* Member */, ["content.repository.id", "content.namespace.id"]);
logMap.set("namespace-member" /* NamespaceMember */, ["content.repositoryId", "content.namespace.id"]);
logMap.set("member-info" /* MemberInfo */, ["metadata.sourceControl", "content.memberId"]);
var handler2 = QueueHandler(messageHandlers, logMap);
export {
  handler2 as handler
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

pvtsutils/build/index.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2022 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)

webcrypto-core/build/webcrypto-core.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

@peculiar/webcrypto/build/webcrypto.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

node-fetch-native/dist/shared/node-fetch-native.8afd3fea.cjs:
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
